(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Brinkbit"] = factory();
	else
		root["Brinkbit"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 48);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var assign = make_assign();
var create = make_create();
var trim = make_trim();
var Global = typeof window !== 'undefined' ? window : global;

module.exports = {
	assign: assign,
	create: create,
	trim: trim,
	bind: bind,
	slice: slice,
	each: each,
	map: map,
	pluck: pluck,
	isList: isList,
	isFunction: isFunction,
	isObject: isObject,
	Global: Global
};

function make_assign() {
	if (Object.assign) {
		return Object.assign;
	} else {
		return function shimAssign(obj, props1, props2, etc) {
			for (var i = 1; i < arguments.length; i++) {
				each(Object(arguments[i]), function (val, key) {
					obj[key] = val;
				});
			}
			return obj;
		};
	}
}

function make_create() {
	if (Object.create) {
		return function create(obj, assignProps1, assignProps2, etc) {
			var assignArgsList = slice(arguments, 1);
			return assign.apply(this, [Object.create(obj)].concat(assignArgsList));
		};
	} else {
		var F = function F() {}; // eslint-disable-line no-inner-declarations


		return function create(obj, assignProps1, assignProps2, etc) {
			var assignArgsList = slice(arguments, 1);
			F.prototype = obj;
			return assign.apply(this, [new F()].concat(assignArgsList));
		};
	}
}

function make_trim() {
	if (String.prototype.trim) {
		return function trim(str) {
			return String.prototype.trim.call(str);
		};
	} else {
		return function trim(str) {
			return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
		};
	}
}

function bind(obj, fn) {
	return function () {
		return fn.apply(obj, Array.prototype.slice.call(arguments, 0));
	};
}

function slice(arr, index) {
	return Array.prototype.slice.call(arr, index || 0);
}

function each(obj, fn) {
	pluck(obj, function (val, key) {
		fn(val, key);
		return false;
	});
}

function map(obj, fn) {
	var res = isList(obj) ? [] : {};
	pluck(obj, function (v, k) {
		res[k] = fn(v, k);
		return false;
	});
	return res;
}

function pluck(obj, fn) {
	if (isList(obj)) {
		for (var i = 0; i < obj.length; i++) {
			if (fn(obj[i], i)) {
				return obj[i];
			}
		}
	} else {
		for (var key in obj) {
			if (obj.hasOwnProperty(key)) {
				if (fn(obj[key], key)) {
					return obj[key];
				}
			}
		}
	}
}

function isList(val) {
	return val != null && typeof val != 'function' && typeof val.length == 'number';
}

function isFunction(val) {
	return val && {}.toString.call(val) === '[object Function]';
}

function isObject(val) {
	return val && {}.toString.call(val) === '[object Object]';
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, module) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = function () {
  try {
    return freeProcess && freeProcess.binding('util');
  } catch (e) {}
}();

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */
function addMapEntry(map, pair) {
  // Don't return `map.set` because it's not chainable in IE 11.
  map.set(pair[0], pair[1]);
  return map;
}

/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */
function addSetEntry(set, value) {
  // Don't return `set.add` because it's not chainable in IE 11.
  set.add(value);
  return set;
}

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array ? array.length : 0;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    _Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    getPrototype = overArg(Object.getPrototypeOf, Object),
    objectCreate = Object.create,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols,
    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
    nativeKeys = overArg(Object.keys, Object),
    nativeMax = Math.max;

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map || ListCache)(),
    'string': new Hash()
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  this.__data__ = new ListCache(entries);
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache();
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  return this.__data__['delete'](key);
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var cache = this.__data__;
  if (cache instanceof ListCache) {
    var pairs = cache.__data__;
    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      return this;
    }
    cache = this.__data__ = new MapCache(pairs);
  }
  cache.set(key, value);
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if (value !== undefined && !eq(object[key], value) || typeof key == 'number' && value === undefined && !(key in object)) {
    object[key] = value;
  }
}

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
    object[key] = value;
  }
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {boolean} [isFull] Specify a clone including symbols.
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
  var result;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || isFunc && !object) {
      if (isHostObject(value)) {
        return object ? value : {};
      }
      result = initCloneObject(isFunc ? {} : value);
      if (!isDeep) {
        return copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, baseClone, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (!isArr) {
    var props = isFull ? getAllKeys(value) : keys(value);
  }
  arrayEach(props || value, function (subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
  });
  return result;
}

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */
function baseCreate(proto) {
  return isObject(proto) ? objectCreate(proto) : {};
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  return objectToString.call(value);
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  if (!(isArray(source) || isTypedArray(source))) {
    var props = baseKeysIn(source);
  }
  arrayEach(props || source, function (srcValue, key) {
    if (props) {
      key = srcValue;
      srcValue = source[key];
    }
    if (isObject(srcValue)) {
      stack || (stack = new Stack());
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(object[key], srcValue, key + '', object, source, stack) : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  });
}

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = object[key],
      srcValue = source[key],
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    newValue = srcValue;
    if (isArray(srcValue) || isTypedArray(srcValue)) {
      if (isArray(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else {
        isCommon = false;
        newValue = baseClone(srcValue, true);
      }
    } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject(objValue) || srcIndex && isFunction(objValue)) {
        isCommon = false;
        newValue = baseClone(srcValue, true);
      } else {
        newValue = objValue;
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  start = nativeMax(start === undefined ? func.length - 1 : start, 0);
  return function () {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = array;
    return apply(func, this, otherArgs);
  };
}

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var result = new buffer.constructor(buffer.length);
  buffer.copy(result);
  return result;
}

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */
function cloneMap(map, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
  return arrayReduce(array, addMapEntry, new map.constructor());
}

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */
function cloneSet(set, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
  return arrayReduce(array, addSetEntry, new set.constructor());
}

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

    assignValue(object, key, newValue === undefined ? source[key] : newValue);
  }
  return object;
}

/**
 * Copies own symbol properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function (object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
  getTag = function getTag(value) {
    var result = objectToString.call(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : undefined;

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;
        case mapCtorString:
          return mapTag;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag;
        case weakMapCtorString:
          return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, cloneFunc, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag:case float64Tag:
    case int8Tag:case int16Tag:case int32Tag:
    case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return cloneMap(object, isDeep, cloneFunc);

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return cloneSet(object, isDeep, cloneFunc);

    case symbolTag:
      return cloneSymbol(object);
  }
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index === 'undefined' ? 'undefined' : _typeof(index);
  if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
    return eq(object[index], value);
  }
  return false;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;

  return value === proto;
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return func + '';
    } catch (e) {}
  }
  return '';
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object';
}

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function (object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = merge;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(9)(module)))

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var validateJs = __webpack_require__(47);

validateJs.validators.dataType = function validateDataType(value, options) {
    return value === null || value === undefined || validateJs['is' + validateJs.capitalize(options)](value) ? null : 'is not of type ' + options;
};

var ValidationError = __webpack_require__(10);

var validate = function validate(attributes, constraints) {
    var invalid = validateJs(attributes, constraints);
    if (invalid) {
        return Promise.reject(new ValidationError({
            message: invalid.error,
            details: invalid
        }));
    }
    return Promise.resolve();
};

validate.constructor = function validateConstructor(config, constraints) {
    if ((typeof config === 'undefined' ? 'undefined' : _typeof(config)) !== 'object') {
        throw new TypeError('config must be an object');
    }
    var invalid = validateJs(config, constraints);
    if (invalid) {
        throw new ValidationError({
            message: invalid.error,
            details: invalid
        });
    }
};

module.exports = validate;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = function normalizeArguments() {
    var _ref;

    var options = {};
    if (_typeof(arguments.length <= 0 ? undefined : arguments[0]) === 'object') {
        options = arguments.length <= 0 ? undefined : arguments[0];
    } else if (_typeof(arguments.length <= 1 ? undefined : arguments[1]) === 'object') {
        options = arguments.length <= 1 ? undefined : arguments[1];
    } else if (typeof (arguments.length <= 1 ? undefined : arguments[1]) === 'string') {
        options.token = arguments.length <= 1 ? undefined : arguments[1];
    }
    if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string') {
        options.uri = arguments.length <= 0 ? undefined : arguments[0];
    }
    if (arguments.length > 0 && typeof (_ref = arguments.length - 1, arguments.length <= _ref ? undefined : arguments[_ref]) === 'function') {
        var _ref2;

        options.callback = (_ref2 = arguments.length - 1, arguments.length <= _ref2 ? undefined : arguments[_ref2]);
    }
    return options;
};

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var d = __webpack_require__(20),
    callable = __webpack_require__(29),
    apply = Function.prototype.apply,
    call = Function.prototype.call,
    create = Object.create,
    defineProperty = Object.defineProperty,
    defineProperties = Object.defineProperties,
    hasOwnProperty = Object.prototype.hasOwnProperty,
    descriptor = { configurable: true, enumerable: false, writable: true },
    on,
    _once2,
    off,
    emit,
    methods,
    descriptors,
    base;

on = function on(type, listener) {
	var data;

	callable(listener);

	if (!hasOwnProperty.call(this, '__ee__')) {
		data = descriptor.value = create(null);
		defineProperty(this, '__ee__', descriptor);
		descriptor.value = null;
	} else {
		data = this.__ee__;
	}
	if (!data[type]) data[type] = listener;else if (_typeof(data[type]) === 'object') data[type].push(listener);else data[type] = [data[type], listener];

	return this;
};

_once2 = function once(type, listener) {
	var _once, self;

	callable(listener);
	self = this;
	on.call(this, type, _once = function once() {
		off.call(self, type, _once);
		apply.call(listener, this, arguments);
	});

	_once.__eeOnceListener__ = listener;
	return this;
};

off = function off(type, listener) {
	var data, listeners, candidate, i;

	callable(listener);

	if (!hasOwnProperty.call(this, '__ee__')) return this;
	data = this.__ee__;
	if (!data[type]) return this;
	listeners = data[type];

	if ((typeof listeners === 'undefined' ? 'undefined' : _typeof(listeners)) === 'object') {
		for (i = 0; candidate = listeners[i]; ++i) {
			if (candidate === listener || candidate.__eeOnceListener__ === listener) {
				if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];else listeners.splice(i, 1);
			}
		}
	} else {
		if (listeners === listener || listeners.__eeOnceListener__ === listener) {
			delete data[type];
		}
	}

	return this;
};

emit = function emit(type) {
	var i, l, listener, listeners, args;

	if (!hasOwnProperty.call(this, '__ee__')) return;
	listeners = this.__ee__[type];
	if (!listeners) return;

	if ((typeof listeners === 'undefined' ? 'undefined' : _typeof(listeners)) === 'object') {
		l = arguments.length;
		args = new Array(l - 1);
		for (i = 1; i < l; ++i) {
			args[i - 1] = arguments[i];
		}listeners = listeners.slice();
		for (i = 0; listener = listeners[i]; ++i) {
			apply.call(listener, this, args);
		}
	} else {
		switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
		}
	}
};

methods = {
	on: on,
	once: _once2,
	off: off,
	emit: emit
};

descriptors = {
	on: d(on),
	once: d(_once2),
	off: d(off),
	emit: d(emit)
};

base = defineProperties({}, descriptors);

module.exports = exports = function exports(o) {
	return o == null ? create(base) : defineProperties(Object(o), descriptors);
};
exports.methods = methods;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BrinkbitEvent = function BrinkbitEvent(eventType, response) {
    _classCallCheck(this, BrinkbitEvent);

    this.type = eventType;
    this.response = response;
};

module.exports = BrinkbitEvent;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function normalizeResponse(promise, options) {
    return promise.then(function (data) {
        if (typeof options.callback === 'function') {
            options.callback(null, data);
        }
        if (typeof options.success === 'function') {
            options.success(data);
        }
        return data;
    }).catch(function (error) {
        if (typeof options.callback === 'function') {
            return options.callback(error);
        }
        if (typeof options.error === 'function') {
            return options.error(error);
        }
        return Promise.reject(error);
    });
};

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
    return [];
};

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function get() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function get() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var customError = __webpack_require__(19);

module.exports = customError('ValidationError', {
    message: 'Validation failed',
    details: []
});

/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = function() {
	throw new Error("define cannot be used indirect");
};


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, global, setImmediate) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/* @preserve
 * The MIT License (MIT)
 * 
 * Copyright (c) 2013-2017 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
/**
 * bluebird build version 3.5.0
 * Features enabled: core, race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, using, timers, filter, any, each
*/
!function (e) {
    if ("object" == ( false ? "undefined" : _typeof(exports)) && "undefined" != typeof module) module.exports = e();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (e),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {
        var f;"undefined" != typeof window ? f = window : "undefined" != typeof global ? f = global : "undefined" != typeof self && (f = self), f.Promise = e();
    }
}(function () {
    var define, module, exports;return function e(t, n, r) {
        function s(o, u) {
            if (!n[o]) {
                if (!t[o]) {
                    var a = typeof _dereq_ == "function" && _dereq_;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
                }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                    var n = t[o][1][e];return s(n ? n : e);
                }, l, l.exports, e, t, n, r);
            }return n[o].exports;
        }var i = typeof _dereq_ == "function" && _dereq_;for (var o = 0; o < r.length; o++) {
            s(r[o]);
        }return s;
    }({ 1: [function (_dereq_, module, exports) {
            "use strict";

            module.exports = function (Promise) {
                var SomePromiseArray = Promise._SomePromiseArray;
                function any(promises) {
                    var ret = new SomePromiseArray(promises);
                    var promise = ret.promise();
                    ret.setHowMany(1);
                    ret.setUnwrap();
                    ret.init();
                    return promise;
                }

                Promise.any = function (promises) {
                    return any(promises);
                };

                Promise.prototype.any = function () {
                    return any(this);
                };
            };
        }, {}], 2: [function (_dereq_, module, exports) {
            "use strict";

            var firstLineError;
            try {
                throw new Error();
            } catch (e) {
                firstLineError = e;
            }
            var schedule = _dereq_("./schedule");
            var Queue = _dereq_("./queue");
            var util = _dereq_("./util");

            function Async() {
                this._customScheduler = false;
                this._isTickUsed = false;
                this._lateQueue = new Queue(16);
                this._normalQueue = new Queue(16);
                this._haveDrainedQueues = false;
                this._trampolineEnabled = true;
                var self = this;
                this.drainQueues = function () {
                    self._drainQueues();
                };
                this._schedule = schedule;
            }

            Async.prototype.setScheduler = function (fn) {
                var prev = this._schedule;
                this._schedule = fn;
                this._customScheduler = true;
                return prev;
            };

            Async.prototype.hasCustomScheduler = function () {
                return this._customScheduler;
            };

            Async.prototype.enableTrampoline = function () {
                this._trampolineEnabled = true;
            };

            Async.prototype.disableTrampolineIfNecessary = function () {
                if (util.hasDevTools) {
                    this._trampolineEnabled = false;
                }
            };

            Async.prototype.haveItemsQueued = function () {
                return this._isTickUsed || this._haveDrainedQueues;
            };

            Async.prototype.fatalError = function (e, isNode) {
                if (isNode) {
                    process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) + "\n");
                    process.exit(2);
                } else {
                    this.throwLater(e);
                }
            };

            Async.prototype.throwLater = function (fn, arg) {
                if (arguments.length === 1) {
                    arg = fn;
                    fn = function fn() {
                        throw arg;
                    };
                }
                if (typeof setTimeout !== "undefined") {
                    setTimeout(function () {
                        fn(arg);
                    }, 0);
                } else try {
                    this._schedule(function () {
                        fn(arg);
                    });
                } catch (e) {
                    throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
                }
            };

            function AsyncInvokeLater(fn, receiver, arg) {
                this._lateQueue.push(fn, receiver, arg);
                this._queueTick();
            }

            function AsyncInvoke(fn, receiver, arg) {
                this._normalQueue.push(fn, receiver, arg);
                this._queueTick();
            }

            function AsyncSettlePromises(promise) {
                this._normalQueue._pushOne(promise);
                this._queueTick();
            }

            if (!util.hasDevTools) {
                Async.prototype.invokeLater = AsyncInvokeLater;
                Async.prototype.invoke = AsyncInvoke;
                Async.prototype.settlePromises = AsyncSettlePromises;
            } else {
                Async.prototype.invokeLater = function (fn, receiver, arg) {
                    if (this._trampolineEnabled) {
                        AsyncInvokeLater.call(this, fn, receiver, arg);
                    } else {
                        this._schedule(function () {
                            setTimeout(function () {
                                fn.call(receiver, arg);
                            }, 100);
                        });
                    }
                };

                Async.prototype.invoke = function (fn, receiver, arg) {
                    if (this._trampolineEnabled) {
                        AsyncInvoke.call(this, fn, receiver, arg);
                    } else {
                        this._schedule(function () {
                            fn.call(receiver, arg);
                        });
                    }
                };

                Async.prototype.settlePromises = function (promise) {
                    if (this._trampolineEnabled) {
                        AsyncSettlePromises.call(this, promise);
                    } else {
                        this._schedule(function () {
                            promise._settlePromises();
                        });
                    }
                };
            }

            Async.prototype._drainQueue = function (queue) {
                while (queue.length() > 0) {
                    var fn = queue.shift();
                    if (typeof fn !== "function") {
                        fn._settlePromises();
                        continue;
                    }
                    var receiver = queue.shift();
                    var arg = queue.shift();
                    fn.call(receiver, arg);
                }
            };

            Async.prototype._drainQueues = function () {
                this._drainQueue(this._normalQueue);
                this._reset();
                this._haveDrainedQueues = true;
                this._drainQueue(this._lateQueue);
            };

            Async.prototype._queueTick = function () {
                if (!this._isTickUsed) {
                    this._isTickUsed = true;
                    this._schedule(this.drainQueues);
                }
            };

            Async.prototype._reset = function () {
                this._isTickUsed = false;
            };

            module.exports = Async;
            module.exports.firstLineError = firstLineError;
        }, { "./queue": 26, "./schedule": 29, "./util": 36 }], 3: [function (_dereq_, module, exports) {
            "use strict";

            module.exports = function (Promise, INTERNAL, tryConvertToPromise, debug) {
                var calledBind = false;
                var rejectThis = function rejectThis(_, e) {
                    this._reject(e);
                };

                var targetRejected = function targetRejected(e, context) {
                    context.promiseRejectionQueued = true;
                    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
                };

                var bindingResolved = function bindingResolved(thisArg, context) {
                    if ((this._bitField & 50397184) === 0) {
                        this._resolveCallback(context.target);
                    }
                };

                var bindingRejected = function bindingRejected(e, context) {
                    if (!context.promiseRejectionQueued) this._reject(e);
                };

                Promise.prototype.bind = function (thisArg) {
                    if (!calledBind) {
                        calledBind = true;
                        Promise.prototype._propagateFrom = debug.propagateFromFunction();
                        Promise.prototype._boundValue = debug.boundValueFunction();
                    }
                    var maybePromise = tryConvertToPromise(thisArg);
                    var ret = new Promise(INTERNAL);
                    ret._propagateFrom(this, 1);
                    var target = this._target();
                    ret._setBoundTo(maybePromise);
                    if (maybePromise instanceof Promise) {
                        var context = {
                            promiseRejectionQueued: false,
                            promise: ret,
                            target: target,
                            bindingPromise: maybePromise
                        };
                        target._then(INTERNAL, targetRejected, undefined, ret, context);
                        maybePromise._then(bindingResolved, bindingRejected, undefined, ret, context);
                        ret._setOnCancel(maybePromise);
                    } else {
                        ret._resolveCallback(target);
                    }
                    return ret;
                };

                Promise.prototype._setBoundTo = function (obj) {
                    if (obj !== undefined) {
                        this._bitField = this._bitField | 2097152;
                        this._boundTo = obj;
                    } else {
                        this._bitField = this._bitField & ~2097152;
                    }
                };

                Promise.prototype._isBound = function () {
                    return (this._bitField & 2097152) === 2097152;
                };

                Promise.bind = function (thisArg, value) {
                    return Promise.resolve(value).bind(thisArg);
                };
            };
        }, {}], 4: [function (_dereq_, module, exports) {
            "use strict";

            var old;
            if (typeof Promise !== "undefined") old = Promise;
            function noConflict() {
                try {
                    if (Promise === bluebird) Promise = old;
                } catch (e) {}
                return bluebird;
            }
            var bluebird = _dereq_("./promise")();
            bluebird.noConflict = noConflict;
            module.exports = bluebird;
        }, { "./promise": 22 }], 5: [function (_dereq_, module, exports) {
            "use strict";

            var cr = Object.create;
            if (cr) {
                var callerCache = cr(null);
                var getterCache = cr(null);
                callerCache[" size"] = getterCache[" size"] = 0;
            }

            module.exports = function (Promise) {
                var util = _dereq_("./util");
                var canEvaluate = util.canEvaluate;
                var isIdentifier = util.isIdentifier;

                var getMethodCaller;
                var getGetter;
                if (false) {
                    var makeMethodCaller = function makeMethodCaller(methodName) {
                        return new Function("ensureMethod", "                                    \n\
        return function(obj) {                                               \n\
            'use strict'                                                     \n\
            var len = this.length;                                           \n\
            ensureMethod(obj, 'methodName');                                 \n\
            switch(len) {                                                    \n\
                case 1: return obj.methodName(this[0]);                      \n\
                case 2: return obj.methodName(this[0], this[1]);             \n\
                case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
                case 0: return obj.methodName();                             \n\
                default:                                                     \n\
                    return obj.methodName.apply(obj, this);                  \n\
            }                                                                \n\
        };                                                                   \n\
        ".replace(/methodName/g, methodName))(ensureMethod);
                    };

                    var makeGetter = function makeGetter(propertyName) {
                        return new Function("obj", "                                             \n\
        'use strict';                                                        \n\
        return obj.propertyName;                                             \n\
        ".replace("propertyName", propertyName));
                    };

                    var getCompiled = function getCompiled(name, compiler, cache) {
                        var ret = cache[name];
                        if (typeof ret !== "function") {
                            if (!isIdentifier(name)) {
                                return null;
                            }
                            ret = compiler(name);
                            cache[name] = ret;
                            cache[" size"]++;
                            if (cache[" size"] > 512) {
                                var keys = Object.keys(cache);
                                for (var i = 0; i < 256; ++i) {
                                    delete cache[keys[i]];
                                }cache[" size"] = keys.length - 256;
                            }
                        }
                        return ret;
                    };

                    getMethodCaller = function getMethodCaller(name) {
                        return getCompiled(name, makeMethodCaller, callerCache);
                    };

                    getGetter = function getGetter(name) {
                        return getCompiled(name, makeGetter, getterCache);
                    };
                }

                function ensureMethod(obj, methodName) {
                    var fn;
                    if (obj != null) fn = obj[methodName];
                    if (typeof fn !== "function") {
                        var message = "Object " + util.classString(obj) + " has no method '" + util.toString(methodName) + "'";
                        throw new Promise.TypeError(message);
                    }
                    return fn;
                }

                function caller(obj) {
                    var methodName = this.pop();
                    var fn = ensureMethod(obj, methodName);
                    return fn.apply(obj, this);
                }
                Promise.prototype.call = function (methodName) {
                    var args = [].slice.call(arguments, 1);;
                    if (false) {
                        if (canEvaluate) {
                            var maybeCaller = getMethodCaller(methodName);
                            if (maybeCaller !== null) {
                                return this._then(maybeCaller, undefined, undefined, args, undefined);
                            }
                        }
                    }
                    args.push(methodName);
                    return this._then(caller, undefined, undefined, args, undefined);
                };

                function namedGetter(obj) {
                    return obj[this];
                }
                function indexedGetter(obj) {
                    var index = +this;
                    if (index < 0) index = Math.max(0, index + obj.length);
                    return obj[index];
                }
                Promise.prototype.get = function (propertyName) {
                    var isIndex = typeof propertyName === "number";
                    var getter;
                    if (!isIndex) {
                        if (canEvaluate) {
                            var maybeGetter = getGetter(propertyName);
                            getter = maybeGetter !== null ? maybeGetter : namedGetter;
                        } else {
                            getter = namedGetter;
                        }
                    } else {
                        getter = indexedGetter;
                    }
                    return this._then(getter, undefined, undefined, propertyName, undefined);
                };
            };
        }, { "./util": 36 }], 6: [function (_dereq_, module, exports) {
            "use strict";

            module.exports = function (Promise, PromiseArray, apiRejection, debug) {
                var util = _dereq_("./util");
                var tryCatch = util.tryCatch;
                var errorObj = util.errorObj;
                var async = Promise._async;

                Promise.prototype["break"] = Promise.prototype.cancel = function () {
                    if (!debug.cancellation()) return this._warn("cancellation is disabled");

                    var promise = this;
                    var child = promise;
                    while (promise._isCancellable()) {
                        if (!promise._cancelBy(child)) {
                            if (child._isFollowing()) {
                                child._followee().cancel();
                            } else {
                                child._cancelBranched();
                            }
                            break;
                        }

                        var parent = promise._cancellationParent;
                        if (parent == null || !parent._isCancellable()) {
                            if (promise._isFollowing()) {
                                promise._followee().cancel();
                            } else {
                                promise._cancelBranched();
                            }
                            break;
                        } else {
                            if (promise._isFollowing()) promise._followee().cancel();
                            promise._setWillBeCancelled();
                            child = promise;
                            promise = parent;
                        }
                    }
                };

                Promise.prototype._branchHasCancelled = function () {
                    this._branchesRemainingToCancel--;
                };

                Promise.prototype._enoughBranchesHaveCancelled = function () {
                    return this._branchesRemainingToCancel === undefined || this._branchesRemainingToCancel <= 0;
                };

                Promise.prototype._cancelBy = function (canceller) {
                    if (canceller === this) {
                        this._branchesRemainingToCancel = 0;
                        this._invokeOnCancel();
                        return true;
                    } else {
                        this._branchHasCancelled();
                        if (this._enoughBranchesHaveCancelled()) {
                            this._invokeOnCancel();
                            return true;
                        }
                    }
                    return false;
                };

                Promise.prototype._cancelBranched = function () {
                    if (this._enoughBranchesHaveCancelled()) {
                        this._cancel();
                    }
                };

                Promise.prototype._cancel = function () {
                    if (!this._isCancellable()) return;
                    this._setCancelled();
                    async.invoke(this._cancelPromises, this, undefined);
                };

                Promise.prototype._cancelPromises = function () {
                    if (this._length() > 0) this._settlePromises();
                };

                Promise.prototype._unsetOnCancel = function () {
                    this._onCancelField = undefined;
                };

                Promise.prototype._isCancellable = function () {
                    return this.isPending() && !this._isCancelled();
                };

                Promise.prototype.isCancellable = function () {
                    return this.isPending() && !this.isCancelled();
                };

                Promise.prototype._doInvokeOnCancel = function (onCancelCallback, internalOnly) {
                    if (util.isArray(onCancelCallback)) {
                        for (var i = 0; i < onCancelCallback.length; ++i) {
                            this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
                        }
                    } else if (onCancelCallback !== undefined) {
                        if (typeof onCancelCallback === "function") {
                            if (!internalOnly) {
                                var e = tryCatch(onCancelCallback).call(this._boundValue());
                                if (e === errorObj) {
                                    this._attachExtraTrace(e.e);
                                    async.throwLater(e.e);
                                }
                            }
                        } else {
                            onCancelCallback._resultCancelled(this);
                        }
                    }
                };

                Promise.prototype._invokeOnCancel = function () {
                    var onCancelCallback = this._onCancel();
                    this._unsetOnCancel();
                    async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
                };

                Promise.prototype._invokeInternalOnCancel = function () {
                    if (this._isCancellable()) {
                        this._doInvokeOnCancel(this._onCancel(), true);
                        this._unsetOnCancel();
                    }
                };

                Promise.prototype._resultCancelled = function () {
                    this.cancel();
                };
            };
        }, { "./util": 36 }], 7: [function (_dereq_, module, exports) {
            "use strict";

            module.exports = function (NEXT_FILTER) {
                var util = _dereq_("./util");
                var getKeys = _dereq_("./es5").keys;
                var tryCatch = util.tryCatch;
                var errorObj = util.errorObj;

                function catchFilter(instances, cb, promise) {
                    return function (e) {
                        var boundTo = promise._boundValue();
                        predicateLoop: for (var i = 0; i < instances.length; ++i) {
                            var item = instances[i];

                            if (item === Error || item != null && item.prototype instanceof Error) {
                                if (e instanceof item) {
                                    return tryCatch(cb).call(boundTo, e);
                                }
                            } else if (typeof item === "function") {
                                var matchesPredicate = tryCatch(item).call(boundTo, e);
                                if (matchesPredicate === errorObj) {
                                    return matchesPredicate;
                                } else if (matchesPredicate) {
                                    return tryCatch(cb).call(boundTo, e);
                                }
                            } else if (util.isObject(e)) {
                                var keys = getKeys(item);
                                for (var j = 0; j < keys.length; ++j) {
                                    var key = keys[j];
                                    if (item[key] != e[key]) {
                                        continue predicateLoop;
                                    }
                                }
                                return tryCatch(cb).call(boundTo, e);
                            }
                        }
                        return NEXT_FILTER;
                    };
                }

                return catchFilter;
            };
        }, { "./es5": 13, "./util": 36 }], 8: [function (_dereq_, module, exports) {
            "use strict";

            module.exports = function (Promise) {
                var longStackTraces = false;
                var contextStack = [];

                Promise.prototype._promiseCreated = function () {};
                Promise.prototype._pushContext = function () {};
                Promise.prototype._popContext = function () {
                    return null;
                };
                Promise._peekContext = Promise.prototype._peekContext = function () {};

                function Context() {
                    this._trace = new Context.CapturedTrace(peekContext());
                }
                Context.prototype._pushContext = function () {
                    if (this._trace !== undefined) {
                        this._trace._promiseCreated = null;
                        contextStack.push(this._trace);
                    }
                };

                Context.prototype._popContext = function () {
                    if (this._trace !== undefined) {
                        var trace = contextStack.pop();
                        var ret = trace._promiseCreated;
                        trace._promiseCreated = null;
                        return ret;
                    }
                    return null;
                };

                function createContext() {
                    if (longStackTraces) return new Context();
                }

                function peekContext() {
                    var lastIndex = contextStack.length - 1;
                    if (lastIndex >= 0) {
                        return contextStack[lastIndex];
                    }
                    return undefined;
                }
                Context.CapturedTrace = null;
                Context.create = createContext;
                Context.deactivateLongStackTraces = function () {};
                Context.activateLongStackTraces = function () {
                    var Promise_pushContext = Promise.prototype._pushContext;
                    var Promise_popContext = Promise.prototype._popContext;
                    var Promise_PeekContext = Promise._peekContext;
                    var Promise_peekContext = Promise.prototype._peekContext;
                    var Promise_promiseCreated = Promise.prototype._promiseCreated;
                    Context.deactivateLongStackTraces = function () {
                        Promise.prototype._pushContext = Promise_pushContext;
                        Promise.prototype._popContext = Promise_popContext;
                        Promise._peekContext = Promise_PeekContext;
                        Promise.prototype._peekContext = Promise_peekContext;
                        Promise.prototype._promiseCreated = Promise_promiseCreated;
                        longStackTraces = false;
                    };
                    longStackTraces = true;
                    Promise.prototype._pushContext = Context.prototype._pushContext;
                    Promise.prototype._popContext = Context.prototype._popContext;
                    Promise._peekContext = Promise.prototype._peekContext = peekContext;
                    Promise.prototype._promiseCreated = function () {
                        var ctx = this._peekContext();
                        if (ctx && ctx._promiseCreated == null) ctx._promiseCreated = this;
                    };
                };
                return Context;
            };
        }, {}], 9: [function (_dereq_, module, exports) {
            "use strict";

            module.exports = function (Promise, Context) {
                var getDomain = Promise._getDomain;
                var async = Promise._async;
                var Warning = _dereq_("./errors").Warning;
                var util = _dereq_("./util");
                var canAttachTrace = util.canAttachTrace;
                var unhandledRejectionHandled;
                var possiblyUnhandledRejection;
                var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
                var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
                var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
                var stackFramePattern = null;
                var formatStack = null;
                var indentStackFrames = false;
                var printWarning;
                var debugging = !!(util.env("BLUEBIRD_DEBUG") != 0 && (true || util.env("BLUEBIRD_DEBUG") || util.env("NODE_ENV") === "development"));

                var warnings = !!(util.env("BLUEBIRD_WARNINGS") != 0 && (debugging || util.env("BLUEBIRD_WARNINGS")));

                var longStackTraces = !!(util.env("BLUEBIRD_LONG_STACK_TRACES") != 0 && (debugging || util.env("BLUEBIRD_LONG_STACK_TRACES")));

                var wForgottenReturn = util.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));

                Promise.prototype.suppressUnhandledRejections = function () {
                    var target = this._target();
                    target._bitField = target._bitField & ~1048576 | 524288;
                };

                Promise.prototype._ensurePossibleRejectionHandled = function () {
                    if ((this._bitField & 524288) !== 0) return;
                    this._setRejectionIsUnhandled();
                    async.invokeLater(this._notifyUnhandledRejection, this, undefined);
                };

                Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
                    fireRejectionEvent("rejectionHandled", unhandledRejectionHandled, undefined, this);
                };

                Promise.prototype._setReturnedNonUndefined = function () {
                    this._bitField = this._bitField | 268435456;
                };

                Promise.prototype._returnedNonUndefined = function () {
                    return (this._bitField & 268435456) !== 0;
                };

                Promise.prototype._notifyUnhandledRejection = function () {
                    if (this._isRejectionUnhandled()) {
                        var reason = this._settledValue();
                        this._setUnhandledRejectionIsNotified();
                        fireRejectionEvent("unhandledRejection", possiblyUnhandledRejection, reason, this);
                    }
                };

                Promise.prototype._setUnhandledRejectionIsNotified = function () {
                    this._bitField = this._bitField | 262144;
                };

                Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
                    this._bitField = this._bitField & ~262144;
                };

                Promise.prototype._isUnhandledRejectionNotified = function () {
                    return (this._bitField & 262144) > 0;
                };

                Promise.prototype._setRejectionIsUnhandled = function () {
                    this._bitField = this._bitField | 1048576;
                };

                Promise.prototype._unsetRejectionIsUnhandled = function () {
                    this._bitField = this._bitField & ~1048576;
                    if (this._isUnhandledRejectionNotified()) {
                        this._unsetUnhandledRejectionIsNotified();
                        this._notifyUnhandledRejectionIsHandled();
                    }
                };

                Promise.prototype._isRejectionUnhandled = function () {
                    return (this._bitField & 1048576) > 0;
                };

                Promise.prototype._warn = function (message, shouldUseOwnTrace, promise) {
                    return warn(message, shouldUseOwnTrace, promise || this);
                };

                Promise.onPossiblyUnhandledRejection = function (fn) {
                    var domain = getDomain();
                    possiblyUnhandledRejection = typeof fn === "function" ? domain === null ? fn : util.domainBind(domain, fn) : undefined;
                };

                Promise.onUnhandledRejectionHandled = function (fn) {
                    var domain = getDomain();
                    unhandledRejectionHandled = typeof fn === "function" ? domain === null ? fn : util.domainBind(domain, fn) : undefined;
                };

                var disableLongStackTraces = function disableLongStackTraces() {};
                Promise.longStackTraces = function () {
                    if (async.haveItemsQueued() && !config.longStackTraces) {
                        throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
                    }
                    if (!config.longStackTraces && longStackTracesIsSupported()) {
                        var Promise_captureStackTrace = Promise.prototype._captureStackTrace;
                        var Promise_attachExtraTrace = Promise.prototype._attachExtraTrace;
                        config.longStackTraces = true;
                        disableLongStackTraces = function disableLongStackTraces() {
                            if (async.haveItemsQueued() && !config.longStackTraces) {
                                throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
                            }
                            Promise.prototype._captureStackTrace = Promise_captureStackTrace;
                            Promise.prototype._attachExtraTrace = Promise_attachExtraTrace;
                            Context.deactivateLongStackTraces();
                            async.enableTrampoline();
                            config.longStackTraces = false;
                        };
                        Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
                        Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
                        Context.activateLongStackTraces();
                        async.disableTrampolineIfNecessary();
                    }
                };

                Promise.hasLongStackTraces = function () {
                    return config.longStackTraces && longStackTracesIsSupported();
                };

                var fireDomEvent = function () {
                    try {
                        if (typeof CustomEvent === "function") {
                            var event = new CustomEvent("CustomEvent");
                            util.global.dispatchEvent(event);
                            return function (name, event) {
                                var domEvent = new CustomEvent(name.toLowerCase(), {
                                    detail: event,
                                    cancelable: true
                                });
                                return !util.global.dispatchEvent(domEvent);
                            };
                        } else if (typeof Event === "function") {
                            var event = new Event("CustomEvent");
                            util.global.dispatchEvent(event);
                            return function (name, event) {
                                var domEvent = new Event(name.toLowerCase(), {
                                    cancelable: true
                                });
                                domEvent.detail = event;
                                return !util.global.dispatchEvent(domEvent);
                            };
                        } else {
                            var event = document.createEvent("CustomEvent");
                            event.initCustomEvent("testingtheevent", false, true, {});
                            util.global.dispatchEvent(event);
                            return function (name, event) {
                                var domEvent = document.createEvent("CustomEvent");
                                domEvent.initCustomEvent(name.toLowerCase(), false, true, event);
                                return !util.global.dispatchEvent(domEvent);
                            };
                        }
                    } catch (e) {}
                    return function () {
                        return false;
                    };
                }();

                var fireGlobalEvent = function () {
                    if (util.isNode) {
                        return function () {
                            return process.emit.apply(process, arguments);
                        };
                    } else {
                        if (!util.global) {
                            return function () {
                                return false;
                            };
                        }
                        return function (name) {
                            var methodName = "on" + name.toLowerCase();
                            var method = util.global[methodName];
                            if (!method) return false;
                            method.apply(util.global, [].slice.call(arguments, 1));
                            return true;
                        };
                    }
                }();

                function generatePromiseLifecycleEventObject(name, promise) {
                    return { promise: promise };
                }

                var eventToObjectGenerator = {
                    promiseCreated: generatePromiseLifecycleEventObject,
                    promiseFulfilled: generatePromiseLifecycleEventObject,
                    promiseRejected: generatePromiseLifecycleEventObject,
                    promiseResolved: generatePromiseLifecycleEventObject,
                    promiseCancelled: generatePromiseLifecycleEventObject,
                    promiseChained: function promiseChained(name, promise, child) {
                        return { promise: promise, child: child };
                    },
                    warning: function warning(name, _warning) {
                        return { warning: _warning };
                    },
                    unhandledRejection: function unhandledRejection(name, reason, promise) {
                        return { reason: reason, promise: promise };
                    },
                    rejectionHandled: generatePromiseLifecycleEventObject
                };

                var activeFireEvent = function activeFireEvent(name) {
                    var globalEventFired = false;
                    try {
                        globalEventFired = fireGlobalEvent.apply(null, arguments);
                    } catch (e) {
                        async.throwLater(e);
                        globalEventFired = true;
                    }

                    var domEventFired = false;
                    try {
                        domEventFired = fireDomEvent(name, eventToObjectGenerator[name].apply(null, arguments));
                    } catch (e) {
                        async.throwLater(e);
                        domEventFired = true;
                    }

                    return domEventFired || globalEventFired;
                };

                Promise.config = function (opts) {
                    opts = Object(opts);
                    if ("longStackTraces" in opts) {
                        if (opts.longStackTraces) {
                            Promise.longStackTraces();
                        } else if (!opts.longStackTraces && Promise.hasLongStackTraces()) {
                            disableLongStackTraces();
                        }
                    }
                    if ("warnings" in opts) {
                        var warningsOption = opts.warnings;
                        config.warnings = !!warningsOption;
                        wForgottenReturn = config.warnings;

                        if (util.isObject(warningsOption)) {
                            if ("wForgottenReturn" in warningsOption) {
                                wForgottenReturn = !!warningsOption.wForgottenReturn;
                            }
                        }
                    }
                    if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
                        if (async.haveItemsQueued()) {
                            throw new Error("cannot enable cancellation after promises are in use");
                        }
                        Promise.prototype._clearCancellationData = cancellationClearCancellationData;
                        Promise.prototype._propagateFrom = cancellationPropagateFrom;
                        Promise.prototype._onCancel = cancellationOnCancel;
                        Promise.prototype._setOnCancel = cancellationSetOnCancel;
                        Promise.prototype._attachCancellationCallback = cancellationAttachCancellationCallback;
                        Promise.prototype._execute = cancellationExecute;
                        _propagateFromFunction = cancellationPropagateFrom;
                        config.cancellation = true;
                    }
                    if ("monitoring" in opts) {
                        if (opts.monitoring && !config.monitoring) {
                            config.monitoring = true;
                            Promise.prototype._fireEvent = activeFireEvent;
                        } else if (!opts.monitoring && config.monitoring) {
                            config.monitoring = false;
                            Promise.prototype._fireEvent = defaultFireEvent;
                        }
                    }
                    return Promise;
                };

                function defaultFireEvent() {
                    return false;
                }

                Promise.prototype._fireEvent = defaultFireEvent;
                Promise.prototype._execute = function (executor, resolve, reject) {
                    try {
                        executor(resolve, reject);
                    } catch (e) {
                        return e;
                    }
                };
                Promise.prototype._onCancel = function () {};
                Promise.prototype._setOnCancel = function (handler) {
                    ;
                };
                Promise.prototype._attachCancellationCallback = function (onCancel) {
                    ;
                };
                Promise.prototype._captureStackTrace = function () {};
                Promise.prototype._attachExtraTrace = function () {};
                Promise.prototype._clearCancellationData = function () {};
                Promise.prototype._propagateFrom = function (parent, flags) {
                    ;
                    ;
                };

                function cancellationExecute(executor, resolve, reject) {
                    var promise = this;
                    try {
                        executor(resolve, reject, function (onCancel) {
                            if (typeof onCancel !== "function") {
                                throw new TypeError("onCancel must be a function, got: " + util.toString(onCancel));
                            }
                            promise._attachCancellationCallback(onCancel);
                        });
                    } catch (e) {
                        return e;
                    }
                }

                function cancellationAttachCancellationCallback(onCancel) {
                    if (!this._isCancellable()) return this;

                    var previousOnCancel = this._onCancel();
                    if (previousOnCancel !== undefined) {
                        if (util.isArray(previousOnCancel)) {
                            previousOnCancel.push(onCancel);
                        } else {
                            this._setOnCancel([previousOnCancel, onCancel]);
                        }
                    } else {
                        this._setOnCancel(onCancel);
                    }
                }

                function cancellationOnCancel() {
                    return this._onCancelField;
                }

                function cancellationSetOnCancel(onCancel) {
                    this._onCancelField = onCancel;
                }

                function cancellationClearCancellationData() {
                    this._cancellationParent = undefined;
                    this._onCancelField = undefined;
                }

                function cancellationPropagateFrom(parent, flags) {
                    if ((flags & 1) !== 0) {
                        this._cancellationParent = parent;
                        var branchesRemainingToCancel = parent._branchesRemainingToCancel;
                        if (branchesRemainingToCancel === undefined) {
                            branchesRemainingToCancel = 0;
                        }
                        parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
                    }
                    if ((flags & 2) !== 0 && parent._isBound()) {
                        this._setBoundTo(parent._boundTo);
                    }
                }

                function bindingPropagateFrom(parent, flags) {
                    if ((flags & 2) !== 0 && parent._isBound()) {
                        this._setBoundTo(parent._boundTo);
                    }
                }
                var _propagateFromFunction = bindingPropagateFrom;

                function _boundValueFunction() {
                    var ret = this._boundTo;
                    if (ret !== undefined) {
                        if (ret instanceof Promise) {
                            if (ret.isFulfilled()) {
                                return ret.value();
                            } else {
                                return undefined;
                            }
                        }
                    }
                    return ret;
                }

                function longStackTracesCaptureStackTrace() {
                    this._trace = new CapturedTrace(this._peekContext());
                }

                function longStackTracesAttachExtraTrace(error, ignoreSelf) {
                    if (canAttachTrace(error)) {
                        var trace = this._trace;
                        if (trace !== undefined) {
                            if (ignoreSelf) trace = trace._parent;
                        }
                        if (trace !== undefined) {
                            trace.attachExtraTrace(error);
                        } else if (!error.__stackCleaned__) {
                            var parsed = parseStackAndMessage(error);
                            util.notEnumerableProp(error, "stack", parsed.message + "\n" + parsed.stack.join("\n"));
                            util.notEnumerableProp(error, "__stackCleaned__", true);
                        }
                    }
                }

                function checkForgottenReturns(returnValue, promiseCreated, name, promise, parent) {
                    if (returnValue === undefined && promiseCreated !== null && wForgottenReturn) {
                        if (parent !== undefined && parent._returnedNonUndefined()) return;
                        if ((promise._bitField & 65535) === 0) return;

                        if (name) name = name + " ";
                        var handlerLine = "";
                        var creatorLine = "";
                        if (promiseCreated._trace) {
                            var traceLines = promiseCreated._trace.stack.split("\n");
                            var stack = cleanStack(traceLines);
                            for (var i = stack.length - 1; i >= 0; --i) {
                                var line = stack[i];
                                if (!nodeFramePattern.test(line)) {
                                    var lineMatches = line.match(parseLinePattern);
                                    if (lineMatches) {
                                        handlerLine = "at " + lineMatches[1] + ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
                                    }
                                    break;
                                }
                            }

                            if (stack.length > 0) {
                                var firstUserLine = stack[0];
                                for (var i = 0; i < traceLines.length; ++i) {

                                    if (traceLines[i] === firstUserLine) {
                                        if (i > 0) {
                                            creatorLine = "\n" + traceLines[i - 1];
                                        }
                                        break;
                                    }
                                }
                            }
                        }
                        var msg = "a promise was created in a " + name + "handler " + handlerLine + "but was not returned from it, " + "see http://goo.gl/rRqMUw" + creatorLine;
                        promise._warn(msg, true, promiseCreated);
                    }
                }

                function deprecated(name, replacement) {
                    var message = name + " is deprecated and will be removed in a future version.";
                    if (replacement) message += " Use " + replacement + " instead.";
                    return warn(message);
                }

                function warn(message, shouldUseOwnTrace, promise) {
                    if (!config.warnings) return;
                    var warning = new Warning(message);
                    var ctx;
                    if (shouldUseOwnTrace) {
                        promise._attachExtraTrace(warning);
                    } else if (config.longStackTraces && (ctx = Promise._peekContext())) {
                        ctx.attachExtraTrace(warning);
                    } else {
                        var parsed = parseStackAndMessage(warning);
                        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
                    }

                    if (!activeFireEvent("warning", warning)) {
                        formatAndLogError(warning, "", true);
                    }
                }

                function reconstructStack(message, stacks) {
                    for (var i = 0; i < stacks.length - 1; ++i) {
                        stacks[i].push("From previous event:");
                        stacks[i] = stacks[i].join("\n");
                    }
                    if (i < stacks.length) {
                        stacks[i] = stacks[i].join("\n");
                    }
                    return message + "\n" + stacks.join("\n");
                }

                function removeDuplicateOrEmptyJumps(stacks) {
                    for (var i = 0; i < stacks.length; ++i) {
                        if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {
                            stacks.splice(i, 1);
                            i--;
                        }
                    }
                }

                function removeCommonRoots(stacks) {
                    var current = stacks[0];
                    for (var i = 1; i < stacks.length; ++i) {
                        var prev = stacks[i];
                        var currentLastIndex = current.length - 1;
                        var currentLastLine = current[currentLastIndex];
                        var commonRootMeetPoint = -1;

                        for (var j = prev.length - 1; j >= 0; --j) {
                            if (prev[j] === currentLastLine) {
                                commonRootMeetPoint = j;
                                break;
                            }
                        }

                        for (var j = commonRootMeetPoint; j >= 0; --j) {
                            var line = prev[j];
                            if (current[currentLastIndex] === line) {
                                current.pop();
                                currentLastIndex--;
                            } else {
                                break;
                            }
                        }
                        current = prev;
                    }
                }

                function cleanStack(stack) {
                    var ret = [];
                    for (var i = 0; i < stack.length; ++i) {
                        var line = stack[i];
                        var isTraceLine = "    (No stack trace)" === line || stackFramePattern.test(line);
                        var isInternalFrame = isTraceLine && shouldIgnore(line);
                        if (isTraceLine && !isInternalFrame) {
                            if (indentStackFrames && line.charAt(0) !== " ") {
                                line = "    " + line;
                            }
                            ret.push(line);
                        }
                    }
                    return ret;
                }

                function stackFramesAsArray(error) {
                    var stack = error.stack.replace(/\s+$/g, "").split("\n");
                    for (var i = 0; i < stack.length; ++i) {
                        var line = stack[i];
                        if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
                            break;
                        }
                    }
                    if (i > 0 && error.name != "SyntaxError") {
                        stack = stack.slice(i);
                    }
                    return stack;
                }

                function parseStackAndMessage(error) {
                    var stack = error.stack;
                    var message = error.toString();
                    stack = typeof stack === "string" && stack.length > 0 ? stackFramesAsArray(error) : ["    (No stack trace)"];
                    return {
                        message: message,
                        stack: error.name == "SyntaxError" ? stack : cleanStack(stack)
                    };
                }

                function formatAndLogError(error, title, isSoft) {
                    if (typeof console !== "undefined") {
                        var message;
                        if (util.isObject(error)) {
                            var stack = error.stack;
                            message = title + formatStack(stack, error);
                        } else {
                            message = title + String(error);
                        }
                        if (typeof printWarning === "function") {
                            printWarning(message, isSoft);
                        } else if (typeof console.log === "function" || _typeof(console.log) === "object") {
                            console.log(message);
                        }
                    }
                }

                function fireRejectionEvent(name, localHandler, reason, promise) {
                    var localEventFired = false;
                    try {
                        if (typeof localHandler === "function") {
                            localEventFired = true;
                            if (name === "rejectionHandled") {
                                localHandler(promise);
                            } else {
                                localHandler(reason, promise);
                            }
                        }
                    } catch (e) {
                        async.throwLater(e);
                    }

                    if (name === "unhandledRejection") {
                        if (!activeFireEvent(name, reason, promise) && !localEventFired) {
                            formatAndLogError(reason, "Unhandled rejection ");
                        }
                    } else {
                        activeFireEvent(name, promise);
                    }
                }

                function formatNonError(obj) {
                    var str;
                    if (typeof obj === "function") {
                        str = "[function " + (obj.name || "anonymous") + "]";
                    } else {
                        str = obj && typeof obj.toString === "function" ? obj.toString() : util.toString(obj);
                        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
                        if (ruselessToString.test(str)) {
                            try {
                                var newStr = JSON.stringify(obj);
                                str = newStr;
                            } catch (e) {}
                        }
                        if (str.length === 0) {
                            str = "(empty array)";
                        }
                    }
                    return "(<" + snip(str) + ">, no stack trace)";
                }

                function snip(str) {
                    var maxChars = 41;
                    if (str.length < maxChars) {
                        return str;
                    }
                    return str.substr(0, maxChars - 3) + "...";
                }

                function longStackTracesIsSupported() {
                    return typeof captureStackTrace === "function";
                }

                var shouldIgnore = function shouldIgnore() {
                    return false;
                };
                var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
                function parseLineInfo(line) {
                    var matches = line.match(parseLineInfoRegex);
                    if (matches) {
                        return {
                            fileName: matches[1],
                            line: parseInt(matches[2], 10)
                        };
                    }
                }

                function setBounds(firstLineError, lastLineError) {
                    if (!longStackTracesIsSupported()) return;
                    var firstStackLines = firstLineError.stack.split("\n");
                    var lastStackLines = lastLineError.stack.split("\n");
                    var firstIndex = -1;
                    var lastIndex = -1;
                    var firstFileName;
                    var lastFileName;
                    for (var i = 0; i < firstStackLines.length; ++i) {
                        var result = parseLineInfo(firstStackLines[i]);
                        if (result) {
                            firstFileName = result.fileName;
                            firstIndex = result.line;
                            break;
                        }
                    }
                    for (var i = 0; i < lastStackLines.length; ++i) {
                        var result = parseLineInfo(lastStackLines[i]);
                        if (result) {
                            lastFileName = result.fileName;
                            lastIndex = result.line;
                            break;
                        }
                    }
                    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
                        return;
                    }

                    shouldIgnore = function shouldIgnore(line) {
                        if (bluebirdFramePattern.test(line)) return true;
                        var info = parseLineInfo(line);
                        if (info) {
                            if (info.fileName === firstFileName && firstIndex <= info.line && info.line <= lastIndex) {
                                return true;
                            }
                        }
                        return false;
                    };
                }

                function CapturedTrace(parent) {
                    this._parent = parent;
                    this._promisesCreated = 0;
                    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
                    captureStackTrace(this, CapturedTrace);
                    if (length > 32) this.uncycle();
                }
                util.inherits(CapturedTrace, Error);
                Context.CapturedTrace = CapturedTrace;

                CapturedTrace.prototype.uncycle = function () {
                    var length = this._length;
                    if (length < 2) return;
                    var nodes = [];
                    var stackToIndex = {};

                    for (var i = 0, node = this; node !== undefined; ++i) {
                        nodes.push(node);
                        node = node._parent;
                    }
                    length = this._length = i;
                    for (var i = length - 1; i >= 0; --i) {
                        var stack = nodes[i].stack;
                        if (stackToIndex[stack] === undefined) {
                            stackToIndex[stack] = i;
                        }
                    }
                    for (var i = 0; i < length; ++i) {
                        var currentStack = nodes[i].stack;
                        var index = stackToIndex[currentStack];
                        if (index !== undefined && index !== i) {
                            if (index > 0) {
                                nodes[index - 1]._parent = undefined;
                                nodes[index - 1]._length = 1;
                            }
                            nodes[i]._parent = undefined;
                            nodes[i]._length = 1;
                            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;

                            if (index < length - 1) {
                                cycleEdgeNode._parent = nodes[index + 1];
                                cycleEdgeNode._parent.uncycle();
                                cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;
                            } else {
                                cycleEdgeNode._parent = undefined;
                                cycleEdgeNode._length = 1;
                            }
                            var currentChildLength = cycleEdgeNode._length + 1;
                            for (var j = i - 2; j >= 0; --j) {
                                nodes[j]._length = currentChildLength;
                                currentChildLength++;
                            }
                            return;
                        }
                    }
                };

                CapturedTrace.prototype.attachExtraTrace = function (error) {
                    if (error.__stackCleaned__) return;
                    this.uncycle();
                    var parsed = parseStackAndMessage(error);
                    var message = parsed.message;
                    var stacks = [parsed.stack];

                    var trace = this;
                    while (trace !== undefined) {
                        stacks.push(cleanStack(trace.stack.split("\n")));
                        trace = trace._parent;
                    }
                    removeCommonRoots(stacks);
                    removeDuplicateOrEmptyJumps(stacks);
                    util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
                    util.notEnumerableProp(error, "__stackCleaned__", true);
                };

                var captureStackTrace = function stackDetection() {
                    var v8stackFramePattern = /^\s*at\s*/;
                    var v8stackFormatter = function v8stackFormatter(stack, error) {
                        if (typeof stack === "string") return stack;

                        if (error.name !== undefined && error.message !== undefined) {
                            return error.toString();
                        }
                        return formatNonError(error);
                    };

                    if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
                        Error.stackTraceLimit += 6;
                        stackFramePattern = v8stackFramePattern;
                        formatStack = v8stackFormatter;
                        var captureStackTrace = Error.captureStackTrace;

                        shouldIgnore = function shouldIgnore(line) {
                            return bluebirdFramePattern.test(line);
                        };
                        return function (receiver, ignoreUntil) {
                            Error.stackTraceLimit += 6;
                            captureStackTrace(receiver, ignoreUntil);
                            Error.stackTraceLimit -= 6;
                        };
                    }
                    var err = new Error();

                    if (typeof err.stack === "string" && err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
                        stackFramePattern = /@/;
                        formatStack = v8stackFormatter;
                        indentStackFrames = true;
                        return function captureStackTrace(o) {
                            o.stack = new Error().stack;
                        };
                    }

                    var hasStackAfterThrow;
                    try {
                        throw new Error();
                    } catch (e) {
                        hasStackAfterThrow = "stack" in e;
                    }
                    if (!("stack" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === "number") {
                        stackFramePattern = v8stackFramePattern;
                        formatStack = v8stackFormatter;
                        return function captureStackTrace(o) {
                            Error.stackTraceLimit += 6;
                            try {
                                throw new Error();
                            } catch (e) {
                                o.stack = e.stack;
                            }
                            Error.stackTraceLimit -= 6;
                        };
                    }

                    formatStack = function formatStack(stack, error) {
                        if (typeof stack === "string") return stack;

                        if (((typeof error === "undefined" ? "undefined" : _typeof(error)) === "object" || typeof error === "function") && error.name !== undefined && error.message !== undefined) {
                            return error.toString();
                        }
                        return formatNonError(error);
                    };

                    return null;
                }([]);

                if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
                    printWarning = function printWarning(message) {
                        console.warn(message);
                    };
                    if (util.isNode && process.stderr.isTTY) {
                        printWarning = function printWarning(message, isSoft) {
                            var color = isSoft ? "\x1B[33m" : "\x1B[31m";
                            console.warn(color + message + "\x1B[0m\n");
                        };
                    } else if (!util.isNode && typeof new Error().stack === "string") {
                        printWarning = function printWarning(message, isSoft) {
                            console.warn("%c" + message, isSoft ? "color: darkorange" : "color: red");
                        };
                    }
                }

                var config = {
                    warnings: warnings,
                    longStackTraces: false,
                    cancellation: false,
                    monitoring: false
                };

                if (longStackTraces) Promise.longStackTraces();

                return {
                    longStackTraces: function longStackTraces() {
                        return config.longStackTraces;
                    },
                    warnings: function warnings() {
                        return config.warnings;
                    },
                    cancellation: function cancellation() {
                        return config.cancellation;
                    },
                    monitoring: function monitoring() {
                        return config.monitoring;
                    },
                    propagateFromFunction: function propagateFromFunction() {
                        return _propagateFromFunction;
                    },
                    boundValueFunction: function boundValueFunction() {
                        return _boundValueFunction;
                    },
                    checkForgottenReturns: checkForgottenReturns,
                    setBounds: setBounds,
                    warn: warn,
                    deprecated: deprecated,
                    CapturedTrace: CapturedTrace,
                    fireDomEvent: fireDomEvent,
                    fireGlobalEvent: fireGlobalEvent
                };
            };
        }, { "./errors": 12, "./util": 36 }], 10: [function (_dereq_, module, exports) {
            "use strict";

            module.exports = function (Promise) {
                function returner() {
                    return this.value;
                }
                function thrower() {
                    throw this.reason;
                }

                Promise.prototype["return"] = Promise.prototype.thenReturn = function (value) {
                    if (value instanceof Promise) value.suppressUnhandledRejections();
                    return this._then(returner, undefined, undefined, { value: value }, undefined);
                };

                Promise.prototype["throw"] = Promise.prototype.thenThrow = function (reason) {
                    return this._then(thrower, undefined, undefined, { reason: reason }, undefined);
                };

                Promise.prototype.catchThrow = function (reason) {
                    if (arguments.length <= 1) {
                        return this._then(undefined, thrower, undefined, { reason: reason }, undefined);
                    } else {
                        var _reason = arguments[1];
                        var handler = function handler() {
                            throw _reason;
                        };
                        return this.caught(reason, handler);
                    }
                };

                Promise.prototype.catchReturn = function (value) {
                    if (arguments.length <= 1) {
                        if (value instanceof Promise) value.suppressUnhandledRejections();
                        return this._then(undefined, returner, undefined, { value: value }, undefined);
                    } else {
                        var _value = arguments[1];
                        if (_value instanceof Promise) _value.suppressUnhandledRejections();
                        var handler = function handler() {
                            return _value;
                        };
                        return this.caught(value, handler);
                    }
                };
            };
        }, {}], 11: [function (_dereq_, module, exports) {
            "use strict";

            module.exports = function (Promise, INTERNAL) {
                var PromiseReduce = Promise.reduce;
                var PromiseAll = Promise.all;

                function promiseAllThis() {
                    return PromiseAll(this);
                }

                function PromiseMapSeries(promises, fn) {
                    return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
                }

                Promise.prototype.each = function (fn) {
                    return PromiseReduce(this, fn, INTERNAL, 0)._then(promiseAllThis, undefined, undefined, this, undefined);
                };

                Promise.prototype.mapSeries = function (fn) {
                    return PromiseReduce(this, fn, INTERNAL, INTERNAL);
                };

                Promise.each = function (promises, fn) {
                    return PromiseReduce(promises, fn, INTERNAL, 0)._then(promiseAllThis, undefined, undefined, promises, undefined);
                };

                Promise.mapSeries = PromiseMapSeries;
            };
        }, {}], 12: [function (_dereq_, module, exports) {
            "use strict";

            var es5 = _dereq_("./es5");
            var Objectfreeze = es5.freeze;
            var util = _dereq_("./util");
            var inherits = util.inherits;
            var notEnumerableProp = util.notEnumerableProp;

            function subError(nameProperty, defaultMessage) {
                function SubError(message) {
                    if (!(this instanceof SubError)) return new SubError(message);
                    notEnumerableProp(this, "message", typeof message === "string" ? message : defaultMessage);
                    notEnumerableProp(this, "name", nameProperty);
                    if (Error.captureStackTrace) {
                        Error.captureStackTrace(this, this.constructor);
                    } else {
                        Error.call(this);
                    }
                }
                inherits(SubError, Error);
                return SubError;
            }

            var _TypeError, _RangeError;
            var Warning = subError("Warning", "warning");
            var CancellationError = subError("CancellationError", "cancellation error");
            var TimeoutError = subError("TimeoutError", "timeout error");
            var AggregateError = subError("AggregateError", "aggregate error");
            try {
                _TypeError = TypeError;
                _RangeError = RangeError;
            } catch (e) {
                _TypeError = subError("TypeError", "type error");
                _RangeError = subError("RangeError", "range error");
            }

            var methods = ("join pop push shift unshift slice filter forEach some " + "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");

            for (var i = 0; i < methods.length; ++i) {
                if (typeof Array.prototype[methods[i]] === "function") {
                    AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
                }
            }

            es5.defineProperty(AggregateError.prototype, "length", {
                value: 0,
                configurable: false,
                writable: true,
                enumerable: true
            });
            AggregateError.prototype["isOperational"] = true;
            var level = 0;
            AggregateError.prototype.toString = function () {
                var indent = Array(level * 4 + 1).join(" ");
                var ret = "\n" + indent + "AggregateError of:" + "\n";
                level++;
                indent = Array(level * 4 + 1).join(" ");
                for (var i = 0; i < this.length; ++i) {
                    var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
                    var lines = str.split("\n");
                    for (var j = 0; j < lines.length; ++j) {
                        lines[j] = indent + lines[j];
                    }
                    str = lines.join("\n");
                    ret += str + "\n";
                }
                level--;
                return ret;
            };

            function OperationalError(message) {
                if (!(this instanceof OperationalError)) return new OperationalError(message);
                notEnumerableProp(this, "name", "OperationalError");
                notEnumerableProp(this, "message", message);
                this.cause = message;
                this["isOperational"] = true;

                if (message instanceof Error) {
                    notEnumerableProp(this, "message", message.message);
                    notEnumerableProp(this, "stack", message.stack);
                } else if (Error.captureStackTrace) {
                    Error.captureStackTrace(this, this.constructor);
                }
            }
            inherits(OperationalError, Error);

            var errorTypes = Error["__BluebirdErrorTypes__"];
            if (!errorTypes) {
                errorTypes = Objectfreeze({
                    CancellationError: CancellationError,
                    TimeoutError: TimeoutError,
                    OperationalError: OperationalError,
                    RejectionError: OperationalError,
                    AggregateError: AggregateError
                });
                es5.defineProperty(Error, "__BluebirdErrorTypes__", {
                    value: errorTypes,
                    writable: false,
                    enumerable: false,
                    configurable: false
                });
            }

            module.exports = {
                Error: Error,
                TypeError: _TypeError,
                RangeError: _RangeError,
                CancellationError: errorTypes.CancellationError,
                OperationalError: errorTypes.OperationalError,
                TimeoutError: errorTypes.TimeoutError,
                AggregateError: errorTypes.AggregateError,
                Warning: Warning
            };
        }, { "./es5": 13, "./util": 36 }], 13: [function (_dereq_, module, exports) {
            var isES5 = function () {
                "use strict";

                return this === undefined;
            }();

            if (isES5) {
                module.exports = {
                    freeze: Object.freeze,
                    defineProperty: Object.defineProperty,
                    getDescriptor: Object.getOwnPropertyDescriptor,
                    keys: Object.keys,
                    names: Object.getOwnPropertyNames,
                    getPrototypeOf: Object.getPrototypeOf,
                    isArray: Array.isArray,
                    isES5: isES5,
                    propertyIsWritable: function propertyIsWritable(obj, prop) {
                        var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
                        return !!(!descriptor || descriptor.writable || descriptor.set);
                    }
                };
            } else {
                var has = {}.hasOwnProperty;
                var str = {}.toString;
                var proto = {}.constructor.prototype;

                var ObjectKeys = function ObjectKeys(o) {
                    var ret = [];
                    for (var key in o) {
                        if (has.call(o, key)) {
                            ret.push(key);
                        }
                    }
                    return ret;
                };

                var ObjectGetDescriptor = function ObjectGetDescriptor(o, key) {
                    return { value: o[key] };
                };

                var ObjectDefineProperty = function ObjectDefineProperty(o, key, desc) {
                    o[key] = desc.value;
                    return o;
                };

                var ObjectFreeze = function ObjectFreeze(obj) {
                    return obj;
                };

                var ObjectGetPrototypeOf = function ObjectGetPrototypeOf(obj) {
                    try {
                        return Object(obj).constructor.prototype;
                    } catch (e) {
                        return proto;
                    }
                };

                var ArrayIsArray = function ArrayIsArray(obj) {
                    try {
                        return str.call(obj) === "[object Array]";
                    } catch (e) {
                        return false;
                    }
                };

                module.exports = {
                    isArray: ArrayIsArray,
                    keys: ObjectKeys,
                    names: ObjectKeys,
                    defineProperty: ObjectDefineProperty,
                    getDescriptor: ObjectGetDescriptor,
                    freeze: ObjectFreeze,
                    getPrototypeOf: ObjectGetPrototypeOf,
                    isES5: isES5,
                    propertyIsWritable: function propertyIsWritable() {
                        return true;
                    }
                };
            }
        }, {}], 14: [function (_dereq_, module, exports) {
            "use strict";

            module.exports = function (Promise, INTERNAL) {
                var PromiseMap = Promise.map;

                Promise.prototype.filter = function (fn, options) {
                    return PromiseMap(this, fn, options, INTERNAL);
                };

                Promise.filter = function (promises, fn, options) {
                    return PromiseMap(promises, fn, options, INTERNAL);
                };
            };
        }, {}], 15: [function (_dereq_, module, exports) {
            "use strict";

            module.exports = function (Promise, tryConvertToPromise, NEXT_FILTER) {
                var util = _dereq_("./util");
                var CancellationError = Promise.CancellationError;
                var errorObj = util.errorObj;
                var catchFilter = _dereq_("./catch_filter")(NEXT_FILTER);

                function PassThroughHandlerContext(promise, type, handler) {
                    this.promise = promise;
                    this.type = type;
                    this.handler = handler;
                    this.called = false;
                    this.cancelPromise = null;
                }

                PassThroughHandlerContext.prototype.isFinallyHandler = function () {
                    return this.type === 0;
                };

                function FinallyHandlerCancelReaction(finallyHandler) {
                    this.finallyHandler = finallyHandler;
                }

                FinallyHandlerCancelReaction.prototype._resultCancelled = function () {
                    checkCancel(this.finallyHandler);
                };

                function checkCancel(ctx, reason) {
                    if (ctx.cancelPromise != null) {
                        if (arguments.length > 1) {
                            ctx.cancelPromise._reject(reason);
                        } else {
                            ctx.cancelPromise._cancel();
                        }
                        ctx.cancelPromise = null;
                        return true;
                    }
                    return false;
                }

                function succeed() {
                    return finallyHandler.call(this, this.promise._target()._settledValue());
                }
                function fail(reason) {
                    if (checkCancel(this, reason)) return;
                    errorObj.e = reason;
                    return errorObj;
                }
                function finallyHandler(reasonOrValue) {
                    var promise = this.promise;
                    var handler = this.handler;

                    if (!this.called) {
                        this.called = true;
                        var ret = this.isFinallyHandler() ? handler.call(promise._boundValue()) : handler.call(promise._boundValue(), reasonOrValue);
                        if (ret === NEXT_FILTER) {
                            return ret;
                        } else if (ret !== undefined) {
                            promise._setReturnedNonUndefined();
                            var maybePromise = tryConvertToPromise(ret, promise);
                            if (maybePromise instanceof Promise) {
                                if (this.cancelPromise != null) {
                                    if (maybePromise._isCancelled()) {
                                        var reason = new CancellationError("late cancellation observer");
                                        promise._attachExtraTrace(reason);
                                        errorObj.e = reason;
                                        return errorObj;
                                    } else if (maybePromise.isPending()) {
                                        maybePromise._attachCancellationCallback(new FinallyHandlerCancelReaction(this));
                                    }
                                }
                                return maybePromise._then(succeed, fail, undefined, this, undefined);
                            }
                        }
                    }

                    if (promise.isRejected()) {
                        checkCancel(this);
                        errorObj.e = reasonOrValue;
                        return errorObj;
                    } else {
                        checkCancel(this);
                        return reasonOrValue;
                    }
                }

                Promise.prototype._passThrough = function (handler, type, success, fail) {
                    if (typeof handler !== "function") return this.then();
                    return this._then(success, fail, undefined, new PassThroughHandlerContext(this, type, handler), undefined);
                };

                Promise.prototype.lastly = Promise.prototype["finally"] = function (handler) {
                    return this._passThrough(handler, 0, finallyHandler, finallyHandler);
                };

                Promise.prototype.tap = function (handler) {
                    return this._passThrough(handler, 1, finallyHandler);
                };

                Promise.prototype.tapCatch = function (handlerOrPredicate) {
                    var len = arguments.length;
                    if (len === 1) {
                        return this._passThrough(handlerOrPredicate, 1, undefined, finallyHandler);
                    } else {
                        var catchInstances = new Array(len - 1),
                            j = 0,
                            i;
                        for (i = 0; i < len - 1; ++i) {
                            var item = arguments[i];
                            if (util.isObject(item)) {
                                catchInstances[j++] = item;
                            } else {
                                return Promise.reject(new TypeError("tapCatch statement predicate: " + "expecting an object but got " + util.classString(item)));
                            }
                        }
                        catchInstances.length = j;
                        var handler = arguments[i];
                        return this._passThrough(catchFilter(catchInstances, handler, this), 1, undefined, finallyHandler);
                    }
                };

                return PassThroughHandlerContext;
            };
        }, { "./catch_filter": 7, "./util": 36 }], 16: [function (_dereq_, module, exports) {
            "use strict";

            module.exports = function (Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug) {
                var errors = _dereq_("./errors");
                var TypeError = errors.TypeError;
                var util = _dereq_("./util");
                var errorObj = util.errorObj;
                var tryCatch = util.tryCatch;
                var yieldHandlers = [];

                function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
                    for (var i = 0; i < yieldHandlers.length; ++i) {
                        traceParent._pushContext();
                        var result = tryCatch(yieldHandlers[i])(value);
                        traceParent._popContext();
                        if (result === errorObj) {
                            traceParent._pushContext();
                            var ret = Promise.reject(errorObj.e);
                            traceParent._popContext();
                            return ret;
                        }
                        var maybePromise = tryConvertToPromise(result, traceParent);
                        if (maybePromise instanceof Promise) return maybePromise;
                    }
                    return null;
                }

                function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
                    if (debug.cancellation()) {
                        var internal = new Promise(INTERNAL);
                        var _finallyPromise = this._finallyPromise = new Promise(INTERNAL);
                        this._promise = internal.lastly(function () {
                            return _finallyPromise;
                        });
                        internal._captureStackTrace();
                        internal._setOnCancel(this);
                    } else {
                        var promise = this._promise = new Promise(INTERNAL);
                        promise._captureStackTrace();
                    }
                    this._stack = stack;
                    this._generatorFunction = generatorFunction;
                    this._receiver = receiver;
                    this._generator = undefined;
                    this._yieldHandlers = typeof yieldHandler === "function" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;
                    this._yieldedPromise = null;
                    this._cancellationPhase = false;
                }
                util.inherits(PromiseSpawn, Proxyable);

                PromiseSpawn.prototype._isResolved = function () {
                    return this._promise === null;
                };

                PromiseSpawn.prototype._cleanup = function () {
                    this._promise = this._generator = null;
                    if (debug.cancellation() && this._finallyPromise !== null) {
                        this._finallyPromise._fulfill();
                        this._finallyPromise = null;
                    }
                };

                PromiseSpawn.prototype._promiseCancelled = function () {
                    if (this._isResolved()) return;
                    var implementsReturn = typeof this._generator["return"] !== "undefined";

                    var result;
                    if (!implementsReturn) {
                        var reason = new Promise.CancellationError("generator .return() sentinel");
                        Promise.coroutine.returnSentinel = reason;
                        this._promise._attachExtraTrace(reason);
                        this._promise._pushContext();
                        result = tryCatch(this._generator["throw"]).call(this._generator, reason);
                        this._promise._popContext();
                    } else {
                        this._promise._pushContext();
                        result = tryCatch(this._generator["return"]).call(this._generator, undefined);
                        this._promise._popContext();
                    }
                    this._cancellationPhase = true;
                    this._yieldedPromise = null;
                    this._continue(result);
                };

                PromiseSpawn.prototype._promiseFulfilled = function (value) {
                    this._yieldedPromise = null;
                    this._promise._pushContext();
                    var result = tryCatch(this._generator.next).call(this._generator, value);
                    this._promise._popContext();
                    this._continue(result);
                };

                PromiseSpawn.prototype._promiseRejected = function (reason) {
                    this._yieldedPromise = null;
                    this._promise._attachExtraTrace(reason);
                    this._promise._pushContext();
                    var result = tryCatch(this._generator["throw"]).call(this._generator, reason);
                    this._promise._popContext();
                    this._continue(result);
                };

                PromiseSpawn.prototype._resultCancelled = function () {
                    if (this._yieldedPromise instanceof Promise) {
                        var promise = this._yieldedPromise;
                        this._yieldedPromise = null;
                        promise.cancel();
                    }
                };

                PromiseSpawn.prototype.promise = function () {
                    return this._promise;
                };

                PromiseSpawn.prototype._run = function () {
                    this._generator = this._generatorFunction.call(this._receiver);
                    this._receiver = this._generatorFunction = undefined;
                    this._promiseFulfilled(undefined);
                };

                PromiseSpawn.prototype._continue = function (result) {
                    var promise = this._promise;
                    if (result === errorObj) {
                        this._cleanup();
                        if (this._cancellationPhase) {
                            return promise.cancel();
                        } else {
                            return promise._rejectCallback(result.e, false);
                        }
                    }

                    var value = result.value;
                    if (result.done === true) {
                        this._cleanup();
                        if (this._cancellationPhase) {
                            return promise.cancel();
                        } else {
                            return promise._resolveCallback(value);
                        }
                    } else {
                        var maybePromise = tryConvertToPromise(value, this._promise);
                        if (!(maybePromise instanceof Promise)) {
                            maybePromise = promiseFromYieldHandler(maybePromise, this._yieldHandlers, this._promise);
                            if (maybePromise === null) {
                                this._promiseRejected(new TypeError("A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n".replace("%s", String(value)) + "From coroutine:\n" + this._stack.split("\n").slice(1, -7).join("\n")));
                                return;
                            }
                        }
                        maybePromise = maybePromise._target();
                        var bitField = maybePromise._bitField;
                        ;
                        if ((bitField & 50397184) === 0) {
                            this._yieldedPromise = maybePromise;
                            maybePromise._proxy(this, null);
                        } else if ((bitField & 33554432) !== 0) {
                            Promise._async.invoke(this._promiseFulfilled, this, maybePromise._value());
                        } else if ((bitField & 16777216) !== 0) {
                            Promise._async.invoke(this._promiseRejected, this, maybePromise._reason());
                        } else {
                            this._promiseCancelled();
                        }
                    }
                };

                Promise.coroutine = function (generatorFunction, options) {
                    if (typeof generatorFunction !== "function") {
                        throw new TypeError("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
                    }
                    var yieldHandler = Object(options).yieldHandler;
                    var PromiseSpawn$ = PromiseSpawn;
                    var stack = new Error().stack;
                    return function () {
                        var generator = generatorFunction.apply(this, arguments);
                        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler, stack);
                        var ret = spawn.promise();
                        spawn._generator = generator;
                        spawn._promiseFulfilled(undefined);
                        return ret;
                    };
                };

                Promise.coroutine.addYieldHandler = function (fn) {
                    if (typeof fn !== "function") {
                        throw new TypeError("expecting a function but got " + util.classString(fn));
                    }
                    yieldHandlers.push(fn);
                };

                Promise.spawn = function (generatorFunction) {
                    debug.deprecated("Promise.spawn()", "Promise.coroutine()");
                    if (typeof generatorFunction !== "function") {
                        return apiRejection("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
                    }
                    var spawn = new PromiseSpawn(generatorFunction, this);
                    var ret = spawn.promise();
                    spawn._run(Promise.spawn);
                    return ret;
                };
            };
        }, { "./errors": 12, "./util": 36 }], 17: [function (_dereq_, module, exports) {
            "use strict";

            module.exports = function (Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain) {
                var util = _dereq_("./util");
                var canEvaluate = util.canEvaluate;
                var tryCatch = util.tryCatch;
                var errorObj = util.errorObj;
                var reject;

                if (false) {
                    if (canEvaluate) {
                        var thenCallback = function thenCallback(i) {
                            return new Function("value", "holder", "                             \n\
            'use strict';                                                    \n\
            holder.pIndex = value;                                           \n\
            holder.checkFulfillment(this);                                   \n\
            ".replace(/Index/g, i));
                        };

                        var promiseSetter = function promiseSetter(i) {
                            return new Function("promise", "holder", "                           \n\
            'use strict';                                                    \n\
            holder.pIndex = promise;                                         \n\
            ".replace(/Index/g, i));
                        };

                        var generateHolderClass = function generateHolderClass(total) {
                            var props = new Array(total);
                            for (var i = 0; i < props.length; ++i) {
                                props[i] = "this.p" + (i + 1);
                            }
                            var assignment = props.join(" = ") + " = null;";
                            var cancellationCode = "var promise;\n" + props.map(function (prop) {
                                return "                                                         \n\
                promise = " + prop + ";                                      \n\
                if (promise instanceof Promise) {                            \n\
                    promise.cancel();                                        \n\
                }                                                            \n\
            ";
                            }).join("\n");
                            var passedArguments = props.join(", ");
                            var name = "Holder$" + total;

                            var code = "return function(tryCatch, errorObj, Promise, async) {    \n\
            'use strict';                                                    \n\
            function [TheName](fn) {                                         \n\
                [TheProperties]                                              \n\
                this.fn = fn;                                                \n\
                this.asyncNeeded = true;                                     \n\
                this.now = 0;                                                \n\
            }                                                                \n\
                                                                             \n\
            [TheName].prototype._callFunction = function(promise) {          \n\
                promise._pushContext();                                      \n\
                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n\
                promise._popContext();                                       \n\
                if (ret === errorObj) {                                      \n\
                    promise._rejectCallback(ret.e, false);                   \n\
                } else {                                                     \n\
                    promise._resolveCallback(ret);                           \n\
                }                                                            \n\
            };                                                               \n\
                                                                             \n\
            [TheName].prototype.checkFulfillment = function(promise) {       \n\
                var now = ++this.now;                                        \n\
                if (now === [TheTotal]) {                                    \n\
                    if (this.asyncNeeded) {                                  \n\
                        async.invoke(this._callFunction, this, promise);     \n\
                    } else {                                                 \n\
                        this._callFunction(promise);                         \n\
                    }                                                        \n\
                                                                             \n\
                }                                                            \n\
            };                                                               \n\
                                                                             \n\
            [TheName].prototype._resultCancelled = function() {              \n\
                [CancellationCode]                                           \n\
            };                                                               \n\
                                                                             \n\
            return [TheName];                                                \n\
        }(tryCatch, errorObj, Promise, async);                               \n\
        ";

                            code = code.replace(/\[TheName\]/g, name).replace(/\[TheTotal\]/g, total).replace(/\[ThePassedArguments\]/g, passedArguments).replace(/\[TheProperties\]/g, assignment).replace(/\[CancellationCode\]/g, cancellationCode);

                            return new Function("tryCatch", "errorObj", "Promise", "async", code)(tryCatch, errorObj, Promise, async);
                        };

                        var holderClasses = [];
                        var thenCallbacks = [];
                        var promiseSetters = [];

                        for (var i = 0; i < 8; ++i) {
                            holderClasses.push(generateHolderClass(i + 1));
                            thenCallbacks.push(thenCallback(i + 1));
                            promiseSetters.push(promiseSetter(i + 1));
                        }

                        reject = function reject(reason) {
                            this._reject(reason);
                        };
                    }
                }

                Promise.join = function () {
                    var last = arguments.length - 1;
                    var fn;
                    if (last > 0 && typeof arguments[last] === "function") {
                        fn = arguments[last];
                        if (false) {
                            if (last <= 8 && canEvaluate) {
                                var ret = new Promise(INTERNAL);
                                ret._captureStackTrace();
                                var HolderClass = holderClasses[last - 1];
                                var holder = new HolderClass(fn);
                                var callbacks = thenCallbacks;

                                for (var i = 0; i < last; ++i) {
                                    var maybePromise = tryConvertToPromise(arguments[i], ret);
                                    if (maybePromise instanceof Promise) {
                                        maybePromise = maybePromise._target();
                                        var bitField = maybePromise._bitField;
                                        ;
                                        if ((bitField & 50397184) === 0) {
                                            maybePromise._then(callbacks[i], reject, undefined, ret, holder);
                                            promiseSetters[i](maybePromise, holder);
                                            holder.asyncNeeded = false;
                                        } else if ((bitField & 33554432) !== 0) {
                                            callbacks[i].call(ret, maybePromise._value(), holder);
                                        } else if ((bitField & 16777216) !== 0) {
                                            ret._reject(maybePromise._reason());
                                        } else {
                                            ret._cancel();
                                        }
                                    } else {
                                        callbacks[i].call(ret, maybePromise, holder);
                                    }
                                }

                                if (!ret._isFateSealed()) {
                                    if (holder.asyncNeeded) {
                                        var domain = getDomain();
                                        if (domain !== null) {
                                            holder.fn = util.domainBind(domain, holder.fn);
                                        }
                                    }
                                    ret._setAsyncGuaranteed();
                                    ret._setOnCancel(holder);
                                }
                                return ret;
                            }
                        }
                    }
                    var args = [].slice.call(arguments);;
                    if (fn) args.pop();
                    var ret = new PromiseArray(args).promise();
                    return fn !== undefined ? ret.spread(fn) : ret;
                };
            };
        }, { "./util": 36 }], 18: [function (_dereq_, module, exports) {
            "use strict";

            module.exports = function (Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
                var getDomain = Promise._getDomain;
                var util = _dereq_("./util");
                var tryCatch = util.tryCatch;
                var errorObj = util.errorObj;
                var async = Promise._async;

                function MappingPromiseArray(promises, fn, limit, _filter) {
                    this.constructor$(promises);
                    this._promise._captureStackTrace();
                    var domain = getDomain();
                    this._callback = domain === null ? fn : util.domainBind(domain, fn);
                    this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;
                    this._limit = limit;
                    this._inFlight = 0;
                    this._queue = [];
                    async.invoke(this._asyncInit, this, undefined);
                }
                util.inherits(MappingPromiseArray, PromiseArray);

                MappingPromiseArray.prototype._asyncInit = function () {
                    this._init$(undefined, -2);
                };

                MappingPromiseArray.prototype._init = function () {};

                MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
                    var values = this._values;
                    var length = this.length();
                    var preservedValues = this._preservedValues;
                    var limit = this._limit;

                    if (index < 0) {
                        index = index * -1 - 1;
                        values[index] = value;
                        if (limit >= 1) {
                            this._inFlight--;
                            this._drainQueue();
                            if (this._isResolved()) return true;
                        }
                    } else {
                        if (limit >= 1 && this._inFlight >= limit) {
                            values[index] = value;
                            this._queue.push(index);
                            return false;
                        }
                        if (preservedValues !== null) preservedValues[index] = value;

                        var promise = this._promise;
                        var callback = this._callback;
                        var receiver = promise._boundValue();
                        promise._pushContext();
                        var ret = tryCatch(callback).call(receiver, value, index, length);
                        var promiseCreated = promise._popContext();
                        debug.checkForgottenReturns(ret, promiseCreated, preservedValues !== null ? "Promise.filter" : "Promise.map", promise);
                        if (ret === errorObj) {
                            this._reject(ret.e);
                            return true;
                        }

                        var maybePromise = tryConvertToPromise(ret, this._promise);
                        if (maybePromise instanceof Promise) {
                            maybePromise = maybePromise._target();
                            var bitField = maybePromise._bitField;
                            ;
                            if ((bitField & 50397184) === 0) {
                                if (limit >= 1) this._inFlight++;
                                values[index] = maybePromise;
                                maybePromise._proxy(this, (index + 1) * -1);
                                return false;
                            } else if ((bitField & 33554432) !== 0) {
                                ret = maybePromise._value();
                            } else if ((bitField & 16777216) !== 0) {
                                this._reject(maybePromise._reason());
                                return true;
                            } else {
                                this._cancel();
                                return true;
                            }
                        }
                        values[index] = ret;
                    }
                    var totalResolved = ++this._totalResolved;
                    if (totalResolved >= length) {
                        if (preservedValues !== null) {
                            this._filter(values, preservedValues);
                        } else {
                            this._resolve(values);
                        }
                        return true;
                    }
                    return false;
                };

                MappingPromiseArray.prototype._drainQueue = function () {
                    var queue = this._queue;
                    var limit = this._limit;
                    var values = this._values;
                    while (queue.length > 0 && this._inFlight < limit) {
                        if (this._isResolved()) return;
                        var index = queue.pop();
                        this._promiseFulfilled(values[index], index);
                    }
                };

                MappingPromiseArray.prototype._filter = function (booleans, values) {
                    var len = values.length;
                    var ret = new Array(len);
                    var j = 0;
                    for (var i = 0; i < len; ++i) {
                        if (booleans[i]) ret[j++] = values[i];
                    }
                    ret.length = j;
                    this._resolve(ret);
                };

                MappingPromiseArray.prototype.preservedValues = function () {
                    return this._preservedValues;
                };

                function map(promises, fn, options, _filter) {
                    if (typeof fn !== "function") {
                        return apiRejection("expecting a function but got " + util.classString(fn));
                    }

                    var limit = 0;
                    if (options !== undefined) {
                        if ((typeof options === "undefined" ? "undefined" : _typeof(options)) === "object" && options !== null) {
                            if (typeof options.concurrency !== "number") {
                                return Promise.reject(new TypeError("'concurrency' must be a number but it is " + util.classString(options.concurrency)));
                            }
                            limit = options.concurrency;
                        } else {
                            return Promise.reject(new TypeError("options argument must be an object but it is " + util.classString(options)));
                        }
                    }
                    limit = typeof limit === "number" && isFinite(limit) && limit >= 1 ? limit : 0;
                    return new MappingPromiseArray(promises, fn, limit, _filter).promise();
                }

                Promise.prototype.map = function (fn, options) {
                    return map(this, fn, options, null);
                };

                Promise.map = function (promises, fn, options, _filter) {
                    return map(promises, fn, options, _filter);
                };
            };
        }, { "./util": 36 }], 19: [function (_dereq_, module, exports) {
            "use strict";

            module.exports = function (Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {
                var util = _dereq_("./util");
                var tryCatch = util.tryCatch;

                Promise.method = function (fn) {
                    if (typeof fn !== "function") {
                        throw new Promise.TypeError("expecting a function but got " + util.classString(fn));
                    }
                    return function () {
                        var ret = new Promise(INTERNAL);
                        ret._captureStackTrace();
                        ret._pushContext();
                        var value = tryCatch(fn).apply(this, arguments);
                        var promiseCreated = ret._popContext();
                        debug.checkForgottenReturns(value, promiseCreated, "Promise.method", ret);
                        ret._resolveFromSyncValue(value);
                        return ret;
                    };
                };

                Promise.attempt = Promise["try"] = function (fn) {
                    if (typeof fn !== "function") {
                        return apiRejection("expecting a function but got " + util.classString(fn));
                    }
                    var ret = new Promise(INTERNAL);
                    ret._captureStackTrace();
                    ret._pushContext();
                    var value;
                    if (arguments.length > 1) {
                        debug.deprecated("calling Promise.try with more than 1 argument");
                        var arg = arguments[1];
                        var ctx = arguments[2];
                        value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg) : tryCatch(fn).call(ctx, arg);
                    } else {
                        value = tryCatch(fn)();
                    }
                    var promiseCreated = ret._popContext();
                    debug.checkForgottenReturns(value, promiseCreated, "Promise.try", ret);
                    ret._resolveFromSyncValue(value);
                    return ret;
                };

                Promise.prototype._resolveFromSyncValue = function (value) {
                    if (value === util.errorObj) {
                        this._rejectCallback(value.e, false);
                    } else {
                        this._resolveCallback(value, true);
                    }
                };
            };
        }, { "./util": 36 }], 20: [function (_dereq_, module, exports) {
            "use strict";

            var util = _dereq_("./util");
            var maybeWrapAsError = util.maybeWrapAsError;
            var errors = _dereq_("./errors");
            var OperationalError = errors.OperationalError;
            var es5 = _dereq_("./es5");

            function isUntypedError(obj) {
                return obj instanceof Error && es5.getPrototypeOf(obj) === Error.prototype;
            }

            var rErrorKey = /^(?:name|message|stack|cause)$/;
            function wrapAsOperationalError(obj) {
                var ret;
                if (isUntypedError(obj)) {
                    ret = new OperationalError(obj);
                    ret.name = obj.name;
                    ret.message = obj.message;
                    ret.stack = obj.stack;
                    var keys = es5.keys(obj);
                    for (var i = 0; i < keys.length; ++i) {
                        var key = keys[i];
                        if (!rErrorKey.test(key)) {
                            ret[key] = obj[key];
                        }
                    }
                    return ret;
                }
                util.markAsOriginatingFromRejection(obj);
                return obj;
            }

            function nodebackForPromise(promise, multiArgs) {
                return function (err, value) {
                    if (promise === null) return;
                    if (err) {
                        var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
                        promise._attachExtraTrace(wrapped);
                        promise._reject(wrapped);
                    } else if (!multiArgs) {
                        promise._fulfill(value);
                    } else {
                        var args = [].slice.call(arguments, 1);;
                        promise._fulfill(args);
                    }
                    promise = null;
                };
            }

            module.exports = nodebackForPromise;
        }, { "./errors": 12, "./es5": 13, "./util": 36 }], 21: [function (_dereq_, module, exports) {
            "use strict";

            module.exports = function (Promise) {
                var util = _dereq_("./util");
                var async = Promise._async;
                var tryCatch = util.tryCatch;
                var errorObj = util.errorObj;

                function spreadAdapter(val, nodeback) {
                    var promise = this;
                    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
                    var ret = tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));
                    if (ret === errorObj) {
                        async.throwLater(ret.e);
                    }
                }

                function successAdapter(val, nodeback) {
                    var promise = this;
                    var receiver = promise._boundValue();
                    var ret = val === undefined ? tryCatch(nodeback).call(receiver, null) : tryCatch(nodeback).call(receiver, null, val);
                    if (ret === errorObj) {
                        async.throwLater(ret.e);
                    }
                }
                function errorAdapter(reason, nodeback) {
                    var promise = this;
                    if (!reason) {
                        var newReason = new Error(reason + "");
                        newReason.cause = reason;
                        reason = newReason;
                    }
                    var ret = tryCatch(nodeback).call(promise._boundValue(), reason);
                    if (ret === errorObj) {
                        async.throwLater(ret.e);
                    }
                }

                Promise.prototype.asCallback = Promise.prototype.nodeify = function (nodeback, options) {
                    if (typeof nodeback == "function") {
                        var adapter = successAdapter;
                        if (options !== undefined && Object(options).spread) {
                            adapter = spreadAdapter;
                        }
                        this._then(adapter, errorAdapter, undefined, this, nodeback);
                    }
                    return this;
                };
            };
        }, { "./util": 36 }], 22: [function (_dereq_, module, exports) {
            "use strict";

            module.exports = function () {
                var makeSelfResolutionError = function makeSelfResolutionError() {
                    return new TypeError("circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n");
                };
                var reflectHandler = function reflectHandler() {
                    return new Promise.PromiseInspection(this._target());
                };
                var apiRejection = function apiRejection(msg) {
                    return Promise.reject(new TypeError(msg));
                };
                function Proxyable() {}
                var UNDEFINED_BINDING = {};
                var util = _dereq_("./util");

                var getDomain;
                if (util.isNode) {
                    getDomain = function getDomain() {
                        var ret = process.domain;
                        if (ret === undefined) ret = null;
                        return ret;
                    };
                } else {
                    getDomain = function getDomain() {
                        return null;
                    };
                }
                util.notEnumerableProp(Promise, "_getDomain", getDomain);

                var es5 = _dereq_("./es5");
                var Async = _dereq_("./async");
                var async = new Async();
                es5.defineProperty(Promise, "_async", { value: async });
                var errors = _dereq_("./errors");
                var TypeError = Promise.TypeError = errors.TypeError;
                Promise.RangeError = errors.RangeError;
                var CancellationError = Promise.CancellationError = errors.CancellationError;
                Promise.TimeoutError = errors.TimeoutError;
                Promise.OperationalError = errors.OperationalError;
                Promise.RejectionError = errors.OperationalError;
                Promise.AggregateError = errors.AggregateError;
                var INTERNAL = function INTERNAL() {};
                var APPLY = {};
                var NEXT_FILTER = {};
                var tryConvertToPromise = _dereq_("./thenables")(Promise, INTERNAL);
                var PromiseArray = _dereq_("./promise_array")(Promise, INTERNAL, tryConvertToPromise, apiRejection, Proxyable);
                var Context = _dereq_("./context")(Promise);
                /*jshint unused:false*/
                var createContext = Context.create;
                var debug = _dereq_("./debuggability")(Promise, Context);
                var CapturedTrace = debug.CapturedTrace;
                var PassThroughHandlerContext = _dereq_("./finally")(Promise, tryConvertToPromise, NEXT_FILTER);
                var catchFilter = _dereq_("./catch_filter")(NEXT_FILTER);
                var nodebackForPromise = _dereq_("./nodeback");
                var errorObj = util.errorObj;
                var tryCatch = util.tryCatch;
                function check(self, executor) {
                    if (self == null || self.constructor !== Promise) {
                        throw new TypeError("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n");
                    }
                    if (typeof executor !== "function") {
                        throw new TypeError("expecting a function but got " + util.classString(executor));
                    }
                }

                function Promise(executor) {
                    if (executor !== INTERNAL) {
                        check(this, executor);
                    }
                    this._bitField = 0;
                    this._fulfillmentHandler0 = undefined;
                    this._rejectionHandler0 = undefined;
                    this._promise0 = undefined;
                    this._receiver0 = undefined;
                    this._resolveFromExecutor(executor);
                    this._promiseCreated();
                    this._fireEvent("promiseCreated", this);
                }

                Promise.prototype.toString = function () {
                    return "[object Promise]";
                };

                Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
                    var len = arguments.length;
                    if (len > 1) {
                        var catchInstances = new Array(len - 1),
                            j = 0,
                            i;
                        for (i = 0; i < len - 1; ++i) {
                            var item = arguments[i];
                            if (util.isObject(item)) {
                                catchInstances[j++] = item;
                            } else {
                                return apiRejection("Catch statement predicate: " + "expecting an object but got " + util.classString(item));
                            }
                        }
                        catchInstances.length = j;
                        fn = arguments[i];
                        return this.then(undefined, catchFilter(catchInstances, fn, this));
                    }
                    return this.then(undefined, fn);
                };

                Promise.prototype.reflect = function () {
                    return this._then(reflectHandler, reflectHandler, undefined, this, undefined);
                };

                Promise.prototype.then = function (didFulfill, didReject) {
                    if (debug.warnings() && arguments.length > 0 && typeof didFulfill !== "function" && typeof didReject !== "function") {
                        var msg = ".then() only accepts functions but was passed: " + util.classString(didFulfill);
                        if (arguments.length > 1) {
                            msg += ", " + util.classString(didReject);
                        }
                        this._warn(msg);
                    }
                    return this._then(didFulfill, didReject, undefined, undefined, undefined);
                };

                Promise.prototype.done = function (didFulfill, didReject) {
                    var promise = this._then(didFulfill, didReject, undefined, undefined, undefined);
                    promise._setIsFinal();
                };

                Promise.prototype.spread = function (fn) {
                    if (typeof fn !== "function") {
                        return apiRejection("expecting a function but got " + util.classString(fn));
                    }
                    return this.all()._then(fn, undefined, undefined, APPLY, undefined);
                };

                Promise.prototype.toJSON = function () {
                    var ret = {
                        isFulfilled: false,
                        isRejected: false,
                        fulfillmentValue: undefined,
                        rejectionReason: undefined
                    };
                    if (this.isFulfilled()) {
                        ret.fulfillmentValue = this.value();
                        ret.isFulfilled = true;
                    } else if (this.isRejected()) {
                        ret.rejectionReason = this.reason();
                        ret.isRejected = true;
                    }
                    return ret;
                };

                Promise.prototype.all = function () {
                    if (arguments.length > 0) {
                        this._warn(".all() was passed arguments but it does not take any");
                    }
                    return new PromiseArray(this).promise();
                };

                Promise.prototype.error = function (fn) {
                    return this.caught(util.originatesFromRejection, fn);
                };

                Promise.getNewLibraryCopy = module.exports;

                Promise.is = function (val) {
                    return val instanceof Promise;
                };

                Promise.fromNode = Promise.fromCallback = function (fn) {
                    var ret = new Promise(INTERNAL);
                    ret._captureStackTrace();
                    var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : false;
                    var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));
                    if (result === errorObj) {
                        ret._rejectCallback(result.e, true);
                    }
                    if (!ret._isFateSealed()) ret._setAsyncGuaranteed();
                    return ret;
                };

                Promise.all = function (promises) {
                    return new PromiseArray(promises).promise();
                };

                Promise.cast = function (obj) {
                    var ret = tryConvertToPromise(obj);
                    if (!(ret instanceof Promise)) {
                        ret = new Promise(INTERNAL);
                        ret._captureStackTrace();
                        ret._setFulfilled();
                        ret._rejectionHandler0 = obj;
                    }
                    return ret;
                };

                Promise.resolve = Promise.fulfilled = Promise.cast;

                Promise.reject = Promise.rejected = function (reason) {
                    var ret = new Promise(INTERNAL);
                    ret._captureStackTrace();
                    ret._rejectCallback(reason, true);
                    return ret;
                };

                Promise.setScheduler = function (fn) {
                    if (typeof fn !== "function") {
                        throw new TypeError("expecting a function but got " + util.classString(fn));
                    }
                    return async.setScheduler(fn);
                };

                Promise.prototype._then = function (didFulfill, didReject, _, receiver, internalData) {
                    var haveInternalData = internalData !== undefined;
                    var promise = haveInternalData ? internalData : new Promise(INTERNAL);
                    var target = this._target();
                    var bitField = target._bitField;

                    if (!haveInternalData) {
                        promise._propagateFrom(this, 3);
                        promise._captureStackTrace();
                        if (receiver === undefined && (this._bitField & 2097152) !== 0) {
                            if (!((bitField & 50397184) === 0)) {
                                receiver = this._boundValue();
                            } else {
                                receiver = target === this ? undefined : this._boundTo;
                            }
                        }
                        this._fireEvent("promiseChained", this, promise);
                    }

                    var domain = getDomain();
                    if (!((bitField & 50397184) === 0)) {
                        var handler,
                            value,
                            settler = target._settlePromiseCtx;
                        if ((bitField & 33554432) !== 0) {
                            value = target._rejectionHandler0;
                            handler = didFulfill;
                        } else if ((bitField & 16777216) !== 0) {
                            value = target._fulfillmentHandler0;
                            handler = didReject;
                            target._unsetRejectionIsUnhandled();
                        } else {
                            settler = target._settlePromiseLateCancellationObserver;
                            value = new CancellationError("late cancellation observer");
                            target._attachExtraTrace(value);
                            handler = didReject;
                        }

                        async.invoke(settler, target, {
                            handler: domain === null ? handler : typeof handler === "function" && util.domainBind(domain, handler),
                            promise: promise,
                            receiver: receiver,
                            value: value
                        });
                    } else {
                        target._addCallbacks(didFulfill, didReject, promise, receiver, domain);
                    }

                    return promise;
                };

                Promise.prototype._length = function () {
                    return this._bitField & 65535;
                };

                Promise.prototype._isFateSealed = function () {
                    return (this._bitField & 117506048) !== 0;
                };

                Promise.prototype._isFollowing = function () {
                    return (this._bitField & 67108864) === 67108864;
                };

                Promise.prototype._setLength = function (len) {
                    this._bitField = this._bitField & -65536 | len & 65535;
                };

                Promise.prototype._setFulfilled = function () {
                    this._bitField = this._bitField | 33554432;
                    this._fireEvent("promiseFulfilled", this);
                };

                Promise.prototype._setRejected = function () {
                    this._bitField = this._bitField | 16777216;
                    this._fireEvent("promiseRejected", this);
                };

                Promise.prototype._setFollowing = function () {
                    this._bitField = this._bitField | 67108864;
                    this._fireEvent("promiseResolved", this);
                };

                Promise.prototype._setIsFinal = function () {
                    this._bitField = this._bitField | 4194304;
                };

                Promise.prototype._isFinal = function () {
                    return (this._bitField & 4194304) > 0;
                };

                Promise.prototype._unsetCancelled = function () {
                    this._bitField = this._bitField & ~65536;
                };

                Promise.prototype._setCancelled = function () {
                    this._bitField = this._bitField | 65536;
                    this._fireEvent("promiseCancelled", this);
                };

                Promise.prototype._setWillBeCancelled = function () {
                    this._bitField = this._bitField | 8388608;
                };

                Promise.prototype._setAsyncGuaranteed = function () {
                    if (async.hasCustomScheduler()) return;
                    this._bitField = this._bitField | 134217728;
                };

                Promise.prototype._receiverAt = function (index) {
                    var ret = index === 0 ? this._receiver0 : this[index * 4 - 4 + 3];
                    if (ret === UNDEFINED_BINDING) {
                        return undefined;
                    } else if (ret === undefined && this._isBound()) {
                        return this._boundValue();
                    }
                    return ret;
                };

                Promise.prototype._promiseAt = function (index) {
                    return this[index * 4 - 4 + 2];
                };

                Promise.prototype._fulfillmentHandlerAt = function (index) {
                    return this[index * 4 - 4 + 0];
                };

                Promise.prototype._rejectionHandlerAt = function (index) {
                    return this[index * 4 - 4 + 1];
                };

                Promise.prototype._boundValue = function () {};

                Promise.prototype._migrateCallback0 = function (follower) {
                    var bitField = follower._bitField;
                    var fulfill = follower._fulfillmentHandler0;
                    var reject = follower._rejectionHandler0;
                    var promise = follower._promise0;
                    var receiver = follower._receiverAt(0);
                    if (receiver === undefined) receiver = UNDEFINED_BINDING;
                    this._addCallbacks(fulfill, reject, promise, receiver, null);
                };

                Promise.prototype._migrateCallbackAt = function (follower, index) {
                    var fulfill = follower._fulfillmentHandlerAt(index);
                    var reject = follower._rejectionHandlerAt(index);
                    var promise = follower._promiseAt(index);
                    var receiver = follower._receiverAt(index);
                    if (receiver === undefined) receiver = UNDEFINED_BINDING;
                    this._addCallbacks(fulfill, reject, promise, receiver, null);
                };

                Promise.prototype._addCallbacks = function (fulfill, reject, promise, receiver, domain) {
                    var index = this._length();

                    if (index >= 65535 - 4) {
                        index = 0;
                        this._setLength(0);
                    }

                    if (index === 0) {
                        this._promise0 = promise;
                        this._receiver0 = receiver;
                        if (typeof fulfill === "function") {
                            this._fulfillmentHandler0 = domain === null ? fulfill : util.domainBind(domain, fulfill);
                        }
                        if (typeof reject === "function") {
                            this._rejectionHandler0 = domain === null ? reject : util.domainBind(domain, reject);
                        }
                    } else {
                        var base = index * 4 - 4;
                        this[base + 2] = promise;
                        this[base + 3] = receiver;
                        if (typeof fulfill === "function") {
                            this[base + 0] = domain === null ? fulfill : util.domainBind(domain, fulfill);
                        }
                        if (typeof reject === "function") {
                            this[base + 1] = domain === null ? reject : util.domainBind(domain, reject);
                        }
                    }
                    this._setLength(index + 1);
                    return index;
                };

                Promise.prototype._proxy = function (proxyable, arg) {
                    this._addCallbacks(undefined, undefined, arg, proxyable, null);
                };

                Promise.prototype._resolveCallback = function (value, shouldBind) {
                    if ((this._bitField & 117506048) !== 0) return;
                    if (value === this) return this._rejectCallback(makeSelfResolutionError(), false);
                    var maybePromise = tryConvertToPromise(value, this);
                    if (!(maybePromise instanceof Promise)) return this._fulfill(value);

                    if (shouldBind) this._propagateFrom(maybePromise, 2);

                    var promise = maybePromise._target();

                    if (promise === this) {
                        this._reject(makeSelfResolutionError());
                        return;
                    }

                    var bitField = promise._bitField;
                    if ((bitField & 50397184) === 0) {
                        var len = this._length();
                        if (len > 0) promise._migrateCallback0(this);
                        for (var i = 1; i < len; ++i) {
                            promise._migrateCallbackAt(this, i);
                        }
                        this._setFollowing();
                        this._setLength(0);
                        this._setFollowee(promise);
                    } else if ((bitField & 33554432) !== 0) {
                        this._fulfill(promise._value());
                    } else if ((bitField & 16777216) !== 0) {
                        this._reject(promise._reason());
                    } else {
                        var reason = new CancellationError("late cancellation observer");
                        promise._attachExtraTrace(reason);
                        this._reject(reason);
                    }
                };

                Promise.prototype._rejectCallback = function (reason, synchronous, ignoreNonErrorWarnings) {
                    var trace = util.ensureErrorObject(reason);
                    var hasStack = trace === reason;
                    if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
                        var message = "a promise was rejected with a non-error: " + util.classString(reason);
                        this._warn(message, true);
                    }
                    this._attachExtraTrace(trace, synchronous ? hasStack : false);
                    this._reject(reason);
                };

                Promise.prototype._resolveFromExecutor = function (executor) {
                    if (executor === INTERNAL) return;
                    var promise = this;
                    this._captureStackTrace();
                    this._pushContext();
                    var synchronous = true;
                    var r = this._execute(executor, function (value) {
                        promise._resolveCallback(value);
                    }, function (reason) {
                        promise._rejectCallback(reason, synchronous);
                    });
                    synchronous = false;
                    this._popContext();

                    if (r !== undefined) {
                        promise._rejectCallback(r, true);
                    }
                };

                Promise.prototype._settlePromiseFromHandler = function (handler, receiver, value, promise) {
                    var bitField = promise._bitField;
                    if ((bitField & 65536) !== 0) return;
                    promise._pushContext();
                    var x;
                    if (receiver === APPLY) {
                        if (!value || typeof value.length !== "number") {
                            x = errorObj;
                            x.e = new TypeError("cannot .spread() a non-array: " + util.classString(value));
                        } else {
                            x = tryCatch(handler).apply(this._boundValue(), value);
                        }
                    } else {
                        x = tryCatch(handler).call(receiver, value);
                    }
                    var promiseCreated = promise._popContext();
                    bitField = promise._bitField;
                    if ((bitField & 65536) !== 0) return;

                    if (x === NEXT_FILTER) {
                        promise._reject(value);
                    } else if (x === errorObj) {
                        promise._rejectCallback(x.e, false);
                    } else {
                        debug.checkForgottenReturns(x, promiseCreated, "", promise, this);
                        promise._resolveCallback(x);
                    }
                };

                Promise.prototype._target = function () {
                    var ret = this;
                    while (ret._isFollowing()) {
                        ret = ret._followee();
                    }return ret;
                };

                Promise.prototype._followee = function () {
                    return this._rejectionHandler0;
                };

                Promise.prototype._setFollowee = function (promise) {
                    this._rejectionHandler0 = promise;
                };

                Promise.prototype._settlePromise = function (promise, handler, receiver, value) {
                    var isPromise = promise instanceof Promise;
                    var bitField = this._bitField;
                    var asyncGuaranteed = (bitField & 134217728) !== 0;
                    if ((bitField & 65536) !== 0) {
                        if (isPromise) promise._invokeInternalOnCancel();

                        if (receiver instanceof PassThroughHandlerContext && receiver.isFinallyHandler()) {
                            receiver.cancelPromise = promise;
                            if (tryCatch(handler).call(receiver, value) === errorObj) {
                                promise._reject(errorObj.e);
                            }
                        } else if (handler === reflectHandler) {
                            promise._fulfill(reflectHandler.call(receiver));
                        } else if (receiver instanceof Proxyable) {
                            receiver._promiseCancelled(promise);
                        } else if (isPromise || promise instanceof PromiseArray) {
                            promise._cancel();
                        } else {
                            receiver.cancel();
                        }
                    } else if (typeof handler === "function") {
                        if (!isPromise) {
                            handler.call(receiver, value, promise);
                        } else {
                            if (asyncGuaranteed) promise._setAsyncGuaranteed();
                            this._settlePromiseFromHandler(handler, receiver, value, promise);
                        }
                    } else if (receiver instanceof Proxyable) {
                        if (!receiver._isResolved()) {
                            if ((bitField & 33554432) !== 0) {
                                receiver._promiseFulfilled(value, promise);
                            } else {
                                receiver._promiseRejected(value, promise);
                            }
                        }
                    } else if (isPromise) {
                        if (asyncGuaranteed) promise._setAsyncGuaranteed();
                        if ((bitField & 33554432) !== 0) {
                            promise._fulfill(value);
                        } else {
                            promise._reject(value);
                        }
                    }
                };

                Promise.prototype._settlePromiseLateCancellationObserver = function (ctx) {
                    var handler = ctx.handler;
                    var promise = ctx.promise;
                    var receiver = ctx.receiver;
                    var value = ctx.value;
                    if (typeof handler === "function") {
                        if (!(promise instanceof Promise)) {
                            handler.call(receiver, value, promise);
                        } else {
                            this._settlePromiseFromHandler(handler, receiver, value, promise);
                        }
                    } else if (promise instanceof Promise) {
                        promise._reject(value);
                    }
                };

                Promise.prototype._settlePromiseCtx = function (ctx) {
                    this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
                };

                Promise.prototype._settlePromise0 = function (handler, value, bitField) {
                    var promise = this._promise0;
                    var receiver = this._receiverAt(0);
                    this._promise0 = undefined;
                    this._receiver0 = undefined;
                    this._settlePromise(promise, handler, receiver, value);
                };

                Promise.prototype._clearCallbackDataAtIndex = function (index) {
                    var base = index * 4 - 4;
                    this[base + 2] = this[base + 3] = this[base + 0] = this[base + 1] = undefined;
                };

                Promise.prototype._fulfill = function (value) {
                    var bitField = this._bitField;
                    if ((bitField & 117506048) >>> 16) return;
                    if (value === this) {
                        var err = makeSelfResolutionError();
                        this._attachExtraTrace(err);
                        return this._reject(err);
                    }
                    this._setFulfilled();
                    this._rejectionHandler0 = value;

                    if ((bitField & 65535) > 0) {
                        if ((bitField & 134217728) !== 0) {
                            this._settlePromises();
                        } else {
                            async.settlePromises(this);
                        }
                    }
                };

                Promise.prototype._reject = function (reason) {
                    var bitField = this._bitField;
                    if ((bitField & 117506048) >>> 16) return;
                    this._setRejected();
                    this._fulfillmentHandler0 = reason;

                    if (this._isFinal()) {
                        return async.fatalError(reason, util.isNode);
                    }

                    if ((bitField & 65535) > 0) {
                        async.settlePromises(this);
                    } else {
                        this._ensurePossibleRejectionHandled();
                    }
                };

                Promise.prototype._fulfillPromises = function (len, value) {
                    for (var i = 1; i < len; i++) {
                        var handler = this._fulfillmentHandlerAt(i);
                        var promise = this._promiseAt(i);
                        var receiver = this._receiverAt(i);
                        this._clearCallbackDataAtIndex(i);
                        this._settlePromise(promise, handler, receiver, value);
                    }
                };

                Promise.prototype._rejectPromises = function (len, reason) {
                    for (var i = 1; i < len; i++) {
                        var handler = this._rejectionHandlerAt(i);
                        var promise = this._promiseAt(i);
                        var receiver = this._receiverAt(i);
                        this._clearCallbackDataAtIndex(i);
                        this._settlePromise(promise, handler, receiver, reason);
                    }
                };

                Promise.prototype._settlePromises = function () {
                    var bitField = this._bitField;
                    var len = bitField & 65535;

                    if (len > 0) {
                        if ((bitField & 16842752) !== 0) {
                            var reason = this._fulfillmentHandler0;
                            this._settlePromise0(this._rejectionHandler0, reason, bitField);
                            this._rejectPromises(len, reason);
                        } else {
                            var value = this._rejectionHandler0;
                            this._settlePromise0(this._fulfillmentHandler0, value, bitField);
                            this._fulfillPromises(len, value);
                        }
                        this._setLength(0);
                    }
                    this._clearCancellationData();
                };

                Promise.prototype._settledValue = function () {
                    var bitField = this._bitField;
                    if ((bitField & 33554432) !== 0) {
                        return this._rejectionHandler0;
                    } else if ((bitField & 16777216) !== 0) {
                        return this._fulfillmentHandler0;
                    }
                };

                function deferResolve(v) {
                    this.promise._resolveCallback(v);
                }
                function deferReject(v) {
                    this.promise._rejectCallback(v, false);
                }

                Promise.defer = Promise.pending = function () {
                    debug.deprecated("Promise.defer", "new Promise");
                    var promise = new Promise(INTERNAL);
                    return {
                        promise: promise,
                        resolve: deferResolve,
                        reject: deferReject
                    };
                };

                util.notEnumerableProp(Promise, "_makeSelfResolutionError", makeSelfResolutionError);

                _dereq_("./method")(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug);
                _dereq_("./bind")(Promise, INTERNAL, tryConvertToPromise, debug);
                _dereq_("./cancel")(Promise, PromiseArray, apiRejection, debug);
                _dereq_("./direct_resolve")(Promise);
                _dereq_("./synchronous_inspection")(Promise);
                _dereq_("./join")(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain);
                Promise.Promise = Promise;
                Promise.version = "3.5.0";
                _dereq_('./map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
                _dereq_('./call_get.js')(Promise);
                _dereq_('./using.js')(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);
                _dereq_('./timers.js')(Promise, INTERNAL, debug);
                _dereq_('./generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);
                _dereq_('./nodeify.js')(Promise);
                _dereq_('./promisify.js')(Promise, INTERNAL);
                _dereq_('./props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);
                _dereq_('./race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);
                _dereq_('./reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
                _dereq_('./settle.js')(Promise, PromiseArray, debug);
                _dereq_('./some.js')(Promise, PromiseArray, apiRejection);
                _dereq_('./filter.js')(Promise, INTERNAL);
                _dereq_('./each.js')(Promise, INTERNAL);
                _dereq_('./any.js')(Promise);

                util.toFastProperties(Promise);
                util.toFastProperties(Promise.prototype);
                function fillTypes(value) {
                    var p = new Promise(INTERNAL);
                    p._fulfillmentHandler0 = value;
                    p._rejectionHandler0 = value;
                    p._promise0 = value;
                    p._receiver0 = value;
                }
                // Complete slack tracking, opt out of field-type tracking and           
                // stabilize map                                                         
                fillTypes({ a: 1 });
                fillTypes({ b: 2 });
                fillTypes({ c: 3 });
                fillTypes(1);
                fillTypes(function () {});
                fillTypes(undefined);
                fillTypes(false);
                fillTypes(new Promise(INTERNAL));
                debug.setBounds(Async.firstLineError, util.lastLineError);
                return Promise;
            };
        }, { "./any.js": 1, "./async": 2, "./bind": 3, "./call_get.js": 5, "./cancel": 6, "./catch_filter": 7, "./context": 8, "./debuggability": 9, "./direct_resolve": 10, "./each.js": 11, "./errors": 12, "./es5": 13, "./filter.js": 14, "./finally": 15, "./generators.js": 16, "./join": 17, "./map.js": 18, "./method": 19, "./nodeback": 20, "./nodeify.js": 21, "./promise_array": 23, "./promisify.js": 24, "./props.js": 25, "./race.js": 27, "./reduce.js": 28, "./settle.js": 30, "./some.js": 31, "./synchronous_inspection": 32, "./thenables": 33, "./timers.js": 34, "./using.js": 35, "./util": 36 }], 23: [function (_dereq_, module, exports) {
            "use strict";

            module.exports = function (Promise, INTERNAL, tryConvertToPromise, apiRejection, Proxyable) {
                var util = _dereq_("./util");
                var isArray = util.isArray;

                function toResolutionValue(val) {
                    switch (val) {
                        case -2:
                            return [];
                        case -3:
                            return {};
                        case -6:
                            return new Map();
                    }
                }

                function PromiseArray(values) {
                    var promise = this._promise = new Promise(INTERNAL);
                    if (values instanceof Promise) {
                        promise._propagateFrom(values, 3);
                    }
                    promise._setOnCancel(this);
                    this._values = values;
                    this._length = 0;
                    this._totalResolved = 0;
                    this._init(undefined, -2);
                }
                util.inherits(PromiseArray, Proxyable);

                PromiseArray.prototype.length = function () {
                    return this._length;
                };

                PromiseArray.prototype.promise = function () {
                    return this._promise;
                };

                PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
                    var values = tryConvertToPromise(this._values, this._promise);
                    if (values instanceof Promise) {
                        values = values._target();
                        var bitField = values._bitField;
                        ;
                        this._values = values;

                        if ((bitField & 50397184) === 0) {
                            this._promise._setAsyncGuaranteed();
                            return values._then(init, this._reject, undefined, this, resolveValueIfEmpty);
                        } else if ((bitField & 33554432) !== 0) {
                            values = values._value();
                        } else if ((bitField & 16777216) !== 0) {
                            return this._reject(values._reason());
                        } else {
                            return this._cancel();
                        }
                    }
                    values = util.asArray(values);
                    if (values === null) {
                        var err = apiRejection("expecting an array or an iterable object but got " + util.classString(values)).reason();
                        this._promise._rejectCallback(err, false);
                        return;
                    }

                    if (values.length === 0) {
                        if (resolveValueIfEmpty === -5) {
                            this._resolveEmptyArray();
                        } else {
                            this._resolve(toResolutionValue(resolveValueIfEmpty));
                        }
                        return;
                    }
                    this._iterate(values);
                };

                PromiseArray.prototype._iterate = function (values) {
                    var len = this.getActualLength(values.length);
                    this._length = len;
                    this._values = this.shouldCopyValues() ? new Array(len) : this._values;
                    var result = this._promise;
                    var isResolved = false;
                    var bitField = null;
                    for (var i = 0; i < len; ++i) {
                        var maybePromise = tryConvertToPromise(values[i], result);

                        if (maybePromise instanceof Promise) {
                            maybePromise = maybePromise._target();
                            bitField = maybePromise._bitField;
                        } else {
                            bitField = null;
                        }

                        if (isResolved) {
                            if (bitField !== null) {
                                maybePromise.suppressUnhandledRejections();
                            }
                        } else if (bitField !== null) {
                            if ((bitField & 50397184) === 0) {
                                maybePromise._proxy(this, i);
                                this._values[i] = maybePromise;
                            } else if ((bitField & 33554432) !== 0) {
                                isResolved = this._promiseFulfilled(maybePromise._value(), i);
                            } else if ((bitField & 16777216) !== 0) {
                                isResolved = this._promiseRejected(maybePromise._reason(), i);
                            } else {
                                isResolved = this._promiseCancelled(i);
                            }
                        } else {
                            isResolved = this._promiseFulfilled(maybePromise, i);
                        }
                    }
                    if (!isResolved) result._setAsyncGuaranteed();
                };

                PromiseArray.prototype._isResolved = function () {
                    return this._values === null;
                };

                PromiseArray.prototype._resolve = function (value) {
                    this._values = null;
                    this._promise._fulfill(value);
                };

                PromiseArray.prototype._cancel = function () {
                    if (this._isResolved() || !this._promise._isCancellable()) return;
                    this._values = null;
                    this._promise._cancel();
                };

                PromiseArray.prototype._reject = function (reason) {
                    this._values = null;
                    this._promise._rejectCallback(reason, false);
                };

                PromiseArray.prototype._promiseFulfilled = function (value, index) {
                    this._values[index] = value;
                    var totalResolved = ++this._totalResolved;
                    if (totalResolved >= this._length) {
                        this._resolve(this._values);
                        return true;
                    }
                    return false;
                };

                PromiseArray.prototype._promiseCancelled = function () {
                    this._cancel();
                    return true;
                };

                PromiseArray.prototype._promiseRejected = function (reason) {
                    this._totalResolved++;
                    this._reject(reason);
                    return true;
                };

                PromiseArray.prototype._resultCancelled = function () {
                    if (this._isResolved()) return;
                    var values = this._values;
                    this._cancel();
                    if (values instanceof Promise) {
                        values.cancel();
                    } else {
                        for (var i = 0; i < values.length; ++i) {
                            if (values[i] instanceof Promise) {
                                values[i].cancel();
                            }
                        }
                    }
                };

                PromiseArray.prototype.shouldCopyValues = function () {
                    return true;
                };

                PromiseArray.prototype.getActualLength = function (len) {
                    return len;
                };

                return PromiseArray;
            };
        }, { "./util": 36 }], 24: [function (_dereq_, module, exports) {
            "use strict";

            module.exports = function (Promise, INTERNAL) {
                var THIS = {};
                var util = _dereq_("./util");
                var nodebackForPromise = _dereq_("./nodeback");
                var withAppended = util.withAppended;
                var maybeWrapAsError = util.maybeWrapAsError;
                var canEvaluate = util.canEvaluate;
                var TypeError = _dereq_("./errors").TypeError;
                var defaultSuffix = "Async";
                var defaultPromisified = { __isPromisified__: true };
                var noCopyProps = ["arity", "length", "name", "arguments", "caller", "callee", "prototype", "__isPromisified__"];
                var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");

                var defaultFilter = function defaultFilter(name) {
                    return util.isIdentifier(name) && name.charAt(0) !== "_" && name !== "constructor";
                };

                function propsFilter(key) {
                    return !noCopyPropsPattern.test(key);
                }

                function isPromisified(fn) {
                    try {
                        return fn.__isPromisified__ === true;
                    } catch (e) {
                        return false;
                    }
                }

                function hasPromisified(obj, key, suffix) {
                    var val = util.getDataPropertyOrDefault(obj, key + suffix, defaultPromisified);
                    return val ? isPromisified(val) : false;
                }
                function checkValid(ret, suffix, suffixRegexp) {
                    for (var i = 0; i < ret.length; i += 2) {
                        var key = ret[i];
                        if (suffixRegexp.test(key)) {
                            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
                            for (var j = 0; j < ret.length; j += 2) {
                                if (ret[j] === keyWithoutAsyncSuffix) {
                                    throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n".replace("%s", suffix));
                                }
                            }
                        }
                    }
                }

                function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
                    var keys = util.inheritedDataKeys(obj);
                    var ret = [];
                    for (var i = 0; i < keys.length; ++i) {
                        var key = keys[i];
                        var value = obj[key];
                        var passesDefaultFilter = filter === defaultFilter ? true : defaultFilter(key, value, obj);
                        if (typeof value === "function" && !isPromisified(value) && !hasPromisified(obj, key, suffix) && filter(key, value, obj, passesDefaultFilter)) {
                            ret.push(key, value);
                        }
                    }
                    checkValid(ret, suffix, suffixRegexp);
                    return ret;
                }

                var escapeIdentRegex = function escapeIdentRegex(str) {
                    return str.replace(/([$])/, "\\$");
                };

                var makeNodePromisifiedEval;
                if (false) {
                    var switchCaseArgumentOrder = function switchCaseArgumentOrder(likelyArgumentCount) {
                        var ret = [likelyArgumentCount];
                        var min = Math.max(0, likelyArgumentCount - 1 - 3);
                        for (var i = likelyArgumentCount - 1; i >= min; --i) {
                            ret.push(i);
                        }
                        for (var i = likelyArgumentCount + 1; i <= 3; ++i) {
                            ret.push(i);
                        }
                        return ret;
                    };

                    var argumentSequence = function argumentSequence(argumentCount) {
                        return util.filledRange(argumentCount, "_arg", "");
                    };

                    var parameterDeclaration = function parameterDeclaration(parameterCount) {
                        return util.filledRange(Math.max(parameterCount, 3), "_arg", "");
                    };

                    var parameterCount = function parameterCount(fn) {
                        if (typeof fn.length === "number") {
                            return Math.max(Math.min(fn.length, 1023 + 1), 0);
                        }
                        return 0;
                    };

                    makeNodePromisifiedEval = function makeNodePromisifiedEval(callback, receiver, originalName, fn, _, multiArgs) {
                        var newParameterCount = Math.max(0, parameterCount(fn) - 1);
                        var argumentOrder = switchCaseArgumentOrder(newParameterCount);
                        var shouldProxyThis = typeof callback === "string" || receiver === THIS;

                        function generateCallForArgumentCount(count) {
                            var args = argumentSequence(count).join(", ");
                            var comma = count > 0 ? ", " : "";
                            var ret;
                            if (shouldProxyThis) {
                                ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
                            } else {
                                ret = receiver === undefined ? "ret = callback({{args}}, nodeback); break;\n" : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
                            }
                            return ret.replace("{{args}}", args).replace(", ", comma);
                        }

                        function generateArgumentSwitchCase() {
                            var ret = "";
                            for (var i = 0; i < argumentOrder.length; ++i) {
                                ret += "case " + argumentOrder[i] + ":" + generateCallForArgumentCount(argumentOrder[i]);
                            }

                            ret += "                                                             \n\
        default:                                                             \n\
            var args = new Array(len + 1);                                   \n\
            var i = 0;                                                       \n\
            for (var i = 0; i < len; ++i) {                                  \n\
               args[i] = arguments[i];                                       \n\
            }                                                                \n\
            args[i] = nodeback;                                              \n\
            [CodeForCall]                                                    \n\
            break;                                                           \n\
        ".replace("[CodeForCall]", shouldProxyThis ? "ret = callback.apply(this, args);\n" : "ret = callback.apply(receiver, args);\n");
                            return ret;
                        }

                        var getFunctionCode = typeof callback === "string" ? "this != null ? this['" + callback + "'] : fn" : "fn";
                        var body = "'use strict';                                                \n\
        var ret = function (Parameters) {                                    \n\
            'use strict';                                                    \n\
            var len = arguments.length;                                      \n\
            var promise = new Promise(INTERNAL);                             \n\
            promise._captureStackTrace();                                    \n\
            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n\
            var ret;                                                         \n\
            var callback = tryCatch([GetFunctionCode]);                      \n\
            switch(len) {                                                    \n\
                [CodeForSwitchCase]                                          \n\
            }                                                                \n\
            if (ret === errorObj) {                                          \n\
                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
            }                                                                \n\
            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n\
            return promise;                                                  \n\
        };                                                                   \n\
        notEnumerableProp(ret, '__isPromisified__', true);                   \n\
        return ret;                                                          \n\
    ".replace("[CodeForSwitchCase]", generateArgumentSwitchCase()).replace("[GetFunctionCode]", getFunctionCode);
                        body = body.replace("Parameters", parameterDeclaration(newParameterCount));
                        return new Function("Promise", "fn", "receiver", "withAppended", "maybeWrapAsError", "nodebackForPromise", "tryCatch", "errorObj", "notEnumerableProp", "INTERNAL", body)(Promise, fn, receiver, withAppended, maybeWrapAsError, nodebackForPromise, util.tryCatch, util.errorObj, util.notEnumerableProp, INTERNAL);
                    };
                }

                function makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {
                    var defaultThis = function () {
                        return this;
                    }();
                    var method = callback;
                    if (typeof method === "string") {
                        callback = fn;
                    }
                    function promisified() {
                        var _receiver = receiver;
                        if (receiver === THIS) _receiver = this;
                        var promise = new Promise(INTERNAL);
                        promise._captureStackTrace();
                        var cb = typeof method === "string" && this !== defaultThis ? this[method] : callback;
                        var fn = nodebackForPromise(promise, multiArgs);
                        try {
                            cb.apply(_receiver, withAppended(arguments, fn));
                        } catch (e) {
                            promise._rejectCallback(maybeWrapAsError(e), true, true);
                        }
                        if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
                        return promise;
                    }
                    util.notEnumerableProp(promisified, "__isPromisified__", true);
                    return promisified;
                }

                var makeNodePromisified = canEvaluate ? makeNodePromisifiedEval : makeNodePromisifiedClosure;

                function promisifyAll(obj, suffix, filter, promisifier, multiArgs) {
                    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
                    var methods = promisifiableMethods(obj, suffix, suffixRegexp, filter);

                    for (var i = 0, len = methods.length; i < len; i += 2) {
                        var key = methods[i];
                        var fn = methods[i + 1];
                        var promisifiedKey = key + suffix;
                        if (promisifier === makeNodePromisified) {
                            obj[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
                        } else {
                            var promisified = promisifier(fn, function () {
                                return makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
                            });
                            util.notEnumerableProp(promisified, "__isPromisified__", true);
                            obj[promisifiedKey] = promisified;
                        }
                    }
                    util.toFastProperties(obj);
                    return obj;
                }

                function promisify(callback, receiver, multiArgs) {
                    return makeNodePromisified(callback, receiver, undefined, callback, null, multiArgs);
                }

                Promise.promisify = function (fn, options) {
                    if (typeof fn !== "function") {
                        throw new TypeError("expecting a function but got " + util.classString(fn));
                    }
                    if (isPromisified(fn)) {
                        return fn;
                    }
                    options = Object(options);
                    var receiver = options.context === undefined ? THIS : options.context;
                    var multiArgs = !!options.multiArgs;
                    var ret = promisify(fn, receiver, multiArgs);
                    util.copyDescriptors(fn, ret, propsFilter);
                    return ret;
                };

                Promise.promisifyAll = function (target, options) {
                    if (typeof target !== "function" && (typeof target === "undefined" ? "undefined" : _typeof(target)) !== "object") {
                        throw new TypeError("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n");
                    }
                    options = Object(options);
                    var multiArgs = !!options.multiArgs;
                    var suffix = options.suffix;
                    if (typeof suffix !== "string") suffix = defaultSuffix;
                    var filter = options.filter;
                    if (typeof filter !== "function") filter = defaultFilter;
                    var promisifier = options.promisifier;
                    if (typeof promisifier !== "function") promisifier = makeNodePromisified;

                    if (!util.isIdentifier(suffix)) {
                        throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n");
                    }

                    var keys = util.inheritedDataKeys(target);
                    for (var i = 0; i < keys.length; ++i) {
                        var value = target[keys[i]];
                        if (keys[i] !== "constructor" && util.isClass(value)) {
                            promisifyAll(value.prototype, suffix, filter, promisifier, multiArgs);
                            promisifyAll(value, suffix, filter, promisifier, multiArgs);
                        }
                    }

                    return promisifyAll(target, suffix, filter, promisifier, multiArgs);
                };
            };
        }, { "./errors": 12, "./nodeback": 20, "./util": 36 }], 25: [function (_dereq_, module, exports) {
            "use strict";

            module.exports = function (Promise, PromiseArray, tryConvertToPromise, apiRejection) {
                var util = _dereq_("./util");
                var isObject = util.isObject;
                var es5 = _dereq_("./es5");
                var Es6Map;
                if (typeof Map === "function") Es6Map = Map;

                var mapToEntries = function () {
                    var index = 0;
                    var size = 0;

                    function extractEntry(value, key) {
                        this[index] = value;
                        this[index + size] = key;
                        index++;
                    }

                    return function mapToEntries(map) {
                        size = map.size;
                        index = 0;
                        var ret = new Array(map.size * 2);
                        map.forEach(extractEntry, ret);
                        return ret;
                    };
                }();

                var entriesToMap = function entriesToMap(entries) {
                    var ret = new Es6Map();
                    var length = entries.length / 2 | 0;
                    for (var i = 0; i < length; ++i) {
                        var key = entries[length + i];
                        var value = entries[i];
                        ret.set(key, value);
                    }
                    return ret;
                };

                function PropertiesPromiseArray(obj) {
                    var isMap = false;
                    var entries;
                    if (Es6Map !== undefined && obj instanceof Es6Map) {
                        entries = mapToEntries(obj);
                        isMap = true;
                    } else {
                        var keys = es5.keys(obj);
                        var len = keys.length;
                        entries = new Array(len * 2);
                        for (var i = 0; i < len; ++i) {
                            var key = keys[i];
                            entries[i] = obj[key];
                            entries[i + len] = key;
                        }
                    }
                    this.constructor$(entries);
                    this._isMap = isMap;
                    this._init$(undefined, isMap ? -6 : -3);
                }
                util.inherits(PropertiesPromiseArray, PromiseArray);

                PropertiesPromiseArray.prototype._init = function () {};

                PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
                    this._values[index] = value;
                    var totalResolved = ++this._totalResolved;
                    if (totalResolved >= this._length) {
                        var val;
                        if (this._isMap) {
                            val = entriesToMap(this._values);
                        } else {
                            val = {};
                            var keyOffset = this.length();
                            for (var i = 0, len = this.length(); i < len; ++i) {
                                val[this._values[i + keyOffset]] = this._values[i];
                            }
                        }
                        this._resolve(val);
                        return true;
                    }
                    return false;
                };

                PropertiesPromiseArray.prototype.shouldCopyValues = function () {
                    return false;
                };

                PropertiesPromiseArray.prototype.getActualLength = function (len) {
                    return len >> 1;
                };

                function props(promises) {
                    var ret;
                    var castValue = tryConvertToPromise(promises);

                    if (!isObject(castValue)) {
                        return apiRejection("cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n");
                    } else if (castValue instanceof Promise) {
                        ret = castValue._then(Promise.props, undefined, undefined, undefined, undefined);
                    } else {
                        ret = new PropertiesPromiseArray(castValue).promise();
                    }

                    if (castValue instanceof Promise) {
                        ret._propagateFrom(castValue, 2);
                    }
                    return ret;
                }

                Promise.prototype.props = function () {
                    return props(this);
                };

                Promise.props = function (promises) {
                    return props(promises);
                };
            };
        }, { "./es5": 13, "./util": 36 }], 26: [function (_dereq_, module, exports) {
            "use strict";

            function arrayMove(src, srcIndex, dst, dstIndex, len) {
                for (var j = 0; j < len; ++j) {
                    dst[j + dstIndex] = src[j + srcIndex];
                    src[j + srcIndex] = void 0;
                }
            }

            function Queue(capacity) {
                this._capacity = capacity;
                this._length = 0;
                this._front = 0;
            }

            Queue.prototype._willBeOverCapacity = function (size) {
                return this._capacity < size;
            };

            Queue.prototype._pushOne = function (arg) {
                var length = this.length();
                this._checkCapacity(length + 1);
                var i = this._front + length & this._capacity - 1;
                this[i] = arg;
                this._length = length + 1;
            };

            Queue.prototype.push = function (fn, receiver, arg) {
                var length = this.length() + 3;
                if (this._willBeOverCapacity(length)) {
                    this._pushOne(fn);
                    this._pushOne(receiver);
                    this._pushOne(arg);
                    return;
                }
                var j = this._front + length - 3;
                this._checkCapacity(length);
                var wrapMask = this._capacity - 1;
                this[j + 0 & wrapMask] = fn;
                this[j + 1 & wrapMask] = receiver;
                this[j + 2 & wrapMask] = arg;
                this._length = length;
            };

            Queue.prototype.shift = function () {
                var front = this._front,
                    ret = this[front];

                this[front] = undefined;
                this._front = front + 1 & this._capacity - 1;
                this._length--;
                return ret;
            };

            Queue.prototype.length = function () {
                return this._length;
            };

            Queue.prototype._checkCapacity = function (size) {
                if (this._capacity < size) {
                    this._resizeTo(this._capacity << 1);
                }
            };

            Queue.prototype._resizeTo = function (capacity) {
                var oldCapacity = this._capacity;
                this._capacity = capacity;
                var front = this._front;
                var length = this._length;
                var moveItemsCount = front + length & oldCapacity - 1;
                arrayMove(this, 0, this, oldCapacity, moveItemsCount);
            };

            module.exports = Queue;
        }, {}], 27: [function (_dereq_, module, exports) {
            "use strict";

            module.exports = function (Promise, INTERNAL, tryConvertToPromise, apiRejection) {
                var util = _dereq_("./util");

                var raceLater = function raceLater(promise) {
                    return promise.then(function (array) {
                        return race(array, promise);
                    });
                };

                function race(promises, parent) {
                    var maybePromise = tryConvertToPromise(promises);

                    if (maybePromise instanceof Promise) {
                        return raceLater(maybePromise);
                    } else {
                        promises = util.asArray(promises);
                        if (promises === null) return apiRejection("expecting an array or an iterable object but got " + util.classString(promises));
                    }

                    var ret = new Promise(INTERNAL);
                    if (parent !== undefined) {
                        ret._propagateFrom(parent, 3);
                    }
                    var fulfill = ret._fulfill;
                    var reject = ret._reject;
                    for (var i = 0, len = promises.length; i < len; ++i) {
                        var val = promises[i];

                        if (val === undefined && !(i in promises)) {
                            continue;
                        }

                        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
                    }
                    return ret;
                }

                Promise.race = function (promises) {
                    return race(promises, undefined);
                };

                Promise.prototype.race = function () {
                    return race(this, undefined);
                };
            };
        }, { "./util": 36 }], 28: [function (_dereq_, module, exports) {
            "use strict";

            module.exports = function (Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
                var getDomain = Promise._getDomain;
                var util = _dereq_("./util");
                var tryCatch = util.tryCatch;

                function ReductionPromiseArray(promises, fn, initialValue, _each) {
                    this.constructor$(promises);
                    var domain = getDomain();
                    this._fn = domain === null ? fn : util.domainBind(domain, fn);
                    if (initialValue !== undefined) {
                        initialValue = Promise.resolve(initialValue);
                        initialValue._attachCancellationCallback(this);
                    }
                    this._initialValue = initialValue;
                    this._currentCancellable = null;
                    if (_each === INTERNAL) {
                        this._eachValues = Array(this._length);
                    } else if (_each === 0) {
                        this._eachValues = null;
                    } else {
                        this._eachValues = undefined;
                    }
                    this._promise._captureStackTrace();
                    this._init$(undefined, -5);
                }
                util.inherits(ReductionPromiseArray, PromiseArray);

                ReductionPromiseArray.prototype._gotAccum = function (accum) {
                    if (this._eachValues !== undefined && this._eachValues !== null && accum !== INTERNAL) {
                        this._eachValues.push(accum);
                    }
                };

                ReductionPromiseArray.prototype._eachComplete = function (value) {
                    if (this._eachValues !== null) {
                        this._eachValues.push(value);
                    }
                    return this._eachValues;
                };

                ReductionPromiseArray.prototype._init = function () {};

                ReductionPromiseArray.prototype._resolveEmptyArray = function () {
                    this._resolve(this._eachValues !== undefined ? this._eachValues : this._initialValue);
                };

                ReductionPromiseArray.prototype.shouldCopyValues = function () {
                    return false;
                };

                ReductionPromiseArray.prototype._resolve = function (value) {
                    this._promise._resolveCallback(value);
                    this._values = null;
                };

                ReductionPromiseArray.prototype._resultCancelled = function (sender) {
                    if (sender === this._initialValue) return this._cancel();
                    if (this._isResolved()) return;
                    this._resultCancelled$();
                    if (this._currentCancellable instanceof Promise) {
                        this._currentCancellable.cancel();
                    }
                    if (this._initialValue instanceof Promise) {
                        this._initialValue.cancel();
                    }
                };

                ReductionPromiseArray.prototype._iterate = function (values) {
                    this._values = values;
                    var value;
                    var i;
                    var length = values.length;
                    if (this._initialValue !== undefined) {
                        value = this._initialValue;
                        i = 0;
                    } else {
                        value = Promise.resolve(values[0]);
                        i = 1;
                    }

                    this._currentCancellable = value;

                    if (!value.isRejected()) {
                        for (; i < length; ++i) {
                            var ctx = {
                                accum: null,
                                value: values[i],
                                index: i,
                                length: length,
                                array: this
                            };
                            value = value._then(gotAccum, undefined, undefined, ctx, undefined);
                        }
                    }

                    if (this._eachValues !== undefined) {
                        value = value._then(this._eachComplete, undefined, undefined, this, undefined);
                    }
                    value._then(completed, completed, undefined, value, this);
                };

                Promise.prototype.reduce = function (fn, initialValue) {
                    return reduce(this, fn, initialValue, null);
                };

                Promise.reduce = function (promises, fn, initialValue, _each) {
                    return reduce(promises, fn, initialValue, _each);
                };

                function completed(valueOrReason, array) {
                    if (this.isFulfilled()) {
                        array._resolve(valueOrReason);
                    } else {
                        array._reject(valueOrReason);
                    }
                }

                function reduce(promises, fn, initialValue, _each) {
                    if (typeof fn !== "function") {
                        return apiRejection("expecting a function but got " + util.classString(fn));
                    }
                    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
                    return array.promise();
                }

                function gotAccum(accum) {
                    this.accum = accum;
                    this.array._gotAccum(accum);
                    var value = tryConvertToPromise(this.value, this.array._promise);
                    if (value instanceof Promise) {
                        this.array._currentCancellable = value;
                        return value._then(gotValue, undefined, undefined, this, undefined);
                    } else {
                        return gotValue.call(this, value);
                    }
                }

                function gotValue(value) {
                    var array = this.array;
                    var promise = array._promise;
                    var fn = tryCatch(array._fn);
                    promise._pushContext();
                    var ret;
                    if (array._eachValues !== undefined) {
                        ret = fn.call(promise._boundValue(), value, this.index, this.length);
                    } else {
                        ret = fn.call(promise._boundValue(), this.accum, value, this.index, this.length);
                    }
                    if (ret instanceof Promise) {
                        array._currentCancellable = ret;
                    }
                    var promiseCreated = promise._popContext();
                    debug.checkForgottenReturns(ret, promiseCreated, array._eachValues !== undefined ? "Promise.each" : "Promise.reduce", promise);
                    return ret;
                }
            };
        }, { "./util": 36 }], 29: [function (_dereq_, module, exports) {
            "use strict";

            var util = _dereq_("./util");
            var schedule;
            var noAsyncScheduler = function noAsyncScheduler() {
                throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
            };
            var NativePromise = util.getNativePromise();
            if (util.isNode && typeof MutationObserver === "undefined") {
                var GlobalSetImmediate = global.setImmediate;
                var ProcessNextTick = process.nextTick;
                schedule = util.isRecentNode ? function (fn) {
                    GlobalSetImmediate.call(global, fn);
                } : function (fn) {
                    ProcessNextTick.call(process, fn);
                };
            } else if (typeof NativePromise === "function" && typeof NativePromise.resolve === "function") {
                var nativePromise = NativePromise.resolve();
                schedule = function schedule(fn) {
                    nativePromise.then(fn);
                };
            } else if (typeof MutationObserver !== "undefined" && !(typeof window !== "undefined" && window.navigator && (window.navigator.standalone || window.cordova))) {
                schedule = function () {
                    var div = document.createElement("div");
                    var opts = { attributes: true };
                    var toggleScheduled = false;
                    var div2 = document.createElement("div");
                    var o2 = new MutationObserver(function () {
                        div.classList.toggle("foo");
                        toggleScheduled = false;
                    });
                    o2.observe(div2, opts);

                    var scheduleToggle = function scheduleToggle() {
                        if (toggleScheduled) return;
                        toggleScheduled = true;
                        div2.classList.toggle("foo");
                    };

                    return function schedule(fn) {
                        var o = new MutationObserver(function () {
                            o.disconnect();
                            fn();
                        });
                        o.observe(div, opts);
                        scheduleToggle();
                    };
                }();
            } else if (typeof setImmediate !== "undefined") {
                schedule = function schedule(fn) {
                    setImmediate(fn);
                };
            } else if (typeof setTimeout !== "undefined") {
                schedule = function schedule(fn) {
                    setTimeout(fn, 0);
                };
            } else {
                schedule = noAsyncScheduler;
            }
            module.exports = schedule;
        }, { "./util": 36 }], 30: [function (_dereq_, module, exports) {
            "use strict";

            module.exports = function (Promise, PromiseArray, debug) {
                var PromiseInspection = Promise.PromiseInspection;
                var util = _dereq_("./util");

                function SettledPromiseArray(values) {
                    this.constructor$(values);
                }
                util.inherits(SettledPromiseArray, PromiseArray);

                SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
                    this._values[index] = inspection;
                    var totalResolved = ++this._totalResolved;
                    if (totalResolved >= this._length) {
                        this._resolve(this._values);
                        return true;
                    }
                    return false;
                };

                SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
                    var ret = new PromiseInspection();
                    ret._bitField = 33554432;
                    ret._settledValueField = value;
                    return this._promiseResolved(index, ret);
                };
                SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
                    var ret = new PromiseInspection();
                    ret._bitField = 16777216;
                    ret._settledValueField = reason;
                    return this._promiseResolved(index, ret);
                };

                Promise.settle = function (promises) {
                    debug.deprecated(".settle()", ".reflect()");
                    return new SettledPromiseArray(promises).promise();
                };

                Promise.prototype.settle = function () {
                    return Promise.settle(this);
                };
            };
        }, { "./util": 36 }], 31: [function (_dereq_, module, exports) {
            "use strict";

            module.exports = function (Promise, PromiseArray, apiRejection) {
                var util = _dereq_("./util");
                var RangeError = _dereq_("./errors").RangeError;
                var AggregateError = _dereq_("./errors").AggregateError;
                var isArray = util.isArray;
                var CANCELLATION = {};

                function SomePromiseArray(values) {
                    this.constructor$(values);
                    this._howMany = 0;
                    this._unwrap = false;
                    this._initialized = false;
                }
                util.inherits(SomePromiseArray, PromiseArray);

                SomePromiseArray.prototype._init = function () {
                    if (!this._initialized) {
                        return;
                    }
                    if (this._howMany === 0) {
                        this._resolve([]);
                        return;
                    }
                    this._init$(undefined, -5);
                    var isArrayResolved = isArray(this._values);
                    if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
                        this._reject(this._getRangeError(this.length()));
                    }
                };

                SomePromiseArray.prototype.init = function () {
                    this._initialized = true;
                    this._init();
                };

                SomePromiseArray.prototype.setUnwrap = function () {
                    this._unwrap = true;
                };

                SomePromiseArray.prototype.howMany = function () {
                    return this._howMany;
                };

                SomePromiseArray.prototype.setHowMany = function (count) {
                    this._howMany = count;
                };

                SomePromiseArray.prototype._promiseFulfilled = function (value) {
                    this._addFulfilled(value);
                    if (this._fulfilled() === this.howMany()) {
                        this._values.length = this.howMany();
                        if (this.howMany() === 1 && this._unwrap) {
                            this._resolve(this._values[0]);
                        } else {
                            this._resolve(this._values);
                        }
                        return true;
                    }
                    return false;
                };
                SomePromiseArray.prototype._promiseRejected = function (reason) {
                    this._addRejected(reason);
                    return this._checkOutcome();
                };

                SomePromiseArray.prototype._promiseCancelled = function () {
                    if (this._values instanceof Promise || this._values == null) {
                        return this._cancel();
                    }
                    this._addRejected(CANCELLATION);
                    return this._checkOutcome();
                };

                SomePromiseArray.prototype._checkOutcome = function () {
                    if (this.howMany() > this._canPossiblyFulfill()) {
                        var e = new AggregateError();
                        for (var i = this.length(); i < this._values.length; ++i) {
                            if (this._values[i] !== CANCELLATION) {
                                e.push(this._values[i]);
                            }
                        }
                        if (e.length > 0) {
                            this._reject(e);
                        } else {
                            this._cancel();
                        }
                        return true;
                    }
                    return false;
                };

                SomePromiseArray.prototype._fulfilled = function () {
                    return this._totalResolved;
                };

                SomePromiseArray.prototype._rejected = function () {
                    return this._values.length - this.length();
                };

                SomePromiseArray.prototype._addRejected = function (reason) {
                    this._values.push(reason);
                };

                SomePromiseArray.prototype._addFulfilled = function (value) {
                    this._values[this._totalResolved++] = value;
                };

                SomePromiseArray.prototype._canPossiblyFulfill = function () {
                    return this.length() - this._rejected();
                };

                SomePromiseArray.prototype._getRangeError = function (count) {
                    var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
                    return new RangeError(message);
                };

                SomePromiseArray.prototype._resolveEmptyArray = function () {
                    this._reject(this._getRangeError(0));
                };

                function some(promises, howMany) {
                    if ((howMany | 0) !== howMany || howMany < 0) {
                        return apiRejection("expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n");
                    }
                    var ret = new SomePromiseArray(promises);
                    var promise = ret.promise();
                    ret.setHowMany(howMany);
                    ret.init();
                    return promise;
                }

                Promise.some = function (promises, howMany) {
                    return some(promises, howMany);
                };

                Promise.prototype.some = function (howMany) {
                    return some(this, howMany);
                };

                Promise._SomePromiseArray = SomePromiseArray;
            };
        }, { "./errors": 12, "./util": 36 }], 32: [function (_dereq_, module, exports) {
            "use strict";

            module.exports = function (Promise) {
                function PromiseInspection(promise) {
                    if (promise !== undefined) {
                        promise = promise._target();
                        this._bitField = promise._bitField;
                        this._settledValueField = promise._isFateSealed() ? promise._settledValue() : undefined;
                    } else {
                        this._bitField = 0;
                        this._settledValueField = undefined;
                    }
                }

                PromiseInspection.prototype._settledValue = function () {
                    return this._settledValueField;
                };

                var value = PromiseInspection.prototype.value = function () {
                    if (!this.isFulfilled()) {
                        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n");
                    }
                    return this._settledValue();
                };

                var reason = PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function () {
                    if (!this.isRejected()) {
                        throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n");
                    }
                    return this._settledValue();
                };

                var isFulfilled = PromiseInspection.prototype.isFulfilled = function () {
                    return (this._bitField & 33554432) !== 0;
                };

                var isRejected = PromiseInspection.prototype.isRejected = function () {
                    return (this._bitField & 16777216) !== 0;
                };

                var isPending = PromiseInspection.prototype.isPending = function () {
                    return (this._bitField & 50397184) === 0;
                };

                var isResolved = PromiseInspection.prototype.isResolved = function () {
                    return (this._bitField & 50331648) !== 0;
                };

                PromiseInspection.prototype.isCancelled = function () {
                    return (this._bitField & 8454144) !== 0;
                };

                Promise.prototype.__isCancelled = function () {
                    return (this._bitField & 65536) === 65536;
                };

                Promise.prototype._isCancelled = function () {
                    return this._target().__isCancelled();
                };

                Promise.prototype.isCancelled = function () {
                    return (this._target()._bitField & 8454144) !== 0;
                };

                Promise.prototype.isPending = function () {
                    return isPending.call(this._target());
                };

                Promise.prototype.isRejected = function () {
                    return isRejected.call(this._target());
                };

                Promise.prototype.isFulfilled = function () {
                    return isFulfilled.call(this._target());
                };

                Promise.prototype.isResolved = function () {
                    return isResolved.call(this._target());
                };

                Promise.prototype.value = function () {
                    return value.call(this._target());
                };

                Promise.prototype.reason = function () {
                    var target = this._target();
                    target._unsetRejectionIsUnhandled();
                    return reason.call(target);
                };

                Promise.prototype._value = function () {
                    return this._settledValue();
                };

                Promise.prototype._reason = function () {
                    this._unsetRejectionIsUnhandled();
                    return this._settledValue();
                };

                Promise.PromiseInspection = PromiseInspection;
            };
        }, {}], 33: [function (_dereq_, module, exports) {
            "use strict";

            module.exports = function (Promise, INTERNAL) {
                var util = _dereq_("./util");
                var errorObj = util.errorObj;
                var isObject = util.isObject;

                function tryConvertToPromise(obj, context) {
                    if (isObject(obj)) {
                        if (obj instanceof Promise) return obj;
                        var then = getThen(obj);
                        if (then === errorObj) {
                            if (context) context._pushContext();
                            var ret = Promise.reject(then.e);
                            if (context) context._popContext();
                            return ret;
                        } else if (typeof then === "function") {
                            if (isAnyBluebirdPromise(obj)) {
                                var ret = new Promise(INTERNAL);
                                obj._then(ret._fulfill, ret._reject, undefined, ret, null);
                                return ret;
                            }
                            return doThenable(obj, then, context);
                        }
                    }
                    return obj;
                }

                function doGetThen(obj) {
                    return obj.then;
                }

                function getThen(obj) {
                    try {
                        return doGetThen(obj);
                    } catch (e) {
                        errorObj.e = e;
                        return errorObj;
                    }
                }

                var hasProp = {}.hasOwnProperty;
                function isAnyBluebirdPromise(obj) {
                    try {
                        return hasProp.call(obj, "_promise0");
                    } catch (e) {
                        return false;
                    }
                }

                function doThenable(x, then, context) {
                    var promise = new Promise(INTERNAL);
                    var ret = promise;
                    if (context) context._pushContext();
                    promise._captureStackTrace();
                    if (context) context._popContext();
                    var synchronous = true;
                    var result = util.tryCatch(then).call(x, resolve, reject);
                    synchronous = false;

                    if (promise && result === errorObj) {
                        promise._rejectCallback(result.e, true, true);
                        promise = null;
                    }

                    function resolve(value) {
                        if (!promise) return;
                        promise._resolveCallback(value);
                        promise = null;
                    }

                    function reject(reason) {
                        if (!promise) return;
                        promise._rejectCallback(reason, synchronous, true);
                        promise = null;
                    }
                    return ret;
                }

                return tryConvertToPromise;
            };
        }, { "./util": 36 }], 34: [function (_dereq_, module, exports) {
            "use strict";

            module.exports = function (Promise, INTERNAL, debug) {
                var util = _dereq_("./util");
                var TimeoutError = Promise.TimeoutError;

                function HandleWrapper(handle) {
                    this.handle = handle;
                }

                HandleWrapper.prototype._resultCancelled = function () {
                    clearTimeout(this.handle);
                };

                var afterValue = function afterValue(value) {
                    return delay(+this).thenReturn(value);
                };
                var delay = Promise.delay = function (ms, value) {
                    var ret;
                    var handle;
                    if (value !== undefined) {
                        ret = Promise.resolve(value)._then(afterValue, null, null, ms, undefined);
                        if (debug.cancellation() && value instanceof Promise) {
                            ret._setOnCancel(value);
                        }
                    } else {
                        ret = new Promise(INTERNAL);
                        handle = setTimeout(function () {
                            ret._fulfill();
                        }, +ms);
                        if (debug.cancellation()) {
                            ret._setOnCancel(new HandleWrapper(handle));
                        }
                        ret._captureStackTrace();
                    }
                    ret._setAsyncGuaranteed();
                    return ret;
                };

                Promise.prototype.delay = function (ms) {
                    return delay(ms, this);
                };

                var afterTimeout = function afterTimeout(promise, message, parent) {
                    var err;
                    if (typeof message !== "string") {
                        if (message instanceof Error) {
                            err = message;
                        } else {
                            err = new TimeoutError("operation timed out");
                        }
                    } else {
                        err = new TimeoutError(message);
                    }
                    util.markAsOriginatingFromRejection(err);
                    promise._attachExtraTrace(err);
                    promise._reject(err);

                    if (parent != null) {
                        parent.cancel();
                    }
                };

                function successClear(value) {
                    clearTimeout(this.handle);
                    return value;
                }

                function failureClear(reason) {
                    clearTimeout(this.handle);
                    throw reason;
                }

                Promise.prototype.timeout = function (ms, message) {
                    ms = +ms;
                    var ret, parent;

                    var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
                        if (ret.isPending()) {
                            afterTimeout(ret, message, parent);
                        }
                    }, ms));

                    if (debug.cancellation()) {
                        parent = this.then();
                        ret = parent._then(successClear, failureClear, undefined, handleWrapper, undefined);
                        ret._setOnCancel(handleWrapper);
                    } else {
                        ret = this._then(successClear, failureClear, undefined, handleWrapper, undefined);
                    }

                    return ret;
                };
            };
        }, { "./util": 36 }], 35: [function (_dereq_, module, exports) {
            "use strict";

            module.exports = function (Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug) {
                var util = _dereq_("./util");
                var TypeError = _dereq_("./errors").TypeError;
                var inherits = _dereq_("./util").inherits;
                var errorObj = util.errorObj;
                var tryCatch = util.tryCatch;
                var NULL = {};

                function thrower(e) {
                    setTimeout(function () {
                        throw e;
                    }, 0);
                }

                function castPreservingDisposable(thenable) {
                    var maybePromise = tryConvertToPromise(thenable);
                    if (maybePromise !== thenable && typeof thenable._isDisposable === "function" && typeof thenable._getDisposer === "function" && thenable._isDisposable()) {
                        maybePromise._setDisposable(thenable._getDisposer());
                    }
                    return maybePromise;
                }
                function dispose(resources, inspection) {
                    var i = 0;
                    var len = resources.length;
                    var ret = new Promise(INTERNAL);
                    function iterator() {
                        if (i >= len) return ret._fulfill();
                        var maybePromise = castPreservingDisposable(resources[i++]);
                        if (maybePromise instanceof Promise && maybePromise._isDisposable()) {
                            try {
                                maybePromise = tryConvertToPromise(maybePromise._getDisposer().tryDispose(inspection), resources.promise);
                            } catch (e) {
                                return thrower(e);
                            }
                            if (maybePromise instanceof Promise) {
                                return maybePromise._then(iterator, thrower, null, null, null);
                            }
                        }
                        iterator();
                    }
                    iterator();
                    return ret;
                }

                function Disposer(data, promise, context) {
                    this._data = data;
                    this._promise = promise;
                    this._context = context;
                }

                Disposer.prototype.data = function () {
                    return this._data;
                };

                Disposer.prototype.promise = function () {
                    return this._promise;
                };

                Disposer.prototype.resource = function () {
                    if (this.promise().isFulfilled()) {
                        return this.promise().value();
                    }
                    return NULL;
                };

                Disposer.prototype.tryDispose = function (inspection) {
                    var resource = this.resource();
                    var context = this._context;
                    if (context !== undefined) context._pushContext();
                    var ret = resource !== NULL ? this.doDispose(resource, inspection) : null;
                    if (context !== undefined) context._popContext();
                    this._promise._unsetDisposable();
                    this._data = null;
                    return ret;
                };

                Disposer.isDisposer = function (d) {
                    return d != null && typeof d.resource === "function" && typeof d.tryDispose === "function";
                };

                function FunctionDisposer(fn, promise, context) {
                    this.constructor$(fn, promise, context);
                }
                inherits(FunctionDisposer, Disposer);

                FunctionDisposer.prototype.doDispose = function (resource, inspection) {
                    var fn = this.data();
                    return fn.call(resource, resource, inspection);
                };

                function maybeUnwrapDisposer(value) {
                    if (Disposer.isDisposer(value)) {
                        this.resources[this.index]._setDisposable(value);
                        return value.promise();
                    }
                    return value;
                }

                function ResourceList(length) {
                    this.length = length;
                    this.promise = null;
                    this[length - 1] = null;
                }

                ResourceList.prototype._resultCancelled = function () {
                    var len = this.length;
                    for (var i = 0; i < len; ++i) {
                        var item = this[i];
                        if (item instanceof Promise) {
                            item.cancel();
                        }
                    }
                };

                Promise.using = function () {
                    var len = arguments.length;
                    if (len < 2) return apiRejection("you must pass at least 2 arguments to Promise.using");
                    var fn = arguments[len - 1];
                    if (typeof fn !== "function") {
                        return apiRejection("expecting a function but got " + util.classString(fn));
                    }
                    var input;
                    var spreadArgs = true;
                    if (len === 2 && Array.isArray(arguments[0])) {
                        input = arguments[0];
                        len = input.length;
                        spreadArgs = false;
                    } else {
                        input = arguments;
                        len--;
                    }
                    var resources = new ResourceList(len);
                    for (var i = 0; i < len; ++i) {
                        var resource = input[i];
                        if (Disposer.isDisposer(resource)) {
                            var disposer = resource;
                            resource = resource.promise();
                            resource._setDisposable(disposer);
                        } else {
                            var maybePromise = tryConvertToPromise(resource);
                            if (maybePromise instanceof Promise) {
                                resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
                                    resources: resources,
                                    index: i
                                }, undefined);
                            }
                        }
                        resources[i] = resource;
                    }

                    var reflectedResources = new Array(resources.length);
                    for (var i = 0; i < reflectedResources.length; ++i) {
                        reflectedResources[i] = Promise.resolve(resources[i]).reflect();
                    }

                    var resultPromise = Promise.all(reflectedResources).then(function (inspections) {
                        for (var i = 0; i < inspections.length; ++i) {
                            var inspection = inspections[i];
                            if (inspection.isRejected()) {
                                errorObj.e = inspection.error();
                                return errorObj;
                            } else if (!inspection.isFulfilled()) {
                                resultPromise.cancel();
                                return;
                            }
                            inspections[i] = inspection.value();
                        }
                        promise._pushContext();

                        fn = tryCatch(fn);
                        var ret = spreadArgs ? fn.apply(undefined, inspections) : fn(inspections);
                        var promiseCreated = promise._popContext();
                        debug.checkForgottenReturns(ret, promiseCreated, "Promise.using", promise);
                        return ret;
                    });

                    var promise = resultPromise.lastly(function () {
                        var inspection = new Promise.PromiseInspection(resultPromise);
                        return dispose(resources, inspection);
                    });
                    resources.promise = promise;
                    promise._setOnCancel(resources);
                    return promise;
                };

                Promise.prototype._setDisposable = function (disposer) {
                    this._bitField = this._bitField | 131072;
                    this._disposer = disposer;
                };

                Promise.prototype._isDisposable = function () {
                    return (this._bitField & 131072) > 0;
                };

                Promise.prototype._getDisposer = function () {
                    return this._disposer;
                };

                Promise.prototype._unsetDisposable = function () {
                    this._bitField = this._bitField & ~131072;
                    this._disposer = undefined;
                };

                Promise.prototype.disposer = function (fn) {
                    if (typeof fn === "function") {
                        return new FunctionDisposer(fn, this, createContext());
                    }
                    throw new TypeError();
                };
            };
        }, { "./errors": 12, "./util": 36 }], 36: [function (_dereq_, module, exports) {
            "use strict";

            var es5 = _dereq_("./es5");
            var canEvaluate = typeof navigator == "undefined";

            var errorObj = { e: {} };
            var tryCatchTarget;
            var globalObject = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : this !== undefined ? this : null;

            function tryCatcher() {
                try {
                    var target = tryCatchTarget;
                    tryCatchTarget = null;
                    return target.apply(this, arguments);
                } catch (e) {
                    errorObj.e = e;
                    return errorObj;
                }
            }
            function tryCatch(fn) {
                tryCatchTarget = fn;
                return tryCatcher;
            }

            var inherits = function inherits(Child, Parent) {
                var hasProp = {}.hasOwnProperty;

                function T() {
                    this.constructor = Child;
                    this.constructor$ = Parent;
                    for (var propertyName in Parent.prototype) {
                        if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
                            this[propertyName + "$"] = Parent.prototype[propertyName];
                        }
                    }
                }
                T.prototype = Parent.prototype;
                Child.prototype = new T();
                return Child.prototype;
            };

            function isPrimitive(val) {
                return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
            }

            function isObject(value) {
                return typeof value === "function" || (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object" && value !== null;
            }

            function maybeWrapAsError(maybeError) {
                if (!isPrimitive(maybeError)) return maybeError;

                return new Error(safeToString(maybeError));
            }

            function withAppended(target, appendee) {
                var len = target.length;
                var ret = new Array(len + 1);
                var i;
                for (i = 0; i < len; ++i) {
                    ret[i] = target[i];
                }
                ret[i] = appendee;
                return ret;
            }

            function getDataPropertyOrDefault(obj, key, defaultValue) {
                if (es5.isES5) {
                    var desc = Object.getOwnPropertyDescriptor(obj, key);

                    if (desc != null) {
                        return desc.get == null && desc.set == null ? desc.value : defaultValue;
                    }
                } else {
                    return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
                }
            }

            function notEnumerableProp(obj, name, value) {
                if (isPrimitive(obj)) return obj;
                var descriptor = {
                    value: value,
                    configurable: true,
                    enumerable: false,
                    writable: true
                };
                es5.defineProperty(obj, name, descriptor);
                return obj;
            }

            function thrower(r) {
                throw r;
            }

            var inheritedDataKeys = function () {
                var excludedPrototypes = [Array.prototype, Object.prototype, Function.prototype];

                var isExcludedProto = function isExcludedProto(val) {
                    for (var i = 0; i < excludedPrototypes.length; ++i) {
                        if (excludedPrototypes[i] === val) {
                            return true;
                        }
                    }
                    return false;
                };

                if (es5.isES5) {
                    var getKeys = Object.getOwnPropertyNames;
                    return function (obj) {
                        var ret = [];
                        var visitedKeys = Object.create(null);
                        while (obj != null && !isExcludedProto(obj)) {
                            var keys;
                            try {
                                keys = getKeys(obj);
                            } catch (e) {
                                return ret;
                            }
                            for (var i = 0; i < keys.length; ++i) {
                                var key = keys[i];
                                if (visitedKeys[key]) continue;
                                visitedKeys[key] = true;
                                var desc = Object.getOwnPropertyDescriptor(obj, key);
                                if (desc != null && desc.get == null && desc.set == null) {
                                    ret.push(key);
                                }
                            }
                            obj = es5.getPrototypeOf(obj);
                        }
                        return ret;
                    };
                } else {
                    var hasProp = {}.hasOwnProperty;
                    return function (obj) {
                        if (isExcludedProto(obj)) return [];
                        var ret = [];

                        /*jshint forin:false */
                        enumeration: for (var key in obj) {
                            if (hasProp.call(obj, key)) {
                                ret.push(key);
                            } else {
                                for (var i = 0; i < excludedPrototypes.length; ++i) {
                                    if (hasProp.call(excludedPrototypes[i], key)) {
                                        continue enumeration;
                                    }
                                }
                                ret.push(key);
                            }
                        }
                        return ret;
                    };
                }
            }();

            var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
            function isClass(fn) {
                try {
                    if (typeof fn === "function") {
                        var keys = es5.names(fn.prototype);

                        var hasMethods = es5.isES5 && keys.length > 1;
                        var hasMethodsOtherThanConstructor = keys.length > 0 && !(keys.length === 1 && keys[0] === "constructor");
                        var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;

                        if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {
                            return true;
                        }
                    }
                    return false;
                } catch (e) {
                    return false;
                }
            }

            function toFastProperties(obj) {
                /*jshint -W027,-W055,-W031*/
                function FakeConstructor() {}
                FakeConstructor.prototype = obj;
                var l = 8;
                while (l--) {
                    new FakeConstructor();
                }return obj;
                eval(obj);
            }

            var rident = /^[a-z$_][a-z$_0-9]*$/i;
            function isIdentifier(str) {
                return rident.test(str);
            }

            function filledRange(count, prefix, suffix) {
                var ret = new Array(count);
                for (var i = 0; i < count; ++i) {
                    ret[i] = prefix + i + suffix;
                }
                return ret;
            }

            function safeToString(obj) {
                try {
                    return obj + "";
                } catch (e) {
                    return "[no string representation]";
                }
            }

            function isError(obj) {
                return obj !== null && (typeof obj === "undefined" ? "undefined" : _typeof(obj)) === "object" && typeof obj.message === "string" && typeof obj.name === "string";
            }

            function markAsOriginatingFromRejection(e) {
                try {
                    notEnumerableProp(e, "isOperational", true);
                } catch (ignore) {}
            }

            function originatesFromRejection(e) {
                if (e == null) return false;
                return e instanceof Error["__BluebirdErrorTypes__"].OperationalError || e["isOperational"] === true;
            }

            function canAttachTrace(obj) {
                return isError(obj) && es5.propertyIsWritable(obj, "stack");
            }

            var ensureErrorObject = function () {
                if (!("stack" in new Error())) {
                    return function (value) {
                        if (canAttachTrace(value)) return value;
                        try {
                            throw new Error(safeToString(value));
                        } catch (err) {
                            return err;
                        }
                    };
                } else {
                    return function (value) {
                        if (canAttachTrace(value)) return value;
                        return new Error(safeToString(value));
                    };
                }
            }();

            function classString(obj) {
                return {}.toString.call(obj);
            }

            function copyDescriptors(from, to, filter) {
                var keys = es5.names(from);
                for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    if (filter(key)) {
                        try {
                            es5.defineProperty(to, key, es5.getDescriptor(from, key));
                        } catch (ignore) {}
                    }
                }
            }

            var asArray = function asArray(v) {
                if (es5.isArray(v)) {
                    return v;
                }
                return null;
            };

            if (typeof Symbol !== "undefined" && Symbol.iterator) {
                var ArrayFrom = typeof Array.from === "function" ? function (v) {
                    return Array.from(v);
                } : function (v) {
                    var ret = [];
                    var it = v[Symbol.iterator]();
                    var itResult;
                    while (!(itResult = it.next()).done) {
                        ret.push(itResult.value);
                    }
                    return ret;
                };

                asArray = function asArray(v) {
                    if (es5.isArray(v)) {
                        return v;
                    } else if (v != null && typeof v[Symbol.iterator] === "function") {
                        return ArrayFrom(v);
                    }
                    return null;
                };
            }

            var isNode = typeof process !== "undefined" && classString(process).toLowerCase() === "[object process]";

            var hasEnvVariables = typeof process !== "undefined" && typeof process.env !== "undefined";

            function env(key) {
                return hasEnvVariables ? process.env[key] : undefined;
            }

            function getNativePromise() {
                if (typeof Promise === "function") {
                    try {
                        var promise = new Promise(function () {});
                        if ({}.toString.call(promise) === "[object Promise]") {
                            return Promise;
                        }
                    } catch (e) {}
                }
            }

            function domainBind(self, cb) {
                return self.bind(cb);
            }

            var ret = {
                isClass: isClass,
                isIdentifier: isIdentifier,
                inheritedDataKeys: inheritedDataKeys,
                getDataPropertyOrDefault: getDataPropertyOrDefault,
                thrower: thrower,
                isArray: es5.isArray,
                asArray: asArray,
                notEnumerableProp: notEnumerableProp,
                isPrimitive: isPrimitive,
                isObject: isObject,
                isError: isError,
                canEvaluate: canEvaluate,
                errorObj: errorObj,
                tryCatch: tryCatch,
                inherits: inherits,
                withAppended: withAppended,
                maybeWrapAsError: maybeWrapAsError,
                toFastProperties: toFastProperties,
                filledRange: filledRange,
                toString: safeToString,
                canAttachTrace: canAttachTrace,
                ensureErrorObject: ensureErrorObject,
                originatesFromRejection: originatesFromRejection,
                markAsOriginatingFromRejection: markAsOriginatingFromRejection,
                classString: classString,
                copyDescriptors: copyDescriptors,
                hasDevTools: typeof chrome !== "undefined" && chrome && typeof chrome.loadTimes === "function",
                isNode: isNode,
                hasEnvVariables: hasEnvVariables,
                env: env,
                global: globalObject,
                getNativePromise: getNativePromise,
                domainBind: domainBind
            };
            ret.isRecentNode = ret.isNode && function () {
                var version = process.versions.node.split(".").map(Number);
                return version[0] === 0 && version[1] > 10 || version[0] > 0;
            }();

            if (ret.isNode) ret.toFastProperties(process);

            try {
                throw new Error();
            } catch (e) {
                ret.lastLineError = e;
            }
            module.exports = ret;
        }, { "./es5": 13 }] }, {}, [4])(4);
});;if (typeof window !== 'undefined' && window !== null) {
    window.P = window.Promise;
} else if (typeof self !== 'undefined' && self !== null) {
    self.P = self.Promise;
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8), __webpack_require__(0), __webpack_require__(46).setImmediate))

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// Browser Request
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// UMD HEADER START 
(function (root, factory) {
  if (true) {
    // AMD. Register as an anonymous module.
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like enviroments that support module.exports,
    // like Node.
    module.exports = factory();
  } else {
    // Browser globals (root is window)
    root.returnExports = factory();
  }
})(undefined, function () {
  // UMD HEADER END

  var XHR = XMLHttpRequest;
  if (!XHR) throw new Error('missing XMLHttpRequest');
  request.log = {
    'trace': noop, 'debug': noop, 'info': noop, 'warn': noop, 'error': noop
  };

  var DEFAULT_TIMEOUT = 3 * 60 * 1000; // 3 minutes

  //
  // request
  //

  function request(options, callback) {
    // The entry-point to the API: prep the options object and pass the real work to run_xhr.
    if (typeof callback !== 'function') throw new Error('Bad callback given: ' + callback);

    if (!options) throw new Error('No options given');

    var options_onResponse = options.onResponse; // Save this for later.

    if (typeof options === 'string') options = { 'uri': options };else options = JSON.parse(JSON.stringify(options)); // Use a duplicate for mutating.

    options.onResponse = options_onResponse; // And put it back.

    if (options.verbose) request.log = getLogger();

    if (options.url) {
      options.uri = options.url;
      delete options.url;
    }

    if (!options.uri && options.uri !== "") throw new Error("options.uri is a required argument");

    if (typeof options.uri != "string") throw new Error("options.uri must be a string");

    var unsupported_options = ['proxy', '_redirectsFollowed', 'maxRedirects', 'followRedirect'];
    for (var i = 0; i < unsupported_options.length; i++) {
      if (options[unsupported_options[i]]) throw new Error("options." + unsupported_options[i] + " is not supported");
    }options.callback = callback;
    options.method = options.method || 'GET';
    options.headers = options.headers || {};
    options.body = options.body || null;
    options.timeout = options.timeout || request.DEFAULT_TIMEOUT;

    if (options.headers.host) throw new Error("Options.headers.host is not supported");

    if (options.json) {
      options.headers.accept = options.headers.accept || 'application/json';
      if (options.method !== 'GET') options.headers['content-type'] = 'application/json';

      if (typeof options.json !== 'boolean') options.body = JSON.stringify(options.json);else if (typeof options.body !== 'string') options.body = JSON.stringify(options.body);
    }

    //BEGIN QS Hack
    var serialize = function serialize(obj) {
      var str = [];
      for (var p in obj) {
        if (obj.hasOwnProperty(p)) {
          str.push(encodeURIComponent(p) + "=" + encodeURIComponent(obj[p]));
        }
      }return str.join("&");
    };

    if (options.qs) {
      var qs = typeof options.qs == 'string' ? options.qs : serialize(options.qs);
      if (options.uri.indexOf('?') !== -1) {
        //no get params
        options.uri = options.uri + '&' + qs;
      } else {
        //existing get params
        options.uri = options.uri + '?' + qs;
      }
    }
    //END QS Hack

    //BEGIN FORM Hack
    var multipart = function multipart(obj) {
      //todo: support file type (useful?)
      var result = {};
      result.boundry = '-------------------------------' + Math.floor(Math.random() * 1000000000);
      var lines = [];
      for (var p in obj) {
        if (obj.hasOwnProperty(p)) {
          lines.push('--' + result.boundry + "\n" + 'Content-Disposition: form-data; name="' + p + '"' + "\n" + "\n" + obj[p] + "\n");
        }
      }
      lines.push('--' + result.boundry + '--');
      result.body = lines.join('');
      result.length = result.body.length;
      result.type = 'multipart/form-data; boundary=' + result.boundry;
      return result;
    };

    if (options.form) {
      if (typeof options.form == 'string') throw 'form name unsupported';
      if (options.method === 'POST') {
        var encoding = (options.encoding || 'application/x-www-form-urlencoded').toLowerCase();
        options.headers['content-type'] = encoding;
        switch (encoding) {
          case 'application/x-www-form-urlencoded':
            options.body = serialize(options.form).replace(/%20/g, "+");
            break;
          case 'multipart/form-data':
            var multi = multipart(options.form);
            //options.headers['content-length'] = multi.length;
            options.body = multi.body;
            options.headers['content-type'] = multi.type;
            break;
          default:
            throw new Error('unsupported encoding:' + encoding);
        }
      }
    }
    //END FORM Hack

    // If onResponse is boolean true, call back immediately when the response is known,
    // not when the full request is complete.
    options.onResponse = options.onResponse || noop;
    if (options.onResponse === true) {
      options.onResponse = callback;
      options.callback = noop;
    }

    // XXX Browsers do not like this.
    //if(options.body)
    //  options.headers['content-length'] = options.body.length;

    // HTTP basic authentication
    if (!options.headers.authorization && options.auth) options.headers.authorization = 'Basic ' + b64_enc(options.auth.username + ':' + options.auth.password);

    return run_xhr(options);
  }

  var req_seq = 0;
  function run_xhr(options) {
    var xhr = new XHR(),
        timed_out = false,
        is_cors = is_crossDomain(options.uri),
        supports_cors = 'withCredentials' in xhr;

    req_seq += 1;
    xhr.seq_id = req_seq;
    xhr.id = req_seq + ': ' + options.method + ' ' + options.uri;
    xhr._id = xhr.id; // I know I will type "_id" from habit all the time.

    if (is_cors && !supports_cors) {
      var cors_err = new Error('Browser does not support cross-origin request: ' + options.uri);
      cors_err.cors = 'unsupported';
      return options.callback(cors_err, xhr);
    }

    xhr.timeoutTimer = setTimeout(too_late, options.timeout);
    function too_late() {
      timed_out = true;
      var er = new Error('ETIMEDOUT');
      er.code = 'ETIMEDOUT';
      er.duration = options.timeout;

      request.log.error('Timeout', { 'id': xhr._id, 'milliseconds': options.timeout });
      return options.callback(er, xhr);
    }

    // Some states can be skipped over, so remember what is still incomplete.
    var did = { 'response': false, 'loading': false, 'end': false };

    xhr.onreadystatechange = on_state_change;
    xhr.open(options.method, options.uri, true); // asynchronous
    if (is_cors) xhr.withCredentials = !!options.withCredentials;
    xhr.send(options.body);
    return xhr;

    function on_state_change(event) {
      if (timed_out) return request.log.debug('Ignoring timed out state change', { 'state': xhr.readyState, 'id': xhr.id });

      request.log.debug('State change', { 'state': xhr.readyState, 'id': xhr.id, 'timed_out': timed_out });

      if (xhr.readyState === XHR.OPENED) {
        request.log.debug('Request started', { 'id': xhr.id });
        for (var key in options.headers) {
          xhr.setRequestHeader(key, options.headers[key]);
        }
      } else if (xhr.readyState === XHR.HEADERS_RECEIVED) on_response();else if (xhr.readyState === XHR.LOADING) {
        on_response();
        on_loading();
      } else if (xhr.readyState === XHR.DONE) {
        on_response();
        on_loading();
        on_end();
      }
    }

    function on_response() {
      if (did.response) return;

      did.response = true;
      request.log.debug('Got response', { 'id': xhr.id, 'status': xhr.status });
      clearTimeout(xhr.timeoutTimer);
      xhr.statusCode = xhr.status; // Node request compatibility

      // Detect failed CORS requests.
      if (is_cors && xhr.statusCode == 0) {
        var cors_err = new Error('CORS request rejected: ' + options.uri);
        cors_err.cors = 'rejected';

        // Do not process this request further.
        did.loading = true;
        did.end = true;

        return options.callback(cors_err, xhr);
      }

      options.onResponse(null, xhr);
    }

    function on_loading() {
      if (did.loading) return;

      did.loading = true;
      request.log.debug('Response body loading', { 'id': xhr.id });
      // TODO: Maybe simulate "data" events by watching xhr.responseText
    }

    function on_end() {
      if (did.end) return;

      did.end = true;
      request.log.debug('Request done', { 'id': xhr.id });

      xhr.body = xhr.responseText;
      if (options.json) {
        try {
          xhr.body = JSON.parse(xhr.responseText);
        } catch (er) {
          return options.callback(er, xhr);
        }
      }

      options.callback(null, xhr, xhr.body);
    }
  } // request

  request.withCredentials = false;
  request.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;

  //
  // defaults
  //

  request.defaults = function (options, requester) {
    var def = function def(method) {
      var d = function d(params, callback) {
        if (typeof params === 'string') params = { 'uri': params };else {
          params = JSON.parse(JSON.stringify(params));
        }
        for (var i in options) {
          if (params[i] === undefined) params[i] = options[i];
        }
        return method(params, callback);
      };
      return d;
    };
    var de = def(request);
    de.get = def(request.get);
    de.post = def(request.post);
    de.put = def(request.put);
    de.head = def(request.head);
    return de;
  };

  //
  // HTTP method shortcuts
  //

  var shortcuts = ['get', 'put', 'post', 'head'];
  shortcuts.forEach(function (shortcut) {
    var method = shortcut.toUpperCase();
    var func = shortcut.toLowerCase();

    request[func] = function (opts) {
      if (typeof opts === 'string') opts = { 'method': method, 'uri': opts };else {
        opts = JSON.parse(JSON.stringify(opts));
        opts.method = method;
      }

      var args = [opts].concat(Array.prototype.slice.apply(arguments, [1]));
      return request.apply(this, args);
    };
  });

  //
  // CouchDB shortcut
  //

  request.couch = function (options, callback) {
    if (typeof options === 'string') options = { 'uri': options

      // Just use the request API to do JSON.
    };options.json = true;
    if (options.body) options.json = options.body;
    delete options.body;

    callback = callback || noop;

    var xhr = request(options, couch_handler);
    return xhr;

    function couch_handler(er, resp, body) {
      if (er) return callback(er, resp, body);

      if ((resp.statusCode < 200 || resp.statusCode > 299) && body.error) {
        // The body is a Couch JSON object indicating the error.
        er = new Error('CouchDB error: ' + (body.error.reason || body.error.error));
        for (var key in body) {
          er[key] = body[key];
        }return callback(er, resp, body);
      }

      return callback(er, resp, body);
    }
  };

  //
  // Utility
  //

  function noop() {}

  function getLogger() {
    var logger = {},
        levels = ['trace', 'debug', 'info', 'warn', 'error'],
        level,
        i;

    for (i = 0; i < levels.length; i++) {
      level = levels[i];

      logger[level] = noop;
      if (typeof console !== 'undefined' && console && console[level]) logger[level] = formatted(console, level);
    }

    return logger;
  }

  function formatted(obj, method) {
    return formatted_logger;

    function formatted_logger(str, context) {
      if ((typeof context === 'undefined' ? 'undefined' : _typeof(context)) === 'object') str += ' ' + JSON.stringify(context);

      return obj[method].call(obj, str);
    }
  }

  // Return whether a URL is a cross-domain request.
  function is_crossDomain(url) {
    var rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/;

    // jQuery #8138, IE may throw an exception when accessing
    // a field from window.location if document.domain has been set
    var ajaxLocation;
    try {
      ajaxLocation = location.href;
    } catch (e) {
      // Use the href attribute of an A element since IE will modify it given document.location
      ajaxLocation = document.createElement("a");
      ajaxLocation.href = "";
      ajaxLocation = ajaxLocation.href;
    }

    var ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [],
        parts = rurl.exec(url.toLowerCase());

    var result = !!(parts && (parts[1] != ajaxLocParts[1] || parts[2] != ajaxLocParts[2] || (parts[3] || (parts[1] === "http:" ? 80 : 443)) != (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? 80 : 443))));

    //console.debug('is_crossDomain('+url+') -> ' + result)
    return result;
  }

  // MIT License from http://phpjs.org/functions/base64_encode:358
  function b64_enc(data) {
    // Encodes string using MIME base64 algorithm
    var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var o1,
        o2,
        o3,
        h1,
        h2,
        h3,
        h4,
        bits,
        i = 0,
        ac = 0,
        enc = "",
        tmp_arr = [];

    if (!data) {
      return data;
    }

    // assume utf8 data
    // data = this.utf8_encode(data+'');

    do {
      // pack three octets into four hexets
      o1 = data.charCodeAt(i++);
      o2 = data.charCodeAt(i++);
      o3 = data.charCodeAt(i++);

      bits = o1 << 16 | o2 << 8 | o3;

      h1 = bits >> 18 & 0x3f;
      h2 = bits >> 12 & 0x3f;
      h3 = bits >> 6 & 0x3f;
      h4 = bits & 0x3f;

      // use hexets to index into b64, and append result to encoded string
      tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
    } while (i < data.length);

    enc = tmp_arr.join('');

    switch (data.length % 3) {
      case 1:
        enc = enc.slice(0, -2) + '==';
        break;
      case 2:
        enc = enc.slice(0, -1) + '=';
        break;
    }

    return enc;
  }
  return request;
  //UMD FOOTER START
});
//UMD FOOTER END

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// Copyright 2014 Simon Lydell
// X11 (“MIT”) Licensed. (See LICENSE.)

void function (root, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === "object") {
    module.exports = factory();
  } else {
    root.resolveUrl = factory();
  }
}(undefined, function () {

  function resolveUrl() /* ...urls */{
    var numUrls = arguments.length;

    if (numUrls === 0) {
      throw new Error("resolveUrl requires at least one argument; got none.");
    }

    var base = document.createElement("base");
    base.href = arguments[0];

    if (numUrls === 1) {
      return base.href;
    }

    var head = document.getElementsByTagName("head")[0];
    head.insertBefore(base, head.firstChild);

    var a = document.createElement("a");
    var resolved;

    for (var index = 1; index < numUrls; index++) {
      a.href = arguments[index];
      resolved = a.href;
      base.href = resolved;
    }

    head.removeChild(base);

    return resolved;
  }

  return resolveUrl;
});

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var engine = __webpack_require__(38);

var storages = __webpack_require__(39);
var plugins = [__webpack_require__(36)];

module.exports = engine.createStore(storages, plugins);

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var merge = __webpack_require__(2);

var _validate = __webpack_require__(3);
var ValidationError = __webpack_require__(10);
var normalizeArguments = __webpack_require__(4);
var Plugin = __webpack_require__(49);

function initialize(brinkbit) {
    var Player = function (_Plugin) {
        _inherits(Player, _Plugin);

        function Player(config) {
            _classCallCheck(this, Player);

            var _this = _possibleConstructorReturn(this, (Player.__proto__ || Object.getPrototypeOf(Player)).call(this, brinkbit, {}, config));

            _this.read = ['_id', 'dateCreated', 'email', 'username'];
            _this.write = ['email', 'password', 'username'];
            if (config) {
                _validate.constructor(config, {
                    username: {
                        dataType: 'string'
                    },
                    email: {
                        dataType: 'string'
                    },
                    password: {
                        dataType: 'string'
                    }
                });
                _this.data = config;
            }
            _this.middleware.save = _this.saveMiddleware.bind(_this);
            return _this;
        }

        _createClass(Player, [{
            key: 'login',
            value: function login() {
                var _this2 = this;

                var options = normalizeArguments.apply(undefined, arguments);
                options.password = options.uri;
                options.uri = undefined;
                return this.brinkbit.login(merge({}, this.data, options)).then(function (user) {
                    _this2.token = user.token;
                    return _this2;
                });
            }
        }, {
            key: 'logout',
            value: function logout() {
                this.token = undefined;
                if (this.isPrimary) {
                    this.brinkbit.logout();
                }
            }
        }, {
            key: 'promote',
            value: function promote() {
                this.brinkbit.promotePlayer(this);
            }
        }, {
            key: 'saveMiddleware',
            value: function saveMiddleware(options) {
                if (!this.id) options.passToken = false;else {
                    options.body.username = undefined;
                    options.body.password = undefined;
                }
                return options;
            }
        }, {
            key: 'getUrl',
            value: function getUrl(method) {
                switch (method) {
                    case 'post':
                        return './players/';
                    default:
                        return './players/' + this.id + '/';
                }
            }
        }, {
            key: 'validate',
            value: function validate(method, data) {
                switch (method) {
                    case 'delete':
                        return typeof this.id === 'string' ? Promise.resolve() : Promise.reject(new ValidationError('Cannot delete user without id'));
                    case 'post':
                        return _validate(data, {
                            username: {
                                dataType: 'string',
                                presence: true
                            },
                            email: {
                                dataType: 'string',
                                presence: true
                            },
                            password: {
                                dataType: 'string',
                                presence: true
                            }
                        });
                    case 'put':
                        return _validate(data, {
                            username: {
                                dataType: 'string',
                                presence: false
                            },
                            email: {
                                dataType: 'string'
                            },
                            password: {
                                dataType: 'string',
                                presence: false
                            }
                        });
                    default:
                        return typeof this.id === 'string' ? Promise.resolve() : Promise.reject(new ValidationError('Cannot fetch user without id'));
                }
            }
        }]);

        return Player;
    }(Plugin);

    return Player;
}

module.exports = {
    name: 'Player',
    initialize: initialize
};

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = CustomError;
CustomError.factory = __webpack_require__(18);

var Err = CustomError('CustomError');
Err.order = CustomError(Err, { message: 'Arguments out of order.', code: 'EOARG' });

/**
 * Create a custom error
 * @param {string} [name] The name to give the error. Defaults to the name of it's parent.
 * @param {function} [parent] The Error or CustomError constructor to inherit from.
 * @param {object} [properties] The default properties for the custom error.
 * @param {function} [factory] A function to call to modify the custom error instance when it is instantiated.
 * @returns {function} that should be used as a constructor.
 */
function CustomError(name, parent, properties, factory) {
    var _construct;
    var isRoot;

    // normalize arguments
    parent = findArg(arguments, 1, Error, isParentArg, [isPropertiesArg, isFactoryArg]);
    properties = findArg(arguments, 2, {}, isPropertiesArg, [isFactoryArg]);
    factory = findArg(arguments, 3, noop, isFactoryArg, []);
    name = findArg(arguments, 0, parent === Error ? 'Error' : parent.prototype.CustomError.name, isNameArg, [isParentArg, isPropertiesArg, isFactoryArg]);

    // if this is the root and their is no factory then use the default root factory
    isRoot = parent === Error;
    if (isRoot && factory === noop) factory = CustomError.factory.root;

    // build the constructor function
    _construct = function construct(message, configuration) {
        var _this;
        var ar;
        var factories;
        var i;
        var item;
        var props;

        // force this function to be called with the new keyword
        if (!(this instanceof _construct)) return new _construct(message, configuration);

        // rename the constructor
        delete this.constructor.name;
        Object.defineProperty(this.constructor, 'name', {
            enumerable: false,
            configurable: true,
            value: name,
            writable: false
        });

        // make sure that the message is an object
        if (typeof message === 'string') message = { message: message };
        if (!message) message = {};

        // build the properties object
        ar = this.CustomError.chain.slice(0).reverse().map(function (value) {
            return value.properties;
        });
        ar.push(message);
        ar.unshift({});
        props = Object.assign.apply(Object, ar);

        // build the factories caller (forcing scope to this)
        _this = this;
        factories = {};
        Object.keys(CustomError.factory).forEach(function (key) {
            factories[key] = function (props, config) {
                CustomError.factory[key].call(_this, props, config, factories);
            };
        });

        // call each factory in the chain, starting at the root
        for (i = this.CustomError.chain.length - 1; i >= 0; i--) {
            item = this.CustomError.chain[i];
            if (item.factory !== noop) {
                item.factory.call(this, props, configuration, factories);
            }
        }
    };

    // cause the function prototype to inherit from parent's prototype
    _construct.prototype = Object.create(parent.prototype);
    _construct.prototype.constructor = _construct;

    // update error name
    _construct.prototype.name = name;

    // add details about the custom error to the prototype
    _construct.prototype.CustomError = {
        chain: isRoot ? [] : parent.prototype.CustomError.chain.slice(0),
        factory: factory,
        name: name,
        parent: parent,
        properties: properties
    };
    _construct.prototype.CustomError.chain.unshift(_construct.prototype.CustomError);

    // update the toString method on the prototype to accept a code
    _construct.prototype.toString = function () {
        var result = this.CustomError.chain[this.CustomError.chain.length - 1].name;
        if (this.code) result += ' ' + this.code;
        if (this.message) result += ': ' + this.message;
        return result;
    };

    return _construct;
}

function findArg(args, index, defaultValue, filter, antiFilters) {
    var anti = -1;
    var found = -1;
    var i;
    var j;
    var len = index < args.length ? index : args.length;
    var val;

    for (i = 0; i <= len; i++) {
        val = args[i];
        if (anti === -1) {
            for (j = 0; j < antiFilters.length; j++) {
                if (antiFilters[j](val)) anti = i;
            }
        }
        if (found === -1 && filter(val)) {
            found = i;
        }
    }

    if (found !== -1 && anti !== -1 && anti < found) throw new Err.order();
    return found !== -1 ? args[found] : defaultValue;
}

function isFactoryArg(value) {
    return typeof value === 'function' && value !== Error && !value.prototype.CustomError;
}

function isNameArg(value) {
    return typeof value === 'string';
}

function isParentArg(value) {
    return typeof value === 'function' && (value === Error || value.prototype.CustomError);
}

function isPropertiesArg(value) {
    return value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object';
}

function noop() {}

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.expectReceive = function (properties, configuration, factory) {
    var message;
    factory.root(properties, configuration, factory);

    message = this.message;
    if (properties.hasOwnProperty('expected')) message += ' Expected ' + properties.expected + '.';
    if (properties.hasOwnProperty('received')) message += ' Received: ' + properties.received + '.';
    this.message = message;
};

exports.root = function (properties, configuration, factories) {
    var _this = this;
    var code;
    var config = { stackLength: Error.stackTraceLimit, rootOnly: true };
    var messageStr = '';
    var originalStackLength = Error.stackTraceLimit;
    var stack;

    function updateStack() {
        stack[0] = _this.toString();
        _this.stack = stack.join('\n');
    }

    // get configuration options
    if (!configuration || (typeof configuration === 'undefined' ? 'undefined' : _typeof(configuration)) !== 'object') configuration = {};
    if (configuration.hasOwnProperty('stackLength') && typeof configuration.stackLength === 'number' && !isNaN(configuration.stackLength) && configuration.stackLength >= 0) config.stackLength = configuration.stackLength;
    if (!configuration.hasOwnProperty('rootOnly')) config.rootOnly = configuration.rootOnly;

    // check if this should only be run as root
    if (!config.rootOnly || this.CustomError.parent === Error) {

        // copy properties onto this object
        Object.keys(properties).forEach(function (key) {
            switch (key) {
                case 'code':
                    code = properties.code || void 0;
                    break;
                case 'message':
                    messageStr = properties.message || '';
                    break;
                default:
                    _this[key] = properties[key];
            }
        });

        // generate the stack trace
        Error.stackTraceLimit = config.stackLength + 2;
        stack = new Error().stack.split('\n');
        stack.splice(0, 3);
        stack.unshift('');
        Error.stackTraceLimit = originalStackLength;
        this.stack = stack.join('\n');

        Object.defineProperty(this, 'code', {
            configurable: true,
            enumerable: true,
            get: function get() {
                return code;
            },
            set: function set(value) {
                code = value;
                updateStack();
            }
        });

        Object.defineProperty(this, 'message', {
            configurable: true,
            enumerable: true,
            get: function get() {
                return messageStr;
            },
            set: function set(value) {
                messageStr = value;
                updateStack();
            }
        });

        updateStack();
    }
};

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(17);

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assign = __webpack_require__(21),
    normalizeOpts = __webpack_require__(28),
    isCallable = __webpack_require__(24),
    contains = __webpack_require__(31),
    d;

d = module.exports = function (dscr, value /*, options*/) {
	var c, e, w, options, desc;
	if (arguments.length < 2 || typeof dscr !== 'string') {
		options = value;
		value = dscr;
		dscr = null;
	} else {
		options = arguments[2];
	}
	if (dscr == null) {
		c = w = true;
		e = false;
	} else {
		c = contains.call(dscr, 'c');
		e = contains.call(dscr, 'e');
		w = contains.call(dscr, 'w');
	}

	desc = { value: value, configurable: c, enumerable: e, writable: w };
	return !options ? desc : assign(normalizeOpts(options), desc);
};

d.gs = function (dscr, get, set /*, options*/) {
	var c, e, options, desc;
	if (typeof dscr !== 'string') {
		options = set;
		set = get;
		get = dscr;
		dscr = null;
	} else {
		options = arguments[3];
	}
	if (get == null) {
		get = undefined;
	} else if (!isCallable(get)) {
		options = get;
		get = set = undefined;
	} else if (set == null) {
		set = undefined;
	} else if (!isCallable(set)) {
		options = set;
		set = undefined;
	}
	if (dscr == null) {
		c = true;
		e = false;
	} else {
		c = contains.call(dscr, 'c');
		e = contains.call(dscr, 'e');
	}

	desc = { get: get, set: set, configurable: c, enumerable: e };
	return !options ? desc : assign(normalizeOpts(options), desc);
};

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(22)() ? Object.assign : __webpack_require__(23);

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
	var assign = Object.assign,
	    obj;
	if (typeof assign !== 'function') return false;
	obj = { foo: 'raz' };
	assign(obj, { bar: 'dwa' }, { trzy: 'trzy' });
	return obj.foo + obj.bar + obj.trzy === 'razdwatrzy';
};

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var keys = __webpack_require__(25),
    value = __webpack_require__(30),
    max = Math.max;

module.exports = function (dest, src /*, …srcn*/) {
	var error,
	    i,
	    l = max(arguments.length, 2),
	    assign;
	dest = Object(value(dest));
	assign = function assign(key) {
		try {
			dest[key] = src[key];
		} catch (e) {
			if (!error) error = e;
		}
	};
	for (i = 1; i < l; ++i) {
		src = arguments[i];
		keys(src).forEach(assign);
	}
	if (error !== undefined) throw error;
	return dest;
};

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Deprecated



module.exports = function (obj) {
  return typeof obj === 'function';
};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(26)() ? Object.keys : __webpack_require__(27);

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
	try {
		Object.keys('primitive');
		return true;
	} catch (e) {
		return false;
	}
};

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var keys = Object.keys;

module.exports = function (object) {
	return keys(object == null ? object : Object(object));
};

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var forEach = Array.prototype.forEach,
    create = Object.create;

var process = function process(src, obj) {
	var key;
	for (key in src) {
		obj[key] = src[key];
	}
};

module.exports = function (options /*, …options*/) {
	var result = create(null);
	forEach.call(arguments, function (options) {
		if (options == null) return;
		process(Object(options), result);
	});
	return result;
};

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (fn) {
	if (typeof fn !== 'function') throw new TypeError(fn + " is not a function");
	return fn;
};

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (value) {
	if (value == null) throw new TypeError("Cannot use null or undefined");
	return value;
};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(32)() ? String.prototype.contains : __webpack_require__(33);

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var str = 'razdwatrzy';

module.exports = function () {
	if (typeof str.contains !== 'function') return false;
	return str.contains('dwa') === true && str.contains('foo') === false;
};

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var indexOf = String.prototype.indexOf;

module.exports = function (searchString /*, position*/) {
	return indexOf.call(this, searchString, arguments[1]) > -1;
};

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    symbolTag = '[object Symbol]';

/** Detect free variable `global` from Node.js. */
var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var _Symbol = root.Symbol,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} props The property identifiers to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, props) {
  object = Object(object);
  return basePickBy(object, props, function (value, key) {
    return key in object;
  });
}

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} props The property identifiers to pick from.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, props, predicate) {
  var index = -1,
      length = props.length,
      result = {};

  while (++index < length) {
    var key = props[index],
        value = object[key];

    if (predicate(value, key)) {
      result[key] = value;
    }
  }
  return result;
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  start = nativeMax(start === undefined ? func.length - 1 : start, 0);
  return function () {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = array;
    return apply(func, this, otherArgs);
  };
}

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
}

/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [props] The property identifiers to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */
var pick = baseRest(function (object, props) {
  return object == null ? {} : basePick(object, arrayMap(baseFlatten(props, 1), toKey));
});

module.exports = pick;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {

(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
        // Callback can either be a function or a string
        if (typeof callback !== "function") {
            callback = new Function("" + callback);
        }
        // Copy function arguments
        var args = new Array(arguments.length - 1);
        for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i + 1];
        }
        // Store and register the task
        var task = { callback: callback, args: args };
        tasksByHandle[nextHandle] = task;
        registerImmediate(nextHandle);
        return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
            case 0:
                callback();
                break;
            case 1:
                callback(args[0]);
                break;
            case 2:
                callback(args[0], args[1]);
                break;
            case 3:
                callback(args[0], args[1], args[2]);
                break;
            default:
                callback.apply(undefined, args);
                break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function registerImmediate(handle) {
            process.nextTick(function () {
                runIfPresent(handle);
            });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function () {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function onGlobalMessage(event) {
            if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function registerImmediate(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function (event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function registerImmediate(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function registerImmediate(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function registerImmediate(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();
    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();
    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();
    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();
    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? undefined : global : self);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(8)))

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = json2Plugin;

function json2Plugin() {
	__webpack_require__(37);
	return {};
}

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/* eslint-disable */

//  json2.js
//  2016-10-28
//  Public Domain.
//  NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
//  See http://www.JSON.org/js.html
//  This code should be minified before deployment.
//  See http://javascript.crockford.com/jsmin.html

//  USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
//  NOT CONTROL.

//  This file creates a global JSON object containing two methods: stringify
//  and parse. This file provides the ES5 JSON capability to ES3 systems.
//  If a project might run on IE8 or earlier, then this file should be included.
//  This file does nothing on ES5 systems.

//      JSON.stringify(value, replacer, space)
//          value       any JavaScript value, usually an object or array.
//          replacer    an optional parameter that determines how object
//                      values are stringified for objects. It can be a
//                      function or an array of strings.
//          space       an optional parameter that specifies the indentation
//                      of nested structures. If it is omitted, the text will
//                      be packed without extra whitespace. If it is a number,
//                      it will specify the number of spaces to indent at each
//                      level. If it is a string (such as "\t" or "&nbsp;"),
//                      it contains the characters used to indent at each level.
//          This method produces a JSON text from a JavaScript value.
//          When an object value is found, if the object contains a toJSON
//          method, its toJSON method will be called and the result will be
//          stringified. A toJSON method does not serialize: it returns the
//          value represented by the name/value pair that should be serialized,
//          or undefined if nothing should be serialized. The toJSON method
//          will be passed the key associated with the value, and this will be
//          bound to the value.

//          For example, this would serialize Dates as ISO strings.

//              Date.prototype.toJSON = function (key) {
//                  function f(n) {
//                      // Format integers to have at least two digits.
//                      return (n < 10)
//                          ? "0" + n
//                          : n;
//                  }
//                  return this.getUTCFullYear()   + "-" +
//                       f(this.getUTCMonth() + 1) + "-" +
//                       f(this.getUTCDate())      + "T" +
//                       f(this.getUTCHours())     + ":" +
//                       f(this.getUTCMinutes())   + ":" +
//                       f(this.getUTCSeconds())   + "Z";
//              };

//          You can provide an optional replacer method. It will be passed the
//          key and value of each member, with this bound to the containing
//          object. The value that is returned from your method will be
//          serialized. If your method returns undefined, then the member will
//          be excluded from the serialization.

//          If the replacer parameter is an array of strings, then it will be
//          used to select the members to be serialized. It filters the results
//          such that only members with keys listed in the replacer array are
//          stringified.

//          Values that do not have JSON representations, such as undefined or
//          functions, will not be serialized. Such values in objects will be
//          dropped; in arrays they will be replaced with null. You can use
//          a replacer function to replace those with JSON values.

//          JSON.stringify(undefined) returns undefined.

//          The optional space parameter produces a stringification of the
//          value that is filled with line breaks and indentation to make it
//          easier to read.

//          If the space parameter is a non-empty string, then that string will
//          be used for indentation. If the space parameter is a number, then
//          the indentation will be that many spaces.

//          Example:

//          text = JSON.stringify(["e", {pluribus: "unum"}]);
//          // text is '["e",{"pluribus":"unum"}]'

//          text = JSON.stringify(["e", {pluribus: "unum"}], null, "\t");
//          // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

//          text = JSON.stringify([new Date()], function (key, value) {
//              return this[key] instanceof Date
//                  ? "Date(" + this[key] + ")"
//                  : value;
//          });
//          // text is '["Date(---current time---)"]'

//      JSON.parse(text, reviver)
//          This method parses a JSON text to produce an object or array.
//          It can throw a SyntaxError exception.

//          The optional reviver parameter is a function that can filter and
//          transform the results. It receives each of the keys and values,
//          and its return value is used instead of the original value.
//          If it returns what it received, then the structure is not modified.
//          If it returns undefined then the member is deleted.

//          Example:

//          // Parse the text. Values that look like ISO date strings will
//          // be converted to Date objects.

//          myData = JSON.parse(text, function (key, value) {
//              var a;
//              if (typeof value === "string") {
//                  a =
//   /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
//                  if (a) {
//                      return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
//                          +a[5], +a[6]));
//                  }
//              }
//              return value;
//          });

//          myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
//              var d;
//              if (typeof value === "string" &&
//                      value.slice(0, 5) === "Date(" &&
//                      value.slice(-1) === ")") {
//                  d = new Date(value.slice(5, -1));
//                  if (d) {
//                      return d;
//                  }
//              }
//              return value;
//          });

//  This is a reference implementation. You are free to copy, modify, or
//  redistribute.

/*jslint
    eval, for, this
*/

/*property
    JSON, apply, call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/

// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

if ((typeof JSON === "undefined" ? "undefined" : _typeof(JSON)) !== "object") {
    JSON = {};
}

(function () {
    "use strict";

    var rx_one = /^[\],:{}\s]*$/;
    var rx_two = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
    var rx_three = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
    var rx_four = /(?:^|:|,)(?:\s*\[)+/g;
    var rx_escapable = /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
    var rx_dangerous = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? "0" + n : n;
    }

    function this_value() {
        return this.valueOf();
    }

    if (typeof Date.prototype.toJSON !== "function") {

        Date.prototype.toJSON = function () {

            return isFinite(this.valueOf()) ? this.getUTCFullYear() + "-" + f(this.getUTCMonth() + 1) + "-" + f(this.getUTCDate()) + "T" + f(this.getUTCHours()) + ":" + f(this.getUTCMinutes()) + ":" + f(this.getUTCSeconds()) + "Z" : null;
        };

        Boolean.prototype.toJSON = this_value;
        Number.prototype.toJSON = this_value;
        String.prototype.toJSON = this_value;
    }

    var gap;
    var indent;
    var meta;
    var rep;

    function quote(string) {

        // If the string contains no control characters, no quote characters, and no
        // backslash characters, then we can safely slap some quotes around it.
        // Otherwise we must also replace the offending characters with safe escape
        // sequences.

        rx_escapable.lastIndex = 0;
        return rx_escapable.test(string) ? "\"" + string.replace(rx_escapable, function (a) {
            var c = meta[a];
            return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
        }) + "\"" : "\"" + string + "\"";
    }

    function str(key, holder) {

        // Produce a string from holder[key].

        var i; // The loop counter.
        var k; // The member key.
        var v; // The member value.
        var length;
        var mind = gap;
        var partial;
        var value = holder[key];

        // If the value has a toJSON method, call it to obtain a replacement value.

        if (value && (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object" && typeof value.toJSON === "function") {
            value = value.toJSON(key);
        }

        // If we were called with a replacer function, then call the replacer to
        // obtain a replacement value.

        if (typeof rep === "function") {
            value = rep.call(holder, key, value);
        }

        // What happens next depends on the value's type.

        switch (typeof value === "undefined" ? "undefined" : _typeof(value)) {
            case "string":
                return quote(value);

            case "number":

                // JSON numbers must be finite. Encode non-finite numbers as null.

                return isFinite(value) ? String(value) : "null";

            case "boolean":
            case "null":

                // If the value is a boolean or null, convert it to a string. Note:
                // typeof null does not produce "null". The case is included here in
                // the remote chance that this gets fixed someday.

                return String(value);

            // If the type is "object", we might be dealing with an object or an array or
            // null.

            case "object":

                // Due to a specification blunder in ECMAScript, typeof null is "object",
                // so watch out for that case.

                if (!value) {
                    return "null";
                }

                // Make an array to hold the partial results of stringifying this object value.

                gap += indent;
                partial = [];

                // Is the value an array?

                if (Object.prototype.toString.apply(value) === "[object Array]") {

                    // The value is an array. Stringify every element. Use null as a placeholder
                    // for non-JSON values.

                    length = value.length;
                    for (i = 0; i < length; i += 1) {
                        partial[i] = str(i, value) || "null";
                    }

                    // Join all of the elements together, separated with commas, and wrap them in
                    // brackets.

                    v = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
                    gap = mind;
                    return v;
                }

                // If the replacer is an array, use it to select the members to be stringified.

                if (rep && (typeof rep === "undefined" ? "undefined" : _typeof(rep)) === "object") {
                    length = rep.length;
                    for (i = 0; i < length; i += 1) {
                        if (typeof rep[i] === "string") {
                            k = rep[i];
                            v = str(k, value);
                            if (v) {
                                partial.push(quote(k) + (gap ? ": " : ":") + v);
                            }
                        }
                    }
                } else {

                    // Otherwise, iterate through all of the keys in the object.

                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = str(k, value);
                            if (v) {
                                partial.push(quote(k) + (gap ? ": " : ":") + v);
                            }
                        }
                    }
                }

                // Join all of the member texts together, separated with commas,
                // and wrap them in braces.

                v = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
                gap = mind;
                return v;
        }
    }

    // If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== "function") {
        meta = { // table of character substitutions
            "\b": "\\b",
            "\t": "\\t",
            "\n": "\\n",
            "\f": "\\f",
            "\r": "\\r",
            "\"": "\\\"",
            "\\": "\\\\"
        };
        JSON.stringify = function (value, replacer, space) {

            // The stringify method takes a value and an optional replacer, and an optional
            // space parameter, and returns a JSON text. The replacer can be a function
            // that can replace values, or an array of strings that will select the keys.
            // A default replacer method can be provided. Use of the space parameter can
            // produce text that is more easily readable.

            var i;
            gap = "";
            indent = "";

            // If the space parameter is a number, make an indent string containing that
            // many spaces.

            if (typeof space === "number") {
                for (i = 0; i < space; i += 1) {
                    indent += " ";
                }

                // If the space parameter is a string, it will be used as the indent string.
            } else if (typeof space === "string") {
                indent = space;
            }

            // If there is a replacer, it must be a function or an array.
            // Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== "function" && ((typeof replacer === "undefined" ? "undefined" : _typeof(replacer)) !== "object" || typeof replacer.length !== "number")) {
                throw new Error("JSON.stringify");
            }

            // Make a fake root object containing our value under the key of "".
            // Return the result of stringifying the value.

            return str("", { "": value });
        };
    }

    // If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== "function") {
        JSON.parse = function (text, reviver) {

            // The parse method takes a text and an optional reviver function, and returns
            // a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

                // The walk method is used to recursively walk the resulting structure so
                // that modifications can be made.

                var k;
                var v;
                var value = holder[key];
                if (value && (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object") {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }

            // Parsing happens in four stages. In the first stage, we replace certain
            // Unicode characters with escape sequences. JavaScript handles many characters
            // incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            rx_dangerous.lastIndex = 0;
            if (rx_dangerous.test(text)) {
                text = text.replace(rx_dangerous, function (a) {
                    return "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

            // In the second stage, we run the text against regular expressions that look
            // for non-JSON patterns. We are especially concerned with "()" and "new"
            // because they can cause invocation, and "=" because it can cause mutation.
            // But just to be safe, we want to reject all unexpected forms.

            // We split the second stage into 4 regexp operations in order to work around
            // crippling inefficiencies in IE's and Safari's regexp engines. First we
            // replace the JSON backslash pairs with "@" (a non-JSON character). Second, we
            // replace all simple value tokens with "]" characters. Third, we delete all
            // open brackets that follow a colon or comma or that begin the text. Finally,
            // we look to see that the remaining characters are only whitespace or "]" or
            // "," or ":" or "{" or "}". If that is so, then the text is safe for eval.

            if (rx_one.test(text.replace(rx_two, "@").replace(rx_three, "]").replace(rx_four, ""))) {

                // In the third stage we use the eval function to compile the text into a
                // JavaScript structure. The "{" operator is subject to a syntactic ambiguity
                // in JavaScript: it can begin a block or an object literal. We wrap the text
                // in parens to eliminate the ambiguity.

                j = eval("(" + text + ")");

                // In the optional fourth stage, we recursively walk the new structure, passing
                // each name/value pair to a reviver function for possible transformation.

                return typeof reviver === "function" ? walk({ "": j }, "") : j;
            }

            // If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError("JSON.parse");
        };
    }
})();

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var slice = util.slice;
var pluck = util.pluck;
var each = util.each;
var bind = util.bind;
var create = util.create;
var isList = util.isList;
var isFunction = util.isFunction;
var isObject = util.isObject;

module.exports = {
	createStore: _createStore
};

var storeAPI = {
	version: '2.0.12',
	enabled: false,

	// get returns the value of the given key. If that value
	// is undefined, it returns optionalDefaultValue instead.
	get: function get(key, optionalDefaultValue) {
		var data = this.storage.read(this._namespacePrefix + key);
		return this._deserialize(data, optionalDefaultValue);
	},

	// set will store the given value at key and returns value.
	// Calling set with value === undefined is equivalent to calling remove.
	set: function set(key, value) {
		if (value === undefined) {
			return this.remove(key);
		}
		this.storage.write(this._namespacePrefix + key, this._serialize(value));
		return value;
	},

	// remove deletes the key and value stored at the given key.
	remove: function remove(key) {
		this.storage.remove(this._namespacePrefix + key);
	},

	// each will call the given callback once for each key-value pair
	// in this store.
	each: function each(callback) {
		var self = this;
		this.storage.each(function (val, namespacedKey) {
			callback.call(self, self._deserialize(val), (namespacedKey || '').replace(self._namespaceRegexp, ''));
		});
	},

	// clearAll will remove all the stored key-value pairs in this store.
	clearAll: function clearAll() {
		this.storage.clearAll();
	},

	// additional functionality that can't live in plugins
	// ---------------------------------------------------

	// hasNamespace returns true if this store instance has the given namespace.
	hasNamespace: function hasNamespace(namespace) {
		return this._namespacePrefix == '__storejs_' + namespace + '_';
	},

	// createStore creates a store.js instance with the first
	// functioning storage in the list of storage candidates,
	// and applies the the given mixins to the instance.
	createStore: function createStore() {
		return _createStore.apply(this, arguments);
	},

	addPlugin: function addPlugin(plugin) {
		this._addPlugin(plugin);
	},

	namespace: function namespace(_namespace) {
		return _createStore(this.storage, this.plugins, _namespace);
	}
};

function _warn() {
	var _console = typeof console == 'undefined' ? null : console;
	if (!_console) {
		return;
	}
	var fn = _console.warn ? _console.warn : _console.log;
	fn.apply(_console, arguments);
}

function _createStore(storages, plugins, namespace) {
	if (!namespace) {
		namespace = '';
	}
	if (storages && !isList(storages)) {
		storages = [storages];
	}
	if (plugins && !isList(plugins)) {
		plugins = [plugins];
	}

	var namespacePrefix = namespace ? '__storejs_' + namespace + '_' : '';
	var namespaceRegexp = namespace ? new RegExp('^' + namespacePrefix) : null;
	var legalNamespaces = /^[a-zA-Z0-9_\-]*$/; // alpha-numeric + underscore and dash
	if (!legalNamespaces.test(namespace)) {
		throw new Error('store.js namespaces can only have alphanumerics + underscores and dashes');
	}

	var _privateStoreProps = {
		_namespacePrefix: namespacePrefix,
		_namespaceRegexp: namespaceRegexp,

		_testStorage: function _testStorage(storage) {
			try {
				var testStr = '__storejs__test__';
				storage.write(testStr, testStr);
				var ok = storage.read(testStr) === testStr;
				storage.remove(testStr);
				return ok;
			} catch (e) {
				return false;
			}
		},

		_assignPluginFnProp: function _assignPluginFnProp(pluginFnProp, propName) {
			var oldFn = this[propName];
			this[propName] = function pluginFn() {
				var args = slice(arguments, 0);
				var self = this;

				// super_fn calls the old function which was overwritten by
				// this mixin.
				function super_fn() {
					if (!oldFn) {
						return;
					}
					each(arguments, function (arg, i) {
						args[i] = arg;
					});
					return oldFn.apply(self, args);
				}

				// Give mixing function access to super_fn by prefixing all mixin function
				// arguments with super_fn.
				var newFnArgs = [super_fn].concat(args);

				return pluginFnProp.apply(self, newFnArgs);
			};
		},

		_serialize: function _serialize(obj) {
			return JSON.stringify(obj);
		},

		_deserialize: function _deserialize(strVal, defaultVal) {
			if (!strVal) {
				return defaultVal;
			}
			// It is possible that a raw string value has been previously stored
			// in a storage without using store.js, meaning it will be a raw
			// string value instead of a JSON serialized string. By defaulting
			// to the raw string value in case of a JSON parse error, we allow
			// for past stored values to be forwards-compatible with store.js
			var val = '';
			try {
				val = JSON.parse(strVal);
			} catch (e) {
				val = strVal;
			}

			return val !== undefined ? val : defaultVal;
		},

		_addStorage: function _addStorage(storage) {
			if (this.enabled) {
				return;
			}
			if (this._testStorage(storage)) {
				this.storage = storage;
				this.enabled = true;
			}
		},

		_addPlugin: function _addPlugin(plugin) {
			var self = this;

			// If the plugin is an array, then add all plugins in the array.
			// This allows for a plugin to depend on other plugins.
			if (isList(plugin)) {
				each(plugin, function (plugin) {
					self._addPlugin(plugin);
				});
				return;
			}

			// Keep track of all plugins we've seen so far, so that we
			// don't add any of them twice.
			var seenPlugin = pluck(this.plugins, function (seenPlugin) {
				return plugin === seenPlugin;
			});
			if (seenPlugin) {
				return;
			}
			this.plugins.push(plugin);

			// Check that the plugin is properly formed
			if (!isFunction(plugin)) {
				throw new Error('Plugins must be function values that return objects');
			}

			var pluginProperties = plugin.call(this);
			if (!isObject(pluginProperties)) {
				throw new Error('Plugins must return an object of function properties');
			}

			// Add the plugin function properties to this store instance.
			each(pluginProperties, function (pluginFnProp, propName) {
				if (!isFunction(pluginFnProp)) {
					throw new Error('Bad plugin property: ' + propName + ' from plugin ' + plugin.name + '. Plugins should only return functions.');
				}
				self._assignPluginFnProp(pluginFnProp, propName);
			});
		},

		// Put deprecated properties in the private API, so as to not expose it to accidential
		// discovery through inspection of the store object.

		// Deprecated: addStorage
		addStorage: function addStorage(storage) {
			_warn('store.addStorage(storage) is deprecated. Use createStore([storages])');
			this._addStorage(storage);
		}
	};

	var store = create(_privateStoreProps, storeAPI, {
		plugins: []
	});
	store.raw = {};
	each(store, function (prop, propName) {
		if (isFunction(prop)) {
			store.raw[propName] = bind(store, prop);
		}
	});
	each(storages, function (storage) {
		store._addStorage(storage);
	});
	each(plugins, function (plugin) {
		store._addPlugin(plugin);
	});
	return store;
}

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = [
// Listed in order of usage preference
__webpack_require__(41), __webpack_require__(43), __webpack_require__(44), __webpack_require__(40), __webpack_require__(45), __webpack_require__(42)];

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// cookieStorage is useful Safari private browser mode, where localStorage
// doesn't work but cookies do. This implementation is adopted from
// https://developer.mozilla.org/en-US/docs/Web/API/Storage/LocalStorage

var util = __webpack_require__(1);
var Global = util.Global;
var trim = util.trim;

module.exports = {
	name: 'cookieStorage',
	read: read,
	write: write,
	each: each,
	remove: remove,
	clearAll: clearAll
};

var doc = Global.document;

function read(key) {
	if (!key || !_has(key)) {
		return null;
	}
	var regexpStr = "(?:^|.*;\\s*)" + escape(key).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*((?:[^;](?!;))*[^;]?).*";
	return unescape(doc.cookie.replace(new RegExp(regexpStr), "$1"));
}

function each(callback) {
	var cookies = doc.cookie.split(/; ?/g);
	for (var i = cookies.length - 1; i >= 0; i--) {
		if (!trim(cookies[i])) {
			continue;
		}
		var kvp = cookies[i].split('=');
		var key = unescape(kvp[0]);
		var val = unescape(kvp[1]);
		callback(val, key);
	}
}

function write(key, data) {
	if (!key) {
		return;
	}
	doc.cookie = escape(key) + "=" + escape(data) + "; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/";
}

function remove(key) {
	if (!key || !_has(key)) {
		return;
	}
	doc.cookie = escape(key) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/";
}

function clearAll() {
	each(function (_, key) {
		remove(key);
	});
}

function _has(key) {
	return new RegExp("(?:^|;\\s*)" + escape(key).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=").test(doc.cookie);
}

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var Global = util.Global;

module.exports = {
	name: 'localStorage',
	read: read,
	write: write,
	each: each,
	remove: remove,
	clearAll: clearAll
};

function localStorage() {
	return Global.localStorage;
}

function read(key) {
	return localStorage().getItem(key);
}

function write(key, data) {
	return localStorage().setItem(key, data);
}

function each(fn) {
	for (var i = localStorage().length - 1; i >= 0; i--) {
		var key = localStorage().key(i);
		fn(read(key), key);
	}
}

function remove(key) {
	return localStorage().removeItem(key);
}

function clearAll() {
	return localStorage().clear();
}

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// memoryStorage is a useful last fallback to ensure that the store
// is functions (meaning store.get(), store.set(), etc will all function).
// However, stored values will not persist when the browser navigates to
// a new page or reloads the current page.

module.exports = {
	name: 'memoryStorage',
	read: read,
	write: write,
	each: each,
	remove: remove,
	clearAll: clearAll
};

var memoryStorage = {};

function read(key) {
	return memoryStorage[key];
}

function write(key, data) {
	memoryStorage[key] = data;
}

function each(callback) {
	for (var key in memoryStorage) {
		if (memoryStorage.hasOwnProperty(key)) {
			callback(memoryStorage[key], key);
		}
	}
}

function remove(key) {
	delete memoryStorage[key];
}

function clearAll(key) {
	memoryStorage = {};
}

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// oldFF-globalStorage provides storage for Firefox
// versions 6 and 7, where no localStorage, etc
// is available.

var util = __webpack_require__(1);
var Global = util.Global;

module.exports = {
	name: 'oldFF-globalStorage',
	read: read,
	write: write,
	each: each,
	remove: remove,
	clearAll: clearAll
};

var globalStorage = Global.globalStorage;

function read(key) {
	return globalStorage[key];
}

function write(key, data) {
	globalStorage[key] = data;
}

function each(fn) {
	for (var i = globalStorage.length - 1; i >= 0; i--) {
		var key = globalStorage.key(i);
		fn(globalStorage[key], key);
	}
}

function remove(key) {
	return globalStorage.removeItem(key);
}

function clearAll() {
	each(function (key, _) {
		delete globalStorage[key];
	});
}

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// oldIE-userDataStorage provides storage for Internet Explorer
// versions 6 and 7, where no localStorage, sessionStorage, etc
// is available.

var util = __webpack_require__(1);
var Global = util.Global;

module.exports = {
	name: 'oldIE-userDataStorage',
	write: write,
	read: read,
	each: each,
	remove: remove,
	clearAll: clearAll
};

var storageName = 'storejs';
var doc = Global.document;
var _withStorageEl = _makeIEStorageElFunction();
var disable = (Global.navigator ? Global.navigator.userAgent : '').match(/ (MSIE 8|MSIE 9|MSIE 10)\./); // MSIE 9.x, MSIE 10.x

function write(unfixedKey, data) {
	if (disable) {
		return;
	}
	var fixedKey = fixKey(unfixedKey);
	_withStorageEl(function (storageEl) {
		storageEl.setAttribute(fixedKey, data);
		storageEl.save(storageName);
	});
}

function read(unfixedKey) {
	if (disable) {
		return;
	}
	var fixedKey = fixKey(unfixedKey);
	var res = null;
	_withStorageEl(function (storageEl) {
		res = storageEl.getAttribute(fixedKey);
	});
	return res;
}

function each(callback) {
	_withStorageEl(function (storageEl) {
		var attributes = storageEl.XMLDocument.documentElement.attributes;
		for (var i = attributes.length - 1; i >= 0; i--) {
			var attr = attributes[i];
			callback(storageEl.getAttribute(attr.name), attr.name);
		}
	});
}

function remove(unfixedKey) {
	var fixedKey = fixKey(unfixedKey);
	_withStorageEl(function (storageEl) {
		storageEl.removeAttribute(fixedKey);
		storageEl.save(storageName);
	});
}

function clearAll() {
	_withStorageEl(function (storageEl) {
		var attributes = storageEl.XMLDocument.documentElement.attributes;
		storageEl.load(storageName);
		for (var i = attributes.length - 1; i >= 0; i--) {
			storageEl.removeAttribute(attributes[i].name);
		}
		storageEl.save(storageName);
	});
}

// Helpers
//////////

// In IE7, keys cannot start with a digit or contain certain chars.
// See https://github.com/marcuswestin/store.js/issues/40
// See https://github.com/marcuswestin/store.js/issues/83
var forbiddenCharsRegex = new RegExp("[!\"#$%&'()*+,/\\\\:;<=>?@[\\]^`{|}~]", "g");
function fixKey(key) {
	return key.replace(/^\d/, '___$&').replace(forbiddenCharsRegex, '___');
}

function _makeIEStorageElFunction() {
	if (!doc || !doc.documentElement || !doc.documentElement.addBehavior) {
		return null;
	}
	var scriptTag = 'script',
	    storageOwner,
	    storageContainer,
	    storageEl;

	// Since #userData storage applies only to specific paths, we need to
	// somehow link our data to a specific path.  We choose /favicon.ico
	// as a pretty safe option, since all browsers already make a request to
	// this URL anyway and being a 404 will not hurt us here.  We wrap an
	// iframe pointing to the favicon in an ActiveXObject(htmlfile) object
	// (see: http://msdn.microsoft.com/en-us/library/aa752574(v=VS.85).aspx)
	// since the iframe access rules appear to allow direct access and
	// manipulation of the document element, even for a 404 page.  This
	// document can be used instead of the current document (which would
	// have been limited to the current path) to perform #userData storage.
	try {
		/* global ActiveXObject */
		storageContainer = new ActiveXObject('htmlfile');
		storageContainer.open();
		storageContainer.write('<' + scriptTag + '>document.w=window</' + scriptTag + '><iframe src="/favicon.ico"></iframe>');
		storageContainer.close();
		storageOwner = storageContainer.w.frames[0].document;
		storageEl = storageOwner.createElement('div');
	} catch (e) {
		// somehow ActiveXObject instantiation failed (perhaps some special
		// security settings or otherwse), fall back to per-path storage
		storageEl = doc.createElement('div');
		storageOwner = doc.body;
	}

	return function (storeFunction) {
		var args = [].slice.call(arguments, 0);
		args.unshift(storageEl);
		// See http://msdn.microsoft.com/en-us/library/ms531081(v=VS.85).aspx
		// and http://msdn.microsoft.com/en-us/library/ms531424(v=VS.85).aspx
		storageOwner.appendChild(storageEl);
		storageEl.addBehavior('#default#userData');
		storageEl.load(storageName);
		storeFunction.apply(this, args);
		storageOwner.removeChild(storageEl);
		return;
	};
}

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var Global = util.Global;

module.exports = {
	name: 'sessionStorage',
	read: read,
	write: write,
	each: each,
	remove: remove,
	clearAll: clearAll
};

function sessionStorage() {
	return Global.sessionStorage;
}

function read(key) {
	return sessionStorage().getItem(key);
}

function write(key, data) {
	return sessionStorage().setItem(key, data);
}

function each(fn) {
	for (var i = sessionStorage().length - 1; i >= 0; i--) {
		var key = sessionStorage().key(i);
		fn(read(key), key);
	}
}

function remove(key) {
	return sessionStorage().removeItem(key);
}

function clearAll() {
	return sessionStorage().clear();
}

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function () {};
Timeout.prototype.close = function () {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(35);
exports.setImmediate = setImmediate;
exports.clearImmediate = clearImmediate;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * validate.js 0.11.1
 *
 * (c) 2013-2016 Nicklas Ansman, 2013 Wrapp
 * Validate.js may be freely distributed under the MIT license.
 * For all details and documentation:
 * http://validatejs.org/
 */

(function (exports, module, define) {
  "use strict";

  // The main function that calls the validators specified by the constraints.
  // The options are the following:
  //   - format (string) - An option that controls how the returned value is formatted
  //     * flat - Returns a flat array of just the error messages
  //     * grouped - Returns the messages grouped by attribute (default)
  //     * detailed - Returns an array of the raw validation data
  //   - fullMessages (boolean) - If `true` (default) the attribute name is prepended to the error.
  //
  // Please note that the options are also passed to each validator.

  var validate = function validate(attributes, constraints, options) {
    options = v.extend({}, v.options, options);

    var results = v.runValidations(attributes, constraints, options),
        attr,
        validator;

    for (attr in results) {
      for (validator in results[attr]) {
        if (v.isPromise(results[attr][validator])) {
          throw new Error("Use validate.async if you want support for promises");
        }
      }
    }
    return validate.processValidationResults(results, options);
  };

  var v = validate;

  // Copies over attributes from one or more sources to a single destination.
  // Very much similar to underscore's extend.
  // The first argument is the target object and the remaining arguments will be
  // used as sources.
  v.extend = function (obj) {
    [].slice.call(arguments, 1).forEach(function (source) {
      for (var attr in source) {
        obj[attr] = source[attr];
      }
    });
    return obj;
  };

  v.extend(validate, {
    // This is the version of the library as a semver.
    // The toString function will allow it to be coerced into a string
    version: {
      major: 0,
      minor: 11,
      patch: 1,
      metadata: null,
      toString: function toString() {
        var version = v.format("%{major}.%{minor}.%{patch}", v.version);
        if (!v.isEmpty(v.version.metadata)) {
          version += "+" + v.version.metadata;
        }
        return version;
      }
    },

    // Below is the dependencies that are used in validate.js

    // The constructor of the Promise implementation.
    // If you are using Q.js, RSVP or any other A+ compatible implementation
    // override this attribute to be the constructor of that promise.
    // Since jQuery promises aren't A+ compatible they won't work.
    Promise: typeof Promise !== "undefined" ? Promise : /* istanbul ignore next */null,

    EMPTY_STRING_REGEXP: /^\s*$/,

    // Runs the validators specified by the constraints object.
    // Will return an array of the format:
    //     [{attribute: "<attribute name>", error: "<validation result>"}, ...]
    runValidations: function runValidations(attributes, constraints, options) {
      var results = [],
          attr,
          validatorName,
          value,
          validators,
          validator,
          validatorOptions,
          error;

      if (v.isDomElement(attributes) || v.isJqueryElement(attributes)) {
        attributes = v.collectFormValues(attributes);
      }

      // Loops through each constraints, finds the correct validator and run it.
      for (attr in constraints) {
        value = v.getDeepObjectValue(attributes, attr);
        // This allows the constraints for an attribute to be a function.
        // The function will be called with the value, attribute name, the complete dict of
        // attributes as well as the options and constraints passed in.
        // This is useful when you want to have different
        // validations depending on the attribute value.
        validators = v.result(constraints[attr], value, attributes, attr, options, constraints);

        for (validatorName in validators) {
          validator = v.validators[validatorName];

          if (!validator) {
            error = v.format("Unknown validator %{name}", { name: validatorName });
            throw new Error(error);
          }

          validatorOptions = validators[validatorName];
          // This allows the options to be a function. The function will be
          // called with the value, attribute name, the complete dict of
          // attributes as well as the options and constraints passed in.
          // This is useful when you want to have different
          // validations depending on the attribute value.
          validatorOptions = v.result(validatorOptions, value, attributes, attr, options, constraints);
          if (!validatorOptions) {
            continue;
          }
          results.push({
            attribute: attr,
            value: value,
            validator: validatorName,
            globalOptions: options,
            attributes: attributes,
            options: validatorOptions,
            error: validator.call(validator, value, validatorOptions, attr, attributes, options)
          });
        }
      }

      return results;
    },

    // Takes the output from runValidations and converts it to the correct
    // output format.
    processValidationResults: function processValidationResults(errors, options) {
      errors = v.pruneEmptyErrors(errors, options);
      errors = v.expandMultipleErrors(errors, options);
      errors = v.convertErrorMessages(errors, options);

      var format = options.format || "grouped";

      if (typeof v.formatters[format] === 'function') {
        errors = v.formatters[format](errors);
      } else {
        throw new Error(v.format("Unknown format %{format}", options));
      }

      return v.isEmpty(errors) ? undefined : errors;
    },

    // Runs the validations with support for promises.
    // This function will return a promise that is settled when all the
    // validation promises have been completed.
    // It can be called even if no validations returned a promise.
    async: function async(attributes, constraints, options) {
      options = v.extend({}, v.async.options, options);

      var WrapErrors = options.wrapErrors || function (errors) {
        return errors;
      };

      // Removes unknown attributes
      if (options.cleanAttributes !== false) {
        attributes = v.cleanAttributes(attributes, constraints);
      }

      var results = v.runValidations(attributes, constraints, options);

      return new v.Promise(function (resolve, reject) {
        v.waitForResults(results).then(function () {
          var errors = v.processValidationResults(results, options);
          if (errors) {
            reject(new WrapErrors(errors, options, attributes, constraints));
          } else {
            resolve(attributes);
          }
        }, function (err) {
          reject(err);
        });
      });
    },

    single: function single(value, constraints, options) {
      options = v.extend({}, v.single.options, options, {
        format: "flat",
        fullMessages: false
      });
      return v({ single: value }, { single: constraints }, options);
    },

    // Returns a promise that is resolved when all promises in the results array
    // are settled. The promise returned from this function is always resolved,
    // never rejected.
    // This function modifies the input argument, it replaces the promises
    // with the value returned from the promise.
    waitForResults: function waitForResults(results) {
      // Create a sequence of all the results starting with a resolved promise.
      return results.reduce(function (memo, result) {
        // If this result isn't a promise skip it in the sequence.
        if (!v.isPromise(result.error)) {
          return memo;
        }

        return memo.then(function () {
          return result.error.then(function (error) {
            result.error = error || null;
          });
        });
      }, new v.Promise(function (r) {
        r();
      })); // A resolved promise
    },

    // If the given argument is a call: function the and: function return the value
    // otherwise just return the value. Additional arguments will be passed as
    // arguments to the function.
    // Example:
    // ```
    // result('foo') // 'foo'
    // result(Math.max, 1, 2) // 2
    // ```
    result: function result(value) {
      var args = [].slice.call(arguments, 1);
      if (typeof value === 'function') {
        value = value.apply(null, args);
      }
      return value;
    },

    // Checks if the value is a number. This function does not consider NaN a
    // number like many other `isNumber` functions do.
    isNumber: function isNumber(value) {
      return typeof value === 'number' && !isNaN(value);
    },

    // Returns false if the object is not a function
    isFunction: function isFunction(value) {
      return typeof value === 'function';
    },

    // A simple check to verify that the value is an integer. Uses `isNumber`
    // and a simple modulo check.
    isInteger: function isInteger(value) {
      return v.isNumber(value) && value % 1 === 0;
    },

    // Checks if the value is a boolean
    isBoolean: function isBoolean(value) {
      return typeof value === 'boolean';
    },

    // Uses the `Object` function to check if the given argument is an object.
    isObject: function isObject(obj) {
      return obj === Object(obj);
    },

    // Simply checks if the object is an instance of a date
    isDate: function isDate(obj) {
      return obj instanceof Date;
    },

    // Returns false if the object is `null` of `undefined`
    isDefined: function isDefined(obj) {
      return obj !== null && obj !== undefined;
    },

    // Checks if the given argument is a promise. Anything with a `then`
    // function is considered a promise.
    isPromise: function isPromise(p) {
      return !!p && v.isFunction(p.then);
    },

    isJqueryElement: function isJqueryElement(o) {
      return o && v.isString(o.jquery);
    },

    isDomElement: function isDomElement(o) {
      if (!o) {
        return false;
      }

      if (!o.querySelectorAll || !o.querySelector) {
        return false;
      }

      if (v.isObject(document) && o === document) {
        return true;
      }

      // http://stackoverflow.com/a/384380/699304
      /* istanbul ignore else */
      if ((typeof HTMLElement === "undefined" ? "undefined" : _typeof(HTMLElement)) === "object") {
        return o instanceof HTMLElement;
      } else {
        return o && (typeof o === "undefined" ? "undefined" : _typeof(o)) === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName === "string";
      }
    },

    isEmpty: function isEmpty(value) {
      var attr;

      // Null and undefined are empty
      if (!v.isDefined(value)) {
        return true;
      }

      // functions are non empty
      if (v.isFunction(value)) {
        return false;
      }

      // Whitespace only strings are empty
      if (v.isString(value)) {
        return v.EMPTY_STRING_REGEXP.test(value);
      }

      // For arrays we use the length property
      if (v.isArray(value)) {
        return value.length === 0;
      }

      // Dates have no attributes but aren't empty
      if (v.isDate(value)) {
        return false;
      }

      // If we find at least one property we consider it non empty
      if (v.isObject(value)) {
        for (attr in value) {
          return false;
        }
        return true;
      }

      return false;
    },

    // Formats the specified strings with the given values like so:
    // ```
    // format("Foo: %{foo}", {foo: "bar"}) // "Foo bar"
    // ```
    // If you want to write %{...} without having it replaced simply
    // prefix it with % like this `Foo: %%{foo}` and it will be returned
    // as `"Foo: %{foo}"`
    format: v.extend(function (str, vals) {
      if (!v.isString(str)) {
        return str;
      }
      return str.replace(v.format.FORMAT_REGEXP, function (m0, m1, m2) {
        if (m1 === '%') {
          return "%{" + m2 + "}";
        } else {
          return String(vals[m2]);
        }
      });
    }, {
      // Finds %{key} style patterns in the given string
      FORMAT_REGEXP: /(%?)%\{([^\}]+)\}/g
    }),

    // "Prettifies" the given string.
    // Prettifying means replacing [.\_-] with spaces as well as splitting
    // camel case words.
    prettify: function prettify(str) {
      if (v.isNumber(str)) {
        // If there are more than 2 decimals round it to two
        if (str * 100 % 1 === 0) {
          return "" + str;
        } else {
          return parseFloat(Math.round(str * 100) / 100).toFixed(2);
        }
      }

      if (v.isArray(str)) {
        return str.map(function (s) {
          return v.prettify(s);
        }).join(", ");
      }

      if (v.isObject(str)) {
        return str.toString();
      }

      // Ensure the string is actually a string
      str = "" + str;

      return str
      // Splits keys separated by periods
      .replace(/([^\s])\.([^\s])/g, '$1 $2')
      // Removes backslashes
      .replace(/\\+/g, '')
      // Replaces - and - with space
      .replace(/[_-]/g, ' ')
      // Splits camel cased words
      .replace(/([a-z])([A-Z])/g, function (m0, m1, m2) {
        return "" + m1 + " " + m2.toLowerCase();
      }).toLowerCase();
    },

    stringifyValue: function stringifyValue(value) {
      return v.prettify(value);
    },

    isString: function isString(value) {
      return typeof value === 'string';
    },

    isArray: function isArray(value) {
      return {}.toString.call(value) === '[object Array]';
    },

    // Checks if the object is a hash, which is equivalent to an object that
    // is neither an array nor a function.
    isHash: function isHash(value) {
      return v.isObject(value) && !v.isArray(value) && !v.isFunction(value);
    },

    contains: function contains(obj, value) {
      if (!v.isDefined(obj)) {
        return false;
      }
      if (v.isArray(obj)) {
        return obj.indexOf(value) !== -1;
      }
      return value in obj;
    },

    unique: function unique(array) {
      if (!v.isArray(array)) {
        return array;
      }
      return array.filter(function (el, index, array) {
        return array.indexOf(el) == index;
      });
    },

    forEachKeyInKeypath: function forEachKeyInKeypath(object, keypath, callback) {
      if (!v.isString(keypath)) {
        return undefined;
      }

      var key = "",
          i,
          escape = false;

      for (i = 0; i < keypath.length; ++i) {
        switch (keypath[i]) {
          case '.':
            if (escape) {
              escape = false;
              key += '.';
            } else {
              object = callback(object, key, false);
              key = "";
            }
            break;

          case '\\':
            if (escape) {
              escape = false;
              key += '\\';
            } else {
              escape = true;
            }
            break;

          default:
            escape = false;
            key += keypath[i];
            break;
        }
      }

      return callback(object, key, true);
    },

    getDeepObjectValue: function getDeepObjectValue(obj, keypath) {
      if (!v.isObject(obj)) {
        return undefined;
      }

      return v.forEachKeyInKeypath(obj, keypath, function (obj, key) {
        if (v.isObject(obj)) {
          return obj[key];
        }
      });
    },

    // This returns an object with all the values of the form.
    // It uses the input name as key and the value as value
    // So for example this:
    // <input type="text" name="email" value="foo@bar.com" />
    // would return:
    // {email: "foo@bar.com"}
    collectFormValues: function collectFormValues(form, options) {
      var values = {},
          i,
          j,
          input,
          inputs,
          option,
          value;

      if (v.isJqueryElement(form)) {
        form = form[0];
      }

      if (!form) {
        return values;
      }

      options = options || {};

      inputs = form.querySelectorAll("input[name], textarea[name]");
      for (i = 0; i < inputs.length; ++i) {
        input = inputs.item(i);

        if (v.isDefined(input.getAttribute("data-ignored"))) {
          continue;
        }

        value = v.sanitizeFormValue(input.value, options);
        if (input.type === "number") {
          value = value ? +value : null;
        } else if (input.type === "checkbox") {
          if (input.attributes.value) {
            if (!input.checked) {
              value = values[input.name] || null;
            }
          } else {
            value = input.checked;
          }
        } else if (input.type === "radio") {
          if (!input.checked) {
            value = values[input.name] || null;
          }
        }
        values[input.name] = value;
      }

      inputs = form.querySelectorAll("select[name]");
      for (i = 0; i < inputs.length; ++i) {
        input = inputs.item(i);
        if (input.multiple) {
          value = [];
          for (j in input.options) {
            option = input.options[j];
            if (option.selected) {
              value.push(v.sanitizeFormValue(option.value, options));
            }
          }
        } else {
          value = v.sanitizeFormValue(input.options[input.selectedIndex].value, options);
        }
        values[input.name] = value;
      }

      return values;
    },

    sanitizeFormValue: function sanitizeFormValue(value, options) {
      if (options.trim && v.isString(value)) {
        value = value.trim();
      }

      if (options.nullify !== false && value === "") {
        return null;
      }
      return value;
    },

    capitalize: function capitalize(str) {
      if (!v.isString(str)) {
        return str;
      }
      return str[0].toUpperCase() + str.slice(1);
    },

    // Remove all errors who's error attribute is empty (null or undefined)
    pruneEmptyErrors: function pruneEmptyErrors(errors) {
      return errors.filter(function (error) {
        return !v.isEmpty(error.error);
      });
    },

    // In
    // [{error: ["err1", "err2"], ...}]
    // Out
    // [{error: "err1", ...}, {error: "err2", ...}]
    //
    // All attributes in an error with multiple messages are duplicated
    // when expanding the errors.
    expandMultipleErrors: function expandMultipleErrors(errors) {
      var ret = [];
      errors.forEach(function (error) {
        // Removes errors without a message
        if (v.isArray(error.error)) {
          error.error.forEach(function (msg) {
            ret.push(v.extend({}, error, { error: msg }));
          });
        } else {
          ret.push(error);
        }
      });
      return ret;
    },

    // Converts the error mesages by prepending the attribute name unless the
    // message is prefixed by ^
    convertErrorMessages: function convertErrorMessages(errors, options) {
      options = options || {};

      var ret = [];
      errors.forEach(function (errorInfo) {
        var error = v.result(errorInfo.error, errorInfo.value, errorInfo.attribute, errorInfo.options, errorInfo.attributes, errorInfo.globalOptions);

        if (!v.isString(error)) {
          ret.push(errorInfo);
          return;
        }

        if (error[0] === '^') {
          error = error.slice(1);
        } else if (options.fullMessages !== false) {
          error = v.capitalize(v.prettify(errorInfo.attribute)) + " " + error;
        }
        error = error.replace(/\\\^/g, "^");
        error = v.format(error, { value: v.stringifyValue(errorInfo.value) });
        ret.push(v.extend({}, errorInfo, { error: error }));
      });
      return ret;
    },

    // In:
    // [{attribute: "<attributeName>", ...}]
    // Out:
    // {"<attributeName>": [{attribute: "<attributeName>", ...}]}
    groupErrorsByAttribute: function groupErrorsByAttribute(errors) {
      var ret = {};
      errors.forEach(function (error) {
        var list = ret[error.attribute];
        if (list) {
          list.push(error);
        } else {
          ret[error.attribute] = [error];
        }
      });
      return ret;
    },

    // In:
    // [{error: "<message 1>", ...}, {error: "<message 2>", ...}]
    // Out:
    // ["<message 1>", "<message 2>"]
    flattenErrorsToArray: function flattenErrorsToArray(errors) {
      return errors.map(function (error) {
        return error.error;
      }).filter(function (value, index, self) {
        return self.indexOf(value) === index;
      });
    },

    cleanAttributes: function cleanAttributes(attributes, whitelist) {
      function whitelistCreator(obj, key, last) {
        if (v.isObject(obj[key])) {
          return obj[key];
        }
        return obj[key] = last ? true : {};
      }

      function buildObjectWhitelist(whitelist) {
        var ow = {},
            lastObject,
            attr;
        for (attr in whitelist) {
          if (!whitelist[attr]) {
            continue;
          }
          v.forEachKeyInKeypath(ow, attr, whitelistCreator);
        }
        return ow;
      }

      function cleanRecursive(attributes, whitelist) {
        if (!v.isObject(attributes)) {
          return attributes;
        }

        var ret = v.extend({}, attributes),
            w,
            attribute;

        for (attribute in attributes) {
          w = whitelist[attribute];

          if (v.isObject(w)) {
            ret[attribute] = cleanRecursive(ret[attribute], w);
          } else if (!w) {
            delete ret[attribute];
          }
        }
        return ret;
      }

      if (!v.isObject(whitelist) || !v.isObject(attributes)) {
        return {};
      }

      whitelist = buildObjectWhitelist(whitelist);
      return cleanRecursive(attributes, whitelist);
    },

    exposeModule: function exposeModule(validate, root, exports, module, define) {
      if (exports) {
        if (module && module.exports) {
          exports = module.exports = validate;
        }
        exports.validate = validate;
      } else {
        root.validate = validate;
        if (validate.isFunction(define) && define.amd) {
          define([], function () {
            return validate;
          });
        }
      }
    },

    warn: function warn(msg) {
      if (typeof console !== "undefined" && console.warn) {
        console.warn("[validate.js] " + msg);
      }
    },

    error: function error(msg) {
      if (typeof console !== "undefined" && console.error) {
        console.error("[validate.js] " + msg);
      }
    }
  });

  validate.validators = {
    // Presence validates that the value isn't empty
    presence: function presence(value, options) {
      options = v.extend({}, this.options, options);
      if (options.allowEmpty ? !v.isDefined(value) : v.isEmpty(value)) {
        return options.message || this.message || "can't be blank";
      }
    },
    length: function length(value, options, attribute) {
      // Empty values are allowed
      if (!v.isDefined(value)) {
        return;
      }

      options = v.extend({}, this.options, options);

      var is = options.is,
          maximum = options.maximum,
          minimum = options.minimum,
          tokenizer = options.tokenizer || function (val) {
        return val;
      },
          err,
          errors = [];

      value = tokenizer(value);
      var length = value.length;
      if (!v.isNumber(length)) {
        v.error(v.format("Attribute %{attr} has a non numeric value for `length`", { attr: attribute }));
        return options.message || this.notValid || "has an incorrect length";
      }

      // Is checks
      if (v.isNumber(is) && length !== is) {
        err = options.wrongLength || this.wrongLength || "is the wrong length (should be %{count} characters)";
        errors.push(v.format(err, { count: is }));
      }

      if (v.isNumber(minimum) && length < minimum) {
        err = options.tooShort || this.tooShort || "is too short (minimum is %{count} characters)";
        errors.push(v.format(err, { count: minimum }));
      }

      if (v.isNumber(maximum) && length > maximum) {
        err = options.tooLong || this.tooLong || "is too long (maximum is %{count} characters)";
        errors.push(v.format(err, { count: maximum }));
      }

      if (errors.length > 0) {
        return options.message || errors;
      }
    },
    numericality: function numericality(value, options) {
      // Empty values are fine
      if (!v.isDefined(value)) {
        return;
      }

      options = v.extend({}, this.options, options);

      var errors = [],
          name,
          count,
          checks = {
        greaterThan: function greaterThan(v, c) {
          return v > c;
        },
        greaterThanOrEqualTo: function greaterThanOrEqualTo(v, c) {
          return v >= c;
        },
        equalTo: function equalTo(v, c) {
          return v === c;
        },
        lessThan: function lessThan(v, c) {
          return v < c;
        },
        lessThanOrEqualTo: function lessThanOrEqualTo(v, c) {
          return v <= c;
        },
        divisibleBy: function divisibleBy(v, c) {
          return v % c === 0;
        }
      };

      // Strict will check that it is a valid looking number
      if (v.isString(value) && options.strict) {
        var pattern = "^(0|[1-9]\\d*)";
        if (!options.onlyInteger) {
          pattern += "(\\.\\d+)?";
        }
        pattern += "$";

        if (!new RegExp(pattern).test(value)) {
          return options.message || options.notValid || this.notValid || this.message || "must be a valid number";
        }
      }

      // Coerce the value to a number unless we're being strict.
      if (options.noStrings !== true && v.isString(value) && !v.isEmpty(value)) {
        value = +value;
      }

      // If it's not a number we shouldn't continue since it will compare it.
      if (!v.isNumber(value)) {
        return options.message || options.notValid || this.notValid || this.message || "is not a number";
      }

      // Same logic as above, sort of. Don't bother with comparisons if this
      // doesn't pass.
      if (options.onlyInteger && !v.isInteger(value)) {
        return options.message || options.notInteger || this.notInteger || this.message || "must be an integer";
      }

      for (name in checks) {
        count = options[name];
        if (v.isNumber(count) && !checks[name](value, count)) {
          // This picks the default message if specified
          // For example the greaterThan check uses the message from
          // this.notGreaterThan so we capitalize the name and prepend "not"
          var key = "not" + v.capitalize(name);
          var msg = options[key] || this[key] || this.message || "must be %{type} %{count}";

          errors.push(v.format(msg, {
            count: count,
            type: v.prettify(name)
          }));
        }
      }

      if (options.odd && value % 2 !== 1) {
        errors.push(options.notOdd || this.notOdd || this.message || "must be odd");
      }
      if (options.even && value % 2 !== 0) {
        errors.push(options.notEven || this.notEven || this.message || "must be even");
      }

      if (errors.length) {
        return options.message || errors;
      }
    },
    datetime: v.extend(function (value, options) {
      if (!v.isFunction(this.parse) || !v.isFunction(this.format)) {
        throw new Error("Both the parse and format functions needs to be set to use the datetime/date validator");
      }

      // Empty values are fine
      if (!v.isDefined(value)) {
        return;
      }

      options = v.extend({}, this.options, options);

      var err,
          errors = [],
          earliest = options.earliest ? this.parse(options.earliest, options) : NaN,
          latest = options.latest ? this.parse(options.latest, options) : NaN;

      value = this.parse(value, options);

      // 86400000 is the number of seconds in a day, this is used to remove
      // the time from the date
      if (isNaN(value) || options.dateOnly && value % 86400000 !== 0) {
        err = options.notValid || options.message || this.notValid || "must be a valid date";
        return v.format(err, { value: arguments[0] });
      }

      if (!isNaN(earliest) && value < earliest) {
        err = options.tooEarly || options.message || this.tooEarly || "must be no earlier than %{date}";
        err = v.format(err, {
          value: this.format(value, options),
          date: this.format(earliest, options)
        });
        errors.push(err);
      }

      if (!isNaN(latest) && value > latest) {
        err = options.tooLate || options.message || this.tooLate || "must be no later than %{date}";
        err = v.format(err, {
          date: this.format(latest, options),
          value: this.format(value, options)
        });
        errors.push(err);
      }

      if (errors.length) {
        return v.unique(errors);
      }
    }, {
      parse: null,
      format: null
    }),
    date: function date(value, options) {
      options = v.extend({}, options, { dateOnly: true });
      return v.validators.datetime.call(v.validators.datetime, value, options);
    },
    format: function format(value, options) {
      if (v.isString(options) || options instanceof RegExp) {
        options = { pattern: options };
      }

      options = v.extend({}, this.options, options);

      var message = options.message || this.message || "is invalid",
          pattern = options.pattern,
          match;

      // Empty values are allowed
      if (!v.isDefined(value)) {
        return;
      }
      if (!v.isString(value)) {
        return message;
      }

      if (v.isString(pattern)) {
        pattern = new RegExp(options.pattern, options.flags);
      }
      match = pattern.exec(value);
      if (!match || match[0].length != value.length) {
        return message;
      }
    },
    inclusion: function inclusion(value, options) {
      // Empty values are fine
      if (!v.isDefined(value)) {
        return;
      }
      if (v.isArray(options)) {
        options = { within: options };
      }
      options = v.extend({}, this.options, options);
      if (v.contains(options.within, value)) {
        return;
      }
      var message = options.message || this.message || "^%{value} is not included in the list";
      return v.format(message, { value: value });
    },
    exclusion: function exclusion(value, options) {
      // Empty values are fine
      if (!v.isDefined(value)) {
        return;
      }
      if (v.isArray(options)) {
        options = { within: options };
      }
      options = v.extend({}, this.options, options);
      if (!v.contains(options.within, value)) {
        return;
      }
      var message = options.message || this.message || "^%{value} is restricted";
      return v.format(message, { value: value });
    },
    email: v.extend(function (value, options) {
      options = v.extend({}, this.options, options);
      var message = options.message || this.message || "is not a valid email";
      // Empty values are fine
      if (!v.isDefined(value)) {
        return;
      }
      if (!v.isString(value)) {
        return message;
      }
      if (!this.PATTERN.exec(value)) {
        return message;
      }
    }, {
      PATTERN: /^[a-z0-9\u007F-\uffff!#$%&'*+\/=?^_`{|}~-]+(?:\.[a-z0-9\u007F-\uffff!#$%&'*+\/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z]{2,}$/i
    }),
    equality: function equality(value, options, attribute, attributes) {
      if (!v.isDefined(value)) {
        return;
      }

      if (v.isString(options)) {
        options = { attribute: options };
      }
      options = v.extend({}, this.options, options);
      var message = options.message || this.message || "is not equal to %{attribute}";

      if (v.isEmpty(options.attribute) || !v.isString(options.attribute)) {
        throw new Error("The attribute must be a non empty string");
      }

      var otherValue = v.getDeepObjectValue(attributes, options.attribute),
          comparator = options.comparator || function (v1, v2) {
        return v1 === v2;
      };

      if (!comparator(value, otherValue, options, attribute, attributes)) {
        return v.format(message, { attribute: v.prettify(options.attribute) });
      }
    },

    // A URL validator that is used to validate URLs with the ability to
    // restrict schemes and some domains.
    url: function url(value, options) {
      if (!v.isDefined(value)) {
        return;
      }

      options = v.extend({}, this.options, options);

      var message = options.message || this.message || "is not a valid url",
          schemes = options.schemes || this.schemes || ['http', 'https'],
          allowLocal = options.allowLocal || this.allowLocal || false;

      if (!v.isString(value)) {
        return message;
      }

      // https://gist.github.com/dperini/729294
      var regex = "^" +
      // protocol identifier
      "(?:(?:" + schemes.join("|") + ")://)" +
      // user:pass authentication
      "(?:\\S+(?::\\S*)?@)?" + "(?:";

      var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";

      if (allowLocal) {
        tld += "?";
      } else {
        regex +=
        // IP address exclusion
        // private & local networks
        "(?!(?:10|127)(?:\\.\\d{1,3}){3})" + "(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})" + "(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})";
      }

      regex +=
      // IP address dotted notation octets
      // excludes loopback network 0.0.0.0
      // excludes reserved space >= 224.0.0.0
      // excludes network & broacast addresses
      // (first & last IP address of each class)
      "(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])" + "(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}" + "(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))" + "|" +
      // host name
      "(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)" +
      // domain name
      "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*" + tld + ")" +
      // port number
      "(?::\\d{2,5})?" +
      // resource path
      "(?:[/?#]\\S*)?" + "$";

      var PATTERN = new RegExp(regex, 'i');
      if (!PATTERN.exec(value)) {
        return message;
      }
    }
  };

  validate.formatters = {
    detailed: function detailed(errors) {
      return errors;
    },
    flat: v.flattenErrorsToArray,
    grouped: function grouped(errors) {
      var attr;

      errors = v.groupErrorsByAttribute(errors);
      for (attr in errors) {
        errors[attr] = v.flattenErrorsToArray(errors[attr]);
      }
      return errors;
    },
    constraint: function constraint(errors) {
      var attr;
      errors = v.groupErrorsByAttribute(errors);
      for (attr in errors) {
        errors[attr] = errors[attr].map(function (result) {
          return result.validator;
        }).sort();
      }
      return errors;
    }
  };

  validate.exposeModule(validate, this, exports, module, __webpack_require__(11));
}).call(undefined,  true ? /* istanbul ignore next */exports : null,  true ? /* istanbul ignore next */module : null, __webpack_require__(11));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9)(module)))

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

global.Promise = __webpack_require__(12);
var eventEmitter = __webpack_require__(5);
var request = Promise.promisify(__webpack_require__(13));
var merge = __webpack_require__(2);
var _resolveUrl = __webpack_require__(14);
var _store = __webpack_require__(15);

var normalizeArguments = __webpack_require__(4);
var normalizeResponse = __webpack_require__(7);
var validate = __webpack_require__(3);
var BrinkbitEvent = __webpack_require__(6);

var Player = __webpack_require__(16);

var Brinkbit = function () {
    function Brinkbit(config) {
        _classCallCheck(this, Brinkbit);

        validate.constructor(config, {
            base: {
                dataType: 'string'
            },
            gameId: {
                dataType: 'string',
                presence: true
            },
            parse: {
                dataType: 'function'
            },
            stayLoggedIn: {
                dataType: 'boolean'
            }
        });
        this.gameId = config.gameId;
        this.base = typeof config.base !== 'string' ? '/api' : config.base;
        this.parse = config.parse ? config.parse : JSON.parse;
        this.stayLoggedIn = config.stayLoggedIn;
        this.use(Player);
    }

    _createClass(Brinkbit, [{
        key: 'resolveUrl',
        value: function resolveUrl(uri) {
            return _resolveUrl(this.base, uri);
        }
    }, {
        key: 'store',
        value: function store(key, value) {
            _store.set(this.gameId + '_' + key, value);
        }
    }, {
        key: 'retrieve',
        value: function retrieve(key) {
            return _store.get(this.gameId + '_' + key);
        }
    }, {
        key: 'remove',
        value: function remove(key) {
            return _store.remove(this.gameId + '_' + key);
        }
    }, {
        key: 'request',
        value: function request() {
            var options = normalizeArguments.apply(undefined, arguments);
            return normalizeResponse(this._request(options), options);
        }
    }, {
        key: 'get',
        value: function get() {
            var options = normalizeArguments.apply(undefined, arguments);
            return normalizeResponse(this._get(options), options);
        }
    }, {
        key: 'put',
        value: function put() {
            var options = normalizeArguments.apply(undefined, arguments);
            return normalizeResponse(this._put(options), options);
        }
    }, {
        key: 'post',
        value: function post() {
            var options = normalizeArguments.apply(undefined, arguments);
            return normalizeResponse(this._post(options), options);
        }
    }, {
        key: 'delete',
        value: function _delete() {
            var options = normalizeArguments.apply(undefined, arguments);
            return normalizeResponse(this._delete(options), options);
        }
    }, {
        key: 'login',
        value: function login() {
            var _this = this;

            var options = normalizeArguments.apply(undefined, arguments);
            var token = void 0;
            var promise = Promise.any([validate(options, {
                email: {
                    dataType: 'string'
                },
                password: {
                    presence: true
                }
            }), validate(options, {
                username: {
                    dataType: 'string'
                },
                password: {
                    presence: true
                }
            })]).then(function () {
                var body = {
                    grant_type: 'password',
                    username: options.username || options.email,
                    password: options.password,
                    scope: 'player.basic_info:read player.basic_info:write data:read:write'
                };
                return _this._post({
                    uri: './token/',
                    body: body
                });
            }).then(function (response) {
                token = response.body.access_token;
                if (_this.stayLoggedIn) {
                    _this.store('token', token);
                }
                return _this._get('./playerinfo/', token);
            }).then(function (response) {
                var player = new _this.Player(response.body);
                player.token = token;
                if (!_this.Player.primary) {
                    _this.Player.primary = player;
                    if (_this.stayLoggedIn) {
                        _this.store('player', player.data);
                    }
                }
                _this.emit('login', new BrinkbitEvent('login', player));
                return player;
            });
            return normalizeResponse(promise, options);
        }
    }, {
        key: 'logout',
        value: function logout() {
            this.Player.primary = undefined;
            this.remove('token');
            this.remove('player');
        }
    }, {
        key: 'promote',
        value: function promote(player) {
            this.Player.primary = player;
            if (this.stayLoggedIn) {
                this.store('token', player.id);
                this.store('player', player.data);
            }
        }
    }, {
        key: 'use',
        value: function use(plugin) {
            if (Object.prototype.hasOwnProperty.call(this, plugin.name)) {
                throw new Error('Brinkbit plugin namespace conflict: two plugins are named \'' + plugin.name + '\'. Please rename one of them.');
            }
            this[plugin.name] = plugin.initialize(this);
        }

        // private promise-driven api

    }, {
        key: '_request',
        value: function _request(options) {
            var _this2 = this;

            return validate(options, {
                uri: {
                    presence: true,
                    dataType: 'string'
                }
            }).then(function () {
                options.uri = _this2.resolveUrl(options.uri);
                if (_typeof(options.body) === 'object') {
                    options.body = JSON.stringify(options.body);
                    options.json = true;
                }
                var token = options.token || _this2.retrieve('token');
                if (token && options.passToken !== false) {
                    options.headers = merge(options.headers, {
                        Authorization: 'Bearer ' + token
                    });
                }
                return request(options).then(function (response) {
                    if (typeof response.body === 'string') {
                        response.body = _this2.parse(response.body);
                    }
                    if (response.statusCode >= 400) {
                        return Promise.reject(new Error(response.body));
                    }
                    _this2.emit('response', new BrinkbitEvent('response', response));
                    return response;
                });
            });
        }
    }, {
        key: '_get',
        value: function _get() {
            var opts = merge({}, normalizeArguments.apply(undefined, arguments), {
                method: 'GET'
            });
            return this._request(opts);
        }
    }, {
        key: '_put',
        value: function _put() {
            var opts = merge({}, normalizeArguments.apply(undefined, arguments), {
                method: 'PUT',
                json: true
            });
            return this._request(opts);
        }
    }, {
        key: '_post',
        value: function _post() {
            var opts = merge({}, normalizeArguments.apply(undefined, arguments), {
                method: 'POST',
                json: true
            });
            return this._request(opts);
        }
    }, {
        key: '_delete',
        value: function _delete() {
            var opts = merge({}, normalizeArguments.apply(undefined, arguments), {
                method: 'DELETE'
            });
            return this._request(opts);
        }
    }]);

    return Brinkbit;
}();

Brinkbit.BrinkbitEvent = BrinkbitEvent;

eventEmitter(Brinkbit.prototype);

module.exports = Brinkbit;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var merge = __webpack_require__(2);
var pick = __webpack_require__(34);
var eventEmitter = __webpack_require__(5);

var validate = __webpack_require__(3);
var normalizeArguments = __webpack_require__(4);
var normalizeResponse = __webpack_require__(7);
var BrinkbitEvent = __webpack_require__(6);

var Plugin = function () {
    function Plugin(brinkbit, defaults, config) {
        _classCallCheck(this, Plugin);

        this.brinkbit = brinkbit;
        this.read = [];
        this.write = [];
        this.data = defaults || {};
        this.middleware = {};
        if (config) {
            validate.constructor(config, {
                _id: {
                    dataType: 'string'
                }
            });
            if (config._id) {
                this.id = config._id;
            }
        }
    }

    _createClass(Plugin, [{
        key: 'validate',
        value: function validate() {
            // eslint-disable-line class-methods-use-this
            return Promise.resolve();
        }
    }, {
        key: 'fetch',
        value: function fetch() {
            var _this = this;

            var options = normalizeArguments.apply(undefined, arguments);
            options.token = this.token;
            options.uri = options.uri || this.getUrl('get');
            var promise = this.validate('get', options).then(function () {
                return _this.brinkbit._get(options);
            }).then(function (response) {
                merge(_this.data, pick(response.body, _this.read));
                _this.emit('fetch', new BrinkbitEvent('fetch', response));
                return response;
            });
            return normalizeResponse(promise, options);
        }
    }, {
        key: 'save',
        value: function save() {
            var _this2 = this;

            var options = normalizeArguments.apply(undefined, arguments);
            if (options.body) {
                this.set(options.body);
            }
            options.token = this.token;
            options.body = pick(this.data, this.write);
            options.method = options.method || (this.id ? 'put' : 'post');
            options.uri = options.uri || this.getUrl(options.method);
            var opts = this.processMiddleware('save', options);
            var promise = this.validate(opts.method, opts.body).then(function () {
                return _this2.brinkbit._request(opts);
            }).then(function (response) {
                _this2.set(response.body);
                if (response.body._id) {
                    _this2.data._id = response.body._id;
                    _this2.id = response.body._id;
                }
                _this2.emit('save', new BrinkbitEvent('save', response));
                return response;
            });
            return normalizeResponse(promise, options);
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            var _this3 = this;

            return this.validate('delete').then(function () {
                return _this3.brinkbit._delete(_this3.getUrl('delete'));
            }).then(function (response) {
                _this3.id = undefined;
                _this3.data.id = undefined;
                return response;
            });
        }
    }, {
        key: 'get',
        value: function get(attr) {
            return typeof attr === 'string' ? this.data[attr] : pick(this.data, attr);
        }
    }, {
        key: 'set',
        value: function set(attr, value) {
            if ((typeof attr === 'undefined' ? 'undefined' : _typeof(attr)) === 'object') {
                merge(this.data, pick(attr, this.write));
            } else if (this.write.includes(attr)) {
                this.data[attr] = value;
            }
        }
    }, {
        key: 'processMiddleware',
        value: function processMiddleware(method, opts) {
            return _typeof(this.middleware) === 'object' && typeof this.middleware[method] === 'function' ? this.middleware[method](opts) : opts;
        }
    }], [{
        key: 'create',
        value: function create() {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            var instance = new (Function.prototype.bind.apply(this, [null].concat(args)))();
            return instance.save().then(function () {
                return instance;
            });
        }
    }]);

    return Plugin;
}();

eventEmitter(Plugin.prototype);

module.exports = Plugin;

/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCA4NTZlOGNjNWE5NWMxNjI4ZTg4MiIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL34vc3RvcmUvc3JjL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gubWVyZ2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZhbGlkYXRlL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy92YWxpZGF0ZS9ub3JtYWxpemVBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ldmVudC1lbWl0dGVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9ldmVudHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZhbGlkYXRlL25vcm1hbGl6ZVJlc3BvbnNlLmpzIiwid2VicGFjazovLy8uL34vcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZhbGlkYXRlL3ZhbGlkYXRpb25FcnJvci5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vYW1kLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JsdWViaXJkL2pzL2Jyb3dzZXIvYmx1ZWJpcmQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9icm93c2VyLXJlcXVlc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZXNvbHZlLXVybC9yZXNvbHZlLXVybC5qcyIsIndlYnBhY2s6Ly8vLi9+L3N0b3JlL2Rpc3Qvc3RvcmUubGVnYWN5LmpzIiwid2VicGFjazovLy8uL3NyYy9wbGF5ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jdXN0b20tZXJyb3ItaW5zdGFuY2UvYmluL2Vycm9yLmpzIiwid2VicGFjazovLy8uL34vY3VzdG9tLWVycm9yLWluc3RhbmNlL2Jpbi9mYWN0b3JpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jdXN0b20tZXJyb3ItaW5zdGFuY2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9kL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvYXNzaWduL2lzLWltcGxlbWVudGVkLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvYXNzaWduL3NoaW0uanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L29iamVjdC9pcy1jYWxsYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1leHQvb2JqZWN0L2tleXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L29iamVjdC9rZXlzL2lzLWltcGxlbWVudGVkLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3Qva2V5cy9zaGltLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3Qvbm9ybWFsaXplLW9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L29iamVjdC92YWxpZC1jYWxsYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1leHQvb2JqZWN0L3ZhbGlkLXZhbHVlLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9zdHJpbmcvIy9jb250YWlucy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1leHQvc3RyaW5nLyMvY29udGFpbnMvaXMtaW1wbGVtZW50ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L3N0cmluZy8jL2NvbnRhaW5zL3NoaW0uanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gucGljay9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zdG9yZS9wbHVnaW5zL2pzb24yLmpzIiwid2VicGFjazovLy8uL34vc3RvcmUvcGx1Z2lucy9saWIvanNvbjIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zdG9yZS9zcmMvc3RvcmUtZW5naW5lLmpzIiwid2VicGFjazovLy8uL34vc3RvcmUvc3RvcmFnZXMvYWxsLmpzIiwid2VicGFjazovLy8uL34vc3RvcmUvc3RvcmFnZXMvY29va2llU3RvcmFnZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3N0b3JlL3N0b3JhZ2VzL2xvY2FsU3RvcmFnZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3N0b3JlL3N0b3JhZ2VzL21lbW9yeVN0b3JhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zdG9yZS9zdG9yYWdlcy9vbGRGRi1nbG9iYWxTdG9yYWdlLmpzIiwid2VicGFjazovLy8uL34vc3RvcmUvc3RvcmFnZXMvb2xkSUUtdXNlckRhdGFTdG9yYWdlLmpzIiwid2VicGFjazovLy8uL34vc3RvcmUvc3RvcmFnZXMvc2Vzc2lvblN0b3JhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovLy8uL34vdmFsaWRhdGUuanMvdmFsaWRhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9wbHVnaW4vaW5kZXguanMiXSwibmFtZXMiOlsiZyIsIkZ1bmN0aW9uIiwiZXZhbCIsImUiLCJ3aW5kb3ciLCJtb2R1bGUiLCJleHBvcnRzIiwiYXNzaWduIiwibWFrZV9hc3NpZ24iLCJjcmVhdGUiLCJtYWtlX2NyZWF0ZSIsInRyaW0iLCJtYWtlX3RyaW0iLCJHbG9iYWwiLCJnbG9iYWwiLCJiaW5kIiwic2xpY2UiLCJlYWNoIiwibWFwIiwicGx1Y2siLCJpc0xpc3QiLCJpc0Z1bmN0aW9uIiwiaXNPYmplY3QiLCJPYmplY3QiLCJzaGltQXNzaWduIiwib2JqIiwicHJvcHMxIiwicHJvcHMyIiwiZXRjIiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInZhbCIsImtleSIsImFzc2lnblByb3BzMSIsImFzc2lnblByb3BzMiIsImFzc2lnbkFyZ3NMaXN0IiwiYXBwbHkiLCJjb25jYXQiLCJGIiwicHJvdG90eXBlIiwiU3RyaW5nIiwic3RyIiwiY2FsbCIsInJlcGxhY2UiLCJmbiIsIkFycmF5IiwiYXJyIiwiaW5kZXgiLCJyZXMiLCJ2IiwiayIsImhhc093blByb3BlcnR5IiwidG9TdHJpbmciLCJMQVJHRV9BUlJBWV9TSVpFIiwiSEFTSF9VTkRFRklORUQiLCJNQVhfU0FGRV9JTlRFR0VSIiwiYXJnc1RhZyIsImFycmF5VGFnIiwiYm9vbFRhZyIsImRhdGVUYWciLCJlcnJvclRhZyIsImZ1bmNUYWciLCJnZW5UYWciLCJtYXBUYWciLCJudW1iZXJUYWciLCJvYmplY3RUYWciLCJwcm9taXNlVGFnIiwicmVnZXhwVGFnIiwic2V0VGFnIiwic3RyaW5nVGFnIiwic3ltYm9sVGFnIiwid2Vha01hcFRhZyIsImFycmF5QnVmZmVyVGFnIiwiZGF0YVZpZXdUYWciLCJmbG9hdDMyVGFnIiwiZmxvYXQ2NFRhZyIsImludDhUYWciLCJpbnQxNlRhZyIsImludDMyVGFnIiwidWludDhUYWciLCJ1aW50OENsYW1wZWRUYWciLCJ1aW50MTZUYWciLCJ1aW50MzJUYWciLCJyZVJlZ0V4cENoYXIiLCJyZUZsYWdzIiwicmVJc0hvc3RDdG9yIiwicmVJc1VpbnQiLCJ0eXBlZEFycmF5VGFncyIsImNsb25lYWJsZVRhZ3MiLCJmcmVlR2xvYmFsIiwiZnJlZVNlbGYiLCJzZWxmIiwicm9vdCIsImZyZWVFeHBvcnRzIiwibm9kZVR5cGUiLCJmcmVlTW9kdWxlIiwibW9kdWxlRXhwb3J0cyIsImZyZWVQcm9jZXNzIiwicHJvY2VzcyIsIm5vZGVVdGlsIiwiYmluZGluZyIsIm5vZGVJc1R5cGVkQXJyYXkiLCJpc1R5cGVkQXJyYXkiLCJhZGRNYXBFbnRyeSIsInBhaXIiLCJzZXQiLCJhZGRTZXRFbnRyeSIsInZhbHVlIiwiYWRkIiwiZnVuYyIsInRoaXNBcmciLCJhcmdzIiwiYXJyYXlFYWNoIiwiYXJyYXkiLCJpdGVyYXRlZSIsImFycmF5UHVzaCIsInZhbHVlcyIsIm9mZnNldCIsImFycmF5UmVkdWNlIiwiYWNjdW11bGF0b3IiLCJpbml0QWNjdW0iLCJiYXNlVGltZXMiLCJuIiwicmVzdWx0IiwiYmFzZVVuYXJ5IiwiZ2V0VmFsdWUiLCJvYmplY3QiLCJ1bmRlZmluZWQiLCJpc0hvc3RPYmplY3QiLCJtYXBUb0FycmF5Iiwic2l6ZSIsImZvckVhY2giLCJvdmVyQXJnIiwidHJhbnNmb3JtIiwiYXJnIiwic2V0VG9BcnJheSIsImFycmF5UHJvdG8iLCJmdW5jUHJvdG8iLCJvYmplY3RQcm90byIsImNvcmVKc0RhdGEiLCJtYXNrU3JjS2V5IiwidWlkIiwiZXhlYyIsImtleXMiLCJJRV9QUk9UTyIsImZ1bmNUb1N0cmluZyIsIm9iamVjdEN0b3JTdHJpbmciLCJvYmplY3RUb1N0cmluZyIsInJlSXNOYXRpdmUiLCJSZWdFeHAiLCJCdWZmZXIiLCJTeW1ib2wiLCJVaW50OEFycmF5IiwiZ2V0UHJvdG90eXBlIiwiZ2V0UHJvdG90eXBlT2YiLCJvYmplY3RDcmVhdGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsInNwbGljZSIsIm5hdGl2ZUdldFN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJuYXRpdmVJc0J1ZmZlciIsImlzQnVmZmVyIiwibmF0aXZlS2V5cyIsIm5hdGl2ZU1heCIsIk1hdGgiLCJtYXgiLCJEYXRhVmlldyIsImdldE5hdGl2ZSIsIk1hcCIsIlByb21pc2UiLCJTZXQiLCJXZWFrTWFwIiwibmF0aXZlQ3JlYXRlIiwiZGF0YVZpZXdDdG9yU3RyaW5nIiwidG9Tb3VyY2UiLCJtYXBDdG9yU3RyaW5nIiwicHJvbWlzZUN0b3JTdHJpbmciLCJzZXRDdG9yU3RyaW5nIiwid2Vha01hcEN0b3JTdHJpbmciLCJzeW1ib2xQcm90byIsInN5bWJvbFZhbHVlT2YiLCJ2YWx1ZU9mIiwiSGFzaCIsImVudHJpZXMiLCJjbGVhciIsImVudHJ5IiwiaGFzaENsZWFyIiwiX19kYXRhX18iLCJoYXNoRGVsZXRlIiwiaGFzIiwiaGFzaEdldCIsImRhdGEiLCJoYXNoSGFzIiwiaGFzaFNldCIsImdldCIsIkxpc3RDYWNoZSIsImxpc3RDYWNoZUNsZWFyIiwibGlzdENhY2hlRGVsZXRlIiwiYXNzb2NJbmRleE9mIiwibGFzdEluZGV4IiwicG9wIiwibGlzdENhY2hlR2V0IiwibGlzdENhY2hlSGFzIiwibGlzdENhY2hlU2V0IiwicHVzaCIsIk1hcENhY2hlIiwibWFwQ2FjaGVDbGVhciIsIm1hcENhY2hlRGVsZXRlIiwiZ2V0TWFwRGF0YSIsIm1hcENhY2hlR2V0IiwibWFwQ2FjaGVIYXMiLCJtYXBDYWNoZVNldCIsIlN0YWNrIiwic3RhY2tDbGVhciIsInN0YWNrRGVsZXRlIiwic3RhY2tHZXQiLCJzdGFja0hhcyIsInN0YWNrU2V0IiwiY2FjaGUiLCJwYWlycyIsImFycmF5TGlrZUtleXMiLCJpbmhlcml0ZWQiLCJpc0FycmF5IiwiaXNBcmd1bWVudHMiLCJza2lwSW5kZXhlcyIsImlzSW5kZXgiLCJhc3NpZ25NZXJnZVZhbHVlIiwiZXEiLCJhc3NpZ25WYWx1ZSIsIm9ialZhbHVlIiwiYmFzZUFzc2lnbiIsInNvdXJjZSIsImNvcHlPYmplY3QiLCJiYXNlQ2xvbmUiLCJpc0RlZXAiLCJpc0Z1bGwiLCJjdXN0b21pemVyIiwic3RhY2siLCJpc0FyciIsImluaXRDbG9uZUFycmF5IiwiY29weUFycmF5IiwidGFnIiwiZ2V0VGFnIiwiaXNGdW5jIiwiY2xvbmVCdWZmZXIiLCJpbml0Q2xvbmVPYmplY3QiLCJjb3B5U3ltYm9scyIsImluaXRDbG9uZUJ5VGFnIiwic3RhY2tlZCIsInByb3BzIiwiZ2V0QWxsS2V5cyIsInN1YlZhbHVlIiwiYmFzZUNyZWF0ZSIsInByb3RvIiwiYmFzZUdldEFsbEtleXMiLCJrZXlzRnVuYyIsInN5bWJvbHNGdW5jIiwiYmFzZUdldFRhZyIsImJhc2VJc05hdGl2ZSIsImlzTWFza2VkIiwicGF0dGVybiIsInRlc3QiLCJiYXNlSXNUeXBlZEFycmF5IiwiaXNPYmplY3RMaWtlIiwiaXNMZW5ndGgiLCJiYXNlS2V5cyIsImlzUHJvdG90eXBlIiwiYmFzZUtleXNJbiIsIm5hdGl2ZUtleXNJbiIsImlzUHJvdG8iLCJiYXNlTWVyZ2UiLCJzcmNJbmRleCIsInNyY1ZhbHVlIiwiYmFzZU1lcmdlRGVlcCIsIm5ld1ZhbHVlIiwibWVyZ2VGdW5jIiwiaXNDb21tb24iLCJpc0FycmF5TGlrZU9iamVjdCIsImlzUGxhaW5PYmplY3QiLCJ0b1BsYWluT2JqZWN0IiwiYmFzZVJlc3QiLCJzdGFydCIsIm90aGVyQXJncyIsImJ1ZmZlciIsImNvbnN0cnVjdG9yIiwiY29weSIsImNsb25lQXJyYXlCdWZmZXIiLCJhcnJheUJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJjbG9uZURhdGFWaWV3IiwiZGF0YVZpZXciLCJieXRlT2Zmc2V0IiwiY2xvbmVNYXAiLCJjbG9uZUZ1bmMiLCJjbG9uZVJlZ0V4cCIsInJlZ2V4cCIsImNsb25lU2V0IiwiY2xvbmVTeW1ib2wiLCJzeW1ib2wiLCJjbG9uZVR5cGVkQXJyYXkiLCJ0eXBlZEFycmF5IiwiZ2V0U3ltYm9scyIsImNyZWF0ZUFzc2lnbmVyIiwiYXNzaWduZXIiLCJzb3VyY2VzIiwiZ3VhcmQiLCJpc0l0ZXJhdGVlQ2FsbCIsImlzS2V5YWJsZSIsInN0dWJBcnJheSIsIkFycmF5QnVmZmVyIiwicmVzb2x2ZSIsIkN0b3IiLCJjdG9yU3RyaW5nIiwiaW5wdXQiLCJ0eXBlIiwiaXNBcnJheUxpa2UiLCJvdGhlciIsInN0dWJGYWxzZSIsImtleXNJbiIsIm1lcmdlIiwidmFsaWRhdGVKcyIsInJlcXVpcmUiLCJ2YWxpZGF0b3JzIiwiZGF0YVR5cGUiLCJ2YWxpZGF0ZURhdGFUeXBlIiwib3B0aW9ucyIsImNhcGl0YWxpemUiLCJWYWxpZGF0aW9uRXJyb3IiLCJ2YWxpZGF0ZSIsImF0dHJpYnV0ZXMiLCJjb25zdHJhaW50cyIsImludmFsaWQiLCJyZWplY3QiLCJtZXNzYWdlIiwiZXJyb3IiLCJkZXRhaWxzIiwidmFsaWRhdGVDb25zdHJ1Y3RvciIsImNvbmZpZyIsIlR5cGVFcnJvciIsIm5vcm1hbGl6ZUFyZ3VtZW50cyIsInRva2VuIiwidXJpIiwiY2FsbGJhY2siLCJkIiwiY2FsbGFibGUiLCJkZWZpbmVQcm9wZXJ0eSIsImRlZmluZVByb3BlcnRpZXMiLCJkZXNjcmlwdG9yIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwib24iLCJvbmNlIiwib2ZmIiwiZW1pdCIsIm1ldGhvZHMiLCJkZXNjcmlwdG9ycyIsImJhc2UiLCJsaXN0ZW5lciIsIl9fZWVfXyIsIl9fZWVPbmNlTGlzdGVuZXJfXyIsImxpc3RlbmVycyIsImNhbmRpZGF0ZSIsImwiLCJvIiwiQnJpbmtiaXRFdmVudCIsImV2ZW50VHlwZSIsInJlc3BvbnNlIiwibm9ybWFsaXplUmVzcG9uc2UiLCJwcm9taXNlIiwidGhlbiIsInN1Y2Nlc3MiLCJjYXRjaCIsImNhY2hlZFNldFRpbWVvdXQiLCJjYWNoZWRDbGVhclRpbWVvdXQiLCJkZWZhdWx0U2V0VGltb3V0IiwiRXJyb3IiLCJkZWZhdWx0Q2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsInJ1blRpbWVvdXQiLCJmdW4iLCJydW5DbGVhclRpbWVvdXQiLCJtYXJrZXIiLCJxdWV1ZSIsImRyYWluaW5nIiwiY3VycmVudFF1ZXVlIiwicXVldWVJbmRleCIsImNsZWFuVXBOZXh0VGljayIsImRyYWluUXVldWUiLCJ0aW1lb3V0IiwibGVuIiwicnVuIiwibmV4dFRpY2siLCJJdGVtIiwidGl0bGUiLCJicm93c2VyIiwiZW52IiwiYXJndiIsInZlcnNpb24iLCJ2ZXJzaW9ucyIsIm5vb3AiLCJhZGRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsIm5hbWUiLCJjd2QiLCJjaGRpciIsImRpciIsInVtYXNrIiwid2VicGFja1BvbHlmaWxsIiwiZGVwcmVjYXRlIiwicGF0aHMiLCJjaGlsZHJlbiIsImN1c3RvbUVycm9yIiwiZiIsImRlZmluZSIsInQiLCJyIiwicyIsInUiLCJhIiwiX2RlcmVxXyIsImNvZGUiLCJTb21lUHJvbWlzZUFycmF5IiwiX1NvbWVQcm9taXNlQXJyYXkiLCJhbnkiLCJwcm9taXNlcyIsInJldCIsInNldEhvd01hbnkiLCJzZXRVbndyYXAiLCJpbml0IiwiZmlyc3RMaW5lRXJyb3IiLCJzY2hlZHVsZSIsIlF1ZXVlIiwidXRpbCIsIkFzeW5jIiwiX2N1c3RvbVNjaGVkdWxlciIsIl9pc1RpY2tVc2VkIiwiX2xhdGVRdWV1ZSIsIl9ub3JtYWxRdWV1ZSIsIl9oYXZlRHJhaW5lZFF1ZXVlcyIsIl90cmFtcG9saW5lRW5hYmxlZCIsImRyYWluUXVldWVzIiwiX2RyYWluUXVldWVzIiwiX3NjaGVkdWxlIiwic2V0U2NoZWR1bGVyIiwicHJldiIsImhhc0N1c3RvbVNjaGVkdWxlciIsImVuYWJsZVRyYW1wb2xpbmUiLCJkaXNhYmxlVHJhbXBvbGluZUlmTmVjZXNzYXJ5IiwiaGFzRGV2VG9vbHMiLCJoYXZlSXRlbXNRdWV1ZWQiLCJmYXRhbEVycm9yIiwiaXNOb2RlIiwic3RkZXJyIiwid3JpdGUiLCJleGl0IiwidGhyb3dMYXRlciIsIkFzeW5jSW52b2tlTGF0ZXIiLCJyZWNlaXZlciIsIl9xdWV1ZVRpY2siLCJBc3luY0ludm9rZSIsIkFzeW5jU2V0dGxlUHJvbWlzZXMiLCJfcHVzaE9uZSIsImludm9rZUxhdGVyIiwiaW52b2tlIiwic2V0dGxlUHJvbWlzZXMiLCJfc2V0dGxlUHJvbWlzZXMiLCJfZHJhaW5RdWV1ZSIsInNoaWZ0IiwiX3Jlc2V0IiwiSU5URVJOQUwiLCJ0cnlDb252ZXJ0VG9Qcm9taXNlIiwiZGVidWciLCJjYWxsZWRCaW5kIiwicmVqZWN0VGhpcyIsIl8iLCJfcmVqZWN0IiwidGFyZ2V0UmVqZWN0ZWQiLCJjb250ZXh0IiwicHJvbWlzZVJlamVjdGlvblF1ZXVlZCIsImJpbmRpbmdQcm9taXNlIiwiX3RoZW4iLCJiaW5kaW5nUmVzb2x2ZWQiLCJfYml0RmllbGQiLCJfcmVzb2x2ZUNhbGxiYWNrIiwidGFyZ2V0IiwiYmluZGluZ1JlamVjdGVkIiwiX3Byb3BhZ2F0ZUZyb20iLCJwcm9wYWdhdGVGcm9tRnVuY3Rpb24iLCJfYm91bmRWYWx1ZSIsImJvdW5kVmFsdWVGdW5jdGlvbiIsIm1heWJlUHJvbWlzZSIsIl90YXJnZXQiLCJfc2V0Qm91bmRUbyIsIl9zZXRPbkNhbmNlbCIsIl9ib3VuZFRvIiwiX2lzQm91bmQiLCJvbGQiLCJub0NvbmZsaWN0IiwiYmx1ZWJpcmQiLCJjciIsImNhbGxlckNhY2hlIiwiZ2V0dGVyQ2FjaGUiLCJjYW5FdmFsdWF0ZSIsImlzSWRlbnRpZmllciIsImdldE1ldGhvZENhbGxlciIsImdldEdldHRlciIsIm1ha2VNZXRob2RDYWxsZXIiLCJtZXRob2ROYW1lIiwiZW5zdXJlTWV0aG9kIiwibWFrZUdldHRlciIsInByb3BlcnR5TmFtZSIsImdldENvbXBpbGVkIiwiY29tcGlsZXIiLCJjbGFzc1N0cmluZyIsImNhbGxlciIsIm1heWJlQ2FsbGVyIiwibmFtZWRHZXR0ZXIiLCJpbmRleGVkR2V0dGVyIiwiZ2V0dGVyIiwibWF5YmVHZXR0ZXIiLCJQcm9taXNlQXJyYXkiLCJhcGlSZWplY3Rpb24iLCJ0cnlDYXRjaCIsImVycm9yT2JqIiwiYXN5bmMiLCJfYXN5bmMiLCJjYW5jZWwiLCJjYW5jZWxsYXRpb24iLCJfd2FybiIsImNoaWxkIiwiX2lzQ2FuY2VsbGFibGUiLCJfY2FuY2VsQnkiLCJfaXNGb2xsb3dpbmciLCJfZm9sbG93ZWUiLCJfY2FuY2VsQnJhbmNoZWQiLCJwYXJlbnQiLCJfY2FuY2VsbGF0aW9uUGFyZW50IiwiX3NldFdpbGxCZUNhbmNlbGxlZCIsIl9icmFuY2hIYXNDYW5jZWxsZWQiLCJfYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbCIsIl9lbm91Z2hCcmFuY2hlc0hhdmVDYW5jZWxsZWQiLCJjYW5jZWxsZXIiLCJfaW52b2tlT25DYW5jZWwiLCJfY2FuY2VsIiwiX3NldENhbmNlbGxlZCIsIl9jYW5jZWxQcm9taXNlcyIsIl9sZW5ndGgiLCJfdW5zZXRPbkNhbmNlbCIsIl9vbkNhbmNlbEZpZWxkIiwiaXNQZW5kaW5nIiwiX2lzQ2FuY2VsbGVkIiwiaXNDYW5jZWxsYWJsZSIsImlzQ2FuY2VsbGVkIiwiX2RvSW52b2tlT25DYW5jZWwiLCJvbkNhbmNlbENhbGxiYWNrIiwiaW50ZXJuYWxPbmx5IiwiX2F0dGFjaEV4dHJhVHJhY2UiLCJfcmVzdWx0Q2FuY2VsbGVkIiwiX29uQ2FuY2VsIiwiX2ludm9rZUludGVybmFsT25DYW5jZWwiLCJORVhUX0ZJTFRFUiIsImdldEtleXMiLCJjYXRjaEZpbHRlciIsImluc3RhbmNlcyIsImNiIiwiYm91bmRUbyIsInByZWRpY2F0ZUxvb3AiLCJpdGVtIiwibWF0Y2hlc1ByZWRpY2F0ZSIsImoiLCJsb25nU3RhY2tUcmFjZXMiLCJjb250ZXh0U3RhY2siLCJfcHJvbWlzZUNyZWF0ZWQiLCJfcHVzaENvbnRleHQiLCJfcG9wQ29udGV4dCIsIl9wZWVrQ29udGV4dCIsIkNvbnRleHQiLCJfdHJhY2UiLCJDYXB0dXJlZFRyYWNlIiwicGVla0NvbnRleHQiLCJ0cmFjZSIsImNyZWF0ZUNvbnRleHQiLCJkZWFjdGl2YXRlTG9uZ1N0YWNrVHJhY2VzIiwiYWN0aXZhdGVMb25nU3RhY2tUcmFjZXMiLCJQcm9taXNlX3B1c2hDb250ZXh0IiwiUHJvbWlzZV9wb3BDb250ZXh0IiwiUHJvbWlzZV9QZWVrQ29udGV4dCIsIlByb21pc2VfcGVla0NvbnRleHQiLCJQcm9taXNlX3Byb21pc2VDcmVhdGVkIiwiY3R4IiwiZ2V0RG9tYWluIiwiX2dldERvbWFpbiIsIldhcm5pbmciLCJjYW5BdHRhY2hUcmFjZSIsInVuaGFuZGxlZFJlamVjdGlvbkhhbmRsZWQiLCJwb3NzaWJseVVuaGFuZGxlZFJlamVjdGlvbiIsImJsdWViaXJkRnJhbWVQYXR0ZXJuIiwibm9kZUZyYW1lUGF0dGVybiIsInBhcnNlTGluZVBhdHRlcm4iLCJzdGFja0ZyYW1lUGF0dGVybiIsImZvcm1hdFN0YWNrIiwiaW5kZW50U3RhY2tGcmFtZXMiLCJwcmludFdhcm5pbmciLCJkZWJ1Z2dpbmciLCJ3YXJuaW5ncyIsIndGb3Jnb3R0ZW5SZXR1cm4iLCJzdXBwcmVzc1VuaGFuZGxlZFJlamVjdGlvbnMiLCJfZW5zdXJlUG9zc2libGVSZWplY3Rpb25IYW5kbGVkIiwiX3NldFJlamVjdGlvbklzVW5oYW5kbGVkIiwiX25vdGlmeVVuaGFuZGxlZFJlamVjdGlvbiIsIl9ub3RpZnlVbmhhbmRsZWRSZWplY3Rpb25Jc0hhbmRsZWQiLCJmaXJlUmVqZWN0aW9uRXZlbnQiLCJfc2V0UmV0dXJuZWROb25VbmRlZmluZWQiLCJfcmV0dXJuZWROb25VbmRlZmluZWQiLCJfaXNSZWplY3Rpb25VbmhhbmRsZWQiLCJyZWFzb24iLCJfc2V0dGxlZFZhbHVlIiwiX3NldFVuaGFuZGxlZFJlamVjdGlvbklzTm90aWZpZWQiLCJfdW5zZXRVbmhhbmRsZWRSZWplY3Rpb25Jc05vdGlmaWVkIiwiX2lzVW5oYW5kbGVkUmVqZWN0aW9uTm90aWZpZWQiLCJfdW5zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCIsInNob3VsZFVzZU93blRyYWNlIiwid2FybiIsIm9uUG9zc2libHlVbmhhbmRsZWRSZWplY3Rpb24iLCJkb21haW4iLCJkb21haW5CaW5kIiwib25VbmhhbmRsZWRSZWplY3Rpb25IYW5kbGVkIiwiZGlzYWJsZUxvbmdTdGFja1RyYWNlcyIsImxvbmdTdGFja1RyYWNlc0lzU3VwcG9ydGVkIiwiUHJvbWlzZV9jYXB0dXJlU3RhY2tUcmFjZSIsIl9jYXB0dXJlU3RhY2tUcmFjZSIsIlByb21pc2VfYXR0YWNoRXh0cmFUcmFjZSIsImxvbmdTdGFja1RyYWNlc0NhcHR1cmVTdGFja1RyYWNlIiwibG9uZ1N0YWNrVHJhY2VzQXR0YWNoRXh0cmFUcmFjZSIsImhhc0xvbmdTdGFja1RyYWNlcyIsImZpcmVEb21FdmVudCIsIkN1c3RvbUV2ZW50IiwiZXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwiZG9tRXZlbnQiLCJ0b0xvd2VyQ2FzZSIsImRldGFpbCIsImNhbmNlbGFibGUiLCJFdmVudCIsImRvY3VtZW50IiwiY3JlYXRlRXZlbnQiLCJpbml0Q3VzdG9tRXZlbnQiLCJmaXJlR2xvYmFsRXZlbnQiLCJtZXRob2QiLCJnZW5lcmF0ZVByb21pc2VMaWZlY3ljbGVFdmVudE9iamVjdCIsImV2ZW50VG9PYmplY3RHZW5lcmF0b3IiLCJwcm9taXNlQ3JlYXRlZCIsInByb21pc2VGdWxmaWxsZWQiLCJwcm9taXNlUmVqZWN0ZWQiLCJwcm9taXNlUmVzb2x2ZWQiLCJwcm9taXNlQ2FuY2VsbGVkIiwicHJvbWlzZUNoYWluZWQiLCJ3YXJuaW5nIiwidW5oYW5kbGVkUmVqZWN0aW9uIiwicmVqZWN0aW9uSGFuZGxlZCIsImFjdGl2ZUZpcmVFdmVudCIsImdsb2JhbEV2ZW50RmlyZWQiLCJkb21FdmVudEZpcmVkIiwib3B0cyIsIndhcm5pbmdzT3B0aW9uIiwiX2NsZWFyQ2FuY2VsbGF0aW9uRGF0YSIsImNhbmNlbGxhdGlvbkNsZWFyQ2FuY2VsbGF0aW9uRGF0YSIsImNhbmNlbGxhdGlvblByb3BhZ2F0ZUZyb20iLCJjYW5jZWxsYXRpb25PbkNhbmNlbCIsImNhbmNlbGxhdGlvblNldE9uQ2FuY2VsIiwiX2F0dGFjaENhbmNlbGxhdGlvbkNhbGxiYWNrIiwiY2FuY2VsbGF0aW9uQXR0YWNoQ2FuY2VsbGF0aW9uQ2FsbGJhY2siLCJfZXhlY3V0ZSIsImNhbmNlbGxhdGlvbkV4ZWN1dGUiLCJtb25pdG9yaW5nIiwiX2ZpcmVFdmVudCIsImRlZmF1bHRGaXJlRXZlbnQiLCJleGVjdXRvciIsImhhbmRsZXIiLCJvbkNhbmNlbCIsImZsYWdzIiwicHJldmlvdXNPbkNhbmNlbCIsImJyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWwiLCJiaW5kaW5nUHJvcGFnYXRlRnJvbSIsImlzRnVsZmlsbGVkIiwiaWdub3JlU2VsZiIsIl9wYXJlbnQiLCJhdHRhY2hFeHRyYVRyYWNlIiwiX19zdGFja0NsZWFuZWRfXyIsInBhcnNlZCIsInBhcnNlU3RhY2tBbmRNZXNzYWdlIiwibm90RW51bWVyYWJsZVByb3AiLCJqb2luIiwiY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zIiwicmV0dXJuVmFsdWUiLCJoYW5kbGVyTGluZSIsImNyZWF0b3JMaW5lIiwidHJhY2VMaW5lcyIsInNwbGl0IiwiY2xlYW5TdGFjayIsImxpbmUiLCJsaW5lTWF0Y2hlcyIsIm1hdGNoIiwiZmlyc3RVc2VyTGluZSIsIm1zZyIsImRlcHJlY2F0ZWQiLCJyZXBsYWNlbWVudCIsImZvcm1hdEFuZExvZ0Vycm9yIiwicmVjb25zdHJ1Y3RTdGFjayIsInN0YWNrcyIsInJlbW92ZUR1cGxpY2F0ZU9yRW1wdHlKdW1wcyIsInJlbW92ZUNvbW1vblJvb3RzIiwiY3VycmVudCIsImN1cnJlbnRMYXN0SW5kZXgiLCJjdXJyZW50TGFzdExpbmUiLCJjb21tb25Sb290TWVldFBvaW50IiwiaXNUcmFjZUxpbmUiLCJpc0ludGVybmFsRnJhbWUiLCJzaG91bGRJZ25vcmUiLCJjaGFyQXQiLCJzdGFja0ZyYW1lc0FzQXJyYXkiLCJpc1NvZnQiLCJjb25zb2xlIiwibG9nIiwibG9jYWxIYW5kbGVyIiwibG9jYWxFdmVudEZpcmVkIiwiZm9ybWF0Tm9uRXJyb3IiLCJydXNlbGVzc1RvU3RyaW5nIiwibmV3U3RyIiwiSlNPTiIsInN0cmluZ2lmeSIsInNuaXAiLCJtYXhDaGFycyIsInN1YnN0ciIsImNhcHR1cmVTdGFja1RyYWNlIiwicGFyc2VMaW5lSW5mb1JlZ2V4IiwicGFyc2VMaW5lSW5mbyIsIm1hdGNoZXMiLCJmaWxlTmFtZSIsInBhcnNlSW50Iiwic2V0Qm91bmRzIiwibGFzdExpbmVFcnJvciIsImZpcnN0U3RhY2tMaW5lcyIsImxhc3RTdGFja0xpbmVzIiwiZmlyc3RJbmRleCIsImZpcnN0RmlsZU5hbWUiLCJsYXN0RmlsZU5hbWUiLCJpbmZvIiwiX3Byb21pc2VzQ3JlYXRlZCIsInVuY3ljbGUiLCJpbmhlcml0cyIsIm5vZGVzIiwic3RhY2tUb0luZGV4Iiwibm9kZSIsImN1cnJlbnRTdGFjayIsImN5Y2xlRWRnZU5vZGUiLCJjdXJyZW50Q2hpbGRMZW5ndGgiLCJzdGFja0RldGVjdGlvbiIsInY4c3RhY2tGcmFtZVBhdHRlcm4iLCJ2OHN0YWNrRm9ybWF0dGVyIiwic3RhY2tUcmFjZUxpbWl0IiwiaWdub3JlVW50aWwiLCJlcnIiLCJpbmRleE9mIiwiaGFzU3RhY2tBZnRlclRocm93IiwiaXNUVFkiLCJjb2xvciIsInJldHVybmVyIiwidGhyb3dlciIsInRoZW5SZXR1cm4iLCJ0aGVuVGhyb3ciLCJjYXRjaFRocm93IiwiX3JlYXNvbiIsImNhdWdodCIsImNhdGNoUmV0dXJuIiwiX3ZhbHVlIiwiUHJvbWlzZVJlZHVjZSIsInJlZHVjZSIsIlByb21pc2VBbGwiLCJhbGwiLCJwcm9taXNlQWxsVGhpcyIsIlByb21pc2VNYXBTZXJpZXMiLCJtYXBTZXJpZXMiLCJlczUiLCJPYmplY3RmcmVlemUiLCJmcmVlemUiLCJzdWJFcnJvciIsIm5hbWVQcm9wZXJ0eSIsImRlZmF1bHRNZXNzYWdlIiwiU3ViRXJyb3IiLCJfVHlwZUVycm9yIiwiX1JhbmdlRXJyb3IiLCJDYW5jZWxsYXRpb25FcnJvciIsIlRpbWVvdXRFcnJvciIsIkFnZ3JlZ2F0ZUVycm9yIiwiUmFuZ2VFcnJvciIsImxldmVsIiwiaW5kZW50IiwibGluZXMiLCJPcGVyYXRpb25hbEVycm9yIiwiY2F1c2UiLCJlcnJvclR5cGVzIiwiUmVqZWN0aW9uRXJyb3IiLCJpc0VTNSIsImdldERlc2NyaXB0b3IiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJuYW1lcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJwcm9wZXJ0eUlzV3JpdGFibGUiLCJwcm9wIiwiT2JqZWN0S2V5cyIsIk9iamVjdEdldERlc2NyaXB0b3IiLCJPYmplY3REZWZpbmVQcm9wZXJ0eSIsImRlc2MiLCJPYmplY3RGcmVlemUiLCJPYmplY3RHZXRQcm90b3R5cGVPZiIsIkFycmF5SXNBcnJheSIsIlByb21pc2VNYXAiLCJmaWx0ZXIiLCJQYXNzVGhyb3VnaEhhbmRsZXJDb250ZXh0IiwiY2FsbGVkIiwiY2FuY2VsUHJvbWlzZSIsImlzRmluYWxseUhhbmRsZXIiLCJGaW5hbGx5SGFuZGxlckNhbmNlbFJlYWN0aW9uIiwiZmluYWxseUhhbmRsZXIiLCJjaGVja0NhbmNlbCIsInN1Y2NlZWQiLCJmYWlsIiwicmVhc29uT3JWYWx1ZSIsImlzUmVqZWN0ZWQiLCJfcGFzc1Rocm91Z2giLCJsYXN0bHkiLCJ0YXAiLCJ0YXBDYXRjaCIsImhhbmRsZXJPclByZWRpY2F0ZSIsImNhdGNoSW5zdGFuY2VzIiwiUHJveHlhYmxlIiwiZXJyb3JzIiwieWllbGRIYW5kbGVycyIsInByb21pc2VGcm9tWWllbGRIYW5kbGVyIiwidHJhY2VQYXJlbnQiLCJQcm9taXNlU3Bhd24iLCJnZW5lcmF0b3JGdW5jdGlvbiIsInlpZWxkSGFuZGxlciIsImludGVybmFsIiwiX2ZpbmFsbHlQcm9taXNlIiwiX3Byb21pc2UiLCJfc3RhY2siLCJfZ2VuZXJhdG9yRnVuY3Rpb24iLCJfcmVjZWl2ZXIiLCJfZ2VuZXJhdG9yIiwiX3lpZWxkSGFuZGxlcnMiLCJfeWllbGRlZFByb21pc2UiLCJfY2FuY2VsbGF0aW9uUGhhc2UiLCJfaXNSZXNvbHZlZCIsIl9jbGVhbnVwIiwiX2Z1bGZpbGwiLCJfcHJvbWlzZUNhbmNlbGxlZCIsImltcGxlbWVudHNSZXR1cm4iLCJjb3JvdXRpbmUiLCJyZXR1cm5TZW50aW5lbCIsIl9jb250aW51ZSIsIl9wcm9taXNlRnVsZmlsbGVkIiwibmV4dCIsIl9wcm9taXNlUmVqZWN0ZWQiLCJfcnVuIiwiX3JlamVjdENhbGxiYWNrIiwiZG9uZSIsImJpdEZpZWxkIiwiX3Byb3h5IiwiUHJvbWlzZVNwYXduJCIsImdlbmVyYXRvciIsInNwYXduIiwiYWRkWWllbGRIYW5kbGVyIiwidGhlbkNhbGxiYWNrIiwicHJvbWlzZVNldHRlciIsImdlbmVyYXRlSG9sZGVyQ2xhc3MiLCJ0b3RhbCIsImFzc2lnbm1lbnQiLCJjYW5jZWxsYXRpb25Db2RlIiwicGFzc2VkQXJndW1lbnRzIiwiaG9sZGVyQ2xhc3NlcyIsInRoZW5DYWxsYmFja3MiLCJwcm9taXNlU2V0dGVycyIsImxhc3QiLCJIb2xkZXJDbGFzcyIsImhvbGRlciIsImNhbGxiYWNrcyIsImFzeW5jTmVlZGVkIiwiX2lzRmF0ZVNlYWxlZCIsIl9zZXRBc3luY0d1YXJhbnRlZWQiLCJzcHJlYWQiLCJNYXBwaW5nUHJvbWlzZUFycmF5IiwibGltaXQiLCJfZmlsdGVyIiwiY29uc3RydWN0b3IkIiwiX2NhbGxiYWNrIiwiX3ByZXNlcnZlZFZhbHVlcyIsIl9saW1pdCIsIl9pbkZsaWdodCIsIl9xdWV1ZSIsIl9hc3luY0luaXQiLCJfaW5pdCQiLCJfaW5pdCIsIl92YWx1ZXMiLCJwcmVzZXJ2ZWRWYWx1ZXMiLCJ0b3RhbFJlc29sdmVkIiwiX3RvdGFsUmVzb2x2ZWQiLCJfcmVzb2x2ZSIsImJvb2xlYW5zIiwiY29uY3VycmVuY3kiLCJpc0Zpbml0ZSIsIl9yZXNvbHZlRnJvbVN5bmNWYWx1ZSIsImF0dGVtcHQiLCJtYXliZVdyYXBBc0Vycm9yIiwiaXNVbnR5cGVkRXJyb3IiLCJyRXJyb3JLZXkiLCJ3cmFwQXNPcGVyYXRpb25hbEVycm9yIiwibWFya0FzT3JpZ2luYXRpbmdGcm9tUmVqZWN0aW9uIiwibm9kZWJhY2tGb3JQcm9taXNlIiwibXVsdGlBcmdzIiwid3JhcHBlZCIsInNwcmVhZEFkYXB0ZXIiLCJub2RlYmFjayIsInN1Y2Nlc3NBZGFwdGVyIiwiZXJyb3JBZGFwdGVyIiwibmV3UmVhc29uIiwiYXNDYWxsYmFjayIsIm5vZGVpZnkiLCJhZGFwdGVyIiwibWFrZVNlbGZSZXNvbHV0aW9uRXJyb3IiLCJyZWZsZWN0SGFuZGxlciIsIlByb21pc2VJbnNwZWN0aW9uIiwiVU5ERUZJTkVEX0JJTkRJTkciLCJBUFBMWSIsImNoZWNrIiwiX2Z1bGZpbGxtZW50SGFuZGxlcjAiLCJfcmVqZWN0aW9uSGFuZGxlcjAiLCJfcHJvbWlzZTAiLCJfcmVjZWl2ZXIwIiwiX3Jlc29sdmVGcm9tRXhlY3V0b3IiLCJyZWZsZWN0IiwiZGlkRnVsZmlsbCIsImRpZFJlamVjdCIsIl9zZXRJc0ZpbmFsIiwidG9KU09OIiwiZnVsZmlsbG1lbnRWYWx1ZSIsInJlamVjdGlvblJlYXNvbiIsIm9yaWdpbmF0ZXNGcm9tUmVqZWN0aW9uIiwiZ2V0TmV3TGlicmFyeUNvcHkiLCJpcyIsImZyb21Ob2RlIiwiZnJvbUNhbGxiYWNrIiwiY2FzdCIsIl9zZXRGdWxmaWxsZWQiLCJmdWxmaWxsZWQiLCJyZWplY3RlZCIsImludGVybmFsRGF0YSIsImhhdmVJbnRlcm5hbERhdGEiLCJzZXR0bGVyIiwiX3NldHRsZVByb21pc2VDdHgiLCJfc2V0dGxlUHJvbWlzZUxhdGVDYW5jZWxsYXRpb25PYnNlcnZlciIsIl9hZGRDYWxsYmFja3MiLCJfc2V0TGVuZ3RoIiwiX3NldFJlamVjdGVkIiwiX3NldEZvbGxvd2luZyIsIl9pc0ZpbmFsIiwiX3Vuc2V0Q2FuY2VsbGVkIiwiX3JlY2VpdmVyQXQiLCJfcHJvbWlzZUF0IiwiX2Z1bGZpbGxtZW50SGFuZGxlckF0IiwiX3JlamVjdGlvbkhhbmRsZXJBdCIsIl9taWdyYXRlQ2FsbGJhY2swIiwiZm9sbG93ZXIiLCJmdWxmaWxsIiwiX21pZ3JhdGVDYWxsYmFja0F0IiwicHJveHlhYmxlIiwic2hvdWxkQmluZCIsIl9zZXRGb2xsb3dlZSIsInN5bmNocm9ub3VzIiwiaWdub3JlTm9uRXJyb3JXYXJuaW5ncyIsImVuc3VyZUVycm9yT2JqZWN0IiwiaGFzU3RhY2siLCJfc2V0dGxlUHJvbWlzZUZyb21IYW5kbGVyIiwieCIsIl9zZXR0bGVQcm9taXNlIiwiaXNQcm9taXNlIiwiYXN5bmNHdWFyYW50ZWVkIiwiX3NldHRsZVByb21pc2UwIiwiX2NsZWFyQ2FsbGJhY2tEYXRhQXRJbmRleCIsIl9mdWxmaWxsUHJvbWlzZXMiLCJfcmVqZWN0UHJvbWlzZXMiLCJkZWZlclJlc29sdmUiLCJkZWZlclJlamVjdCIsImRlZmVyIiwicGVuZGluZyIsInRvRmFzdFByb3BlcnRpZXMiLCJmaWxsVHlwZXMiLCJwIiwiYiIsImMiLCJ0b1Jlc29sdXRpb25WYWx1ZSIsInJlc29sdmVWYWx1ZUlmRW1wdHkiLCJhc0FycmF5IiwiX3Jlc29sdmVFbXB0eUFycmF5IiwiX2l0ZXJhdGUiLCJnZXRBY3R1YWxMZW5ndGgiLCJzaG91bGRDb3B5VmFsdWVzIiwiaXNSZXNvbHZlZCIsIlRISVMiLCJ3aXRoQXBwZW5kZWQiLCJkZWZhdWx0U3VmZml4IiwiZGVmYXVsdFByb21pc2lmaWVkIiwiX19pc1Byb21pc2lmaWVkX18iLCJub0NvcHlQcm9wcyIsIm5vQ29weVByb3BzUGF0dGVybiIsImRlZmF1bHRGaWx0ZXIiLCJwcm9wc0ZpbHRlciIsImlzUHJvbWlzaWZpZWQiLCJoYXNQcm9taXNpZmllZCIsInN1ZmZpeCIsImdldERhdGFQcm9wZXJ0eU9yRGVmYXVsdCIsImNoZWNrVmFsaWQiLCJzdWZmaXhSZWdleHAiLCJrZXlXaXRob3V0QXN5bmNTdWZmaXgiLCJwcm9taXNpZmlhYmxlTWV0aG9kcyIsImluaGVyaXRlZERhdGFLZXlzIiwicGFzc2VzRGVmYXVsdEZpbHRlciIsImVzY2FwZUlkZW50UmVnZXgiLCJtYWtlTm9kZVByb21pc2lmaWVkRXZhbCIsInN3aXRjaENhc2VBcmd1bWVudE9yZGVyIiwibGlrZWx5QXJndW1lbnRDb3VudCIsIm1pbiIsImFyZ3VtZW50U2VxdWVuY2UiLCJhcmd1bWVudENvdW50IiwiZmlsbGVkUmFuZ2UiLCJwYXJhbWV0ZXJEZWNsYXJhdGlvbiIsInBhcmFtZXRlckNvdW50Iiwib3JpZ2luYWxOYW1lIiwibmV3UGFyYW1ldGVyQ291bnQiLCJhcmd1bWVudE9yZGVyIiwic2hvdWxkUHJveHlUaGlzIiwiZ2VuZXJhdGVDYWxsRm9yQXJndW1lbnRDb3VudCIsImNvdW50IiwiY29tbWEiLCJnZW5lcmF0ZUFyZ3VtZW50U3dpdGNoQ2FzZSIsImdldEZ1bmN0aW9uQ29kZSIsImJvZHkiLCJtYWtlTm9kZVByb21pc2lmaWVkQ2xvc3VyZSIsIl9fIiwiZGVmYXVsdFRoaXMiLCJwcm9taXNpZmllZCIsIm1ha2VOb2RlUHJvbWlzaWZpZWQiLCJwcm9taXNpZnlBbGwiLCJwcm9taXNpZmllciIsInByb21pc2lmaWVkS2V5IiwicHJvbWlzaWZ5IiwiY29weURlc2NyaXB0b3JzIiwiaXNDbGFzcyIsIkVzNk1hcCIsIm1hcFRvRW50cmllcyIsImV4dHJhY3RFbnRyeSIsImVudHJpZXNUb01hcCIsIlByb3BlcnRpZXNQcm9taXNlQXJyYXkiLCJpc01hcCIsIl9pc01hcCIsImtleU9mZnNldCIsImNhc3RWYWx1ZSIsImFycmF5TW92ZSIsInNyYyIsImRzdCIsImRzdEluZGV4IiwiY2FwYWNpdHkiLCJfY2FwYWNpdHkiLCJfZnJvbnQiLCJfd2lsbEJlT3ZlckNhcGFjaXR5IiwiX2NoZWNrQ2FwYWNpdHkiLCJ3cmFwTWFzayIsImZyb250IiwiX3Jlc2l6ZVRvIiwib2xkQ2FwYWNpdHkiLCJtb3ZlSXRlbXNDb3VudCIsInJhY2VMYXRlciIsInJhY2UiLCJSZWR1Y3Rpb25Qcm9taXNlQXJyYXkiLCJpbml0aWFsVmFsdWUiLCJfZWFjaCIsIl9mbiIsIl9pbml0aWFsVmFsdWUiLCJfY3VycmVudENhbmNlbGxhYmxlIiwiX2VhY2hWYWx1ZXMiLCJfZ290QWNjdW0iLCJhY2N1bSIsIl9lYWNoQ29tcGxldGUiLCJzZW5kZXIiLCJfcmVzdWx0Q2FuY2VsbGVkJCIsImdvdEFjY3VtIiwiY29tcGxldGVkIiwidmFsdWVPclJlYXNvbiIsImdvdFZhbHVlIiwibm9Bc3luY1NjaGVkdWxlciIsIk5hdGl2ZVByb21pc2UiLCJnZXROYXRpdmVQcm9taXNlIiwiTXV0YXRpb25PYnNlcnZlciIsIkdsb2JhbFNldEltbWVkaWF0ZSIsInNldEltbWVkaWF0ZSIsIlByb2Nlc3NOZXh0VGljayIsImlzUmVjZW50Tm9kZSIsIm5hdGl2ZVByb21pc2UiLCJuYXZpZ2F0b3IiLCJzdGFuZGFsb25lIiwiY29yZG92YSIsImRpdiIsImNyZWF0ZUVsZW1lbnQiLCJ0b2dnbGVTY2hlZHVsZWQiLCJkaXYyIiwibzIiLCJjbGFzc0xpc3QiLCJ0b2dnbGUiLCJvYnNlcnZlIiwic2NoZWR1bGVUb2dnbGUiLCJkaXNjb25uZWN0IiwiU2V0dGxlZFByb21pc2VBcnJheSIsIl9wcm9taXNlUmVzb2x2ZWQiLCJpbnNwZWN0aW9uIiwiX3NldHRsZWRWYWx1ZUZpZWxkIiwic2V0dGxlIiwiQ0FOQ0VMTEFUSU9OIiwiX2hvd01hbnkiLCJfdW53cmFwIiwiX2luaXRpYWxpemVkIiwiaXNBcnJheVJlc29sdmVkIiwiX2NhblBvc3NpYmx5RnVsZmlsbCIsIl9nZXRSYW5nZUVycm9yIiwiaG93TWFueSIsIl9hZGRGdWxmaWxsZWQiLCJfZnVsZmlsbGVkIiwiX2FkZFJlamVjdGVkIiwiX2NoZWNrT3V0Y29tZSIsIl9yZWplY3RlZCIsInNvbWUiLCJfX2lzQ2FuY2VsbGVkIiwiZ2V0VGhlbiIsImlzQW55Qmx1ZWJpcmRQcm9taXNlIiwiZG9UaGVuYWJsZSIsImRvR2V0VGhlbiIsImhhc1Byb3AiLCJIYW5kbGVXcmFwcGVyIiwiaGFuZGxlIiwiYWZ0ZXJWYWx1ZSIsImRlbGF5IiwibXMiLCJhZnRlclRpbWVvdXQiLCJzdWNjZXNzQ2xlYXIiLCJmYWlsdXJlQ2xlYXIiLCJoYW5kbGVXcmFwcGVyIiwidGltZW91dFRpbWVvdXQiLCJOVUxMIiwiY2FzdFByZXNlcnZpbmdEaXNwb3NhYmxlIiwidGhlbmFibGUiLCJfaXNEaXNwb3NhYmxlIiwiX2dldERpc3Bvc2VyIiwiX3NldERpc3Bvc2FibGUiLCJkaXNwb3NlIiwicmVzb3VyY2VzIiwiaXRlcmF0b3IiLCJ0cnlEaXNwb3NlIiwiRGlzcG9zZXIiLCJfZGF0YSIsIl9jb250ZXh0IiwicmVzb3VyY2UiLCJkb0Rpc3Bvc2UiLCJfdW5zZXREaXNwb3NhYmxlIiwiaXNEaXNwb3NlciIsIkZ1bmN0aW9uRGlzcG9zZXIiLCJtYXliZVVud3JhcERpc3Bvc2VyIiwiUmVzb3VyY2VMaXN0IiwidXNpbmciLCJzcHJlYWRBcmdzIiwiZGlzcG9zZXIiLCJyZWZsZWN0ZWRSZXNvdXJjZXMiLCJyZXN1bHRQcm9taXNlIiwiaW5zcGVjdGlvbnMiLCJfZGlzcG9zZXIiLCJ0cnlDYXRjaFRhcmdldCIsImdsb2JhbE9iamVjdCIsInRyeUNhdGNoZXIiLCJDaGlsZCIsIlBhcmVudCIsIlQiLCJpc1ByaW1pdGl2ZSIsIm1heWJlRXJyb3IiLCJzYWZlVG9TdHJpbmciLCJhcHBlbmRlZSIsImRlZmF1bHRWYWx1ZSIsImV4Y2x1ZGVkUHJvdG90eXBlcyIsImlzRXhjbHVkZWRQcm90byIsInZpc2l0ZWRLZXlzIiwiZW51bWVyYXRpb24iLCJ0aGlzQXNzaWdubWVudFBhdHRlcm4iLCJoYXNNZXRob2RzIiwiaGFzTWV0aG9kc090aGVyVGhhbkNvbnN0cnVjdG9yIiwiaGFzVGhpc0Fzc2lnbm1lbnRBbmRTdGF0aWNNZXRob2RzIiwiRmFrZUNvbnN0cnVjdG9yIiwicmlkZW50IiwicHJlZml4IiwiaXNFcnJvciIsImlnbm9yZSIsImZyb20iLCJ0byIsIkFycmF5RnJvbSIsIml0IiwiaXRSZXN1bHQiLCJoYXNFbnZWYXJpYWJsZXMiLCJjaHJvbWUiLCJsb2FkVGltZXMiLCJOdW1iZXIiLCJQIiwiZmFjdG9yeSIsInJldHVybkV4cG9ydHMiLCJYSFIiLCJYTUxIdHRwUmVxdWVzdCIsInJlcXVlc3QiLCJERUZBVUxUX1RJTUVPVVQiLCJvcHRpb25zX29uUmVzcG9uc2UiLCJvblJlc3BvbnNlIiwicGFyc2UiLCJ2ZXJib3NlIiwiZ2V0TG9nZ2VyIiwidXJsIiwidW5zdXBwb3J0ZWRfb3B0aW9ucyIsImhlYWRlcnMiLCJob3N0IiwianNvbiIsImFjY2VwdCIsInNlcmlhbGl6ZSIsImVuY29kZVVSSUNvbXBvbmVudCIsInFzIiwibXVsdGlwYXJ0IiwiYm91bmRyeSIsImZsb29yIiwicmFuZG9tIiwiZm9ybSIsImVuY29kaW5nIiwibXVsdGkiLCJhdXRob3JpemF0aW9uIiwiYXV0aCIsImI2NF9lbmMiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwicnVuX3hociIsInJlcV9zZXEiLCJ4aHIiLCJ0aW1lZF9vdXQiLCJpc19jb3JzIiwiaXNfY3Jvc3NEb21haW4iLCJzdXBwb3J0c19jb3JzIiwic2VxX2lkIiwiaWQiLCJfaWQiLCJjb3JzX2VyciIsImNvcnMiLCJ0aW1lb3V0VGltZXIiLCJ0b29fbGF0ZSIsImVyIiwiZHVyYXRpb24iLCJkaWQiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJvbl9zdGF0ZV9jaGFuZ2UiLCJvcGVuIiwid2l0aENyZWRlbnRpYWxzIiwic2VuZCIsInJlYWR5U3RhdGUiLCJPUEVORUQiLCJzZXRSZXF1ZXN0SGVhZGVyIiwiSEVBREVSU19SRUNFSVZFRCIsIm9uX3Jlc3BvbnNlIiwiTE9BRElORyIsIm9uX2xvYWRpbmciLCJET05FIiwib25fZW5kIiwic3RhdHVzIiwic3RhdHVzQ29kZSIsImxvYWRpbmciLCJlbmQiLCJyZXNwb25zZVRleHQiLCJkZWZhdWx0cyIsInJlcXVlc3RlciIsImRlZiIsInBhcmFtcyIsImRlIiwicG9zdCIsInB1dCIsImhlYWQiLCJzaG9ydGN1dHMiLCJzaG9ydGN1dCIsInRvVXBwZXJDYXNlIiwiY291Y2giLCJjb3VjaF9oYW5kbGVyIiwicmVzcCIsImxvZ2dlciIsImxldmVscyIsImZvcm1hdHRlZCIsImZvcm1hdHRlZF9sb2dnZXIiLCJydXJsIiwiYWpheExvY2F0aW9uIiwibG9jYXRpb24iLCJocmVmIiwiYWpheExvY1BhcnRzIiwicGFydHMiLCJiNjQiLCJvMSIsIm8zIiwiaDEiLCJoMiIsImgzIiwiaDQiLCJiaXRzIiwiYWMiLCJlbmMiLCJ0bXBfYXJyIiwiY2hhckNvZGVBdCIsInJlc29sdmVVcmwiLCJudW1VcmxzIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJpbnNlcnRCZWZvcmUiLCJmaXJzdENoaWxkIiwicmVzb2x2ZWQiLCJyZW1vdmVDaGlsZCIsImVuZ2luZSIsInN0b3JhZ2VzIiwicGx1Z2lucyIsImNyZWF0ZVN0b3JlIiwiUGx1Z2luIiwiaW5pdGlhbGl6ZSIsImJyaW5rYml0IiwiUGxheWVyIiwicmVhZCIsImVtYWlsIiwibWlkZGxld2FyZSIsInNhdmUiLCJzYXZlTWlkZGxld2FyZSIsImxvZ2luIiwidXNlciIsImlzUHJpbWFyeSIsImxvZ291dCIsInByb21vdGVQbGF5ZXIiLCJwYXNzVG9rZW4iLCJwcmVzZW5jZSIsIkN1c3RvbUVycm9yIiwiRXJyIiwib3JkZXIiLCJwcm9wZXJ0aWVzIiwiY29uc3RydWN0IiwiaXNSb290IiwiZmluZEFyZyIsImlzUGFyZW50QXJnIiwiaXNQcm9wZXJ0aWVzQXJnIiwiaXNGYWN0b3J5QXJnIiwiaXNOYW1lQXJnIiwiY29uZmlndXJhdGlvbiIsIl90aGlzIiwiYXIiLCJmYWN0b3JpZXMiLCJjaGFpbiIsInJldmVyc2UiLCJ1bnNoaWZ0IiwiYW50aUZpbHRlcnMiLCJhbnRpIiwiZm91bmQiLCJleHBlY3RSZWNlaXZlIiwiZXhwZWN0ZWQiLCJyZWNlaXZlZCIsInN0YWNrTGVuZ3RoIiwicm9vdE9ubHkiLCJtZXNzYWdlU3RyIiwib3JpZ2luYWxTdGFja0xlbmd0aCIsInVwZGF0ZVN0YWNrIiwiaXNOYU4iLCJub3JtYWxpemVPcHRzIiwiaXNDYWxsYWJsZSIsImNvbnRhaW5zIiwiZHNjciIsInciLCJncyIsImZvbyIsImJhciIsInRyenkiLCJkZXN0Iiwic2VhcmNoU3RyaW5nIiwiSU5GSU5JVFkiLCJhcnJheU1hcCIsInNwcmVhZGFibGVTeW1ib2wiLCJpc0NvbmNhdFNwcmVhZGFibGUiLCJiYXNlRmxhdHRlbiIsImRlcHRoIiwicHJlZGljYXRlIiwiaXNTdHJpY3QiLCJpc0ZsYXR0ZW5hYmxlIiwiYmFzZVBpY2siLCJiYXNlUGlja0J5IiwidG9LZXkiLCJpc1N5bWJvbCIsInBpY2siLCJuZXh0SGFuZGxlIiwidGFza3NCeUhhbmRsZSIsImN1cnJlbnRseVJ1bm5pbmdBVGFzayIsImRvYyIsInJlZ2lzdGVySW1tZWRpYXRlIiwidGFzayIsImNsZWFySW1tZWRpYXRlIiwicnVuSWZQcmVzZW50IiwiaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24iLCJjYW5Vc2VQb3N0TWVzc2FnZSIsInBvc3RNZXNzYWdlIiwiaW1wb3J0U2NyaXB0cyIsInBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMiLCJvbGRPbk1lc3NhZ2UiLCJvbm1lc3NhZ2UiLCJpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbiIsIm1lc3NhZ2VQcmVmaXgiLCJvbkdsb2JhbE1lc3NhZ2UiLCJhZGRFdmVudExpc3RlbmVyIiwiYXR0YWNoRXZlbnQiLCJpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbiIsImNoYW5uZWwiLCJNZXNzYWdlQ2hhbm5lbCIsInBvcnQxIiwicG9ydDIiLCJpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uIiwiaHRtbCIsImRvY3VtZW50RWxlbWVudCIsInNjcmlwdCIsImFwcGVuZENoaWxkIiwiaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbiIsImF0dGFjaFRvIiwianNvbjJQbHVnaW4iLCJyeF9vbmUiLCJyeF90d28iLCJyeF90aHJlZSIsInJ4X2ZvdXIiLCJyeF9lc2NhcGFibGUiLCJyeF9kYW5nZXJvdXMiLCJ0aGlzX3ZhbHVlIiwiRGF0ZSIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENEYXRlIiwiZ2V0VVRDSG91cnMiLCJnZXRVVENNaW51dGVzIiwiZ2V0VVRDU2Vjb25kcyIsIkJvb2xlYW4iLCJnYXAiLCJtZXRhIiwicmVwIiwicXVvdGUiLCJzdHJpbmciLCJtaW5kIiwicGFydGlhbCIsInJlcGxhY2VyIiwic3BhY2UiLCJ0ZXh0IiwicmV2aXZlciIsIndhbGsiLCJTeW50YXhFcnJvciIsInN0b3JlQVBJIiwiZW5hYmxlZCIsIm9wdGlvbmFsRGVmYXVsdFZhbHVlIiwic3RvcmFnZSIsIl9uYW1lc3BhY2VQcmVmaXgiLCJfZGVzZXJpYWxpemUiLCJyZW1vdmUiLCJfc2VyaWFsaXplIiwibmFtZXNwYWNlZEtleSIsIl9uYW1lc3BhY2VSZWdleHAiLCJjbGVhckFsbCIsImhhc05hbWVzcGFjZSIsIm5hbWVzcGFjZSIsImFkZFBsdWdpbiIsInBsdWdpbiIsIl9hZGRQbHVnaW4iLCJfY29uc29sZSIsIm5hbWVzcGFjZVByZWZpeCIsIm5hbWVzcGFjZVJlZ2V4cCIsImxlZ2FsTmFtZXNwYWNlcyIsIl9wcml2YXRlU3RvcmVQcm9wcyIsIl90ZXN0U3RvcmFnZSIsInRlc3RTdHIiLCJvayIsIl9hc3NpZ25QbHVnaW5GblByb3AiLCJwbHVnaW5GblByb3AiLCJwcm9wTmFtZSIsIm9sZEZuIiwicGx1Z2luRm4iLCJzdXBlcl9mbiIsIm5ld0ZuQXJncyIsInN0clZhbCIsImRlZmF1bHRWYWwiLCJfYWRkU3RvcmFnZSIsInNlZW5QbHVnaW4iLCJwbHVnaW5Qcm9wZXJ0aWVzIiwiYWRkU3RvcmFnZSIsInN0b3JlIiwicmF3IiwiX2hhcyIsInJlZ2V4cFN0ciIsImVzY2FwZSIsInVuZXNjYXBlIiwiY29va2llIiwiY29va2llcyIsImt2cCIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsIm1lbW9yeVN0b3JhZ2UiLCJnbG9iYWxTdG9yYWdlIiwic3RvcmFnZU5hbWUiLCJfd2l0aFN0b3JhZ2VFbCIsIl9tYWtlSUVTdG9yYWdlRWxGdW5jdGlvbiIsImRpc2FibGUiLCJ1c2VyQWdlbnQiLCJ1bmZpeGVkS2V5IiwiZml4ZWRLZXkiLCJmaXhLZXkiLCJzdG9yYWdlRWwiLCJzZXRBdHRyaWJ1dGUiLCJnZXRBdHRyaWJ1dGUiLCJYTUxEb2N1bWVudCIsImF0dHIiLCJyZW1vdmVBdHRyaWJ1dGUiLCJsb2FkIiwiZm9yYmlkZGVuQ2hhcnNSZWdleCIsImFkZEJlaGF2aW9yIiwic2NyaXB0VGFnIiwic3RvcmFnZU93bmVyIiwic3RvcmFnZUNvbnRhaW5lciIsIkFjdGl2ZVhPYmplY3QiLCJjbG9zZSIsImZyYW1lcyIsInN0b3JlRnVuY3Rpb24iLCJzZXNzaW9uU3RvcmFnZSIsIlRpbWVvdXQiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJjbGVhckZuIiwiX2NsZWFyRm4iLCJ1bnJlZiIsInJlZiIsImVucm9sbCIsIm1zZWNzIiwiX2lkbGVUaW1lb3V0SWQiLCJfaWRsZVRpbWVvdXQiLCJ1bmVucm9sbCIsIl91bnJlZkFjdGl2ZSIsImFjdGl2ZSIsIm9uVGltZW91dCIsIl9vblRpbWVvdXQiLCJleHRlbmQiLCJyZXN1bHRzIiwicnVuVmFsaWRhdGlvbnMiLCJ2YWxpZGF0b3IiLCJwcm9jZXNzVmFsaWRhdGlvblJlc3VsdHMiLCJtYWpvciIsIm1pbm9yIiwicGF0Y2giLCJtZXRhZGF0YSIsImZvcm1hdCIsImlzRW1wdHkiLCJFTVBUWV9TVFJJTkdfUkVHRVhQIiwidmFsaWRhdG9yTmFtZSIsInZhbGlkYXRvck9wdGlvbnMiLCJpc0RvbUVsZW1lbnQiLCJpc0pxdWVyeUVsZW1lbnQiLCJjb2xsZWN0Rm9ybVZhbHVlcyIsImdldERlZXBPYmplY3RWYWx1ZSIsImF0dHJpYnV0ZSIsImdsb2JhbE9wdGlvbnMiLCJwcnVuZUVtcHR5RXJyb3JzIiwiZXhwYW5kTXVsdGlwbGVFcnJvcnMiLCJjb252ZXJ0RXJyb3JNZXNzYWdlcyIsImZvcm1hdHRlcnMiLCJXcmFwRXJyb3JzIiwid3JhcEVycm9ycyIsImNsZWFuQXR0cmlidXRlcyIsIndhaXRGb3JSZXN1bHRzIiwic2luZ2xlIiwiZnVsbE1lc3NhZ2VzIiwibWVtbyIsImlzTnVtYmVyIiwiaXNJbnRlZ2VyIiwiaXNCb29sZWFuIiwiaXNEYXRlIiwiaXNEZWZpbmVkIiwiaXNTdHJpbmciLCJqcXVlcnkiLCJxdWVyeVNlbGVjdG9yQWxsIiwicXVlcnlTZWxlY3RvciIsIkhUTUxFbGVtZW50Iiwibm9kZU5hbWUiLCJ2YWxzIiwiRk9STUFUX1JFR0VYUCIsIm0wIiwibTEiLCJtMiIsInByZXR0aWZ5IiwicGFyc2VGbG9hdCIsInJvdW5kIiwidG9GaXhlZCIsInN0cmluZ2lmeVZhbHVlIiwiaXNIYXNoIiwidW5pcXVlIiwiZWwiLCJmb3JFYWNoS2V5SW5LZXlwYXRoIiwia2V5cGF0aCIsImlucHV0cyIsIm9wdGlvbiIsInNhbml0aXplRm9ybVZhbHVlIiwiY2hlY2tlZCIsIm11bHRpcGxlIiwic2VsZWN0ZWQiLCJzZWxlY3RlZEluZGV4IiwibnVsbGlmeSIsImVycm9ySW5mbyIsImdyb3VwRXJyb3JzQnlBdHRyaWJ1dGUiLCJsaXN0IiwiZmxhdHRlbkVycm9yc1RvQXJyYXkiLCJ3aGl0ZWxpc3QiLCJ3aGl0ZWxpc3RDcmVhdG9yIiwiYnVpbGRPYmplY3RXaGl0ZWxpc3QiLCJvdyIsImxhc3RPYmplY3QiLCJjbGVhblJlY3Vyc2l2ZSIsImV4cG9zZU1vZHVsZSIsImFtZCIsImFsbG93RW1wdHkiLCJtYXhpbXVtIiwibWluaW11bSIsInRva2VuaXplciIsIm5vdFZhbGlkIiwid3JvbmdMZW5ndGgiLCJ0b29TaG9ydCIsInRvb0xvbmciLCJudW1lcmljYWxpdHkiLCJjaGVja3MiLCJncmVhdGVyVGhhbiIsImdyZWF0ZXJUaGFuT3JFcXVhbFRvIiwiZXF1YWxUbyIsImxlc3NUaGFuIiwibGVzc1RoYW5PckVxdWFsVG8iLCJkaXZpc2libGVCeSIsInN0cmljdCIsIm9ubHlJbnRlZ2VyIiwibm9TdHJpbmdzIiwibm90SW50ZWdlciIsIm9kZCIsIm5vdE9kZCIsImV2ZW4iLCJub3RFdmVuIiwiZGF0ZXRpbWUiLCJlYXJsaWVzdCIsIk5hTiIsImxhdGVzdCIsImRhdGVPbmx5IiwidG9vRWFybHkiLCJkYXRlIiwidG9vTGF0ZSIsImluY2x1c2lvbiIsIndpdGhpbiIsImV4Y2x1c2lvbiIsIlBBVFRFUk4iLCJlcXVhbGl0eSIsIm90aGVyVmFsdWUiLCJjb21wYXJhdG9yIiwidjEiLCJ2MiIsInNjaGVtZXMiLCJhbGxvd0xvY2FsIiwicmVnZXgiLCJ0bGQiLCJkZXRhaWxlZCIsImZsYXQiLCJncm91cGVkIiwiY29uc3RyYWludCIsInNvcnQiLCJldmVudEVtaXR0ZXIiLCJCcmlua2JpdCIsImdhbWVJZCIsInN0YXlMb2dnZWRJbiIsInVzZSIsIl9yZXF1ZXN0IiwiX2dldCIsIl9wdXQiLCJfcG9zdCIsIl9kZWxldGUiLCJncmFudF90eXBlIiwic2NvcGUiLCJhY2Nlc3NfdG9rZW4iLCJwbGF5ZXIiLCJwcmltYXJ5IiwicmV0cmlldmUiLCJBdXRob3JpemF0aW9uIiwiZ2V0VXJsIiwicHJvY2Vzc01pZGRsZXdhcmUiLCJpbmNsdWRlcyIsImluc3RhbmNlIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztBQ1ZBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtREFBMkMsY0FBYzs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNoRUEsSUFBSUEsQ0FBSjs7QUFFQTtBQUNBQSxJQUFLLFlBQVc7QUFDZixRQUFPLElBQVA7QUFDQSxDQUZHLEVBQUo7O0FBSUEsSUFBSTtBQUNIO0FBQ0FBLEtBQUlBLEtBQUtDLFNBQVMsYUFBVCxHQUFMLElBQWtDLENBQUMsR0FBRUMsSUFBSCxFQUFTLE1BQVQsQ0FBdEM7QUFDQSxDQUhELENBR0UsT0FBTUMsQ0FBTixFQUFTO0FBQ1Y7QUFDQSxLQUFHLFFBQU9DLE1BQVAseUNBQU9BLE1BQVAsT0FBa0IsUUFBckIsRUFDQ0osSUFBSUksTUFBSjtBQUNEOztBQUVEO0FBQ0E7QUFDQTs7QUFFQUMsT0FBT0MsT0FBUCxHQUFpQk4sQ0FBakIsQzs7Ozs7Ozs7O0FDcEJBLElBQUlPLFNBQVNDLGFBQWI7QUFDQSxJQUFJQyxTQUFTQyxhQUFiO0FBQ0EsSUFBSUMsT0FBT0MsV0FBWDtBQUNBLElBQUlDLFNBQVUsT0FBT1QsTUFBUCxLQUFrQixXQUFsQixHQUFnQ0EsTUFBaEMsR0FBeUNVLE1BQXZEOztBQUVBVCxPQUFPQyxPQUFQLEdBQWlCO0FBQ2hCQyxTQUFRQSxNQURRO0FBRWhCRSxTQUFRQSxNQUZRO0FBR2hCRSxPQUFNQSxJQUhVO0FBSWhCSSxPQUFNQSxJQUpVO0FBS2hCQyxRQUFPQSxLQUxTO0FBTWhCQyxPQUFNQSxJQU5VO0FBT2hCQyxNQUFLQSxHQVBXO0FBUWhCQyxRQUFPQSxLQVJTO0FBU2hCQyxTQUFRQSxNQVRRO0FBVWhCQyxhQUFZQSxVQVZJO0FBV2hCQyxXQUFVQSxRQVhNO0FBWWhCVCxTQUFRQTtBQVpRLENBQWpCOztBQWVBLFNBQVNMLFdBQVQsR0FBdUI7QUFDdEIsS0FBSWUsT0FBT2hCLE1BQVgsRUFBbUI7QUFDbEIsU0FBT2dCLE9BQU9oQixNQUFkO0FBQ0EsRUFGRCxNQUVPO0FBQ04sU0FBTyxTQUFTaUIsVUFBVCxDQUFvQkMsR0FBcEIsRUFBeUJDLE1BQXpCLEVBQWlDQyxNQUFqQyxFQUF5Q0MsR0FBekMsRUFBOEM7QUFDcEQsUUFBSyxJQUFJQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlDLFVBQVVDLE1BQTlCLEVBQXNDRixHQUF0QyxFQUEyQztBQUMxQ1osU0FBS00sT0FBT08sVUFBVUQsQ0FBVixDQUFQLENBQUwsRUFBMkIsVUFBU0csR0FBVCxFQUFjQyxHQUFkLEVBQW1CO0FBQzdDUixTQUFJUSxHQUFKLElBQVdELEdBQVg7QUFDQSxLQUZEO0FBR0E7QUFDRCxVQUFPUCxHQUFQO0FBQ0EsR0FQRDtBQVFBO0FBQ0Q7O0FBRUQsU0FBU2YsV0FBVCxHQUF1QjtBQUN0QixLQUFJYSxPQUFPZCxNQUFYLEVBQW1CO0FBQ2xCLFNBQU8sU0FBU0EsTUFBVCxDQUFnQmdCLEdBQWhCLEVBQXFCUyxZQUFyQixFQUFtQ0MsWUFBbkMsRUFBaURQLEdBQWpELEVBQXNEO0FBQzVELE9BQUlRLGlCQUFpQnBCLE1BQU1jLFNBQU4sRUFBaUIsQ0FBakIsQ0FBckI7QUFDQSxVQUFPdkIsT0FBTzhCLEtBQVAsQ0FBYSxJQUFiLEVBQW1CLENBQUNkLE9BQU9kLE1BQVAsQ0FBY2dCLEdBQWQsQ0FBRCxFQUFxQmEsTUFBckIsQ0FBNEJGLGNBQTVCLENBQW5CLENBQVA7QUFDQSxHQUhEO0FBSUEsRUFMRCxNQUtPO0FBQUEsTUFDR0csQ0FESCxHQUNOLFNBQVNBLENBQVQsR0FBYSxDQUFFLENBRFQsRUFDVTs7O0FBQ2hCLFNBQU8sU0FBUzlCLE1BQVQsQ0FBZ0JnQixHQUFoQixFQUFxQlMsWUFBckIsRUFBbUNDLFlBQW5DLEVBQWlEUCxHQUFqRCxFQUFzRDtBQUM1RCxPQUFJUSxpQkFBaUJwQixNQUFNYyxTQUFOLEVBQWlCLENBQWpCLENBQXJCO0FBQ0FTLEtBQUVDLFNBQUYsR0FBY2YsR0FBZDtBQUNBLFVBQU9sQixPQUFPOEIsS0FBUCxDQUFhLElBQWIsRUFBbUIsQ0FBQyxJQUFJRSxDQUFKLEVBQUQsRUFBVUQsTUFBVixDQUFpQkYsY0FBakIsQ0FBbkIsQ0FBUDtBQUNBLEdBSkQ7QUFLQTtBQUNEOztBQUVELFNBQVN4QixTQUFULEdBQXFCO0FBQ3BCLEtBQUk2QixPQUFPRCxTQUFQLENBQWlCN0IsSUFBckIsRUFBMkI7QUFDMUIsU0FBTyxTQUFTQSxJQUFULENBQWMrQixHQUFkLEVBQW1CO0FBQ3pCLFVBQU9ELE9BQU9ELFNBQVAsQ0FBaUI3QixJQUFqQixDQUFzQmdDLElBQXRCLENBQTJCRCxHQUEzQixDQUFQO0FBQ0EsR0FGRDtBQUdBLEVBSkQsTUFJTztBQUNOLFNBQU8sU0FBUy9CLElBQVQsQ0FBYytCLEdBQWQsRUFBbUI7QUFDekIsVUFBT0EsSUFBSUUsT0FBSixDQUFZLG9DQUFaLEVBQWtELEVBQWxELENBQVA7QUFDQSxHQUZEO0FBR0E7QUFDRDs7QUFFRCxTQUFTN0IsSUFBVCxDQUFjVSxHQUFkLEVBQW1Cb0IsRUFBbkIsRUFBdUI7QUFDdEIsUUFBTyxZQUFXO0FBQ2pCLFNBQU9BLEdBQUdSLEtBQUgsQ0FBU1osR0FBVCxFQUFjcUIsTUFBTU4sU0FBTixDQUFnQnhCLEtBQWhCLENBQXNCMkIsSUFBdEIsQ0FBMkJiLFNBQTNCLEVBQXNDLENBQXRDLENBQWQsQ0FBUDtBQUNBLEVBRkQ7QUFHQTs7QUFFRCxTQUFTZCxLQUFULENBQWUrQixHQUFmLEVBQW9CQyxLQUFwQixFQUEyQjtBQUMxQixRQUFPRixNQUFNTixTQUFOLENBQWdCeEIsS0FBaEIsQ0FBc0IyQixJQUF0QixDQUEyQkksR0FBM0IsRUFBZ0NDLFNBQVMsQ0FBekMsQ0FBUDtBQUNBOztBQUVELFNBQVMvQixJQUFULENBQWNRLEdBQWQsRUFBbUJvQixFQUFuQixFQUF1QjtBQUN0QjFCLE9BQU1NLEdBQU4sRUFBVyxVQUFTTyxHQUFULEVBQWNDLEdBQWQsRUFBbUI7QUFDN0JZLEtBQUdiLEdBQUgsRUFBUUMsR0FBUjtBQUNBLFNBQU8sS0FBUDtBQUNBLEVBSEQ7QUFJQTs7QUFFRCxTQUFTZixHQUFULENBQWFPLEdBQWIsRUFBa0JvQixFQUFsQixFQUFzQjtBQUNyQixLQUFJSSxNQUFPN0IsT0FBT0ssR0FBUCxJQUFjLEVBQWQsR0FBbUIsRUFBOUI7QUFDQU4sT0FBTU0sR0FBTixFQUFXLFVBQVN5QixDQUFULEVBQVlDLENBQVosRUFBZTtBQUN6QkYsTUFBSUUsQ0FBSixJQUFTTixHQUFHSyxDQUFILEVBQU1DLENBQU4sQ0FBVDtBQUNBLFNBQU8sS0FBUDtBQUNBLEVBSEQ7QUFJQSxRQUFPRixHQUFQO0FBQ0E7O0FBRUQsU0FBUzlCLEtBQVQsQ0FBZU0sR0FBZixFQUFvQm9CLEVBQXBCLEVBQXdCO0FBQ3ZCLEtBQUl6QixPQUFPSyxHQUFQLENBQUosRUFBaUI7QUFDaEIsT0FBSyxJQUFJSSxJQUFFLENBQVgsRUFBY0EsSUFBRUosSUFBSU0sTUFBcEIsRUFBNEJGLEdBQTVCLEVBQWlDO0FBQ2hDLE9BQUlnQixHQUFHcEIsSUFBSUksQ0FBSixDQUFILEVBQVdBLENBQVgsQ0FBSixFQUFtQjtBQUNsQixXQUFPSixJQUFJSSxDQUFKLENBQVA7QUFDQTtBQUNEO0FBQ0QsRUFORCxNQU1PO0FBQ04sT0FBSyxJQUFJSSxHQUFULElBQWdCUixHQUFoQixFQUFxQjtBQUNwQixPQUFJQSxJQUFJMkIsY0FBSixDQUFtQm5CLEdBQW5CLENBQUosRUFBNkI7QUFDNUIsUUFBSVksR0FBR3BCLElBQUlRLEdBQUosQ0FBSCxFQUFhQSxHQUFiLENBQUosRUFBdUI7QUFDdEIsWUFBT1IsSUFBSVEsR0FBSixDQUFQO0FBQ0E7QUFDRDtBQUNEO0FBQ0Q7QUFDRDs7QUFFRCxTQUFTYixNQUFULENBQWdCWSxHQUFoQixFQUFxQjtBQUNwQixRQUFRQSxPQUFPLElBQVAsSUFBZSxPQUFPQSxHQUFQLElBQWMsVUFBN0IsSUFBMkMsT0FBT0EsSUFBSUQsTUFBWCxJQUFxQixRQUF4RTtBQUNBOztBQUVELFNBQVNWLFVBQVQsQ0FBb0JXLEdBQXBCLEVBQXlCO0FBQ3hCLFFBQU9BLE9BQU8sR0FBR3FCLFFBQUgsQ0FBWVYsSUFBWixDQUFpQlgsR0FBakIsTUFBMEIsbUJBQXhDO0FBQ0E7O0FBRUQsU0FBU1YsUUFBVCxDQUFrQlUsR0FBbEIsRUFBdUI7QUFDdEIsUUFBT0EsT0FBTyxHQUFHcUIsUUFBSCxDQUFZVixJQUFaLENBQWlCWCxHQUFqQixNQUEwQixpQkFBeEM7QUFDQSxDOzs7Ozs7Ozs7Ozs7QUNySEQ7Ozs7Ozs7OztBQVNBO0FBQ0EsSUFBSXNCLG1CQUFtQixHQUF2Qjs7QUFFQTtBQUNBLElBQUlDLGlCQUFpQiwyQkFBckI7O0FBRUE7QUFDQSxJQUFJQyxtQkFBbUIsZ0JBQXZCOztBQUVBO0FBQ0EsSUFBSUMsVUFBVSxvQkFBZDtBQUFBLElBQ0lDLFdBQVcsZ0JBRGY7QUFBQSxJQUVJQyxVQUFVLGtCQUZkO0FBQUEsSUFHSUMsVUFBVSxlQUhkO0FBQUEsSUFJSUMsV0FBVyxnQkFKZjtBQUFBLElBS0lDLFVBQVUsbUJBTGQ7QUFBQSxJQU1JQyxTQUFTLDRCQU5iO0FBQUEsSUFPSUMsU0FBUyxjQVBiO0FBQUEsSUFRSUMsWUFBWSxpQkFSaEI7QUFBQSxJQVNJQyxZQUFZLGlCQVRoQjtBQUFBLElBVUlDLGFBQWEsa0JBVmpCO0FBQUEsSUFXSUMsWUFBWSxpQkFYaEI7QUFBQSxJQVlJQyxTQUFTLGNBWmI7QUFBQSxJQWFJQyxZQUFZLGlCQWJoQjtBQUFBLElBY0lDLFlBQVksaUJBZGhCO0FBQUEsSUFlSUMsYUFBYSxrQkFmakI7O0FBaUJBLElBQUlDLGlCQUFpQixzQkFBckI7QUFBQSxJQUNJQyxjQUFjLG1CQURsQjtBQUFBLElBRUlDLGFBQWEsdUJBRmpCO0FBQUEsSUFHSUMsYUFBYSx1QkFIakI7QUFBQSxJQUlJQyxVQUFVLG9CQUpkO0FBQUEsSUFLSUMsV0FBVyxxQkFMZjtBQUFBLElBTUlDLFdBQVcscUJBTmY7QUFBQSxJQU9JQyxXQUFXLHFCQVBmO0FBQUEsSUFRSUMsa0JBQWtCLDRCQVJ0QjtBQUFBLElBU0lDLFlBQVksc0JBVGhCO0FBQUEsSUFVSUMsWUFBWSxzQkFWaEI7O0FBWUE7Ozs7QUFJQSxJQUFJQyxlQUFlLHFCQUFuQjs7QUFFQTtBQUNBLElBQUlDLFVBQVUsTUFBZDs7QUFFQTtBQUNBLElBQUlDLGVBQWUsNkJBQW5COztBQUVBO0FBQ0EsSUFBSUMsV0FBVyxrQkFBZjs7QUFFQTtBQUNBLElBQUlDLGlCQUFpQixFQUFyQjtBQUNBQSxlQUFlYixVQUFmLElBQTZCYSxlQUFlWixVQUFmLElBQzdCWSxlQUFlWCxPQUFmLElBQTBCVyxlQUFlVixRQUFmLElBQzFCVSxlQUFlVCxRQUFmLElBQTJCUyxlQUFlUixRQUFmLElBQzNCUSxlQUFlUCxlQUFmLElBQWtDTyxlQUFlTixTQUFmLElBQ2xDTSxlQUFlTCxTQUFmLElBQTRCLElBSjVCO0FBS0FLLGVBQWUvQixPQUFmLElBQTBCK0IsZUFBZTlCLFFBQWYsSUFDMUI4QixlQUFlZixjQUFmLElBQWlDZSxlQUFlN0IsT0FBZixJQUNqQzZCLGVBQWVkLFdBQWYsSUFBOEJjLGVBQWU1QixPQUFmLElBQzlCNEIsZUFBZTNCLFFBQWYsSUFBMkIyQixlQUFlMUIsT0FBZixJQUMzQjBCLGVBQWV4QixNQUFmLElBQXlCd0IsZUFBZXZCLFNBQWYsSUFDekJ1QixlQUFldEIsU0FBZixJQUE0QnNCLGVBQWVwQixTQUFmLElBQzVCb0IsZUFBZW5CLE1BQWYsSUFBeUJtQixlQUFlbEIsU0FBZixJQUN6QmtCLGVBQWVoQixVQUFmLElBQTZCLEtBUDdCOztBQVNBO0FBQ0EsSUFBSWlCLGdCQUFnQixFQUFwQjtBQUNBQSxjQUFjaEMsT0FBZCxJQUF5QmdDLGNBQWMvQixRQUFkLElBQ3pCK0IsY0FBY2hCLGNBQWQsSUFBZ0NnQixjQUFjZixXQUFkLElBQ2hDZSxjQUFjOUIsT0FBZCxJQUF5QjhCLGNBQWM3QixPQUFkLElBQ3pCNkIsY0FBY2QsVUFBZCxJQUE0QmMsY0FBY2IsVUFBZCxJQUM1QmEsY0FBY1osT0FBZCxJQUF5QlksY0FBY1gsUUFBZCxJQUN6QlcsY0FBY1YsUUFBZCxJQUEwQlUsY0FBY3pCLE1BQWQsSUFDMUJ5QixjQUFjeEIsU0FBZCxJQUEyQndCLGNBQWN2QixTQUFkLElBQzNCdUIsY0FBY3JCLFNBQWQsSUFBMkJxQixjQUFjcEIsTUFBZCxJQUMzQm9CLGNBQWNuQixTQUFkLElBQTJCbUIsY0FBY2xCLFNBQWQsSUFDM0JrQixjQUFjVCxRQUFkLElBQTBCUyxjQUFjUixlQUFkLElBQzFCUSxjQUFjUCxTQUFkLElBQTJCTyxjQUFjTixTQUFkLElBQTJCLElBVnREO0FBV0FNLGNBQWM1QixRQUFkLElBQTBCNEIsY0FBYzNCLE9BQWQsSUFDMUIyQixjQUFjakIsVUFBZCxJQUE0QixLQUQ1Qjs7QUFHQTtBQUNBLElBQUlrQixhQUFhLFFBQU81RSxNQUFQLHlDQUFPQSxNQUFQLE1BQWlCLFFBQWpCLElBQTZCQSxNQUE3QixJQUF1Q0EsT0FBT1MsTUFBUCxLQUFrQkEsTUFBekQsSUFBbUVULE1BQXBGOztBQUVBO0FBQ0EsSUFBSTZFLFdBQVcsUUFBT0MsSUFBUCx5Q0FBT0EsSUFBUCxNQUFlLFFBQWYsSUFBMkJBLElBQTNCLElBQW1DQSxLQUFLckUsTUFBTCxLQUFnQkEsTUFBbkQsSUFBNkRxRSxJQUE1RTs7QUFFQTtBQUNBLElBQUlDLE9BQU9ILGNBQWNDLFFBQWQsSUFBMEIxRixTQUFTLGFBQVQsR0FBckM7O0FBRUE7QUFDQSxJQUFJNkYsY0FBYyxnQ0FBT3hGLE9BQVAsTUFBa0IsUUFBbEIsSUFBOEJBLE9BQTlCLElBQXlDLENBQUNBLFFBQVF5RixRQUFsRCxJQUE4RHpGLE9BQWhGOztBQUVBO0FBQ0EsSUFBSTBGLGFBQWFGLGVBQWUsZ0NBQU96RixNQUFQLE1BQWlCLFFBQWhDLElBQTRDQSxNQUE1QyxJQUFzRCxDQUFDQSxPQUFPMEYsUUFBOUQsSUFBMEUxRixNQUEzRjs7QUFFQTtBQUNBLElBQUk0RixnQkFBZ0JELGNBQWNBLFdBQVcxRixPQUFYLEtBQXVCd0YsV0FBekQ7O0FBRUE7QUFDQSxJQUFJSSxjQUFjRCxpQkFBaUJQLFdBQVdTLE9BQTlDOztBQUVBO0FBQ0EsSUFBSUMsV0FBWSxZQUFXO0FBQ3pCLE1BQUk7QUFDRixXQUFPRixlQUFlQSxZQUFZRyxPQUFaLENBQW9CLE1BQXBCLENBQXRCO0FBQ0QsR0FGRCxDQUVFLE9BQU9sRyxDQUFQLEVBQVUsQ0FBRTtBQUNmLENBSmUsRUFBaEI7O0FBTUE7QUFDQSxJQUFJbUcsbUJBQW1CRixZQUFZQSxTQUFTRyxZQUE1Qzs7QUFFQTs7Ozs7Ozs7QUFRQSxTQUFTQyxXQUFULENBQXFCdEYsR0FBckIsRUFBMEJ1RixJQUExQixFQUFnQztBQUM5QjtBQUNBdkYsTUFBSXdGLEdBQUosQ0FBUUQsS0FBSyxDQUFMLENBQVIsRUFBaUJBLEtBQUssQ0FBTCxDQUFqQjtBQUNBLFNBQU92RixHQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUEsU0FBU3lGLFdBQVQsQ0FBcUJELEdBQXJCLEVBQTBCRSxLQUExQixFQUFpQztBQUMvQjtBQUNBRixNQUFJRyxHQUFKLENBQVFELEtBQVI7QUFDQSxTQUFPRixHQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7QUFVQSxTQUFTckUsS0FBVCxDQUFleUUsSUFBZixFQUFxQkMsT0FBckIsRUFBOEJDLElBQTlCLEVBQW9DO0FBQ2xDLFVBQVFBLEtBQUtqRixNQUFiO0FBQ0UsU0FBSyxDQUFMO0FBQVEsYUFBTytFLEtBQUtuRSxJQUFMLENBQVVvRSxPQUFWLENBQVA7QUFDUixTQUFLLENBQUw7QUFBUSxhQUFPRCxLQUFLbkUsSUFBTCxDQUFVb0UsT0FBVixFQUFtQkMsS0FBSyxDQUFMLENBQW5CLENBQVA7QUFDUixTQUFLLENBQUw7QUFBUSxhQUFPRixLQUFLbkUsSUFBTCxDQUFVb0UsT0FBVixFQUFtQkMsS0FBSyxDQUFMLENBQW5CLEVBQTRCQSxLQUFLLENBQUwsQ0FBNUIsQ0FBUDtBQUNSLFNBQUssQ0FBTDtBQUFRLGFBQU9GLEtBQUtuRSxJQUFMLENBQVVvRSxPQUFWLEVBQW1CQyxLQUFLLENBQUwsQ0FBbkIsRUFBNEJBLEtBQUssQ0FBTCxDQUE1QixFQUFxQ0EsS0FBSyxDQUFMLENBQXJDLENBQVA7QUFKVjtBQU1BLFNBQU9GLEtBQUt6RSxLQUFMLENBQVcwRSxPQUFYLEVBQW9CQyxJQUFwQixDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztBQVNBLFNBQVNDLFNBQVQsQ0FBbUJDLEtBQW5CLEVBQTBCQyxRQUExQixFQUFvQztBQUNsQyxNQUFJbkUsUUFBUSxDQUFDLENBQWI7QUFBQSxNQUNJakIsU0FBU21GLFFBQVFBLE1BQU1uRixNQUFkLEdBQXVCLENBRHBDOztBQUdBLFNBQU8sRUFBRWlCLEtBQUYsR0FBVWpCLE1BQWpCLEVBQXlCO0FBQ3ZCLFFBQUlvRixTQUFTRCxNQUFNbEUsS0FBTixDQUFULEVBQXVCQSxLQUF2QixFQUE4QmtFLEtBQTlCLE1BQXlDLEtBQTdDLEVBQW9EO0FBQ2xEO0FBQ0Q7QUFDRjtBQUNELFNBQU9BLEtBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7QUFRQSxTQUFTRSxTQUFULENBQW1CRixLQUFuQixFQUEwQkcsTUFBMUIsRUFBa0M7QUFDaEMsTUFBSXJFLFFBQVEsQ0FBQyxDQUFiO0FBQUEsTUFDSWpCLFNBQVNzRixPQUFPdEYsTUFEcEI7QUFBQSxNQUVJdUYsU0FBU0osTUFBTW5GLE1BRm5COztBQUlBLFNBQU8sRUFBRWlCLEtBQUYsR0FBVWpCLE1BQWpCLEVBQXlCO0FBQ3ZCbUYsVUFBTUksU0FBU3RFLEtBQWYsSUFBd0JxRSxPQUFPckUsS0FBUCxDQUF4QjtBQUNEO0FBQ0QsU0FBT2tFLEtBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7O0FBWUEsU0FBU0ssV0FBVCxDQUFxQkwsS0FBckIsRUFBNEJDLFFBQTVCLEVBQXNDSyxXQUF0QyxFQUFtREMsU0FBbkQsRUFBOEQ7QUFDNUQsTUFBSXpFLFFBQVEsQ0FBQyxDQUFiO0FBQUEsTUFDSWpCLFNBQVNtRixRQUFRQSxNQUFNbkYsTUFBZCxHQUF1QixDQURwQzs7QUFHQSxNQUFJMEYsYUFBYTFGLE1BQWpCLEVBQXlCO0FBQ3ZCeUYsa0JBQWNOLE1BQU0sRUFBRWxFLEtBQVIsQ0FBZDtBQUNEO0FBQ0QsU0FBTyxFQUFFQSxLQUFGLEdBQVVqQixNQUFqQixFQUF5QjtBQUN2QnlGLGtCQUFjTCxTQUFTSyxXQUFULEVBQXNCTixNQUFNbEUsS0FBTixDQUF0QixFQUFvQ0EsS0FBcEMsRUFBMkNrRSxLQUEzQyxDQUFkO0FBQ0Q7QUFDRCxTQUFPTSxXQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztBQVNBLFNBQVNFLFNBQVQsQ0FBbUJDLENBQW5CLEVBQXNCUixRQUF0QixFQUFnQztBQUM5QixNQUFJbkUsUUFBUSxDQUFDLENBQWI7QUFBQSxNQUNJNEUsU0FBUzlFLE1BQU02RSxDQUFOLENBRGI7O0FBR0EsU0FBTyxFQUFFM0UsS0FBRixHQUFVMkUsQ0FBakIsRUFBb0I7QUFDbEJDLFdBQU81RSxLQUFQLElBQWdCbUUsU0FBU25FLEtBQVQsQ0FBaEI7QUFDRDtBQUNELFNBQU80RSxNQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQSxTQUFTQyxTQUFULENBQW1CZixJQUFuQixFQUF5QjtBQUN2QixTQUFPLFVBQVNGLEtBQVQsRUFBZ0I7QUFDckIsV0FBT0UsS0FBS0YsS0FBTCxDQUFQO0FBQ0QsR0FGRDtBQUdEOztBQUVEOzs7Ozs7OztBQVFBLFNBQVNrQixRQUFULENBQWtCQyxNQUFsQixFQUEwQjlGLEdBQTFCLEVBQStCO0FBQzdCLFNBQU84RixVQUFVLElBQVYsR0FBaUJDLFNBQWpCLEdBQTZCRCxPQUFPOUYsR0FBUCxDQUFwQztBQUNEOztBQUVEOzs7Ozs7O0FBT0EsU0FBU2dHLFlBQVQsQ0FBc0JyQixLQUF0QixFQUE2QjtBQUMzQjtBQUNBO0FBQ0EsTUFBSWdCLFNBQVMsS0FBYjtBQUNBLE1BQUloQixTQUFTLElBQVQsSUFBaUIsT0FBT0EsTUFBTXZELFFBQWIsSUFBeUIsVUFBOUMsRUFBMEQ7QUFDeEQsUUFBSTtBQUNGdUUsZUFBUyxDQUFDLEVBQUVoQixRQUFRLEVBQVYsQ0FBVjtBQUNELEtBRkQsQ0FFRSxPQUFPekcsQ0FBUCxFQUFVLENBQUU7QUFDZjtBQUNELFNBQU95SCxNQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQSxTQUFTTSxVQUFULENBQW9CaEgsR0FBcEIsRUFBeUI7QUFDdkIsTUFBSThCLFFBQVEsQ0FBQyxDQUFiO0FBQUEsTUFDSTRFLFNBQVM5RSxNQUFNNUIsSUFBSWlILElBQVYsQ0FEYjs7QUFHQWpILE1BQUlrSCxPQUFKLENBQVksVUFBU3hCLEtBQVQsRUFBZ0IzRSxHQUFoQixFQUFxQjtBQUMvQjJGLFdBQU8sRUFBRTVFLEtBQVQsSUFBa0IsQ0FBQ2YsR0FBRCxFQUFNMkUsS0FBTixDQUFsQjtBQUNELEdBRkQ7QUFHQSxTQUFPZ0IsTUFBUDtBQUNEOztBQUVEOzs7Ozs7OztBQVFBLFNBQVNTLE9BQVQsQ0FBaUJ2QixJQUFqQixFQUF1QndCLFNBQXZCLEVBQWtDO0FBQ2hDLFNBQU8sVUFBU0MsR0FBVCxFQUFjO0FBQ25CLFdBQU96QixLQUFLd0IsVUFBVUMsR0FBVixDQUFMLENBQVA7QUFDRCxHQUZEO0FBR0Q7O0FBRUQ7Ozs7Ozs7QUFPQSxTQUFTQyxVQUFULENBQW9COUIsR0FBcEIsRUFBeUI7QUFDdkIsTUFBSTFELFFBQVEsQ0FBQyxDQUFiO0FBQUEsTUFDSTRFLFNBQVM5RSxNQUFNNEQsSUFBSXlCLElBQVYsQ0FEYjs7QUFHQXpCLE1BQUkwQixPQUFKLENBQVksVUFBU3hCLEtBQVQsRUFBZ0I7QUFDMUJnQixXQUFPLEVBQUU1RSxLQUFULElBQWtCNEQsS0FBbEI7QUFDRCxHQUZEO0FBR0EsU0FBT2dCLE1BQVA7QUFDRDs7QUFFRDtBQUNBLElBQUlhLGFBQWEzRixNQUFNTixTQUF2QjtBQUFBLElBQ0lrRyxZQUFZekksU0FBU3VDLFNBRHpCO0FBQUEsSUFFSW1HLGNBQWNwSCxPQUFPaUIsU0FGekI7O0FBSUE7QUFDQSxJQUFJb0csYUFBYS9DLEtBQUssb0JBQUwsQ0FBakI7O0FBRUE7QUFDQSxJQUFJZ0QsYUFBYyxZQUFXO0FBQzNCLE1BQUlDLE1BQU0sU0FBU0MsSUFBVCxDQUFjSCxjQUFjQSxXQUFXSSxJQUF6QixJQUFpQ0osV0FBV0ksSUFBWCxDQUFnQkMsUUFBakQsSUFBNkQsRUFBM0UsQ0FBVjtBQUNBLFNBQU9ILE1BQU8sbUJBQW1CQSxHQUExQixHQUFpQyxFQUF4QztBQUNELENBSGlCLEVBQWxCOztBQUtBO0FBQ0EsSUFBSUksZUFBZVIsVUFBVXJGLFFBQTdCOztBQUVBO0FBQ0EsSUFBSUQsaUJBQWlCdUYsWUFBWXZGLGNBQWpDOztBQUVBO0FBQ0EsSUFBSStGLG1CQUFtQkQsYUFBYXZHLElBQWIsQ0FBa0JwQixNQUFsQixDQUF2Qjs7QUFFQTs7Ozs7QUFLQSxJQUFJNkgsaUJBQWlCVCxZQUFZdEYsUUFBakM7O0FBRUE7QUFDQSxJQUFJZ0csYUFBYUMsT0FBTyxNQUN0QkosYUFBYXZHLElBQWIsQ0FBa0JTLGNBQWxCLEVBQWtDUixPQUFsQyxDQUEwQ3dDLFlBQTFDLEVBQXdELE1BQXhELEVBQ0N4QyxPQURELENBQ1Msd0RBRFQsRUFDbUUsT0FEbkUsQ0FEc0IsR0FFd0QsR0FGL0QsQ0FBakI7O0FBS0E7QUFDQSxJQUFJMkcsU0FBU3RELGdCQUFnQkosS0FBSzBELE1BQXJCLEdBQThCdkIsU0FBM0M7QUFBQSxJQUNJd0IsVUFBUzNELEtBQUsyRCxNQURsQjtBQUFBLElBRUlDLGFBQWE1RCxLQUFLNEQsVUFGdEI7QUFBQSxJQUdJQyxlQUFlckIsUUFBUTlHLE9BQU9vSSxjQUFmLEVBQStCcEksTUFBL0IsQ0FIbkI7QUFBQSxJQUlJcUksZUFBZXJJLE9BQU9kLE1BSjFCO0FBQUEsSUFLSW9KLHVCQUF1QmxCLFlBQVlrQixvQkFMdkM7QUFBQSxJQU1JQyxTQUFTckIsV0FBV3FCLE1BTnhCOztBQVFBO0FBQ0EsSUFBSUMsbUJBQW1CeEksT0FBT3lJLHFCQUE5QjtBQUFBLElBQ0lDLGlCQUFpQlYsU0FBU0EsT0FBT1csUUFBaEIsR0FBMkJsQyxTQURoRDtBQUFBLElBRUltQyxhQUFhOUIsUUFBUTlHLE9BQU95SCxJQUFmLEVBQXFCekgsTUFBckIsQ0FGakI7QUFBQSxJQUdJNkksWUFBWUMsS0FBS0MsR0FIckI7O0FBS0E7QUFDQSxJQUFJQyxXQUFXQyxVQUFVM0UsSUFBVixFQUFnQixVQUFoQixDQUFmO0FBQUEsSUFDSTRFLE1BQU1ELFVBQVUzRSxJQUFWLEVBQWdCLEtBQWhCLENBRFY7QUFBQSxJQUVJNkUsVUFBVUYsVUFBVTNFLElBQVYsRUFBZ0IsU0FBaEIsQ0FGZDtBQUFBLElBR0k4RSxNQUFNSCxVQUFVM0UsSUFBVixFQUFnQixLQUFoQixDQUhWO0FBQUEsSUFJSStFLFVBQVVKLFVBQVUzRSxJQUFWLEVBQWdCLFNBQWhCLENBSmQ7QUFBQSxJQUtJZ0YsZUFBZUwsVUFBVWpKLE1BQVYsRUFBa0IsUUFBbEIsQ0FMbkI7O0FBT0E7QUFDQSxJQUFJdUoscUJBQXFCQyxTQUFTUixRQUFULENBQXpCO0FBQUEsSUFDSVMsZ0JBQWdCRCxTQUFTTixHQUFULENBRHBCO0FBQUEsSUFFSVEsb0JBQW9CRixTQUFTTCxPQUFULENBRnhCO0FBQUEsSUFHSVEsZ0JBQWdCSCxTQUFTSixHQUFULENBSHBCO0FBQUEsSUFJSVEsb0JBQW9CSixTQUFTSCxPQUFULENBSnhCOztBQU1BO0FBQ0EsSUFBSVEsY0FBYzVCLFVBQVNBLFFBQU9oSCxTQUFoQixHQUE0QndGLFNBQTlDO0FBQUEsSUFDSXFELGdCQUFnQkQsY0FBY0EsWUFBWUUsT0FBMUIsR0FBb0N0RCxTQUR4RDs7QUFHQTs7Ozs7OztBQU9BLFNBQVN1RCxJQUFULENBQWNDLE9BQWQsRUFBdUI7QUFDckIsTUFBSXhJLFFBQVEsQ0FBQyxDQUFiO0FBQUEsTUFDSWpCLFNBQVN5SixVQUFVQSxRQUFRekosTUFBbEIsR0FBMkIsQ0FEeEM7O0FBR0EsT0FBSzBKLEtBQUw7QUFDQSxTQUFPLEVBQUV6SSxLQUFGLEdBQVVqQixNQUFqQixFQUF5QjtBQUN2QixRQUFJMkosUUFBUUYsUUFBUXhJLEtBQVIsQ0FBWjtBQUNBLFNBQUswRCxHQUFMLENBQVNnRixNQUFNLENBQU4sQ0FBVCxFQUFtQkEsTUFBTSxDQUFOLENBQW5CO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7OztBQU9BLFNBQVNDLFNBQVQsR0FBcUI7QUFDbkIsT0FBS0MsUUFBTCxHQUFnQmYsZUFBZUEsYUFBYSxJQUFiLENBQWYsR0FBb0MsRUFBcEQ7QUFDRDs7QUFFRDs7Ozs7Ozs7OztBQVVBLFNBQVNnQixVQUFULENBQW9CNUosR0FBcEIsRUFBeUI7QUFDdkIsU0FBTyxLQUFLNkosR0FBTCxDQUFTN0osR0FBVCxLQUFpQixPQUFPLEtBQUsySixRQUFMLENBQWMzSixHQUFkLENBQS9CO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztBQVNBLFNBQVM4SixPQUFULENBQWlCOUosR0FBakIsRUFBc0I7QUFDcEIsTUFBSStKLE9BQU8sS0FBS0osUUFBaEI7QUFDQSxNQUFJZixZQUFKLEVBQWtCO0FBQ2hCLFFBQUlqRCxTQUFTb0UsS0FBSy9KLEdBQUwsQ0FBYjtBQUNBLFdBQU8yRixXQUFXckUsY0FBWCxHQUE0QnlFLFNBQTVCLEdBQXdDSixNQUEvQztBQUNEO0FBQ0QsU0FBT3hFLGVBQWVULElBQWYsQ0FBb0JxSixJQUFwQixFQUEwQi9KLEdBQTFCLElBQWlDK0osS0FBSy9KLEdBQUwsQ0FBakMsR0FBNkMrRixTQUFwRDtBQUNEOztBQUVEOzs7Ozs7Ozs7QUFTQSxTQUFTaUUsT0FBVCxDQUFpQmhLLEdBQWpCLEVBQXNCO0FBQ3BCLE1BQUkrSixPQUFPLEtBQUtKLFFBQWhCO0FBQ0EsU0FBT2YsZUFBZW1CLEtBQUsvSixHQUFMLE1BQWMrRixTQUE3QixHQUF5QzVFLGVBQWVULElBQWYsQ0FBb0JxSixJQUFwQixFQUEwQi9KLEdBQTFCLENBQWhEO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7QUFVQSxTQUFTaUssT0FBVCxDQUFpQmpLLEdBQWpCLEVBQXNCMkUsS0FBdEIsRUFBNkI7QUFDM0IsTUFBSW9GLE9BQU8sS0FBS0osUUFBaEI7QUFDQUksT0FBSy9KLEdBQUwsSUFBYTRJLGdCQUFnQmpFLFVBQVVvQixTQUEzQixHQUF3Q3pFLGNBQXhDLEdBQXlEcUQsS0FBckU7QUFDQSxTQUFPLElBQVA7QUFDRDs7QUFFRDtBQUNBMkUsS0FBSy9JLFNBQUwsQ0FBZWlKLEtBQWYsR0FBdUJFLFNBQXZCO0FBQ0FKLEtBQUsvSSxTQUFMLENBQWUsUUFBZixJQUEyQnFKLFVBQTNCO0FBQ0FOLEtBQUsvSSxTQUFMLENBQWUySixHQUFmLEdBQXFCSixPQUFyQjtBQUNBUixLQUFLL0ksU0FBTCxDQUFlc0osR0FBZixHQUFxQkcsT0FBckI7QUFDQVYsS0FBSy9JLFNBQUwsQ0FBZWtFLEdBQWYsR0FBcUJ3RixPQUFyQjs7QUFFQTs7Ozs7OztBQU9BLFNBQVNFLFNBQVQsQ0FBbUJaLE9BQW5CLEVBQTRCO0FBQzFCLE1BQUl4SSxRQUFRLENBQUMsQ0FBYjtBQUFBLE1BQ0lqQixTQUFTeUosVUFBVUEsUUFBUXpKLE1BQWxCLEdBQTJCLENBRHhDOztBQUdBLE9BQUswSixLQUFMO0FBQ0EsU0FBTyxFQUFFekksS0FBRixHQUFVakIsTUFBakIsRUFBeUI7QUFDdkIsUUFBSTJKLFFBQVFGLFFBQVF4SSxLQUFSLENBQVo7QUFDQSxTQUFLMEQsR0FBTCxDQUFTZ0YsTUFBTSxDQUFOLENBQVQsRUFBbUJBLE1BQU0sQ0FBTixDQUFuQjtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7QUFPQSxTQUFTVyxjQUFULEdBQTBCO0FBQ3hCLE9BQUtULFFBQUwsR0FBZ0IsRUFBaEI7QUFDRDs7QUFFRDs7Ozs7Ozs7O0FBU0EsU0FBU1UsZUFBVCxDQUF5QnJLLEdBQXpCLEVBQThCO0FBQzVCLE1BQUkrSixPQUFPLEtBQUtKLFFBQWhCO0FBQUEsTUFDSTVJLFFBQVF1SixhQUFhUCxJQUFiLEVBQW1CL0osR0FBbkIsQ0FEWjs7QUFHQSxNQUFJZSxRQUFRLENBQVosRUFBZTtBQUNiLFdBQU8sS0FBUDtBQUNEO0FBQ0QsTUFBSXdKLFlBQVlSLEtBQUtqSyxNQUFMLEdBQWMsQ0FBOUI7QUFDQSxNQUFJaUIsU0FBU3dKLFNBQWIsRUFBd0I7QUFDdEJSLFNBQUtTLEdBQUw7QUFDRCxHQUZELE1BRU87QUFDTDNDLFdBQU9uSCxJQUFQLENBQVlxSixJQUFaLEVBQWtCaEosS0FBbEIsRUFBeUIsQ0FBekI7QUFDRDtBQUNELFNBQU8sSUFBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7QUFTQSxTQUFTMEosWUFBVCxDQUFzQnpLLEdBQXRCLEVBQTJCO0FBQ3pCLE1BQUkrSixPQUFPLEtBQUtKLFFBQWhCO0FBQUEsTUFDSTVJLFFBQVF1SixhQUFhUCxJQUFiLEVBQW1CL0osR0FBbkIsQ0FEWjs7QUFHQSxTQUFPZSxRQUFRLENBQVIsR0FBWWdGLFNBQVosR0FBd0JnRSxLQUFLaEosS0FBTCxFQUFZLENBQVosQ0FBL0I7QUFDRDs7QUFFRDs7Ozs7Ozs7O0FBU0EsU0FBUzJKLFlBQVQsQ0FBc0IxSyxHQUF0QixFQUEyQjtBQUN6QixTQUFPc0ssYUFBYSxLQUFLWCxRQUFsQixFQUE0QjNKLEdBQTVCLElBQW1DLENBQUMsQ0FBM0M7QUFDRDs7QUFFRDs7Ozs7Ozs7OztBQVVBLFNBQVMySyxZQUFULENBQXNCM0ssR0FBdEIsRUFBMkIyRSxLQUEzQixFQUFrQztBQUNoQyxNQUFJb0YsT0FBTyxLQUFLSixRQUFoQjtBQUFBLE1BQ0k1SSxRQUFRdUosYUFBYVAsSUFBYixFQUFtQi9KLEdBQW5CLENBRFo7O0FBR0EsTUFBSWUsUUFBUSxDQUFaLEVBQWU7QUFDYmdKLFNBQUthLElBQUwsQ0FBVSxDQUFDNUssR0FBRCxFQUFNMkUsS0FBTixDQUFWO0FBQ0QsR0FGRCxNQUVPO0FBQ0xvRixTQUFLaEosS0FBTCxFQUFZLENBQVosSUFBaUI0RCxLQUFqQjtBQUNEO0FBQ0QsU0FBTyxJQUFQO0FBQ0Q7O0FBRUQ7QUFDQXdGLFVBQVU1SixTQUFWLENBQW9CaUosS0FBcEIsR0FBNEJZLGNBQTVCO0FBQ0FELFVBQVU1SixTQUFWLENBQW9CLFFBQXBCLElBQWdDOEosZUFBaEM7QUFDQUYsVUFBVTVKLFNBQVYsQ0FBb0IySixHQUFwQixHQUEwQk8sWUFBMUI7QUFDQU4sVUFBVTVKLFNBQVYsQ0FBb0JzSixHQUFwQixHQUEwQmEsWUFBMUI7QUFDQVAsVUFBVTVKLFNBQVYsQ0FBb0JrRSxHQUFwQixHQUEwQmtHLFlBQTFCOztBQUVBOzs7Ozs7O0FBT0EsU0FBU0UsUUFBVCxDQUFrQnRCLE9BQWxCLEVBQTJCO0FBQ3pCLE1BQUl4SSxRQUFRLENBQUMsQ0FBYjtBQUFBLE1BQ0lqQixTQUFTeUosVUFBVUEsUUFBUXpKLE1BQWxCLEdBQTJCLENBRHhDOztBQUdBLE9BQUswSixLQUFMO0FBQ0EsU0FBTyxFQUFFekksS0FBRixHQUFVakIsTUFBakIsRUFBeUI7QUFDdkIsUUFBSTJKLFFBQVFGLFFBQVF4SSxLQUFSLENBQVo7QUFDQSxTQUFLMEQsR0FBTCxDQUFTZ0YsTUFBTSxDQUFOLENBQVQsRUFBbUJBLE1BQU0sQ0FBTixDQUFuQjtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7QUFPQSxTQUFTcUIsYUFBVCxHQUF5QjtBQUN2QixPQUFLbkIsUUFBTCxHQUFnQjtBQUNkLFlBQVEsSUFBSUwsSUFBSixFQURNO0FBRWQsV0FBTyxLQUFLZCxPQUFPMkIsU0FBWixHQUZPO0FBR2QsY0FBVSxJQUFJYixJQUFKO0FBSEksR0FBaEI7QUFLRDs7QUFFRDs7Ozs7Ozs7O0FBU0EsU0FBU3lCLGNBQVQsQ0FBd0IvSyxHQUF4QixFQUE2QjtBQUMzQixTQUFPZ0wsV0FBVyxJQUFYLEVBQWlCaEwsR0FBakIsRUFBc0IsUUFBdEIsRUFBZ0NBLEdBQWhDLENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7O0FBU0EsU0FBU2lMLFdBQVQsQ0FBcUJqTCxHQUFyQixFQUEwQjtBQUN4QixTQUFPZ0wsV0FBVyxJQUFYLEVBQWlCaEwsR0FBakIsRUFBc0JrSyxHQUF0QixDQUEwQmxLLEdBQTFCLENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7O0FBU0EsU0FBU2tMLFdBQVQsQ0FBcUJsTCxHQUFyQixFQUEwQjtBQUN4QixTQUFPZ0wsV0FBVyxJQUFYLEVBQWlCaEwsR0FBakIsRUFBc0I2SixHQUF0QixDQUEwQjdKLEdBQTFCLENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7OztBQVVBLFNBQVNtTCxXQUFULENBQXFCbkwsR0FBckIsRUFBMEIyRSxLQUExQixFQUFpQztBQUMvQnFHLGFBQVcsSUFBWCxFQUFpQmhMLEdBQWpCLEVBQXNCeUUsR0FBdEIsQ0FBMEJ6RSxHQUExQixFQUErQjJFLEtBQS9CO0FBQ0EsU0FBTyxJQUFQO0FBQ0Q7O0FBRUQ7QUFDQWtHLFNBQVN0SyxTQUFULENBQW1CaUosS0FBbkIsR0FBMkJzQixhQUEzQjtBQUNBRCxTQUFTdEssU0FBVCxDQUFtQixRQUFuQixJQUErQndLLGNBQS9CO0FBQ0FGLFNBQVN0SyxTQUFULENBQW1CMkosR0FBbkIsR0FBeUJlLFdBQXpCO0FBQ0FKLFNBQVN0SyxTQUFULENBQW1Cc0osR0FBbkIsR0FBeUJxQixXQUF6QjtBQUNBTCxTQUFTdEssU0FBVCxDQUFtQmtFLEdBQW5CLEdBQXlCMEcsV0FBekI7O0FBRUE7Ozs7Ozs7QUFPQSxTQUFTQyxLQUFULENBQWU3QixPQUFmLEVBQXdCO0FBQ3RCLE9BQUtJLFFBQUwsR0FBZ0IsSUFBSVEsU0FBSixDQUFjWixPQUFkLENBQWhCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQSxTQUFTOEIsVUFBVCxHQUFzQjtBQUNwQixPQUFLMUIsUUFBTCxHQUFnQixJQUFJUSxTQUFKLEVBQWhCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztBQVNBLFNBQVNtQixXQUFULENBQXFCdEwsR0FBckIsRUFBMEI7QUFDeEIsU0FBTyxLQUFLMkosUUFBTCxDQUFjLFFBQWQsRUFBd0IzSixHQUF4QixDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztBQVNBLFNBQVN1TCxRQUFULENBQWtCdkwsR0FBbEIsRUFBdUI7QUFDckIsU0FBTyxLQUFLMkosUUFBTCxDQUFjTyxHQUFkLENBQWtCbEssR0FBbEIsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7QUFTQSxTQUFTd0wsUUFBVCxDQUFrQnhMLEdBQWxCLEVBQXVCO0FBQ3JCLFNBQU8sS0FBSzJKLFFBQUwsQ0FBY0UsR0FBZCxDQUFrQjdKLEdBQWxCLENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7OztBQVVBLFNBQVN5TCxRQUFULENBQWtCekwsR0FBbEIsRUFBdUIyRSxLQUF2QixFQUE4QjtBQUM1QixNQUFJK0csUUFBUSxLQUFLL0IsUUFBakI7QUFDQSxNQUFJK0IsaUJBQWlCdkIsU0FBckIsRUFBZ0M7QUFDOUIsUUFBSXdCLFFBQVFELE1BQU0vQixRQUFsQjtBQUNBLFFBQUksQ0FBQ25CLEdBQUQsSUFBU21ELE1BQU03TCxNQUFOLEdBQWV1QixtQkFBbUIsQ0FBL0MsRUFBbUQ7QUFDakRzSyxZQUFNZixJQUFOLENBQVcsQ0FBQzVLLEdBQUQsRUFBTTJFLEtBQU4sQ0FBWDtBQUNBLGFBQU8sSUFBUDtBQUNEO0FBQ0QrRyxZQUFRLEtBQUsvQixRQUFMLEdBQWdCLElBQUlrQixRQUFKLENBQWFjLEtBQWIsQ0FBeEI7QUFDRDtBQUNERCxRQUFNakgsR0FBTixDQUFVekUsR0FBVixFQUFlMkUsS0FBZjtBQUNBLFNBQU8sSUFBUDtBQUNEOztBQUVEO0FBQ0F5RyxNQUFNN0ssU0FBTixDQUFnQmlKLEtBQWhCLEdBQXdCNkIsVUFBeEI7QUFDQUQsTUFBTTdLLFNBQU4sQ0FBZ0IsUUFBaEIsSUFBNEIrSyxXQUE1QjtBQUNBRixNQUFNN0ssU0FBTixDQUFnQjJKLEdBQWhCLEdBQXNCcUIsUUFBdEI7QUFDQUgsTUFBTTdLLFNBQU4sQ0FBZ0JzSixHQUFoQixHQUFzQjJCLFFBQXRCO0FBQ0FKLE1BQU03SyxTQUFOLENBQWdCa0UsR0FBaEIsR0FBc0JnSCxRQUF0Qjs7QUFFQTs7Ozs7Ozs7QUFRQSxTQUFTRyxhQUFULENBQXVCakgsS0FBdkIsRUFBOEJrSCxTQUE5QixFQUF5QztBQUN2QztBQUNBO0FBQ0EsTUFBSWxHLFNBQVVtRyxRQUFRbkgsS0FBUixLQUFrQm9ILFlBQVlwSCxLQUFaLENBQW5CLEdBQ1RjLFVBQVVkLE1BQU03RSxNQUFoQixFQUF3QlUsTUFBeEIsQ0FEUyxHQUVULEVBRko7O0FBSUEsTUFBSVYsU0FBUzZGLE9BQU83RixNQUFwQjtBQUFBLE1BQ0lrTSxjQUFjLENBQUMsQ0FBQ2xNLE1BRHBCOztBQUdBLE9BQUssSUFBSUUsR0FBVCxJQUFnQjJFLEtBQWhCLEVBQXVCO0FBQ3JCLFFBQUksQ0FBQ2tILGFBQWExSyxlQUFlVCxJQUFmLENBQW9CaUUsS0FBcEIsRUFBMkIzRSxHQUEzQixDQUFkLEtBQ0EsRUFBRWdNLGdCQUFnQmhNLE9BQU8sUUFBUCxJQUFtQmlNLFFBQVFqTSxHQUFSLEVBQWFGLE1BQWIsQ0FBbkMsQ0FBRixDQURKLEVBQ2lFO0FBQy9ENkYsYUFBT2lGLElBQVAsQ0FBWTVLLEdBQVo7QUFDRDtBQUNGO0FBQ0QsU0FBTzJGLE1BQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7O0FBU0EsU0FBU3VHLGdCQUFULENBQTBCcEcsTUFBMUIsRUFBa0M5RixHQUFsQyxFQUF1QzJFLEtBQXZDLEVBQThDO0FBQzVDLE1BQUtBLFVBQVVvQixTQUFWLElBQXVCLENBQUNvRyxHQUFHckcsT0FBTzlGLEdBQVAsQ0FBSCxFQUFnQjJFLEtBQWhCLENBQXpCLElBQ0MsT0FBTzNFLEdBQVAsSUFBYyxRQUFkLElBQTBCMkUsVUFBVW9CLFNBQXBDLElBQWlELEVBQUUvRixPQUFPOEYsTUFBVCxDQUR0RCxFQUN5RTtBQUN2RUEsV0FBTzlGLEdBQVAsSUFBYzJFLEtBQWQ7QUFDRDtBQUNGOztBQUVEOzs7Ozs7Ozs7O0FBVUEsU0FBU3lILFdBQVQsQ0FBcUJ0RyxNQUFyQixFQUE2QjlGLEdBQTdCLEVBQWtDMkUsS0FBbEMsRUFBeUM7QUFDdkMsTUFBSTBILFdBQVd2RyxPQUFPOUYsR0FBUCxDQUFmO0FBQ0EsTUFBSSxFQUFFbUIsZUFBZVQsSUFBZixDQUFvQm9GLE1BQXBCLEVBQTRCOUYsR0FBNUIsS0FBb0NtTSxHQUFHRSxRQUFILEVBQWExSCxLQUFiLENBQXRDLEtBQ0NBLFVBQVVvQixTQUFWLElBQXVCLEVBQUUvRixPQUFPOEYsTUFBVCxDQUQ1QixFQUMrQztBQUM3Q0EsV0FBTzlGLEdBQVAsSUFBYzJFLEtBQWQ7QUFDRDtBQUNGOztBQUVEOzs7Ozs7OztBQVFBLFNBQVMyRixZQUFULENBQXNCckYsS0FBdEIsRUFBNkJqRixHQUE3QixFQUFrQztBQUNoQyxNQUFJRixTQUFTbUYsTUFBTW5GLE1BQW5CO0FBQ0EsU0FBT0EsUUFBUCxFQUFpQjtBQUNmLFFBQUlxTSxHQUFHbEgsTUFBTW5GLE1BQU4sRUFBYyxDQUFkLENBQUgsRUFBcUJFLEdBQXJCLENBQUosRUFBK0I7QUFDN0IsYUFBT0YsTUFBUDtBQUNEO0FBQ0Y7QUFDRCxTQUFPLENBQUMsQ0FBUjtBQUNEOztBQUVEOzs7Ozs7Ozs7QUFTQSxTQUFTd00sVUFBVCxDQUFvQnhHLE1BQXBCLEVBQTRCeUcsTUFBNUIsRUFBb0M7QUFDbEMsU0FBT3pHLFVBQVUwRyxXQUFXRCxNQUFYLEVBQW1CeEYsS0FBS3dGLE1BQUwsQ0FBbkIsRUFBaUN6RyxNQUFqQyxDQUFqQjtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7OztBQWNBLFNBQVMyRyxTQUFULENBQW1COUgsS0FBbkIsRUFBMEIrSCxNQUExQixFQUFrQ0MsTUFBbEMsRUFBMENDLFVBQTFDLEVBQXNENU0sR0FBdEQsRUFBMkQ4RixNQUEzRCxFQUFtRStHLEtBQW5FLEVBQTBFO0FBQ3hFLE1BQUlsSCxNQUFKO0FBQ0EsTUFBSWlILFVBQUosRUFBZ0I7QUFDZGpILGFBQVNHLFNBQVM4RyxXQUFXakksS0FBWCxFQUFrQjNFLEdBQWxCLEVBQXVCOEYsTUFBdkIsRUFBK0IrRyxLQUEvQixDQUFULEdBQWlERCxXQUFXakksS0FBWCxDQUExRDtBQUNEO0FBQ0QsTUFBSWdCLFdBQVdJLFNBQWYsRUFBMEI7QUFDeEIsV0FBT0osTUFBUDtBQUNEO0FBQ0QsTUFBSSxDQUFDdEcsU0FBU3NGLEtBQVQsQ0FBTCxFQUFzQjtBQUNwQixXQUFPQSxLQUFQO0FBQ0Q7QUFDRCxNQUFJbUksUUFBUWhCLFFBQVFuSCxLQUFSLENBQVo7QUFDQSxNQUFJbUksS0FBSixFQUFXO0FBQ1RuSCxhQUFTb0gsZUFBZXBJLEtBQWYsQ0FBVDtBQUNBLFFBQUksQ0FBQytILE1BQUwsRUFBYTtBQUNYLGFBQU9NLFVBQVVySSxLQUFWLEVBQWlCZ0IsTUFBakIsQ0FBUDtBQUNEO0FBQ0YsR0FMRCxNQUtPO0FBQ0wsUUFBSXNILE1BQU1DLE9BQU92SSxLQUFQLENBQVY7QUFBQSxRQUNJd0ksU0FBU0YsT0FBT3BMLE9BQVAsSUFBa0JvTCxPQUFPbkwsTUFEdEM7O0FBR0EsUUFBSW1HLFNBQVN0RCxLQUFULENBQUosRUFBcUI7QUFDbkIsYUFBT3lJLFlBQVl6SSxLQUFaLEVBQW1CK0gsTUFBbkIsQ0FBUDtBQUNEO0FBQ0QsUUFBSU8sT0FBT2hMLFNBQVAsSUFBb0JnTCxPQUFPekwsT0FBM0IsSUFBdUMyTCxVQUFVLENBQUNySCxNQUF0RCxFQUErRDtBQUM3RCxVQUFJRSxhQUFhckIsS0FBYixDQUFKLEVBQXlCO0FBQ3ZCLGVBQU9tQixTQUFTbkIsS0FBVCxHQUFpQixFQUF4QjtBQUNEO0FBQ0RnQixlQUFTMEgsZ0JBQWdCRixTQUFTLEVBQVQsR0FBY3hJLEtBQTlCLENBQVQ7QUFDQSxVQUFJLENBQUMrSCxNQUFMLEVBQWE7QUFDWCxlQUFPWSxZQUFZM0ksS0FBWixFQUFtQjJILFdBQVczRyxNQUFYLEVBQW1CaEIsS0FBbkIsQ0FBbkIsQ0FBUDtBQUNEO0FBQ0YsS0FSRCxNQVFPO0FBQ0wsVUFBSSxDQUFDbkIsY0FBY3lKLEdBQWQsQ0FBTCxFQUF5QjtBQUN2QixlQUFPbkgsU0FBU25CLEtBQVQsR0FBaUIsRUFBeEI7QUFDRDtBQUNEZ0IsZUFBUzRILGVBQWU1SSxLQUFmLEVBQXNCc0ksR0FBdEIsRUFBMkJSLFNBQTNCLEVBQXNDQyxNQUF0QyxDQUFUO0FBQ0Q7QUFDRjtBQUNEO0FBQ0FHLFlBQVVBLFFBQVEsSUFBSXpCLEtBQUosRUFBbEI7QUFDQSxNQUFJb0MsVUFBVVgsTUFBTTNDLEdBQU4sQ0FBVXZGLEtBQVYsQ0FBZDtBQUNBLE1BQUk2SSxPQUFKLEVBQWE7QUFDWCxXQUFPQSxPQUFQO0FBQ0Q7QUFDRFgsUUFBTXBJLEdBQU4sQ0FBVUUsS0FBVixFQUFpQmdCLE1BQWpCOztBQUVBLE1BQUksQ0FBQ21ILEtBQUwsRUFBWTtBQUNWLFFBQUlXLFFBQVFkLFNBQVNlLFdBQVcvSSxLQUFYLENBQVQsR0FBNkJvQyxLQUFLcEMsS0FBTCxDQUF6QztBQUNEO0FBQ0RLLFlBQVV5SSxTQUFTOUksS0FBbkIsRUFBMEIsVUFBU2dKLFFBQVQsRUFBbUIzTixHQUFuQixFQUF3QjtBQUNoRCxRQUFJeU4sS0FBSixFQUFXO0FBQ1R6TixZQUFNMk4sUUFBTjtBQUNBQSxpQkFBV2hKLE1BQU0zRSxHQUFOLENBQVg7QUFDRDtBQUNEO0FBQ0FvTSxnQkFBWXpHLE1BQVosRUFBb0IzRixHQUFwQixFQUF5QnlNLFVBQVVrQixRQUFWLEVBQW9CakIsTUFBcEIsRUFBNEJDLE1BQTVCLEVBQW9DQyxVQUFwQyxFQUFnRDVNLEdBQWhELEVBQXFEMkUsS0FBckQsRUFBNERrSSxLQUE1RCxDQUF6QjtBQUNELEdBUEQ7QUFRQSxTQUFPbEgsTUFBUDtBQUNEOztBQUVEOzs7Ozs7OztBQVFBLFNBQVNpSSxVQUFULENBQW9CQyxLQUFwQixFQUEyQjtBQUN6QixTQUFPeE8sU0FBU3dPLEtBQVQsSUFBa0JsRyxhQUFha0csS0FBYixDQUFsQixHQUF3QyxFQUEvQztBQUNEOztBQUVEOzs7Ozs7Ozs7OztBQVdBLFNBQVNDLGNBQVQsQ0FBd0JoSSxNQUF4QixFQUFnQ2lJLFFBQWhDLEVBQTBDQyxXQUExQyxFQUF1RDtBQUNyRCxNQUFJckksU0FBU29JLFNBQVNqSSxNQUFULENBQWI7QUFDQSxTQUFPZ0csUUFBUWhHLE1BQVIsSUFBa0JILE1BQWxCLEdBQTJCUixVQUFVUSxNQUFWLEVBQWtCcUksWUFBWWxJLE1BQVosQ0FBbEIsQ0FBbEM7QUFDRDs7QUFFRDs7Ozs7OztBQU9BLFNBQVNtSSxVQUFULENBQW9CdEosS0FBcEIsRUFBMkI7QUFDekIsU0FBT3dDLGVBQWV6RyxJQUFmLENBQW9CaUUsS0FBcEIsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7OztBQVFBLFNBQVN1SixZQUFULENBQXNCdkosS0FBdEIsRUFBNkI7QUFDM0IsTUFBSSxDQUFDdEYsU0FBU3NGLEtBQVQsQ0FBRCxJQUFvQndKLFNBQVN4SixLQUFULENBQXhCLEVBQXlDO0FBQ3ZDLFdBQU8sS0FBUDtBQUNEO0FBQ0QsTUFBSXlKLFVBQVdoUCxXQUFXdUYsS0FBWCxLQUFxQnFCLGFBQWFyQixLQUFiLENBQXRCLEdBQTZDeUMsVUFBN0MsR0FBMEQvRCxZQUF4RTtBQUNBLFNBQU8rSyxRQUFRQyxJQUFSLENBQWF2RixTQUFTbkUsS0FBVCxDQUFiLENBQVA7QUFDRDs7QUFFRDs7Ozs7OztBQU9BLFNBQVMySixnQkFBVCxDQUEwQjNKLEtBQTFCLEVBQWlDO0FBQy9CLFNBQU80SixhQUFhNUosS0FBYixLQUNMNkosU0FBUzdKLE1BQU03RSxNQUFmLENBREssSUFDcUIsQ0FBQyxDQUFDeUQsZUFBZTRELGVBQWV6RyxJQUFmLENBQW9CaUUsS0FBcEIsQ0FBZixDQUQ5QjtBQUVEOztBQUVEOzs7Ozs7O0FBT0EsU0FBUzhKLFFBQVQsQ0FBa0IzSSxNQUFsQixFQUEwQjtBQUN4QixNQUFJLENBQUM0SSxZQUFZNUksTUFBWixDQUFMLEVBQTBCO0FBQ3hCLFdBQU9vQyxXQUFXcEMsTUFBWCxDQUFQO0FBQ0Q7QUFDRCxNQUFJSCxTQUFTLEVBQWI7QUFDQSxPQUFLLElBQUkzRixHQUFULElBQWdCVixPQUFPd0csTUFBUCxDQUFoQixFQUFnQztBQUM5QixRQUFJM0UsZUFBZVQsSUFBZixDQUFvQm9GLE1BQXBCLEVBQTRCOUYsR0FBNUIsS0FBb0NBLE9BQU8sYUFBL0MsRUFBOEQ7QUFDNUQyRixhQUFPaUYsSUFBUCxDQUFZNUssR0FBWjtBQUNEO0FBQ0Y7QUFDRCxTQUFPMkYsTUFBUDtBQUNEOztBQUVEOzs7Ozs7O0FBT0EsU0FBU2dKLFVBQVQsQ0FBb0I3SSxNQUFwQixFQUE0QjtBQUMxQixNQUFJLENBQUN6RyxTQUFTeUcsTUFBVCxDQUFMLEVBQXVCO0FBQ3JCLFdBQU84SSxhQUFhOUksTUFBYixDQUFQO0FBQ0Q7QUFDRCxNQUFJK0ksVUFBVUgsWUFBWTVJLE1BQVosQ0FBZDtBQUFBLE1BQ0lILFNBQVMsRUFEYjs7QUFHQSxPQUFLLElBQUkzRixHQUFULElBQWdCOEYsTUFBaEIsRUFBd0I7QUFDdEIsUUFBSSxFQUFFOUYsT0FBTyxhQUFQLEtBQXlCNk8sV0FBVyxDQUFDMU4sZUFBZVQsSUFBZixDQUFvQm9GLE1BQXBCLEVBQTRCOUYsR0FBNUIsQ0FBckMsQ0FBRixDQUFKLEVBQStFO0FBQzdFMkYsYUFBT2lGLElBQVAsQ0FBWTVLLEdBQVo7QUFDRDtBQUNGO0FBQ0QsU0FBTzJGLE1BQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7QUFXQSxTQUFTbUosU0FBVCxDQUFtQmhKLE1BQW5CLEVBQTJCeUcsTUFBM0IsRUFBbUN3QyxRQUFuQyxFQUE2Q25DLFVBQTdDLEVBQXlEQyxLQUF6RCxFQUFnRTtBQUM5RCxNQUFJL0csV0FBV3lHLE1BQWYsRUFBdUI7QUFDckI7QUFDRDtBQUNELE1BQUksRUFBRVQsUUFBUVMsTUFBUixLQUFtQmpJLGFBQWFpSSxNQUFiLENBQXJCLENBQUosRUFBZ0Q7QUFDOUMsUUFBSWtCLFFBQVFrQixXQUFXcEMsTUFBWCxDQUFaO0FBQ0Q7QUFDRHZILFlBQVV5SSxTQUFTbEIsTUFBbkIsRUFBMkIsVUFBU3lDLFFBQVQsRUFBbUJoUCxHQUFuQixFQUF3QjtBQUNqRCxRQUFJeU4sS0FBSixFQUFXO0FBQ1R6TixZQUFNZ1AsUUFBTjtBQUNBQSxpQkFBV3pDLE9BQU92TSxHQUFQLENBQVg7QUFDRDtBQUNELFFBQUlYLFNBQVMyUCxRQUFULENBQUosRUFBd0I7QUFDdEJuQyxnQkFBVUEsUUFBUSxJQUFJekIsS0FBSixFQUFsQjtBQUNBNkQsb0JBQWNuSixNQUFkLEVBQXNCeUcsTUFBdEIsRUFBOEJ2TSxHQUE5QixFQUFtQytPLFFBQW5DLEVBQTZDRCxTQUE3QyxFQUF3RGxDLFVBQXhELEVBQW9FQyxLQUFwRTtBQUNELEtBSEQsTUFJSztBQUNILFVBQUlxQyxXQUFXdEMsYUFDWEEsV0FBVzlHLE9BQU85RixHQUFQLENBQVgsRUFBd0JnUCxRQUF4QixFQUFtQ2hQLE1BQU0sRUFBekMsRUFBOEM4RixNQUE5QyxFQUFzRHlHLE1BQXRELEVBQThETSxLQUE5RCxDQURXLEdBRVg5RyxTQUZKOztBQUlBLFVBQUltSixhQUFhbkosU0FBakIsRUFBNEI7QUFDMUJtSixtQkFBV0YsUUFBWDtBQUNEO0FBQ0Q5Qyx1QkFBaUJwRyxNQUFqQixFQUF5QjlGLEdBQXpCLEVBQThCa1AsUUFBOUI7QUFDRDtBQUNGLEdBbkJEO0FBb0JEOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7QUFlQSxTQUFTRCxhQUFULENBQXVCbkosTUFBdkIsRUFBK0J5RyxNQUEvQixFQUF1Q3ZNLEdBQXZDLEVBQTRDK08sUUFBNUMsRUFBc0RJLFNBQXRELEVBQWlFdkMsVUFBakUsRUFBNkVDLEtBQTdFLEVBQW9GO0FBQ2xGLE1BQUlSLFdBQVd2RyxPQUFPOUYsR0FBUCxDQUFmO0FBQUEsTUFDSWdQLFdBQVd6QyxPQUFPdk0sR0FBUCxDQURmO0FBQUEsTUFFSXdOLFVBQVVYLE1BQU0zQyxHQUFOLENBQVU4RSxRQUFWLENBRmQ7O0FBSUEsTUFBSXhCLE9BQUosRUFBYTtBQUNYdEIscUJBQWlCcEcsTUFBakIsRUFBeUI5RixHQUF6QixFQUE4QndOLE9BQTlCO0FBQ0E7QUFDRDtBQUNELE1BQUkwQixXQUFXdEMsYUFDWEEsV0FBV1AsUUFBWCxFQUFxQjJDLFFBQXJCLEVBQWdDaFAsTUFBTSxFQUF0QyxFQUEyQzhGLE1BQTNDLEVBQW1EeUcsTUFBbkQsRUFBMkRNLEtBQTNELENBRFcsR0FFWDlHLFNBRko7O0FBSUEsTUFBSXFKLFdBQVdGLGFBQWFuSixTQUE1Qjs7QUFFQSxNQUFJcUosUUFBSixFQUFjO0FBQ1pGLGVBQVdGLFFBQVg7QUFDQSxRQUFJbEQsUUFBUWtELFFBQVIsS0FBcUIxSyxhQUFhMEssUUFBYixDQUF6QixFQUFpRDtBQUMvQyxVQUFJbEQsUUFBUU8sUUFBUixDQUFKLEVBQXVCO0FBQ3JCNkMsbUJBQVc3QyxRQUFYO0FBQ0QsT0FGRCxNQUdLLElBQUlnRCxrQkFBa0JoRCxRQUFsQixDQUFKLEVBQWlDO0FBQ3BDNkMsbUJBQVdsQyxVQUFVWCxRQUFWLENBQVg7QUFDRCxPQUZJLE1BR0E7QUFDSCtDLG1CQUFXLEtBQVg7QUFDQUYsbUJBQVd6QyxVQUFVdUMsUUFBVixFQUFvQixJQUFwQixDQUFYO0FBQ0Q7QUFDRixLQVhELE1BWUssSUFBSU0sY0FBY04sUUFBZCxLQUEyQmpELFlBQVlpRCxRQUFaLENBQS9CLEVBQXNEO0FBQ3pELFVBQUlqRCxZQUFZTSxRQUFaLENBQUosRUFBMkI7QUFDekI2QyxtQkFBV0ssY0FBY2xELFFBQWQsQ0FBWDtBQUNELE9BRkQsTUFHSyxJQUFJLENBQUNoTixTQUFTZ04sUUFBVCxDQUFELElBQXdCMEMsWUFBWTNQLFdBQVdpTixRQUFYLENBQXhDLEVBQStEO0FBQ2xFK0MsbUJBQVcsS0FBWDtBQUNBRixtQkFBV3pDLFVBQVV1QyxRQUFWLEVBQW9CLElBQXBCLENBQVg7QUFDRCxPQUhJLE1BSUE7QUFDSEUsbUJBQVc3QyxRQUFYO0FBQ0Q7QUFDRixLQVhJLE1BWUE7QUFDSCtDLGlCQUFXLEtBQVg7QUFDRDtBQUNGO0FBQ0QsTUFBSUEsUUFBSixFQUFjO0FBQ1o7QUFDQXZDLFVBQU1wSSxHQUFOLENBQVV1SyxRQUFWLEVBQW9CRSxRQUFwQjtBQUNBQyxjQUFVRCxRQUFWLEVBQW9CRixRQUFwQixFQUE4QkQsUUFBOUIsRUFBd0NuQyxVQUF4QyxFQUFvREMsS0FBcEQ7QUFDQUEsVUFBTSxRQUFOLEVBQWdCbUMsUUFBaEI7QUFDRDtBQUNEOUMsbUJBQWlCcEcsTUFBakIsRUFBeUI5RixHQUF6QixFQUE4QmtQLFFBQTlCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUEsU0FBU00sUUFBVCxDQUFrQjNLLElBQWxCLEVBQXdCNEssS0FBeEIsRUFBK0I7QUFDN0JBLFVBQVF0SCxVQUFVc0gsVUFBVTFKLFNBQVYsR0FBdUJsQixLQUFLL0UsTUFBTCxHQUFjLENBQXJDLEdBQTBDMlAsS0FBcEQsRUFBMkQsQ0FBM0QsQ0FBUjtBQUNBLFNBQU8sWUFBVztBQUNoQixRQUFJMUssT0FBT2xGLFNBQVg7QUFBQSxRQUNJa0IsUUFBUSxDQUFDLENBRGI7QUFBQSxRQUVJakIsU0FBU3FJLFVBQVVwRCxLQUFLakYsTUFBTCxHQUFjMlAsS0FBeEIsRUFBK0IsQ0FBL0IsQ0FGYjtBQUFBLFFBR0l4SyxRQUFRcEUsTUFBTWYsTUFBTixDQUhaOztBQUtBLFdBQU8sRUFBRWlCLEtBQUYsR0FBVWpCLE1BQWpCLEVBQXlCO0FBQ3ZCbUYsWUFBTWxFLEtBQU4sSUFBZWdFLEtBQUswSyxRQUFRMU8sS0FBYixDQUFmO0FBQ0Q7QUFDREEsWUFBUSxDQUFDLENBQVQ7QUFDQSxRQUFJMk8sWUFBWTdPLE1BQU00TyxRQUFRLENBQWQsQ0FBaEI7QUFDQSxXQUFPLEVBQUUxTyxLQUFGLEdBQVUwTyxLQUFqQixFQUF3QjtBQUN0QkMsZ0JBQVUzTyxLQUFWLElBQW1CZ0UsS0FBS2hFLEtBQUwsQ0FBbkI7QUFDRDtBQUNEMk8sY0FBVUQsS0FBVixJQUFtQnhLLEtBQW5CO0FBQ0EsV0FBTzdFLE1BQU15RSxJQUFOLEVBQVksSUFBWixFQUFrQjZLLFNBQWxCLENBQVA7QUFDRCxHQWhCRDtBQWlCRDs7QUFFRDs7Ozs7Ozs7QUFRQSxTQUFTdEMsV0FBVCxDQUFxQnVDLE1BQXJCLEVBQTZCakQsTUFBN0IsRUFBcUM7QUFDbkMsTUFBSUEsTUFBSixFQUFZO0FBQ1YsV0FBT2lELE9BQU81USxLQUFQLEVBQVA7QUFDRDtBQUNELE1BQUk0RyxTQUFTLElBQUlnSyxPQUFPQyxXQUFYLENBQXVCRCxPQUFPN1AsTUFBOUIsQ0FBYjtBQUNBNlAsU0FBT0UsSUFBUCxDQUFZbEssTUFBWjtBQUNBLFNBQU9BLE1BQVA7QUFDRDs7QUFFRDs7Ozs7OztBQU9BLFNBQVNtSyxnQkFBVCxDQUEwQkMsV0FBMUIsRUFBdUM7QUFDckMsTUFBSXBLLFNBQVMsSUFBSW9LLFlBQVlILFdBQWhCLENBQTRCRyxZQUFZQyxVQUF4QyxDQUFiO0FBQ0EsTUFBSXhJLFVBQUosQ0FBZTdCLE1BQWYsRUFBdUJsQixHQUF2QixDQUEyQixJQUFJK0MsVUFBSixDQUFldUksV0FBZixDQUEzQjtBQUNBLFNBQU9wSyxNQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUEsU0FBU3NLLGFBQVQsQ0FBdUJDLFFBQXZCLEVBQWlDeEQsTUFBakMsRUFBeUM7QUFDdkMsTUFBSWlELFNBQVNqRCxTQUFTb0QsaUJBQWlCSSxTQUFTUCxNQUExQixDQUFULEdBQTZDTyxTQUFTUCxNQUFuRTtBQUNBLFNBQU8sSUFBSU8sU0FBU04sV0FBYixDQUF5QkQsTUFBekIsRUFBaUNPLFNBQVNDLFVBQTFDLEVBQXNERCxTQUFTRixVQUEvRCxDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztBQVNBLFNBQVNJLFFBQVQsQ0FBa0JuUixHQUFsQixFQUF1QnlOLE1BQXZCLEVBQStCMkQsU0FBL0IsRUFBMEM7QUFDeEMsTUFBSXBMLFFBQVF5SCxTQUFTMkQsVUFBVXBLLFdBQVdoSCxHQUFYLENBQVYsRUFBMkIsSUFBM0IsQ0FBVCxHQUE0Q2dILFdBQVdoSCxHQUFYLENBQXhEO0FBQ0EsU0FBT3FHLFlBQVlMLEtBQVosRUFBbUJWLFdBQW5CLEVBQWdDLElBQUl0RixJQUFJMlEsV0FBUixFQUFoQyxDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQSxTQUFTVSxXQUFULENBQXFCQyxNQUFyQixFQUE2QjtBQUMzQixNQUFJNUssU0FBUyxJQUFJNEssT0FBT1gsV0FBWCxDQUF1QlcsT0FBT2hFLE1BQTlCLEVBQXNDbkosUUFBUTBELElBQVIsQ0FBYXlKLE1BQWIsQ0FBdEMsQ0FBYjtBQUNBNUssU0FBTzRFLFNBQVAsR0FBbUJnRyxPQUFPaEcsU0FBMUI7QUFDQSxTQUFPNUUsTUFBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7QUFTQSxTQUFTNkssUUFBVCxDQUFrQi9MLEdBQWxCLEVBQXVCaUksTUFBdkIsRUFBK0IyRCxTQUEvQixFQUEwQztBQUN4QyxNQUFJcEwsUUFBUXlILFNBQVMyRCxVQUFVOUosV0FBVzlCLEdBQVgsQ0FBVixFQUEyQixJQUEzQixDQUFULEdBQTRDOEIsV0FBVzlCLEdBQVgsQ0FBeEQ7QUFDQSxTQUFPYSxZQUFZTCxLQUFaLEVBQW1CUCxXQUFuQixFQUFnQyxJQUFJRCxJQUFJbUwsV0FBUixFQUFoQyxDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQSxTQUFTYSxXQUFULENBQXFCQyxNQUFyQixFQUE2QjtBQUMzQixTQUFPdEgsZ0JBQWdCOUosT0FBTzhKLGNBQWMxSSxJQUFkLENBQW1CZ1EsTUFBbkIsQ0FBUCxDQUFoQixHQUFxRCxFQUE1RDtBQUNEOztBQUVEOzs7Ozs7OztBQVFBLFNBQVNDLGVBQVQsQ0FBeUJDLFVBQXpCLEVBQXFDbEUsTUFBckMsRUFBNkM7QUFDM0MsTUFBSWlELFNBQVNqRCxTQUFTb0QsaUJBQWlCYyxXQUFXakIsTUFBNUIsQ0FBVCxHQUErQ2lCLFdBQVdqQixNQUF2RTtBQUNBLFNBQU8sSUFBSWlCLFdBQVdoQixXQUFmLENBQTJCRCxNQUEzQixFQUFtQ2lCLFdBQVdULFVBQTlDLEVBQTBEUyxXQUFXOVEsTUFBckUsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7OztBQVFBLFNBQVNrTixTQUFULENBQW1CVCxNQUFuQixFQUEyQnRILEtBQTNCLEVBQWtDO0FBQ2hDLE1BQUlsRSxRQUFRLENBQUMsQ0FBYjtBQUFBLE1BQ0lqQixTQUFTeU0sT0FBT3pNLE1BRHBCOztBQUdBbUYsWUFBVUEsUUFBUXBFLE1BQU1mLE1BQU4sQ0FBbEI7QUFDQSxTQUFPLEVBQUVpQixLQUFGLEdBQVVqQixNQUFqQixFQUF5QjtBQUN2Qm1GLFVBQU1sRSxLQUFOLElBQWV3TCxPQUFPeEwsS0FBUCxDQUFmO0FBQ0Q7QUFDRCxTQUFPa0UsS0FBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7O0FBVUEsU0FBU3VILFVBQVQsQ0FBb0JELE1BQXBCLEVBQTRCa0IsS0FBNUIsRUFBbUMzSCxNQUFuQyxFQUEyQzhHLFVBQTNDLEVBQXVEO0FBQ3JEOUcsYUFBV0EsU0FBUyxFQUFwQjs7QUFFQSxNQUFJL0UsUUFBUSxDQUFDLENBQWI7QUFBQSxNQUNJakIsU0FBUzJOLE1BQU0zTixNQURuQjs7QUFHQSxTQUFPLEVBQUVpQixLQUFGLEdBQVVqQixNQUFqQixFQUF5QjtBQUN2QixRQUFJRSxNQUFNeU4sTUFBTTFNLEtBQU4sQ0FBVjs7QUFFQSxRQUFJbU8sV0FBV3RDLGFBQ1hBLFdBQVc5RyxPQUFPOUYsR0FBUCxDQUFYLEVBQXdCdU0sT0FBT3ZNLEdBQVAsQ0FBeEIsRUFBcUNBLEdBQXJDLEVBQTBDOEYsTUFBMUMsRUFBa0R5RyxNQUFsRCxDQURXLEdBRVh4RyxTQUZKOztBQUlBcUcsZ0JBQVl0RyxNQUFaLEVBQW9COUYsR0FBcEIsRUFBeUJrUCxhQUFhbkosU0FBYixHQUF5QndHLE9BQU92TSxHQUFQLENBQXpCLEdBQXVDa1AsUUFBaEU7QUFDRDtBQUNELFNBQU9wSixNQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUEsU0FBU3dILFdBQVQsQ0FBcUJmLE1BQXJCLEVBQTZCekcsTUFBN0IsRUFBcUM7QUFDbkMsU0FBTzBHLFdBQVdELE1BQVgsRUFBbUJzRSxXQUFXdEUsTUFBWCxDQUFuQixFQUF1Q3pHLE1BQXZDLENBQVA7QUFDRDs7QUFFRDs7Ozs7OztBQU9BLFNBQVNnTCxjQUFULENBQXdCQyxRQUF4QixFQUFrQztBQUNoQyxTQUFPdkIsU0FBUyxVQUFTMUosTUFBVCxFQUFpQmtMLE9BQWpCLEVBQTBCO0FBQ3hDLFFBQUlqUSxRQUFRLENBQUMsQ0FBYjtBQUFBLFFBQ0lqQixTQUFTa1IsUUFBUWxSLE1BRHJCO0FBQUEsUUFFSThNLGFBQWE5TSxTQUFTLENBQVQsR0FBYWtSLFFBQVFsUixTQUFTLENBQWpCLENBQWIsR0FBbUNpRyxTQUZwRDtBQUFBLFFBR0lrTCxRQUFRblIsU0FBUyxDQUFULEdBQWFrUixRQUFRLENBQVIsQ0FBYixHQUEwQmpMLFNBSHRDOztBQUtBNkcsaUJBQWNtRSxTQUFTalIsTUFBVCxHQUFrQixDQUFsQixJQUF1QixPQUFPOE0sVUFBUCxJQUFxQixVQUE3QyxJQUNSOU0sVUFBVThNLFVBREYsSUFFVDdHLFNBRko7O0FBSUEsUUFBSWtMLFNBQVNDLGVBQWVGLFFBQVEsQ0FBUixDQUFmLEVBQTJCQSxRQUFRLENBQVIsQ0FBM0IsRUFBdUNDLEtBQXZDLENBQWIsRUFBNEQ7QUFDMURyRSxtQkFBYTlNLFNBQVMsQ0FBVCxHQUFhaUcsU0FBYixHQUF5QjZHLFVBQXRDO0FBQ0E5TSxlQUFTLENBQVQ7QUFDRDtBQUNEZ0csYUFBU3hHLE9BQU93RyxNQUFQLENBQVQ7QUFDQSxXQUFPLEVBQUUvRSxLQUFGLEdBQVVqQixNQUFqQixFQUF5QjtBQUN2QixVQUFJeU0sU0FBU3lFLFFBQVFqUSxLQUFSLENBQWI7QUFDQSxVQUFJd0wsTUFBSixFQUFZO0FBQ1Z3RSxpQkFBU2pMLE1BQVQsRUFBaUJ5RyxNQUFqQixFQUF5QnhMLEtBQXpCLEVBQWdDNkwsVUFBaEM7QUFDRDtBQUNGO0FBQ0QsV0FBTzlHLE1BQVA7QUFDRCxHQXRCTSxDQUFQO0FBdUJEOztBQUVEOzs7Ozs7O0FBT0EsU0FBUzRILFVBQVQsQ0FBb0I1SCxNQUFwQixFQUE0QjtBQUMxQixTQUFPZ0ksZUFBZWhJLE1BQWYsRUFBdUJpQixJQUF2QixFQUE2QjhKLFVBQTdCLENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7QUFRQSxTQUFTN0YsVUFBVCxDQUFvQi9MLEdBQXBCLEVBQXlCZSxHQUF6QixFQUE4QjtBQUM1QixNQUFJK0osT0FBTzlLLElBQUkwSyxRQUFmO0FBQ0EsU0FBT3dILFVBQVVuUixHQUFWLElBQ0grSixLQUFLLE9BQU8vSixHQUFQLElBQWMsUUFBZCxHQUF5QixRQUF6QixHQUFvQyxNQUF6QyxDQURHLEdBRUgrSixLQUFLOUssR0FGVDtBQUdEOztBQUVEOzs7Ozs7OztBQVFBLFNBQVNzSixTQUFULENBQW1CekMsTUFBbkIsRUFBMkI5RixHQUEzQixFQUFnQztBQUM5QixNQUFJMkUsUUFBUWtCLFNBQVNDLE1BQVQsRUFBaUI5RixHQUFqQixDQUFaO0FBQ0EsU0FBT2tPLGFBQWF2SixLQUFiLElBQXNCQSxLQUF0QixHQUE4Qm9CLFNBQXJDO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQSxJQUFJOEssYUFBYS9JLG1CQUFtQjFCLFFBQVEwQixnQkFBUixFQUEwQnhJLE1BQTFCLENBQW5CLEdBQXVEOFIsU0FBeEU7O0FBRUE7Ozs7Ozs7QUFPQSxJQUFJbEUsU0FBU2UsVUFBYjs7QUFFQTtBQUNBO0FBQ0EsSUFBSzNGLFlBQVk0RSxPQUFPLElBQUk1RSxRQUFKLENBQWEsSUFBSStJLFdBQUosQ0FBZ0IsQ0FBaEIsQ0FBYixDQUFQLEtBQTRDNU8sV0FBekQsSUFDQytGLE9BQU8wRSxPQUFPLElBQUkxRSxHQUFKLEVBQVAsS0FBbUJ6RyxNQUQzQixJQUVDMEcsV0FBV3lFLE9BQU96RSxRQUFRNkksT0FBUixFQUFQLEtBQTZCcFAsVUFGekMsSUFHQ3dHLE9BQU93RSxPQUFPLElBQUl4RSxHQUFKLEVBQVAsS0FBbUJ0RyxNQUgzQixJQUlDdUcsV0FBV3VFLE9BQU8sSUFBSXZFLE9BQUosRUFBUCxLQUF1QnBHLFVBSnZDLEVBSW9EO0FBQ2xEMkssV0FBUyxnQkFBU3ZJLEtBQVQsRUFBZ0I7QUFDdkIsUUFBSWdCLFNBQVN3QixlQUFlekcsSUFBZixDQUFvQmlFLEtBQXBCLENBQWI7QUFBQSxRQUNJNE0sT0FBTzVMLFVBQVUxRCxTQUFWLEdBQXNCMEMsTUFBTWlMLFdBQTVCLEdBQTBDN0osU0FEckQ7QUFBQSxRQUVJeUwsYUFBYUQsT0FBT3pJLFNBQVN5SSxJQUFULENBQVAsR0FBd0J4TCxTQUZ6Qzs7QUFJQSxRQUFJeUwsVUFBSixFQUFnQjtBQUNkLGNBQVFBLFVBQVI7QUFDRSxhQUFLM0ksa0JBQUw7QUFBeUIsaUJBQU9wRyxXQUFQO0FBQ3pCLGFBQUtzRyxhQUFMO0FBQW9CLGlCQUFPaEgsTUFBUDtBQUNwQixhQUFLaUgsaUJBQUw7QUFBd0IsaUJBQU85RyxVQUFQO0FBQ3hCLGFBQUsrRyxhQUFMO0FBQW9CLGlCQUFPN0csTUFBUDtBQUNwQixhQUFLOEcsaUJBQUw7QUFBd0IsaUJBQU8zRyxVQUFQO0FBTDFCO0FBT0Q7QUFDRCxXQUFPb0QsTUFBUDtBQUNELEdBZkQ7QUFnQkQ7O0FBRUQ7Ozs7Ozs7QUFPQSxTQUFTb0gsY0FBVCxDQUF3QjlILEtBQXhCLEVBQStCO0FBQzdCLE1BQUluRixTQUFTbUYsTUFBTW5GLE1BQW5CO0FBQUEsTUFDSTZGLFNBQVNWLE1BQU0ySyxXQUFOLENBQWtCOVAsTUFBbEIsQ0FEYjs7QUFHQTtBQUNBLE1BQUlBLFVBQVUsT0FBT21GLE1BQU0sQ0FBTixDQUFQLElBQW1CLFFBQTdCLElBQXlDOUQsZUFBZVQsSUFBZixDQUFvQnVFLEtBQXBCLEVBQTJCLE9BQTNCLENBQTdDLEVBQWtGO0FBQ2hGVSxXQUFPNUUsS0FBUCxHQUFla0UsTUFBTWxFLEtBQXJCO0FBQ0E0RSxXQUFPOEwsS0FBUCxHQUFleE0sTUFBTXdNLEtBQXJCO0FBQ0Q7QUFDRCxTQUFPOUwsTUFBUDtBQUNEOztBQUVEOzs7Ozs7O0FBT0EsU0FBUzBILGVBQVQsQ0FBeUJ2SCxNQUF6QixFQUFpQztBQUMvQixTQUFRLE9BQU9BLE9BQU84SixXQUFkLElBQTZCLFVBQTdCLElBQTJDLENBQUNsQixZQUFZNUksTUFBWixDQUE3QyxHQUNIOEgsV0FBV25HLGFBQWEzQixNQUFiLENBQVgsQ0FERyxHQUVILEVBRko7QUFHRDs7QUFFRDs7Ozs7Ozs7Ozs7OztBQWFBLFNBQVN5SCxjQUFULENBQXdCekgsTUFBeEIsRUFBZ0NtSCxHQUFoQyxFQUFxQ29ELFNBQXJDLEVBQWdEM0QsTUFBaEQsRUFBd0Q7QUFDdEQsTUFBSTZFLE9BQU96TCxPQUFPOEosV0FBbEI7QUFDQSxVQUFRM0MsR0FBUjtBQUNFLFNBQUt6SyxjQUFMO0FBQ0UsYUFBT3NOLGlCQUFpQmhLLE1BQWpCLENBQVA7O0FBRUYsU0FBS3BFLE9BQUw7QUFDQSxTQUFLQyxPQUFMO0FBQ0UsYUFBTyxJQUFJNFAsSUFBSixDQUFTLENBQUN6TCxNQUFWLENBQVA7O0FBRUYsU0FBS3JELFdBQUw7QUFDRSxhQUFPd04sY0FBY25LLE1BQWQsRUFBc0I0RyxNQUF0QixDQUFQOztBQUVGLFNBQUtoSyxVQUFMLENBQWlCLEtBQUtDLFVBQUw7QUFDakIsU0FBS0MsT0FBTCxDQUFjLEtBQUtDLFFBQUwsQ0FBZSxLQUFLQyxRQUFMO0FBQzdCLFNBQUtDLFFBQUwsQ0FBZSxLQUFLQyxlQUFMLENBQXNCLEtBQUtDLFNBQUwsQ0FBZ0IsS0FBS0MsU0FBTDtBQUNuRCxhQUFPeU4sZ0JBQWdCN0ssTUFBaEIsRUFBd0I0RyxNQUF4QixDQUFQOztBQUVGLFNBQUszSyxNQUFMO0FBQ0UsYUFBT3FPLFNBQVN0SyxNQUFULEVBQWlCNEcsTUFBakIsRUFBeUIyRCxTQUF6QixDQUFQOztBQUVGLFNBQUtyTyxTQUFMO0FBQ0EsU0FBS0ssU0FBTDtBQUNFLGFBQU8sSUFBSWtQLElBQUosQ0FBU3pMLE1BQVQsQ0FBUDs7QUFFRixTQUFLM0QsU0FBTDtBQUNFLGFBQU9tTyxZQUFZeEssTUFBWixDQUFQOztBQUVGLFNBQUsxRCxNQUFMO0FBQ0UsYUFBT29PLFNBQVMxSyxNQUFULEVBQWlCNEcsTUFBakIsRUFBeUIyRCxTQUF6QixDQUFQOztBQUVGLFNBQUsvTixTQUFMO0FBQ0UsYUFBT21PLFlBQVkzSyxNQUFaLENBQVA7QUE5Qko7QUFnQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUEsU0FBU21HLE9BQVQsQ0FBaUJ0SCxLQUFqQixFQUF3QjdFLE1BQXhCLEVBQWdDO0FBQzlCQSxXQUFTQSxVQUFVLElBQVYsR0FBaUJ5QixnQkFBakIsR0FBb0N6QixNQUE3QztBQUNBLFNBQU8sQ0FBQyxDQUFDQSxNQUFGLEtBQ0osT0FBTzZFLEtBQVAsSUFBZ0IsUUFBaEIsSUFBNEJyQixTQUFTK0ssSUFBVCxDQUFjMUosS0FBZCxDQUR4QixLQUVKQSxRQUFRLENBQUMsQ0FBVCxJQUFjQSxRQUFRLENBQVIsSUFBYSxDQUEzQixJQUFnQ0EsUUFBUTdFLE1BRjNDO0FBR0Q7O0FBRUQ7Ozs7Ozs7Ozs7QUFVQSxTQUFTb1IsY0FBVCxDQUF3QnZNLEtBQXhCLEVBQStCNUQsS0FBL0IsRUFBc0MrRSxNQUF0QyxFQUE4QztBQUM1QyxNQUFJLENBQUN6RyxTQUFTeUcsTUFBVCxDQUFMLEVBQXVCO0FBQ3JCLFdBQU8sS0FBUDtBQUNEO0FBQ0QsTUFBSTRMLGNBQWMzUSxLQUFkLHlDQUFjQSxLQUFkLENBQUo7QUFDQSxNQUFJMlEsUUFBUSxRQUFSLEdBQ0tDLFlBQVk3TCxNQUFaLEtBQXVCbUcsUUFBUWxMLEtBQVIsRUFBZStFLE9BQU9oRyxNQUF0QixDQUQ1QixHQUVLNFIsUUFBUSxRQUFSLElBQW9CM1EsU0FBUytFLE1BRnRDLEVBR007QUFDSixXQUFPcUcsR0FBR3JHLE9BQU8vRSxLQUFQLENBQUgsRUFBa0I0RCxLQUFsQixDQUFQO0FBQ0Q7QUFDRCxTQUFPLEtBQVA7QUFDRDs7QUFFRDs7Ozs7OztBQU9BLFNBQVN3TSxTQUFULENBQW1CeE0sS0FBbkIsRUFBMEI7QUFDeEIsTUFBSStNLGNBQWMvTSxLQUFkLHlDQUFjQSxLQUFkLENBQUo7QUFDQSxTQUFRK00sUUFBUSxRQUFSLElBQW9CQSxRQUFRLFFBQTVCLElBQXdDQSxRQUFRLFFBQWhELElBQTREQSxRQUFRLFNBQXJFLEdBQ0YvTSxVQUFVLFdBRFIsR0FFRkEsVUFBVSxJQUZmO0FBR0Q7O0FBRUQ7Ozs7Ozs7QUFPQSxTQUFTd0osUUFBVCxDQUFrQnRKLElBQWxCLEVBQXdCO0FBQ3RCLFNBQU8sQ0FBQyxDQUFDK0IsVUFBRixJQUFpQkEsY0FBYy9CLElBQXRDO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQSxTQUFTNkosV0FBVCxDQUFxQi9KLEtBQXJCLEVBQTRCO0FBQzFCLE1BQUk0TSxPQUFPNU0sU0FBU0EsTUFBTWlMLFdBQTFCO0FBQUEsTUFDSS9CLFFBQVMsT0FBTzBELElBQVAsSUFBZSxVQUFmLElBQTZCQSxLQUFLaFIsU0FBbkMsSUFBaURtRyxXQUQ3RDs7QUFHQSxTQUFPL0IsVUFBVWtKLEtBQWpCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztBQVNBLFNBQVNlLFlBQVQsQ0FBc0I5SSxNQUF0QixFQUE4QjtBQUM1QixNQUFJSCxTQUFTLEVBQWI7QUFDQSxNQUFJRyxVQUFVLElBQWQsRUFBb0I7QUFDbEIsU0FBSyxJQUFJOUYsR0FBVCxJQUFnQlYsT0FBT3dHLE1BQVAsQ0FBaEIsRUFBZ0M7QUFDOUJILGFBQU9pRixJQUFQLENBQVk1SyxHQUFaO0FBQ0Q7QUFDRjtBQUNELFNBQU8yRixNQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQSxTQUFTbUQsUUFBVCxDQUFrQmpFLElBQWxCLEVBQXdCO0FBQ3RCLE1BQUlBLFFBQVEsSUFBWixFQUFrQjtBQUNoQixRQUFJO0FBQ0YsYUFBT29DLGFBQWF2RyxJQUFiLENBQWtCbUUsSUFBbEIsQ0FBUDtBQUNELEtBRkQsQ0FFRSxPQUFPM0csQ0FBUCxFQUFVLENBQUU7QUFDZCxRQUFJO0FBQ0YsYUFBUTJHLE9BQU8sRUFBZjtBQUNELEtBRkQsQ0FFRSxPQUFPM0csQ0FBUCxFQUFVLENBQUU7QUFDZjtBQUNELFNBQU8sRUFBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWdDQSxTQUFTaU8sRUFBVCxDQUFZeEgsS0FBWixFQUFtQmlOLEtBQW5CLEVBQTBCO0FBQ3hCLFNBQU9qTixVQUFVaU4sS0FBVixJQUFvQmpOLFVBQVVBLEtBQVYsSUFBbUJpTixVQUFVQSxLQUF4RDtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkEsU0FBUzdGLFdBQVQsQ0FBcUJwSCxLQUFyQixFQUE0QjtBQUMxQjtBQUNBLFNBQU8wSyxrQkFBa0IxSyxLQUFsQixLQUE0QnhELGVBQWVULElBQWYsQ0FBb0JpRSxLQUFwQixFQUEyQixRQUEzQixDQUE1QixLQUNKLENBQUNpRCxxQkFBcUJsSCxJQUFyQixDQUEwQmlFLEtBQTFCLEVBQWlDLFFBQWpDLENBQUQsSUFBK0N3QyxlQUFlekcsSUFBZixDQUFvQmlFLEtBQXBCLEtBQThCbkQsT0FEekUsQ0FBUDtBQUVEOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVCQSxJQUFJc0ssVUFBVWpMLE1BQU1pTCxPQUFwQjs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQSxTQUFTNkYsV0FBVCxDQUFxQmhOLEtBQXJCLEVBQTRCO0FBQzFCLFNBQU9BLFNBQVMsSUFBVCxJQUFpQjZKLFNBQVM3SixNQUFNN0UsTUFBZixDQUFqQixJQUEyQyxDQUFDVixXQUFXdUYsS0FBWCxDQUFuRDtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBLFNBQVMwSyxpQkFBVCxDQUEyQjFLLEtBQTNCLEVBQWtDO0FBQ2hDLFNBQU80SixhQUFhNUosS0FBYixLQUF1QmdOLFlBQVloTixLQUFaLENBQTlCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLElBQUlzRCxXQUFXRCxrQkFBa0I2SixTQUFqQzs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsU0FBU3pTLFVBQVQsQ0FBb0J1RixLQUFwQixFQUEyQjtBQUN6QjtBQUNBO0FBQ0EsTUFBSXNJLE1BQU01TixTQUFTc0YsS0FBVCxJQUFrQndDLGVBQWV6RyxJQUFmLENBQW9CaUUsS0FBcEIsQ0FBbEIsR0FBK0MsRUFBekQ7QUFDQSxTQUFPc0ksT0FBT3BMLE9BQVAsSUFBa0JvTCxPQUFPbkwsTUFBaEM7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQkEsU0FBUzBNLFFBQVQsQ0FBa0I3SixLQUFsQixFQUF5QjtBQUN2QixTQUFPLE9BQU9BLEtBQVAsSUFBZ0IsUUFBaEIsSUFDTEEsUUFBUSxDQUFDLENBREosSUFDU0EsUUFBUSxDQUFSLElBQWEsQ0FEdEIsSUFDMkJBLFNBQVNwRCxnQkFEM0M7QUFFRDs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQSxTQUFTbEMsUUFBVCxDQUFrQnNGLEtBQWxCLEVBQXlCO0FBQ3ZCLE1BQUkrTSxjQUFjL00sS0FBZCx5Q0FBY0EsS0FBZCxDQUFKO0FBQ0EsU0FBTyxDQUFDLENBQUNBLEtBQUYsS0FBWStNLFFBQVEsUUFBUixJQUFvQkEsUUFBUSxVQUF4QyxDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdCQSxTQUFTbkQsWUFBVCxDQUFzQjVKLEtBQXRCLEVBQTZCO0FBQzNCLFNBQU8sQ0FBQyxDQUFDQSxLQUFGLElBQVcsUUFBT0EsS0FBUCx5Q0FBT0EsS0FBUCxNQUFnQixRQUFsQztBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEJBLFNBQVMySyxhQUFULENBQXVCM0ssS0FBdkIsRUFBOEI7QUFDNUIsTUFBSSxDQUFDNEosYUFBYTVKLEtBQWIsQ0FBRCxJQUNBd0MsZUFBZXpHLElBQWYsQ0FBb0JpRSxLQUFwQixLQUE4QjFDLFNBRDlCLElBQzJDK0QsYUFBYXJCLEtBQWIsQ0FEL0MsRUFDb0U7QUFDbEUsV0FBTyxLQUFQO0FBQ0Q7QUFDRCxNQUFJa0osUUFBUXBHLGFBQWE5QyxLQUFiLENBQVo7QUFDQSxNQUFJa0osVUFBVSxJQUFkLEVBQW9CO0FBQ2xCLFdBQU8sSUFBUDtBQUNEO0FBQ0QsTUFBSTBELE9BQU9wUSxlQUFlVCxJQUFmLENBQW9CbU4sS0FBcEIsRUFBMkIsYUFBM0IsS0FBNkNBLE1BQU0rQixXQUE5RDtBQUNBLFNBQVEsT0FBTzJCLElBQVAsSUFBZSxVQUFmLElBQ05BLGdCQUFnQkEsSUFEVixJQUNrQnRLLGFBQWF2RyxJQUFiLENBQWtCNlEsSUFBbEIsS0FBMkJySyxnQkFEckQ7QUFFRDs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsSUFBSTVDLGVBQWVELG1CQUFtQnVCLFVBQVV2QixnQkFBVixDQUFuQixHQUFpRGlLLGdCQUFwRTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0JBLFNBQVNpQixhQUFULENBQXVCNUssS0FBdkIsRUFBOEI7QUFDNUIsU0FBTzZILFdBQVc3SCxLQUFYLEVBQWtCbU4sT0FBT25OLEtBQVAsQ0FBbEIsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEJBLFNBQVNvQyxJQUFULENBQWNqQixNQUFkLEVBQXNCO0FBQ3BCLFNBQU82TCxZQUFZN0wsTUFBWixJQUFzQjhGLGNBQWM5RixNQUFkLENBQXRCLEdBQThDMkksU0FBUzNJLE1BQVQsQ0FBckQ7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkEsU0FBU2dNLE1BQVQsQ0FBZ0JoTSxNQUFoQixFQUF3QjtBQUN0QixTQUFPNkwsWUFBWTdMLE1BQVosSUFBc0I4RixjQUFjOUYsTUFBZCxFQUFzQixJQUF0QixDQUF0QixHQUFvRDZJLFdBQVc3SSxNQUFYLENBQTNEO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUErQkEsSUFBSWlNLFFBQVFqQixlQUFlLFVBQVNoTCxNQUFULEVBQWlCeUcsTUFBakIsRUFBeUJ3QyxRQUF6QixFQUFtQztBQUM1REQsWUFBVWhKLE1BQVYsRUFBa0J5RyxNQUFsQixFQUEwQndDLFFBQTFCO0FBQ0QsQ0FGVyxDQUFaOztBQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkEsU0FBU3FDLFNBQVQsR0FBcUI7QUFDbkIsU0FBTyxFQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7QUFhQSxTQUFTUyxTQUFULEdBQXFCO0FBQ25CLFNBQU8sS0FBUDtBQUNEOztBQUVEelQsT0FBT0MsT0FBUCxHQUFpQjBULEtBQWpCLEM7Ozs7Ozs7Ozs7OztBQzlwRUEsSUFBTUMsYUFBYSxtQkFBQUMsQ0FBUyxFQUFULENBQW5COztBQUVBRCxXQUFXRSxVQUFYLENBQXNCQyxRQUF0QixHQUFpQyxTQUFTQyxnQkFBVCxDQUEyQnpOLEtBQTNCLEVBQWtDME4sT0FBbEMsRUFBNEM7QUFDekUsV0FBUzFOLFVBQVUsSUFBVixJQUFrQkEsVUFBVW9CLFNBQTVCLElBQXlDaU0sa0JBQWdCQSxXQUFXTSxVQUFYLENBQXVCRCxPQUF2QixDQUFoQixFQUFxRDFOLEtBQXJELENBQTNDLEdBQTJHLElBQTNHLHVCQUFvSTBOLE9BQTNJO0FBQ0gsQ0FGRDs7QUFJQSxJQUFNRSxrQkFBa0IsbUJBQUFOLENBQVMsRUFBVCxDQUF4Qjs7QUFFQSxJQUFNTyxXQUFXLFNBQVNBLFFBQVQsQ0FBbUJDLFVBQW5CLEVBQStCQyxXQUEvQixFQUE2QztBQUMxRCxRQUFNQyxVQUFVWCxXQUFZUyxVQUFaLEVBQXdCQyxXQUF4QixDQUFoQjtBQUNBLFFBQUtDLE9BQUwsRUFBZTtBQUNYLGVBQU9sSyxRQUFRbUssTUFBUixDQUFnQixJQUFJTCxlQUFKLENBQW9CO0FBQ3ZDTSxxQkFBU0YsUUFBUUcsS0FEc0I7QUFFdkNDLHFCQUFTSjtBQUY4QixTQUFwQixDQUFoQixDQUFQO0FBSUg7QUFDRCxXQUFPbEssUUFBUTZJLE9BQVIsRUFBUDtBQUNILENBVEQ7O0FBV0FrQixTQUFTNUMsV0FBVCxHQUF1QixTQUFTb0QsbUJBQVQsQ0FBOEJDLE1BQTlCLEVBQXNDUCxXQUF0QyxFQUFvRDtBQUN2RSxRQUFLLFFBQU9PLE1BQVAseUNBQU9BLE1BQVAsT0FBa0IsUUFBdkIsRUFBa0M7QUFDOUIsY0FBTSxJQUFJQyxTQUFKLENBQWUsMEJBQWYsQ0FBTjtBQUNIO0FBQ0QsUUFBTVAsVUFBVVgsV0FBWWlCLE1BQVosRUFBb0JQLFdBQXBCLENBQWhCO0FBQ0EsUUFBS0MsT0FBTCxFQUFlO0FBQ1gsY0FBTSxJQUFJSixlQUFKLENBQW9CO0FBQ3RCTSxxQkFBU0YsUUFBUUcsS0FESztBQUV0QkMscUJBQVNKO0FBRmEsU0FBcEIsQ0FBTjtBQUlIO0FBQ0osQ0FYRDs7QUFhQXZVLE9BQU9DLE9BQVAsR0FBaUJtVSxRQUFqQixDOzs7Ozs7Ozs7OztBQ2hDQXBVLE9BQU9DLE9BQVAsR0FBaUIsU0FBUzhVLGtCQUFULEdBQXVDO0FBQUE7O0FBQ3BELFFBQUlkLFVBQVUsRUFBZDtBQUNBLFFBQUssOERBQW1CLFFBQXhCLEVBQW1DO0FBQy9CQTtBQUNILEtBRkQsTUFHSyxJQUFLLDhEQUFtQixRQUF4QixFQUFtQztBQUNwQ0E7QUFDSCxLQUZJLE1BR0EsSUFBSyw4REFBbUIsUUFBeEIsRUFBbUM7QUFDcENBLGdCQUFRZSxLQUFSO0FBQ0g7QUFDRCxRQUFLLDhEQUFtQixRQUF4QixFQUFtQztBQUMvQmYsZ0JBQVFnQixHQUFSO0FBQ0g7QUFDRCxRQUFLLFVBQUt2VCxNQUFMLEdBQWMsQ0FBZCxJQUFtQixlQUFZLFVBQUtBLE1BQUwsR0FBYyxDQUExQiw4REFBaUMsVUFBekQsRUFBc0U7QUFBQTs7QUFDbEV1UyxnQkFBUWlCLFFBQVIsWUFBd0IsVUFBS3hULE1BQUwsR0FBYyxDQUF0QztBQUNIO0FBQ0QsV0FBT3VTLE9BQVA7QUFDSCxDQWxCRCxDOzs7Ozs7O0FDQUE7Ozs7QUFFQSxJQUFJa0IsSUFBVyxtQkFBQXRCLENBQVEsRUFBUixDQUFmO0FBQUEsSUFDSXVCLFdBQVcsbUJBQUF2QixDQUFRLEVBQVIsQ0FEZjtBQUFBLElBR0k3UixRQUFRcEMsU0FBU3VDLFNBQVQsQ0FBbUJILEtBSC9CO0FBQUEsSUFHc0NNLE9BQU8xQyxTQUFTdUMsU0FBVCxDQUFtQkcsSUFIaEU7QUFBQSxJQUlJbEMsU0FBU2MsT0FBT2QsTUFKcEI7QUFBQSxJQUk0QmlWLGlCQUFpQm5VLE9BQU9tVSxjQUpwRDtBQUFBLElBS0lDLG1CQUFtQnBVLE9BQU9vVSxnQkFMOUI7QUFBQSxJQU1JdlMsaUJBQWlCN0IsT0FBT2lCLFNBQVAsQ0FBaUJZLGNBTnRDO0FBQUEsSUFPSXdTLGFBQWEsRUFBRUMsY0FBYyxJQUFoQixFQUFzQkMsWUFBWSxLQUFsQyxFQUF5Q0MsVUFBVSxJQUFuRCxFQVBqQjtBQUFBLElBU0lDLEVBVEo7QUFBQSxJQVNRQyxNQVRSO0FBQUEsSUFTY0MsR0FUZDtBQUFBLElBU21CQyxJQVRuQjtBQUFBLElBU3lCQyxPQVR6QjtBQUFBLElBU2tDQyxXQVRsQztBQUFBLElBUytDQyxJQVQvQzs7QUFXQU4sS0FBSyxZQUFVckMsSUFBVixFQUFnQjRDLFFBQWhCLEVBQTBCO0FBQzlCLEtBQUl2SyxJQUFKOztBQUVBeUosVUFBU2MsUUFBVDs7QUFFQSxLQUFJLENBQUNuVCxlQUFlVCxJQUFmLENBQW9CLElBQXBCLEVBQTBCLFFBQTFCLENBQUwsRUFBMEM7QUFDekNxSixTQUFPNEosV0FBV2hQLEtBQVgsR0FBbUJuRyxPQUFPLElBQVAsQ0FBMUI7QUFDQWlWLGlCQUFlLElBQWYsRUFBcUIsUUFBckIsRUFBK0JFLFVBQS9CO0FBQ0FBLGFBQVdoUCxLQUFYLEdBQW1CLElBQW5CO0FBQ0EsRUFKRCxNQUlPO0FBQ05vRixTQUFPLEtBQUt3SyxNQUFaO0FBQ0E7QUFDRCxLQUFJLENBQUN4SyxLQUFLMkgsSUFBTCxDQUFMLEVBQWlCM0gsS0FBSzJILElBQUwsSUFBYTRDLFFBQWIsQ0FBakIsS0FDSyxJQUFJLFFBQU92SyxLQUFLMkgsSUFBTCxDQUFQLE1BQXNCLFFBQTFCLEVBQW9DM0gsS0FBSzJILElBQUwsRUFBVzlHLElBQVgsQ0FBZ0IwSixRQUFoQixFQUFwQyxLQUNBdkssS0FBSzJILElBQUwsSUFBYSxDQUFDM0gsS0FBSzJILElBQUwsQ0FBRCxFQUFhNEMsUUFBYixDQUFiOztBQUVMLFFBQU8sSUFBUDtBQUNBLENBakJEOztBQW1CQU4sU0FBTyxjQUFVdEMsSUFBVixFQUFnQjRDLFFBQWhCLEVBQTBCO0FBQ2hDLEtBQUlOLEtBQUosRUFBVXJRLElBQVY7O0FBRUE2UCxVQUFTYyxRQUFUO0FBQ0EzUSxRQUFPLElBQVA7QUFDQW9RLElBQUdyVCxJQUFILENBQVEsSUFBUixFQUFjZ1IsSUFBZCxFQUFvQnNDLFFBQU8sZ0JBQVk7QUFDdENDLE1BQUl2VCxJQUFKLENBQVNpRCxJQUFULEVBQWUrTixJQUFmLEVBQXFCc0MsS0FBckI7QUFDQTVULFFBQU1NLElBQU4sQ0FBVzRULFFBQVgsRUFBcUIsSUFBckIsRUFBMkJ6VSxTQUEzQjtBQUNBLEVBSEQ7O0FBS0FtVSxPQUFLUSxrQkFBTCxHQUEwQkYsUUFBMUI7QUFDQSxRQUFPLElBQVA7QUFDQSxDQVpEOztBQWNBTCxNQUFNLGFBQVV2QyxJQUFWLEVBQWdCNEMsUUFBaEIsRUFBMEI7QUFDL0IsS0FBSXZLLElBQUosRUFBVTBLLFNBQVYsRUFBcUJDLFNBQXJCLEVBQWdDOVUsQ0FBaEM7O0FBRUE0VCxVQUFTYyxRQUFUOztBQUVBLEtBQUksQ0FBQ25ULGVBQWVULElBQWYsQ0FBb0IsSUFBcEIsRUFBMEIsUUFBMUIsQ0FBTCxFQUEwQyxPQUFPLElBQVA7QUFDMUNxSixRQUFPLEtBQUt3SyxNQUFaO0FBQ0EsS0FBSSxDQUFDeEssS0FBSzJILElBQUwsQ0FBTCxFQUFpQixPQUFPLElBQVA7QUFDakIrQyxhQUFZMUssS0FBSzJILElBQUwsQ0FBWjs7QUFFQSxLQUFJLFFBQU8rQyxTQUFQLHlDQUFPQSxTQUFQLE9BQXFCLFFBQXpCLEVBQW1DO0FBQ2xDLE9BQUs3VSxJQUFJLENBQVQsRUFBYThVLFlBQVlELFVBQVU3VSxDQUFWLENBQXpCLEVBQXdDLEVBQUVBLENBQTFDLEVBQTZDO0FBQzVDLE9BQUs4VSxjQUFjSixRQUFmLElBQ0RJLFVBQVVGLGtCQUFWLEtBQWlDRixRQURwQyxFQUMrQztBQUM5QyxRQUFJRyxVQUFVM1UsTUFBVixLQUFxQixDQUF6QixFQUE0QmlLLEtBQUsySCxJQUFMLElBQWErQyxVQUFVN1UsSUFBSSxDQUFKLEdBQVEsQ0FBbEIsQ0FBYixDQUE1QixLQUNLNlUsVUFBVTVNLE1BQVYsQ0FBaUJqSSxDQUFqQixFQUFvQixDQUFwQjtBQUNMO0FBQ0Q7QUFDRCxFQVJELE1BUU87QUFDTixNQUFLNlUsY0FBY0gsUUFBZixJQUNERyxVQUFVRCxrQkFBVixLQUFpQ0YsUUFEcEMsRUFDK0M7QUFDOUMsVUFBT3ZLLEtBQUsySCxJQUFMLENBQVA7QUFDQTtBQUNEOztBQUVELFFBQU8sSUFBUDtBQUNBLENBMUJEOztBQTRCQXdDLE9BQU8sY0FBVXhDLElBQVYsRUFBZ0I7QUFDdEIsS0FBSTlSLENBQUosRUFBTytVLENBQVAsRUFBVUwsUUFBVixFQUFvQkcsU0FBcEIsRUFBK0IxUCxJQUEvQjs7QUFFQSxLQUFJLENBQUM1RCxlQUFlVCxJQUFmLENBQW9CLElBQXBCLEVBQTBCLFFBQTFCLENBQUwsRUFBMEM7QUFDMUMrVCxhQUFZLEtBQUtGLE1BQUwsQ0FBWTdDLElBQVosQ0FBWjtBQUNBLEtBQUksQ0FBQytDLFNBQUwsRUFBZ0I7O0FBRWhCLEtBQUksUUFBT0EsU0FBUCx5Q0FBT0EsU0FBUCxPQUFxQixRQUF6QixFQUFtQztBQUNsQ0UsTUFBSTlVLFVBQVVDLE1BQWQ7QUFDQWlGLFNBQU8sSUFBSWxFLEtBQUosQ0FBVThULElBQUksQ0FBZCxDQUFQO0FBQ0EsT0FBSy9VLElBQUksQ0FBVCxFQUFZQSxJQUFJK1UsQ0FBaEIsRUFBbUIsRUFBRS9VLENBQXJCO0FBQXdCbUYsUUFBS25GLElBQUksQ0FBVCxJQUFjQyxVQUFVRCxDQUFWLENBQWQ7QUFBeEIsR0FFQTZVLFlBQVlBLFVBQVUxVixLQUFWLEVBQVo7QUFDQSxPQUFLYSxJQUFJLENBQVQsRUFBYTBVLFdBQVdHLFVBQVU3VSxDQUFWLENBQXhCLEVBQXVDLEVBQUVBLENBQXpDLEVBQTRDO0FBQzNDUSxTQUFNTSxJQUFOLENBQVc0VCxRQUFYLEVBQXFCLElBQXJCLEVBQTJCdlAsSUFBM0I7QUFDQTtBQUNELEVBVEQsTUFTTztBQUNOLFVBQVFsRixVQUFVQyxNQUFsQjtBQUNBLFFBQUssQ0FBTDtBQUNDWSxTQUFLQSxJQUFMLENBQVUrVCxTQUFWLEVBQXFCLElBQXJCO0FBQ0E7QUFDRCxRQUFLLENBQUw7QUFDQy9ULFNBQUtBLElBQUwsQ0FBVStULFNBQVYsRUFBcUIsSUFBckIsRUFBMkI1VSxVQUFVLENBQVYsQ0FBM0I7QUFDQTtBQUNELFFBQUssQ0FBTDtBQUNDYSxTQUFLQSxJQUFMLENBQVUrVCxTQUFWLEVBQXFCLElBQXJCLEVBQTJCNVUsVUFBVSxDQUFWLENBQTNCLEVBQXlDQSxVQUFVLENBQVYsQ0FBekM7QUFDQTtBQUNEO0FBQ0M4VSxRQUFJOVUsVUFBVUMsTUFBZDtBQUNBaUYsV0FBTyxJQUFJbEUsS0FBSixDQUFVOFQsSUFBSSxDQUFkLENBQVA7QUFDQSxTQUFLL1UsSUFBSSxDQUFULEVBQVlBLElBQUkrVSxDQUFoQixFQUFtQixFQUFFL1UsQ0FBckIsRUFBd0I7QUFDdkJtRixVQUFLbkYsSUFBSSxDQUFULElBQWNDLFVBQVVELENBQVYsQ0FBZDtBQUNBO0FBQ0RRLFVBQU1NLElBQU4sQ0FBVytULFNBQVgsRUFBc0IsSUFBdEIsRUFBNEIxUCxJQUE1QjtBQWhCRDtBQWtCQTtBQUNELENBcENEOztBQXNDQW9QLFVBQVU7QUFDVEosS0FBSUEsRUFESztBQUVUQyxPQUFNQSxNQUZHO0FBR1RDLE1BQUtBLEdBSEk7QUFJVEMsT0FBTUE7QUFKRyxDQUFWOztBQU9BRSxjQUFjO0FBQ2JMLEtBQUlSLEVBQUVRLEVBQUYsQ0FEUztBQUViQyxPQUFNVCxFQUFFUyxNQUFGLENBRk87QUFHYkMsTUFBS1YsRUFBRVUsR0FBRixDQUhRO0FBSWJDLE9BQU1YLEVBQUVXLElBQUY7QUFKTyxDQUFkOztBQU9BRyxPQUFPWCxpQkFBaUIsRUFBakIsRUFBcUJVLFdBQXJCLENBQVA7O0FBRUFoVyxPQUFPQyxPQUFQLEdBQWlCQSxVQUFVLGlCQUFVdVcsQ0FBVixFQUFhO0FBQ3ZDLFFBQVFBLEtBQUssSUFBTixHQUFjcFcsT0FBTzZWLElBQVAsQ0FBZCxHQUE2QlgsaUJBQWlCcFUsT0FBT3NWLENBQVAsQ0FBakIsRUFBNEJSLFdBQTVCLENBQXBDO0FBQ0EsQ0FGRDtBQUdBL1YsUUFBUThWLE9BQVIsR0FBa0JBLE9BQWxCLEM7Ozs7Ozs7Ozs7O0lDbklNVSxhLEdBQ0YsdUJBQWFDLFNBQWIsRUFBd0JDLFFBQXhCLEVBQW1DO0FBQUE7O0FBQy9CLFNBQUtyRCxJQUFMLEdBQVlvRCxTQUFaO0FBQ0EsU0FBS0MsUUFBTCxHQUFnQkEsUUFBaEI7QUFDSCxDOztBQUdMM1csT0FBT0MsT0FBUCxHQUFpQndXLGFBQWpCLEM7Ozs7Ozs7OztBQ1BBelcsT0FBT0MsT0FBUCxHQUFpQixTQUFTMlcsaUJBQVQsQ0FBNEJDLE9BQTVCLEVBQXFDNUMsT0FBckMsRUFBK0M7QUFDNUQsV0FBTzRDLFFBQVFDLElBQVIsQ0FBYSxVQUFFbkwsSUFBRixFQUFZO0FBQzVCLFlBQUssT0FBT3NJLFFBQVFpQixRQUFmLEtBQTRCLFVBQWpDLEVBQThDO0FBQzFDakIsb0JBQVFpQixRQUFSLENBQWtCLElBQWxCLEVBQXdCdkosSUFBeEI7QUFDSDtBQUNELFlBQUssT0FBT3NJLFFBQVE4QyxPQUFmLEtBQTJCLFVBQWhDLEVBQTZDO0FBQ3pDOUMsb0JBQVE4QyxPQUFSLENBQWlCcEwsSUFBakI7QUFDSDtBQUNELGVBQU9BLElBQVA7QUFDSCxLQVJNLEVBU05xTCxLQVRNLENBU0EsVUFBRXRDLEtBQUYsRUFBYTtBQUNoQixZQUFLLE9BQU9ULFFBQVFpQixRQUFmLEtBQTRCLFVBQWpDLEVBQThDO0FBQzFDLG1CQUFPakIsUUFBUWlCLFFBQVIsQ0FBa0JSLEtBQWxCLENBQVA7QUFDSDtBQUNELFlBQUssT0FBT1QsUUFBUVMsS0FBZixLQUF5QixVQUE5QixFQUEyQztBQUN2QyxtQkFBT1QsUUFBUVMsS0FBUixDQUFlQSxLQUFmLENBQVA7QUFDSDtBQUNELGVBQU9ySyxRQUFRbUssTUFBUixDQUFnQkUsS0FBaEIsQ0FBUDtBQUNILEtBakJNLENBQVA7QUFrQkgsQ0FuQkQsQzs7Ozs7Ozs7O0FDQUE7QUFDQSxJQUFJNU8sVUFBVTlGLE9BQU9DLE9BQVAsR0FBaUIsRUFBL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSWdYLGdCQUFKO0FBQ0EsSUFBSUMsa0JBQUo7O0FBRUEsU0FBU0MsZ0JBQVQsR0FBNEI7QUFDeEIsVUFBTSxJQUFJQyxLQUFKLENBQVUsaUNBQVYsQ0FBTjtBQUNIO0FBQ0QsU0FBU0MsbUJBQVQsR0FBZ0M7QUFDNUIsVUFBTSxJQUFJRCxLQUFKLENBQVUsbUNBQVYsQ0FBTjtBQUNIO0FBQ0EsYUFBWTtBQUNULFFBQUk7QUFDQSxZQUFJLE9BQU9FLFVBQVAsS0FBc0IsVUFBMUIsRUFBc0M7QUFDbENMLCtCQUFtQkssVUFBbkI7QUFDSCxTQUZELE1BRU87QUFDSEwsK0JBQW1CRSxnQkFBbkI7QUFDSDtBQUNKLEtBTkQsQ0FNRSxPQUFPclgsQ0FBUCxFQUFVO0FBQ1JtWCwyQkFBbUJFLGdCQUFuQjtBQUNIO0FBQ0QsUUFBSTtBQUNBLFlBQUksT0FBT0ksWUFBUCxLQUF3QixVQUE1QixFQUF3QztBQUNwQ0wsaUNBQXFCSyxZQUFyQjtBQUNILFNBRkQsTUFFTztBQUNITCxpQ0FBcUJHLG1CQUFyQjtBQUNIO0FBQ0osS0FORCxDQU1FLE9BQU92WCxDQUFQLEVBQVU7QUFDUm9YLDZCQUFxQkcsbUJBQXJCO0FBQ0g7QUFDSixDQW5CQSxHQUFEO0FBb0JBLFNBQVNHLFVBQVQsQ0FBb0JDLEdBQXBCLEVBQXlCO0FBQ3JCLFFBQUlSLHFCQUFxQkssVUFBekIsRUFBcUM7QUFDakM7QUFDQSxlQUFPQSxXQUFXRyxHQUFYLEVBQWdCLENBQWhCLENBQVA7QUFDSDtBQUNEO0FBQ0EsUUFBSSxDQUFDUixxQkFBcUJFLGdCQUFyQixJQUF5QyxDQUFDRixnQkFBM0MsS0FBZ0VLLFVBQXBFLEVBQWdGO0FBQzVFTCwyQkFBbUJLLFVBQW5CO0FBQ0EsZUFBT0EsV0FBV0csR0FBWCxFQUFnQixDQUFoQixDQUFQO0FBQ0g7QUFDRCxRQUFJO0FBQ0E7QUFDQSxlQUFPUixpQkFBaUJRLEdBQWpCLEVBQXNCLENBQXRCLENBQVA7QUFDSCxLQUhELENBR0UsT0FBTTNYLENBQU4sRUFBUTtBQUNOLFlBQUk7QUFDQTtBQUNBLG1CQUFPbVgsaUJBQWlCM1UsSUFBakIsQ0FBc0IsSUFBdEIsRUFBNEJtVixHQUE1QixFQUFpQyxDQUFqQyxDQUFQO0FBQ0gsU0FIRCxDQUdFLE9BQU0zWCxDQUFOLEVBQVE7QUFDTjtBQUNBLG1CQUFPbVgsaUJBQWlCM1UsSUFBakIsQ0FBc0IsSUFBdEIsRUFBNEJtVixHQUE1QixFQUFpQyxDQUFqQyxDQUFQO0FBQ0g7QUFDSjtBQUdKO0FBQ0QsU0FBU0MsZUFBVCxDQUF5QkMsTUFBekIsRUFBaUM7QUFDN0IsUUFBSVQsdUJBQXVCSyxZQUEzQixFQUF5QztBQUNyQztBQUNBLGVBQU9BLGFBQWFJLE1BQWIsQ0FBUDtBQUNIO0FBQ0Q7QUFDQSxRQUFJLENBQUNULHVCQUF1QkcsbUJBQXZCLElBQThDLENBQUNILGtCQUFoRCxLQUF1RUssWUFBM0UsRUFBeUY7QUFDckZMLDZCQUFxQkssWUFBckI7QUFDQSxlQUFPQSxhQUFhSSxNQUFiLENBQVA7QUFDSDtBQUNELFFBQUk7QUFDQTtBQUNBLGVBQU9ULG1CQUFtQlMsTUFBbkIsQ0FBUDtBQUNILEtBSEQsQ0FHRSxPQUFPN1gsQ0FBUCxFQUFTO0FBQ1AsWUFBSTtBQUNBO0FBQ0EsbUJBQU9vWCxtQkFBbUI1VSxJQUFuQixDQUF3QixJQUF4QixFQUE4QnFWLE1BQTlCLENBQVA7QUFDSCxTQUhELENBR0UsT0FBTzdYLENBQVAsRUFBUztBQUNQO0FBQ0E7QUFDQSxtQkFBT29YLG1CQUFtQjVVLElBQW5CLENBQXdCLElBQXhCLEVBQThCcVYsTUFBOUIsQ0FBUDtBQUNIO0FBQ0o7QUFJSjtBQUNELElBQUlDLFFBQVEsRUFBWjtBQUNBLElBQUlDLFdBQVcsS0FBZjtBQUNBLElBQUlDLFlBQUo7QUFDQSxJQUFJQyxhQUFhLENBQUMsQ0FBbEI7O0FBRUEsU0FBU0MsZUFBVCxHQUEyQjtBQUN2QixRQUFJLENBQUNILFFBQUQsSUFBYSxDQUFDQyxZQUFsQixFQUFnQztBQUM1QjtBQUNIO0FBQ0RELGVBQVcsS0FBWDtBQUNBLFFBQUlDLGFBQWFwVyxNQUFqQixFQUF5QjtBQUNyQmtXLGdCQUFRRSxhQUFhN1YsTUFBYixDQUFvQjJWLEtBQXBCLENBQVI7QUFDSCxLQUZELE1BRU87QUFDSEcscUJBQWEsQ0FBQyxDQUFkO0FBQ0g7QUFDRCxRQUFJSCxNQUFNbFcsTUFBVixFQUFrQjtBQUNkdVc7QUFDSDtBQUNKOztBQUVELFNBQVNBLFVBQVQsR0FBc0I7QUFDbEIsUUFBSUosUUFBSixFQUFjO0FBQ1Y7QUFDSDtBQUNELFFBQUlLLFVBQVVWLFdBQVdRLGVBQVgsQ0FBZDtBQUNBSCxlQUFXLElBQVg7O0FBRUEsUUFBSU0sTUFBTVAsTUFBTWxXLE1BQWhCO0FBQ0EsV0FBTXlXLEdBQU4sRUFBVztBQUNQTCx1QkFBZUYsS0FBZjtBQUNBQSxnQkFBUSxFQUFSO0FBQ0EsZUFBTyxFQUFFRyxVQUFGLEdBQWVJLEdBQXRCLEVBQTJCO0FBQ3ZCLGdCQUFJTCxZQUFKLEVBQWtCO0FBQ2RBLDZCQUFhQyxVQUFiLEVBQXlCSyxHQUF6QjtBQUNIO0FBQ0o7QUFDREwscUJBQWEsQ0FBQyxDQUFkO0FBQ0FJLGNBQU1QLE1BQU1sVyxNQUFaO0FBQ0g7QUFDRG9XLG1CQUFlLElBQWY7QUFDQUQsZUFBVyxLQUFYO0FBQ0FILG9CQUFnQlEsT0FBaEI7QUFDSDs7QUFFRHBTLFFBQVF1UyxRQUFSLEdBQW1CLFVBQVVaLEdBQVYsRUFBZTtBQUM5QixRQUFJOVEsT0FBTyxJQUFJbEUsS0FBSixDQUFVaEIsVUFBVUMsTUFBVixHQUFtQixDQUE3QixDQUFYO0FBQ0EsUUFBSUQsVUFBVUMsTUFBVixHQUFtQixDQUF2QixFQUEwQjtBQUN0QixhQUFLLElBQUlGLElBQUksQ0FBYixFQUFnQkEsSUFBSUMsVUFBVUMsTUFBOUIsRUFBc0NGLEdBQXRDLEVBQTJDO0FBQ3ZDbUYsaUJBQUtuRixJQUFJLENBQVQsSUFBY0MsVUFBVUQsQ0FBVixDQUFkO0FBQ0g7QUFDSjtBQUNEb1csVUFBTXBMLElBQU4sQ0FBVyxJQUFJOEwsSUFBSixDQUFTYixHQUFULEVBQWM5USxJQUFkLENBQVg7QUFDQSxRQUFJaVIsTUFBTWxXLE1BQU4sS0FBaUIsQ0FBakIsSUFBc0IsQ0FBQ21XLFFBQTNCLEVBQXFDO0FBQ2pDTCxtQkFBV1MsVUFBWDtBQUNIO0FBQ0osQ0FYRDs7QUFhQTtBQUNBLFNBQVNLLElBQVQsQ0FBY2IsR0FBZCxFQUFtQjVRLEtBQW5CLEVBQTBCO0FBQ3RCLFNBQUs0USxHQUFMLEdBQVdBLEdBQVg7QUFDQSxTQUFLNVEsS0FBTCxHQUFhQSxLQUFiO0FBQ0g7QUFDRHlSLEtBQUtuVyxTQUFMLENBQWVpVyxHQUFmLEdBQXFCLFlBQVk7QUFDN0IsU0FBS1gsR0FBTCxDQUFTelYsS0FBVCxDQUFlLElBQWYsRUFBcUIsS0FBSzZFLEtBQTFCO0FBQ0gsQ0FGRDtBQUdBZixRQUFReVMsS0FBUixHQUFnQixTQUFoQjtBQUNBelMsUUFBUTBTLE9BQVIsR0FBa0IsSUFBbEI7QUFDQTFTLFFBQVEyUyxHQUFSLEdBQWMsRUFBZDtBQUNBM1MsUUFBUTRTLElBQVIsR0FBZSxFQUFmO0FBQ0E1UyxRQUFRNlMsT0FBUixHQUFrQixFQUFsQixDLENBQXNCO0FBQ3RCN1MsUUFBUThTLFFBQVIsR0FBbUIsRUFBbkI7O0FBRUEsU0FBU0MsSUFBVCxHQUFnQixDQUFFOztBQUVsQi9TLFFBQVE2UCxFQUFSLEdBQWFrRCxJQUFiO0FBQ0EvUyxRQUFRZ1QsV0FBUixHQUFzQkQsSUFBdEI7QUFDQS9TLFFBQVE4UCxJQUFSLEdBQWVpRCxJQUFmO0FBQ0EvUyxRQUFRK1AsR0FBUixHQUFjZ0QsSUFBZDtBQUNBL1MsUUFBUWlULGNBQVIsR0FBeUJGLElBQXpCO0FBQ0EvUyxRQUFRa1Qsa0JBQVIsR0FBNkJILElBQTdCO0FBQ0EvUyxRQUFRZ1EsSUFBUixHQUFlK0MsSUFBZjtBQUNBL1MsUUFBUW1ULGVBQVIsR0FBMEJKLElBQTFCO0FBQ0EvUyxRQUFRb1QsbUJBQVIsR0FBOEJMLElBQTlCOztBQUVBL1MsUUFBUXVRLFNBQVIsR0FBb0IsVUFBVThDLElBQVYsRUFBZ0I7QUFBRSxXQUFPLEVBQVA7QUFBVyxDQUFqRDs7QUFFQXJULFFBQVFFLE9BQVIsR0FBa0IsVUFBVW1ULElBQVYsRUFBZ0I7QUFDOUIsVUFBTSxJQUFJL0IsS0FBSixDQUFVLGtDQUFWLENBQU47QUFDSCxDQUZEOztBQUlBdFIsUUFBUXNULEdBQVIsR0FBYyxZQUFZO0FBQUUsV0FBTyxHQUFQO0FBQVksQ0FBeEM7QUFDQXRULFFBQVF1VCxLQUFSLEdBQWdCLFVBQVVDLEdBQVYsRUFBZTtBQUMzQixVQUFNLElBQUlsQyxLQUFKLENBQVUsZ0NBQVYsQ0FBTjtBQUNILENBRkQ7QUFHQXRSLFFBQVF5VCxLQUFSLEdBQWdCLFlBQVc7QUFBRSxXQUFPLENBQVA7QUFBVyxDQUF4QyxDOzs7Ozs7Ozs7QUN2TEF2WixPQUFPQyxPQUFQLEdBQWlCLFVBQVNELE1BQVQsRUFBaUI7QUFDakMsS0FBRyxDQUFDQSxPQUFPd1osZUFBWCxFQUE0QjtBQUMzQnhaLFNBQU95WixTQUFQLEdBQW1CLFlBQVcsQ0FBRSxDQUFoQztBQUNBelosU0FBTzBaLEtBQVAsR0FBZSxFQUFmO0FBQ0E7QUFDQSxNQUFHLENBQUMxWixPQUFPMlosUUFBWCxFQUFxQjNaLE9BQU8yWixRQUFQLEdBQWtCLEVBQWxCO0FBQ3JCelksU0FBT21VLGNBQVAsQ0FBc0JyVixNQUF0QixFQUE4QixRQUE5QixFQUF3QztBQUN2Q3lWLGVBQVksSUFEMkI7QUFFdkMzSixRQUFLLGVBQVc7QUFDZixXQUFPOUwsT0FBT3VXLENBQWQ7QUFDQTtBQUpzQyxHQUF4QztBQU1BclYsU0FBT21VLGNBQVAsQ0FBc0JyVixNQUF0QixFQUE4QixJQUE5QixFQUFvQztBQUNuQ3lWLGVBQVksSUFEdUI7QUFFbkMzSixRQUFLLGVBQVc7QUFDZixXQUFPOUwsT0FBT3dCLENBQWQ7QUFDQTtBQUprQyxHQUFwQztBQU1BeEIsU0FBT3daLGVBQVAsR0FBeUIsQ0FBekI7QUFDQTtBQUNELFFBQU94WixNQUFQO0FBQ0EsQ0FyQkQsQzs7Ozs7Ozs7O0FDQUEsSUFBTTRaLGNBQWMsbUJBQUEvRixDQUFTLEVBQVQsQ0FBcEI7O0FBRUE3VCxPQUFPQyxPQUFQLEdBQWlCMlosWUFBYSxpQkFBYixFQUFnQztBQUM3Q25GLGFBQVMsbUJBRG9DO0FBRTdDRSxhQUFTO0FBRm9DLENBQWhDLENBQWpCLEM7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDRkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdCQTs7OztBQUlBLENBQUMsVUFBUzdVLENBQVQsRUFBVztBQUFDLFFBQUcsNENBQWlCRyxPQUFqQixNQUEwQixlQUFhLE9BQU9ELE1BQWpELEVBQXdEQSxPQUFPQyxPQUFQLEdBQWVILEdBQWYsQ0FBeEQsS0FBZ0YsSUFBRyxJQUFILEVBQXlDLGlDQUFPLEVBQVAsb0NBQVVBLENBQVY7QUFBQTtBQUFBO0FBQUEscUdBQXpDLEtBQTBEO0FBQUMsWUFBSStaLENBQUosQ0FBTSxlQUFhLE9BQU85WixNQUFwQixHQUEyQjhaLElBQUU5WixNQUE3QixHQUFvQyxlQUFhLE9BQU9VLE1BQXBCLEdBQTJCb1osSUFBRXBaLE1BQTdCLEdBQW9DLGVBQWEsT0FBTzhFLElBQXBCLEtBQTJCc1UsSUFBRXRVLElBQTdCLENBQXhFLEVBQTJHc1UsRUFBRXhQLE9BQUYsR0FBVXZLLEdBQXJIO0FBQXlIO0FBQUMsQ0FBdlIsQ0FBd1IsWUFBVTtBQUFDLFFBQUlnYSxNQUFKLEVBQVc5WixNQUFYLEVBQWtCQyxPQUFsQixDQUEwQixPQUFRLFNBQVNILENBQVQsQ0FBV2lhLENBQVgsRUFBYXpTLENBQWIsRUFBZTBTLENBQWYsRUFBaUI7QUFBQyxpQkFBU0MsQ0FBVCxDQUFXekQsQ0FBWCxFQUFhMEQsQ0FBYixFQUFlO0FBQUMsZ0JBQUcsQ0FBQzVTLEVBQUVrUCxDQUFGLENBQUosRUFBUztBQUFDLG9CQUFHLENBQUN1RCxFQUFFdkQsQ0FBRixDQUFKLEVBQVM7QUFBQyx3QkFBSTJELElBQUUsT0FBT0MsT0FBUCxJQUFnQixVQUFoQixJQUE0QkEsT0FBbEMsQ0FBMEMsSUFBRyxDQUFDRixDQUFELElBQUlDLENBQVAsRUFBUyxPQUFPQSxFQUFFM0QsQ0FBRixFQUFJLENBQUMsQ0FBTCxDQUFQLENBQWUsSUFBR2hWLENBQUgsRUFBSyxPQUFPQSxFQUFFZ1YsQ0FBRixFQUFJLENBQUMsQ0FBTCxDQUFQLENBQWUsSUFBSXFELElBQUUsSUFBSXpDLEtBQUosQ0FBVSx5QkFBdUJaLENBQXZCLEdBQXlCLEdBQW5DLENBQU4sQ0FBOEMsTUFBTXFELEVBQUVRLElBQUYsR0FBTyxrQkFBUCxFQUEwQlIsQ0FBaEM7QUFBa0MscUJBQUl0RCxJQUFFalAsRUFBRWtQLENBQUYsSUFBSyxFQUFDdlcsU0FBUSxFQUFULEVBQVgsQ0FBd0I4WixFQUFFdkQsQ0FBRixFQUFLLENBQUwsRUFBUWxVLElBQVIsQ0FBYWlVLEVBQUV0VyxPQUFmLEVBQXVCLFVBQVNILENBQVQsRUFBVztBQUFDLHdCQUFJd0gsSUFBRXlTLEVBQUV2RCxDQUFGLEVBQUssQ0FBTCxFQUFRMVcsQ0FBUixDQUFOLENBQWlCLE9BQU9tYSxFQUFFM1MsSUFBRUEsQ0FBRixHQUFJeEgsQ0FBTixDQUFQO0FBQWdCLGlCQUFwRSxFQUFxRXlXLENBQXJFLEVBQXVFQSxFQUFFdFcsT0FBekUsRUFBaUZILENBQWpGLEVBQW1GaWEsQ0FBbkYsRUFBcUZ6UyxDQUFyRixFQUF1RjBTLENBQXZGO0FBQTBGLG9CQUFPMVMsRUFBRWtQLENBQUYsRUFBS3ZXLE9BQVo7QUFBb0IsYUFBSXVCLElBQUUsT0FBTzRZLE9BQVAsSUFBZ0IsVUFBaEIsSUFBNEJBLE9BQWxDLENBQTBDLEtBQUksSUFBSTVELElBQUUsQ0FBVixFQUFZQSxJQUFFd0QsRUFBRXRZLE1BQWhCLEVBQXVCOFUsR0FBdkI7QUFBMkJ5RCxjQUFFRCxFQUFFeEQsQ0FBRixDQUFGO0FBQTNCLFNBQW1DLE9BQU95RCxDQUFQO0FBQVMsS0FBemIsQ0FBMmIsRUFBQyxHQUFFLENBQUMsVUFBU0csT0FBVCxFQUFpQnBhLE1BQWpCLEVBQXdCQyxPQUF4QixFQUFnQztBQUNweUI7O0FBQ0FELG1CQUFPQyxPQUFQLEdBQWlCLFVBQVNvSyxPQUFULEVBQWtCO0FBQ25DLG9CQUFJaVEsbUJBQW1CalEsUUFBUWtRLGlCQUEvQjtBQUNBLHlCQUFTQyxHQUFULENBQWFDLFFBQWIsRUFBdUI7QUFDbkIsd0JBQUlDLE1BQU0sSUFBSUosZ0JBQUosQ0FBcUJHLFFBQXJCLENBQVY7QUFDQSx3QkFBSTVELFVBQVU2RCxJQUFJN0QsT0FBSixFQUFkO0FBQ0E2RCx3QkFBSUMsVUFBSixDQUFlLENBQWY7QUFDQUQsd0JBQUlFLFNBQUo7QUFDQUYsd0JBQUlHLElBQUo7QUFDQSwyQkFBT2hFLE9BQVA7QUFDSDs7QUFFRHhNLHdCQUFRbVEsR0FBUixHQUFjLFVBQVVDLFFBQVYsRUFBb0I7QUFDOUIsMkJBQU9ELElBQUlDLFFBQUosQ0FBUDtBQUNILGlCQUZEOztBQUlBcFEsd0JBQVFsSSxTQUFSLENBQWtCcVksR0FBbEIsR0FBd0IsWUFBWTtBQUNoQywyQkFBT0EsSUFBSSxJQUFKLENBQVA7QUFDSCxpQkFGRDtBQUlDLGFBbkJEO0FBcUJDLFNBdkJrd0IsRUF1Qmp3QixFQXZCaXdCLENBQUgsRUF1QjF2QixHQUFFLENBQUMsVUFBU0osT0FBVCxFQUFpQnBhLE1BQWpCLEVBQXdCQyxPQUF4QixFQUFnQztBQUN6Qzs7QUFDQSxnQkFBSTZhLGNBQUo7QUFDQSxnQkFBSTtBQUFDLHNCQUFNLElBQUkxRCxLQUFKLEVBQU47QUFBb0IsYUFBekIsQ0FBMEIsT0FBT3RYLENBQVAsRUFBVTtBQUFDZ2IsaUNBQWlCaGIsQ0FBakI7QUFBb0I7QUFDekQsZ0JBQUlpYixXQUFXWCxRQUFRLFlBQVIsQ0FBZjtBQUNBLGdCQUFJWSxRQUFRWixRQUFRLFNBQVIsQ0FBWjtBQUNBLGdCQUFJYSxPQUFPYixRQUFRLFFBQVIsQ0FBWDs7QUFFQSxxQkFBU2MsS0FBVCxHQUFpQjtBQUNiLHFCQUFLQyxnQkFBTCxHQUF3QixLQUF4QjtBQUNBLHFCQUFLQyxXQUFMLEdBQW1CLEtBQW5CO0FBQ0EscUJBQUtDLFVBQUwsR0FBa0IsSUFBSUwsS0FBSixDQUFVLEVBQVYsQ0FBbEI7QUFDQSxxQkFBS00sWUFBTCxHQUFvQixJQUFJTixLQUFKLENBQVUsRUFBVixDQUFwQjtBQUNBLHFCQUFLTyxrQkFBTCxHQUEwQixLQUExQjtBQUNBLHFCQUFLQyxrQkFBTCxHQUEwQixJQUExQjtBQUNBLG9CQUFJalcsT0FBTyxJQUFYO0FBQ0EscUJBQUtrVyxXQUFMLEdBQW1CLFlBQVk7QUFDM0JsVyx5QkFBS21XLFlBQUw7QUFDSCxpQkFGRDtBQUdBLHFCQUFLQyxTQUFMLEdBQWlCWixRQUFqQjtBQUNIOztBQUVERyxrQkFBTS9ZLFNBQU4sQ0FBZ0J5WixZQUFoQixHQUErQixVQUFTcFosRUFBVCxFQUFhO0FBQ3hDLG9CQUFJcVosT0FBTyxLQUFLRixTQUFoQjtBQUNBLHFCQUFLQSxTQUFMLEdBQWlCblosRUFBakI7QUFDQSxxQkFBSzJZLGdCQUFMLEdBQXdCLElBQXhCO0FBQ0EsdUJBQU9VLElBQVA7QUFDSCxhQUxEOztBQU9BWCxrQkFBTS9ZLFNBQU4sQ0FBZ0IyWixrQkFBaEIsR0FBcUMsWUFBVztBQUM1Qyx1QkFBTyxLQUFLWCxnQkFBWjtBQUNILGFBRkQ7O0FBSUFELGtCQUFNL1ksU0FBTixDQUFnQjRaLGdCQUFoQixHQUFtQyxZQUFXO0FBQzFDLHFCQUFLUCxrQkFBTCxHQUEwQixJQUExQjtBQUNILGFBRkQ7O0FBSUFOLGtCQUFNL1ksU0FBTixDQUFnQjZaLDRCQUFoQixHQUErQyxZQUFXO0FBQ3RELG9CQUFJZixLQUFLZ0IsV0FBVCxFQUFzQjtBQUNsQix5QkFBS1Qsa0JBQUwsR0FBMEIsS0FBMUI7QUFDSDtBQUNKLGFBSkQ7O0FBTUFOLGtCQUFNL1ksU0FBTixDQUFnQitaLGVBQWhCLEdBQWtDLFlBQVk7QUFDMUMsdUJBQU8sS0FBS2QsV0FBTCxJQUFvQixLQUFLRyxrQkFBaEM7QUFDSCxhQUZEOztBQUtBTCxrQkFBTS9ZLFNBQU4sQ0FBZ0JnYSxVQUFoQixHQUE2QixVQUFTcmMsQ0FBVCxFQUFZc2MsTUFBWixFQUFvQjtBQUM3QyxvQkFBSUEsTUFBSixFQUFZO0FBQ1J0Vyw0QkFBUXVXLE1BQVIsQ0FBZUMsS0FBZixDQUFxQixZQUFZeGMsYUFBYXNYLEtBQWIsR0FBcUJ0WCxFQUFFMk8sS0FBdkIsR0FBK0IzTyxDQUEzQyxJQUNqQixJQURKO0FBRUFnRyw0QkFBUXlXLElBQVIsQ0FBYSxDQUFiO0FBQ0gsaUJBSkQsTUFJTztBQUNILHlCQUFLQyxVQUFMLENBQWdCMWMsQ0FBaEI7QUFDSDtBQUNKLGFBUkQ7O0FBVUFvYixrQkFBTS9ZLFNBQU4sQ0FBZ0JxYSxVQUFoQixHQUE2QixVQUFTaGEsRUFBVCxFQUFhMEYsR0FBYixFQUFrQjtBQUMzQyxvQkFBSXpHLFVBQVVDLE1BQVYsS0FBcUIsQ0FBekIsRUFBNEI7QUFDeEJ3RywwQkFBTTFGLEVBQU47QUFDQUEseUJBQUssY0FBWTtBQUFFLDhCQUFNMEYsR0FBTjtBQUFZLHFCQUEvQjtBQUNIO0FBQ0Qsb0JBQUksT0FBT29QLFVBQVAsS0FBc0IsV0FBMUIsRUFBdUM7QUFDbkNBLCtCQUFXLFlBQVc7QUFDbEI5VSwyQkFBRzBGLEdBQUg7QUFDSCxxQkFGRCxFQUVHLENBRkg7QUFHSCxpQkFKRCxNQUlPLElBQUk7QUFDUCx5QkFBS3lULFNBQUwsQ0FBZSxZQUFXO0FBQ3RCblosMkJBQUcwRixHQUFIO0FBQ0gscUJBRkQ7QUFHSCxpQkFKTSxDQUlMLE9BQU9wSSxDQUFQLEVBQVU7QUFDUiwwQkFBTSxJQUFJc1gsS0FBSixDQUFVLGdFQUFWLENBQU47QUFDSDtBQUNKLGFBaEJEOztBQWtCQSxxQkFBU3FGLGdCQUFULENBQTBCamEsRUFBMUIsRUFBOEJrYSxRQUE5QixFQUF3Q3hVLEdBQXhDLEVBQTZDO0FBQ3pDLHFCQUFLbVQsVUFBTCxDQUFnQjdPLElBQWhCLENBQXFCaEssRUFBckIsRUFBeUJrYSxRQUF6QixFQUFtQ3hVLEdBQW5DO0FBQ0EscUJBQUt5VSxVQUFMO0FBQ0g7O0FBRUQscUJBQVNDLFdBQVQsQ0FBcUJwYSxFQUFyQixFQUF5QmthLFFBQXpCLEVBQW1DeFUsR0FBbkMsRUFBd0M7QUFDcEMscUJBQUtvVCxZQUFMLENBQWtCOU8sSUFBbEIsQ0FBdUJoSyxFQUF2QixFQUEyQmthLFFBQTNCLEVBQXFDeFUsR0FBckM7QUFDQSxxQkFBS3lVLFVBQUw7QUFDSDs7QUFFRCxxQkFBU0UsbUJBQVQsQ0FBNkJoRyxPQUE3QixFQUFzQztBQUNsQyxxQkFBS3lFLFlBQUwsQ0FBa0J3QixRQUFsQixDQUEyQmpHLE9BQTNCO0FBQ0EscUJBQUs4RixVQUFMO0FBQ0g7O0FBRUQsZ0JBQUksQ0FBQzFCLEtBQUtnQixXQUFWLEVBQXVCO0FBQ25CZixzQkFBTS9ZLFNBQU4sQ0FBZ0I0YSxXQUFoQixHQUE4Qk4sZ0JBQTlCO0FBQ0F2QixzQkFBTS9ZLFNBQU4sQ0FBZ0I2YSxNQUFoQixHQUF5QkosV0FBekI7QUFDQTFCLHNCQUFNL1ksU0FBTixDQUFnQjhhLGNBQWhCLEdBQWlDSixtQkFBakM7QUFDSCxhQUpELE1BSU87QUFDSDNCLHNCQUFNL1ksU0FBTixDQUFnQjRhLFdBQWhCLEdBQThCLFVBQVV2YSxFQUFWLEVBQWNrYSxRQUFkLEVBQXdCeFUsR0FBeEIsRUFBNkI7QUFDdkQsd0JBQUksS0FBS3NULGtCQUFULEVBQTZCO0FBQ3pCaUIseUNBQWlCbmEsSUFBakIsQ0FBc0IsSUFBdEIsRUFBNEJFLEVBQTVCLEVBQWdDa2EsUUFBaEMsRUFBMEN4VSxHQUExQztBQUNILHFCQUZELE1BRU87QUFDSCw2QkFBS3lULFNBQUwsQ0FBZSxZQUFXO0FBQ3RCckUsdUNBQVcsWUFBVztBQUNsQjlVLG1DQUFHRixJQUFILENBQVFvYSxRQUFSLEVBQWtCeFUsR0FBbEI7QUFDSCw2QkFGRCxFQUVHLEdBRkg7QUFHSCx5QkFKRDtBQUtIO0FBQ0osaUJBVkQ7O0FBWUFnVCxzQkFBTS9ZLFNBQU4sQ0FBZ0I2YSxNQUFoQixHQUF5QixVQUFVeGEsRUFBVixFQUFja2EsUUFBZCxFQUF3QnhVLEdBQXhCLEVBQTZCO0FBQ2xELHdCQUFJLEtBQUtzVCxrQkFBVCxFQUE2QjtBQUN6Qm9CLG9DQUFZdGEsSUFBWixDQUFpQixJQUFqQixFQUF1QkUsRUFBdkIsRUFBMkJrYSxRQUEzQixFQUFxQ3hVLEdBQXJDO0FBQ0gscUJBRkQsTUFFTztBQUNILDZCQUFLeVQsU0FBTCxDQUFlLFlBQVc7QUFDdEJuWiwrQkFBR0YsSUFBSCxDQUFRb2EsUUFBUixFQUFrQnhVLEdBQWxCO0FBQ0gseUJBRkQ7QUFHSDtBQUNKLGlCQVJEOztBQVVBZ1Qsc0JBQU0vWSxTQUFOLENBQWdCOGEsY0FBaEIsR0FBaUMsVUFBU3BHLE9BQVQsRUFBa0I7QUFDL0Msd0JBQUksS0FBSzJFLGtCQUFULEVBQTZCO0FBQ3pCcUIsNENBQW9CdmEsSUFBcEIsQ0FBeUIsSUFBekIsRUFBK0J1VSxPQUEvQjtBQUNILHFCQUZELE1BRU87QUFDSCw2QkFBSzhFLFNBQUwsQ0FBZSxZQUFXO0FBQ3RCOUUsb0NBQVFxRyxlQUFSO0FBQ0gseUJBRkQ7QUFHSDtBQUNKLGlCQVJEO0FBU0g7O0FBRURoQyxrQkFBTS9ZLFNBQU4sQ0FBZ0JnYixXQUFoQixHQUE4QixVQUFTdkYsS0FBVCxFQUFnQjtBQUMxQyx1QkFBT0EsTUFBTWxXLE1BQU4sS0FBaUIsQ0FBeEIsRUFBMkI7QUFDdkIsd0JBQUljLEtBQUtvVixNQUFNd0YsS0FBTixFQUFUO0FBQ0Esd0JBQUksT0FBTzVhLEVBQVAsS0FBYyxVQUFsQixFQUE4QjtBQUMxQkEsMkJBQUcwYSxlQUFIO0FBQ0E7QUFDSDtBQUNELHdCQUFJUixXQUFXOUUsTUFBTXdGLEtBQU4sRUFBZjtBQUNBLHdCQUFJbFYsTUFBTTBQLE1BQU13RixLQUFOLEVBQVY7QUFDQTVhLHVCQUFHRixJQUFILENBQVFvYSxRQUFSLEVBQWtCeFUsR0FBbEI7QUFDSDtBQUNKLGFBWEQ7O0FBYUFnVCxrQkFBTS9ZLFNBQU4sQ0FBZ0J1WixZQUFoQixHQUErQixZQUFZO0FBQ3ZDLHFCQUFLeUIsV0FBTCxDQUFpQixLQUFLN0IsWUFBdEI7QUFDQSxxQkFBSytCLE1BQUw7QUFDQSxxQkFBSzlCLGtCQUFMLEdBQTBCLElBQTFCO0FBQ0EscUJBQUs0QixXQUFMLENBQWlCLEtBQUs5QixVQUF0QjtBQUNILGFBTEQ7O0FBT0FILGtCQUFNL1ksU0FBTixDQUFnQndhLFVBQWhCLEdBQTZCLFlBQVk7QUFDckMsb0JBQUksQ0FBQyxLQUFLdkIsV0FBVixFQUF1QjtBQUNuQix5QkFBS0EsV0FBTCxHQUFtQixJQUFuQjtBQUNBLHlCQUFLTyxTQUFMLENBQWUsS0FBS0YsV0FBcEI7QUFDSDtBQUNKLGFBTEQ7O0FBT0FQLGtCQUFNL1ksU0FBTixDQUFnQmtiLE1BQWhCLEdBQXlCLFlBQVk7QUFDakMscUJBQUtqQyxXQUFMLEdBQW1CLEtBQW5CO0FBQ0gsYUFGRDs7QUFJQXBiLG1CQUFPQyxPQUFQLEdBQWlCaWIsS0FBakI7QUFDQWxiLG1CQUFPQyxPQUFQLENBQWU2YSxjQUFmLEdBQWdDQSxjQUFoQztBQUVDLFNBbktPLEVBbUtOLEVBQUMsV0FBVSxFQUFYLEVBQWMsY0FBYSxFQUEzQixFQUE4QixVQUFTLEVBQXZDLEVBbktNLENBdkJ3dkIsRUEwTGx0QixHQUFFLENBQUMsVUFBU1YsT0FBVCxFQUFpQnBhLE1BQWpCLEVBQXdCQyxPQUF4QixFQUFnQztBQUNqRjs7QUFDQUQsbUJBQU9DLE9BQVAsR0FBaUIsVUFBU29LLE9BQVQsRUFBa0JpVCxRQUFsQixFQUE0QkMsbUJBQTVCLEVBQWlEQyxLQUFqRCxFQUF3RDtBQUN6RSxvQkFBSUMsYUFBYSxLQUFqQjtBQUNBLG9CQUFJQyxhQUFhLFNBQWJBLFVBQWEsQ0FBU0MsQ0FBVCxFQUFZN2QsQ0FBWixFQUFlO0FBQzVCLHlCQUFLOGQsT0FBTCxDQUFhOWQsQ0FBYjtBQUNILGlCQUZEOztBQUlBLG9CQUFJK2QsaUJBQWlCLFNBQWpCQSxjQUFpQixDQUFTL2QsQ0FBVCxFQUFZZ2UsT0FBWixFQUFxQjtBQUN0Q0EsNEJBQVFDLHNCQUFSLEdBQWlDLElBQWpDO0FBQ0FELDRCQUFRRSxjQUFSLENBQXVCQyxLQUF2QixDQUE2QlAsVUFBN0IsRUFBeUNBLFVBQXpDLEVBQXFELElBQXJELEVBQTJELElBQTNELEVBQWlFNWQsQ0FBakU7QUFDSCxpQkFIRDs7QUFLQSxvQkFBSW9lLGtCQUFrQixTQUFsQkEsZUFBa0IsQ0FBU3hYLE9BQVQsRUFBa0JvWCxPQUFsQixFQUEyQjtBQUM3Qyx3QkFBSyxDQUFDLEtBQUtLLFNBQUwsR0FBaUIsUUFBbEIsTUFBZ0MsQ0FBckMsRUFBeUM7QUFDckMsNkJBQUtDLGdCQUFMLENBQXNCTixRQUFRTyxNQUE5QjtBQUNIO0FBQ0osaUJBSkQ7O0FBTUEsb0JBQUlDLGtCQUFrQixTQUFsQkEsZUFBa0IsQ0FBU3hlLENBQVQsRUFBWWdlLE9BQVosRUFBcUI7QUFDdkMsd0JBQUksQ0FBQ0EsUUFBUUMsc0JBQWIsRUFBcUMsS0FBS0gsT0FBTCxDQUFhOWQsQ0FBYjtBQUN4QyxpQkFGRDs7QUFJQXVLLHdCQUFRbEksU0FBUixDQUFrQnpCLElBQWxCLEdBQXlCLFVBQVVnRyxPQUFWLEVBQW1CO0FBQ3hDLHdCQUFJLENBQUMrVyxVQUFMLEVBQWlCO0FBQ2JBLHFDQUFhLElBQWI7QUFDQXBULGdDQUFRbEksU0FBUixDQUFrQm9jLGNBQWxCLEdBQW1DZixNQUFNZ0IscUJBQU4sRUFBbkM7QUFDQW5VLGdDQUFRbEksU0FBUixDQUFrQnNjLFdBQWxCLEdBQWdDakIsTUFBTWtCLGtCQUFOLEVBQWhDO0FBQ0g7QUFDRCx3QkFBSUMsZUFBZXBCLG9CQUFvQjdXLE9BQXBCLENBQW5CO0FBQ0Esd0JBQUlnVSxNQUFNLElBQUlyUSxPQUFKLENBQVlpVCxRQUFaLENBQVY7QUFDQTVDLHdCQUFJNkQsY0FBSixDQUFtQixJQUFuQixFQUF5QixDQUF6QjtBQUNBLHdCQUFJRixTQUFTLEtBQUtPLE9BQUwsRUFBYjtBQUNBbEUsd0JBQUltRSxXQUFKLENBQWdCRixZQUFoQjtBQUNBLHdCQUFJQSx3QkFBd0J0VSxPQUE1QixFQUFxQztBQUNqQyw0QkFBSXlULFVBQVU7QUFDVkMsb0RBQXdCLEtBRGQ7QUFFVmxILHFDQUFTNkQsR0FGQztBQUdWMkQsb0NBQVFBLE1BSEU7QUFJVkwsNENBQWdCVztBQUpOLHlCQUFkO0FBTUFOLCtCQUFPSixLQUFQLENBQWFYLFFBQWIsRUFBdUJPLGNBQXZCLEVBQXVDbFcsU0FBdkMsRUFBa0QrUyxHQUFsRCxFQUF1RG9ELE9BQXZEO0FBQ0FhLHFDQUFhVixLQUFiLENBQ0lDLGVBREosRUFDcUJJLGVBRHJCLEVBQ3NDM1csU0FEdEMsRUFDaUQrUyxHQURqRCxFQUNzRG9ELE9BRHREO0FBRUFwRCw0QkFBSW9FLFlBQUosQ0FBaUJILFlBQWpCO0FBQ0gscUJBWEQsTUFXTztBQUNIakUsNEJBQUkwRCxnQkFBSixDQUFxQkMsTUFBckI7QUFDSDtBQUNELDJCQUFPM0QsR0FBUDtBQUNILGlCQTFCRDs7QUE0QkFyUSx3QkFBUWxJLFNBQVIsQ0FBa0IwYyxXQUFsQixHQUFnQyxVQUFVemQsR0FBVixFQUFlO0FBQzNDLHdCQUFJQSxRQUFRdUcsU0FBWixFQUF1QjtBQUNuQiw2QkFBS3dXLFNBQUwsR0FBaUIsS0FBS0EsU0FBTCxHQUFpQixPQUFsQztBQUNBLDZCQUFLWSxRQUFMLEdBQWdCM2QsR0FBaEI7QUFDSCxxQkFIRCxNQUdPO0FBQ0gsNkJBQUsrYyxTQUFMLEdBQWlCLEtBQUtBLFNBQUwsR0FBa0IsQ0FBQyxPQUFwQztBQUNIO0FBQ0osaUJBUEQ7O0FBU0E5VCx3QkFBUWxJLFNBQVIsQ0FBa0I2YyxRQUFsQixHQUE2QixZQUFZO0FBQ3JDLDJCQUFPLENBQUMsS0FBS2IsU0FBTCxHQUFpQixPQUFsQixNQUErQixPQUF0QztBQUNILGlCQUZEOztBQUlBOVQsd0JBQVEzSixJQUFSLEdBQWUsVUFBVWdHLE9BQVYsRUFBbUJILEtBQW5CLEVBQTBCO0FBQ3JDLDJCQUFPOEQsUUFBUTZJLE9BQVIsQ0FBZ0IzTSxLQUFoQixFQUF1QjdGLElBQXZCLENBQTRCZ0csT0FBNUIsQ0FBUDtBQUNILGlCQUZEO0FBR0MsYUFqRUQ7QUFtRUMsU0FyRStDLEVBcUU5QyxFQXJFOEMsQ0ExTGd0QixFQStQMXZCLEdBQUUsQ0FBQyxVQUFTMFQsT0FBVCxFQUFpQnBhLE1BQWpCLEVBQXdCQyxPQUF4QixFQUFnQztBQUN6Qzs7QUFDQSxnQkFBSWdmLEdBQUo7QUFDQSxnQkFBSSxPQUFPNVUsT0FBUCxLQUFtQixXQUF2QixFQUFvQzRVLE1BQU01VSxPQUFOO0FBQ3BDLHFCQUFTNlUsVUFBVCxHQUFzQjtBQUNsQixvQkFBSTtBQUFFLHdCQUFJN1UsWUFBWThVLFFBQWhCLEVBQTBCOVUsVUFBVTRVLEdBQVY7QUFBZ0IsaUJBQWhELENBQ0EsT0FBT25mLENBQVAsRUFBVSxDQUFFO0FBQ1osdUJBQU9xZixRQUFQO0FBQ0g7QUFDRCxnQkFBSUEsV0FBVy9FLFFBQVEsV0FBUixHQUFmO0FBQ0ErRSxxQkFBU0QsVUFBVCxHQUFzQkEsVUFBdEI7QUFDQWxmLG1CQUFPQyxPQUFQLEdBQWlCa2YsUUFBakI7QUFFQyxTQWJPLEVBYU4sRUFBQyxhQUFZLEVBQWIsRUFiTSxDQS9Qd3ZCLEVBNFE1dUIsR0FBRSxDQUFDLFVBQVMvRSxPQUFULEVBQWlCcGEsTUFBakIsRUFBd0JDLE9BQXhCLEVBQWdDO0FBQ3ZEOztBQUNBLGdCQUFJbWYsS0FBS2xlLE9BQU9kLE1BQWhCO0FBQ0EsZ0JBQUlnZixFQUFKLEVBQVE7QUFDSixvQkFBSUMsY0FBY0QsR0FBRyxJQUFILENBQWxCO0FBQ0Esb0JBQUlFLGNBQWNGLEdBQUcsSUFBSCxDQUFsQjtBQUNBQyw0QkFBWSxPQUFaLElBQXVCQyxZQUFZLE9BQVosSUFBdUIsQ0FBOUM7QUFDSDs7QUFFRHRmLG1CQUFPQyxPQUFQLEdBQWlCLFVBQVNvSyxPQUFULEVBQWtCO0FBQ25DLG9CQUFJNFEsT0FBT2IsUUFBUSxRQUFSLENBQVg7QUFDQSxvQkFBSW1GLGNBQWN0RSxLQUFLc0UsV0FBdkI7QUFDQSxvQkFBSUMsZUFBZXZFLEtBQUt1RSxZQUF4Qjs7QUFFQSxvQkFBSUMsZUFBSjtBQUNBLG9CQUFJQyxTQUFKO0FBQ0Esb0JBQUksS0FBSixFQUFXO0FBQ1gsd0JBQUlDLG1CQUFtQixTQUFuQkEsZ0JBQW1CLENBQVVDLFVBQVYsRUFBc0I7QUFDekMsK0JBQU8sSUFBSWhnQixRQUFKLENBQWEsY0FBYixFQUE2Qjs7Ozs7Ozs7Ozs7Ozs7U0FBQSxDQWM5QjJDLE9BZDhCLENBY3RCLGFBZHNCLEVBY1BxZCxVQWRPLENBQTdCLEVBY21DQyxZQWRuQyxDQUFQO0FBZUgscUJBaEJEOztBQWtCQSx3QkFBSUMsYUFBYSxTQUFiQSxVQUFhLENBQVVDLFlBQVYsRUFBd0I7QUFDckMsK0JBQU8sSUFBSW5nQixRQUFKLENBQWEsS0FBYixFQUFvQjs7O1NBQUEsQ0FHckIyQyxPQUhxQixDQUdiLGNBSGEsRUFHR3dkLFlBSEgsQ0FBcEIsQ0FBUDtBQUlILHFCQUxEOztBQU9BLHdCQUFJQyxjQUFjLFNBQWRBLFdBQWMsQ0FBUzdHLElBQVQsRUFBZThHLFFBQWYsRUFBeUIzUyxLQUF6QixFQUFnQztBQUM5Qyw0QkFBSW9OLE1BQU1wTixNQUFNNkwsSUFBTixDQUFWO0FBQ0EsNEJBQUksT0FBT3VCLEdBQVAsS0FBZSxVQUFuQixFQUErQjtBQUMzQixnQ0FBSSxDQUFDOEUsYUFBYXJHLElBQWIsQ0FBTCxFQUF5QjtBQUNyQix1Q0FBTyxJQUFQO0FBQ0g7QUFDRHVCLGtDQUFNdUYsU0FBUzlHLElBQVQsQ0FBTjtBQUNBN0wsa0NBQU02TCxJQUFOLElBQWN1QixHQUFkO0FBQ0FwTixrQ0FBTSxPQUFOO0FBQ0EsZ0NBQUlBLE1BQU0sT0FBTixJQUFpQixHQUFyQixFQUEwQjtBQUN0QixvQ0FBSTNFLE9BQU96SCxPQUFPeUgsSUFBUCxDQUFZMkUsS0FBWixDQUFYO0FBQ0EscUNBQUssSUFBSTlMLElBQUksQ0FBYixFQUFnQkEsSUFBSSxHQUFwQixFQUF5QixFQUFFQSxDQUEzQjtBQUE4QiwyQ0FBTzhMLE1BQU0zRSxLQUFLbkgsQ0FBTCxDQUFOLENBQVA7QUFBOUIsaUNBQ0E4TCxNQUFNLE9BQU4sSUFBaUIzRSxLQUFLakgsTUFBTCxHQUFjLEdBQS9CO0FBQ0g7QUFDSjtBQUNELCtCQUFPZ1osR0FBUDtBQUNILHFCQWhCRDs7QUFrQkErRSxzQ0FBa0IseUJBQVN0RyxJQUFULEVBQWU7QUFDN0IsK0JBQU82RyxZQUFZN0csSUFBWixFQUFrQndHLGdCQUFsQixFQUFvQ04sV0FBcEMsQ0FBUDtBQUNILHFCQUZEOztBQUlBSyxnQ0FBWSxtQkFBU3ZHLElBQVQsRUFBZTtBQUN2QiwrQkFBTzZHLFlBQVk3RyxJQUFaLEVBQWtCMkcsVUFBbEIsRUFBOEJSLFdBQTlCLENBQVA7QUFDSCxxQkFGRDtBQUdDOztBQUVELHlCQUFTTyxZQUFULENBQXNCemUsR0FBdEIsRUFBMkJ3ZSxVQUEzQixFQUF1QztBQUNuQyx3QkFBSXBkLEVBQUo7QUFDQSx3QkFBSXBCLE9BQU8sSUFBWCxFQUFpQm9CLEtBQUtwQixJQUFJd2UsVUFBSixDQUFMO0FBQ2pCLHdCQUFJLE9BQU9wZCxFQUFQLEtBQWMsVUFBbEIsRUFBOEI7QUFDMUIsNEJBQUlpUyxVQUFVLFlBQVl3RyxLQUFLaUYsV0FBTCxDQUFpQjllLEdBQWpCLENBQVosR0FBb0Msa0JBQXBDLEdBQ1Y2WixLQUFLalksUUFBTCxDQUFjNGMsVUFBZCxDQURVLEdBQ2tCLEdBRGhDO0FBRUEsOEJBQU0sSUFBSXZWLFFBQVF5SyxTQUFaLENBQXNCTCxPQUF0QixDQUFOO0FBQ0g7QUFDRCwyQkFBT2pTLEVBQVA7QUFDSDs7QUFFRCx5QkFBUzJkLE1BQVQsQ0FBZ0IvZSxHQUFoQixFQUFxQjtBQUNqQix3QkFBSXdlLGFBQWEsS0FBS3hULEdBQUwsRUFBakI7QUFDQSx3QkFBSTVKLEtBQUtxZCxhQUFhemUsR0FBYixFQUFrQndlLFVBQWxCLENBQVQ7QUFDQSwyQkFBT3BkLEdBQUdSLEtBQUgsQ0FBU1osR0FBVCxFQUFjLElBQWQsQ0FBUDtBQUNIO0FBQ0RpSix3QkFBUWxJLFNBQVIsQ0FBa0JHLElBQWxCLEdBQXlCLFVBQVVzZCxVQUFWLEVBQXNCO0FBQzNDLHdCQUFJalosT0FBTyxHQUFHaEcsS0FBSCxDQUFTMkIsSUFBVCxDQUFjYixTQUFkLEVBQXlCLENBQXpCLENBQVgsQ0FBdUM7QUFDdkMsd0JBQUksS0FBSixFQUFXO0FBQ1AsNEJBQUk4ZCxXQUFKLEVBQWlCO0FBQ2IsZ0NBQUlhLGNBQWNYLGdCQUFnQkcsVUFBaEIsQ0FBbEI7QUFDQSxnQ0FBSVEsZ0JBQWdCLElBQXBCLEVBQTBCO0FBQ3RCLHVDQUFPLEtBQUtuQyxLQUFMLENBQ0htQyxXQURHLEVBQ1V6WSxTQURWLEVBQ3FCQSxTQURyQixFQUNnQ2hCLElBRGhDLEVBQ3NDZ0IsU0FEdEMsQ0FBUDtBQUVIO0FBQ0o7QUFDSjtBQUNEaEIseUJBQUs2RixJQUFMLENBQVVvVCxVQUFWO0FBQ0EsMkJBQU8sS0FBSzNCLEtBQUwsQ0FBV2tDLE1BQVgsRUFBbUJ4WSxTQUFuQixFQUE4QkEsU0FBOUIsRUFBeUNoQixJQUF6QyxFQUErQ2dCLFNBQS9DLENBQVA7QUFDSCxpQkFiRDs7QUFlQSx5QkFBUzBZLFdBQVQsQ0FBcUJqZixHQUFyQixFQUEwQjtBQUN0QiwyQkFBT0EsSUFBSSxJQUFKLENBQVA7QUFDSDtBQUNELHlCQUFTa2YsYUFBVCxDQUF1QmxmLEdBQXZCLEVBQTRCO0FBQ3hCLHdCQUFJdUIsUUFBUSxDQUFDLElBQWI7QUFDQSx3QkFBSUEsUUFBUSxDQUFaLEVBQWVBLFFBQVFxSCxLQUFLQyxHQUFMLENBQVMsQ0FBVCxFQUFZdEgsUUFBUXZCLElBQUlNLE1BQXhCLENBQVI7QUFDZiwyQkFBT04sSUFBSXVCLEtBQUosQ0FBUDtBQUNIO0FBQ0QwSCx3QkFBUWxJLFNBQVIsQ0FBa0IySixHQUFsQixHQUF3QixVQUFVaVUsWUFBVixFQUF3QjtBQUM1Qyx3QkFBSWxTLFVBQVcsT0FBT2tTLFlBQVAsS0FBd0IsUUFBdkM7QUFDQSx3QkFBSVEsTUFBSjtBQUNBLHdCQUFJLENBQUMxUyxPQUFMLEVBQWM7QUFDViw0QkFBSTBSLFdBQUosRUFBaUI7QUFDYixnQ0FBSWlCLGNBQWNkLFVBQVVLLFlBQVYsQ0FBbEI7QUFDQVEscUNBQVNDLGdCQUFnQixJQUFoQixHQUF1QkEsV0FBdkIsR0FBcUNILFdBQTlDO0FBQ0gseUJBSEQsTUFHTztBQUNIRSxxQ0FBU0YsV0FBVDtBQUNIO0FBQ0oscUJBUEQsTUFPTztBQUNIRSxpQ0FBU0QsYUFBVDtBQUNIO0FBQ0QsMkJBQU8sS0FBS3JDLEtBQUwsQ0FBV3NDLE1BQVgsRUFBbUI1WSxTQUFuQixFQUE4QkEsU0FBOUIsRUFBeUNvWSxZQUF6QyxFQUF1RHBZLFNBQXZELENBQVA7QUFDSCxpQkFkRDtBQWVDLGFBbEhEO0FBb0hDLFNBN0hxQixFQTZIcEIsRUFBQyxVQUFTLEVBQVYsRUE3SG9CLENBNVEwdUIsRUF5WS91QixHQUFFLENBQUMsVUFBU3lTLE9BQVQsRUFBaUJwYSxNQUFqQixFQUF3QkMsT0FBeEIsRUFBZ0M7QUFDcEQ7O0FBQ0FELG1CQUFPQyxPQUFQLEdBQWlCLFVBQVNvSyxPQUFULEVBQWtCb1csWUFBbEIsRUFBZ0NDLFlBQWhDLEVBQThDbEQsS0FBOUMsRUFBcUQ7QUFDdEUsb0JBQUl2QyxPQUFPYixRQUFRLFFBQVIsQ0FBWDtBQUNBLG9CQUFJdUcsV0FBVzFGLEtBQUswRixRQUFwQjtBQUNBLG9CQUFJQyxXQUFXM0YsS0FBSzJGLFFBQXBCO0FBQ0Esb0JBQUlDLFFBQVF4VyxRQUFReVcsTUFBcEI7O0FBRUF6Vyx3QkFBUWxJLFNBQVIsQ0FBa0IsT0FBbEIsSUFBNkJrSSxRQUFRbEksU0FBUixDQUFrQjRlLE1BQWxCLEdBQTJCLFlBQVc7QUFDL0Qsd0JBQUksQ0FBQ3ZELE1BQU13RCxZQUFOLEVBQUwsRUFBMkIsT0FBTyxLQUFLQyxLQUFMLENBQVcsMEJBQVgsQ0FBUDs7QUFFM0Isd0JBQUlwSyxVQUFVLElBQWQ7QUFDQSx3QkFBSXFLLFFBQVFySyxPQUFaO0FBQ0EsMkJBQU9BLFFBQVFzSyxjQUFSLEVBQVAsRUFBaUM7QUFDN0IsNEJBQUksQ0FBQ3RLLFFBQVF1SyxTQUFSLENBQWtCRixLQUFsQixDQUFMLEVBQStCO0FBQzNCLGdDQUFJQSxNQUFNRyxZQUFOLEVBQUosRUFBMEI7QUFDdEJILHNDQUFNSSxTQUFOLEdBQWtCUCxNQUFsQjtBQUNILDZCQUZELE1BRU87QUFDSEcsc0NBQU1LLGVBQU47QUFDSDtBQUNEO0FBQ0g7O0FBRUQsNEJBQUlDLFNBQVMzSyxRQUFRNEssbUJBQXJCO0FBQ0EsNEJBQUlELFVBQVUsSUFBVixJQUFrQixDQUFDQSxPQUFPTCxjQUFQLEVBQXZCLEVBQWdEO0FBQzVDLGdDQUFJdEssUUFBUXdLLFlBQVIsRUFBSixFQUE0QjtBQUN4QnhLLHdDQUFReUssU0FBUixHQUFvQlAsTUFBcEI7QUFDSCw2QkFGRCxNQUVPO0FBQ0hsSyx3Q0FBUTBLLGVBQVI7QUFDSDtBQUNEO0FBQ0gseUJBUEQsTUFPTztBQUNILGdDQUFJMUssUUFBUXdLLFlBQVIsRUFBSixFQUE0QnhLLFFBQVF5SyxTQUFSLEdBQW9CUCxNQUFwQjtBQUM1QmxLLG9DQUFRNkssbUJBQVI7QUFDQVIsb0NBQVFySyxPQUFSO0FBQ0FBLHNDQUFVMkssTUFBVjtBQUNIO0FBQ0o7QUFDSixpQkE5QkQ7O0FBZ0NBblgsd0JBQVFsSSxTQUFSLENBQWtCd2YsbUJBQWxCLEdBQXdDLFlBQVc7QUFDL0MseUJBQUtDLDBCQUFMO0FBQ0gsaUJBRkQ7O0FBSUF2WCx3QkFBUWxJLFNBQVIsQ0FBa0IwZiw0QkFBbEIsR0FBaUQsWUFBVztBQUN4RCwyQkFBTyxLQUFLRCwwQkFBTCxLQUFvQ2phLFNBQXBDLElBQ0EsS0FBS2lhLDBCQUFMLElBQW1DLENBRDFDO0FBRUgsaUJBSEQ7O0FBS0F2WCx3QkFBUWxJLFNBQVIsQ0FBa0JpZixTQUFsQixHQUE4QixVQUFTVSxTQUFULEVBQW9CO0FBQzlDLHdCQUFJQSxjQUFjLElBQWxCLEVBQXdCO0FBQ3BCLDZCQUFLRiwwQkFBTCxHQUFrQyxDQUFsQztBQUNBLDZCQUFLRyxlQUFMO0FBQ0EsK0JBQU8sSUFBUDtBQUNILHFCQUpELE1BSU87QUFDSCw2QkFBS0osbUJBQUw7QUFDQSw0QkFBSSxLQUFLRSw0QkFBTCxFQUFKLEVBQXlDO0FBQ3JDLGlDQUFLRSxlQUFMO0FBQ0EsbUNBQU8sSUFBUDtBQUNIO0FBQ0o7QUFDRCwyQkFBTyxLQUFQO0FBQ0gsaUJBYkQ7O0FBZUExWCx3QkFBUWxJLFNBQVIsQ0FBa0JvZixlQUFsQixHQUFvQyxZQUFXO0FBQzNDLHdCQUFJLEtBQUtNLDRCQUFMLEVBQUosRUFBeUM7QUFDckMsNkJBQUtHLE9BQUw7QUFDSDtBQUNKLGlCQUpEOztBQU1BM1gsd0JBQVFsSSxTQUFSLENBQWtCNmYsT0FBbEIsR0FBNEIsWUFBVztBQUNuQyx3QkFBSSxDQUFDLEtBQUtiLGNBQUwsRUFBTCxFQUE0QjtBQUM1Qix5QkFBS2MsYUFBTDtBQUNBcEIsMEJBQU03RCxNQUFOLENBQWEsS0FBS2tGLGVBQWxCLEVBQW1DLElBQW5DLEVBQXlDdmEsU0FBekM7QUFDSCxpQkFKRDs7QUFNQTBDLHdCQUFRbEksU0FBUixDQUFrQitmLGVBQWxCLEdBQW9DLFlBQVc7QUFDM0Msd0JBQUksS0FBS0MsT0FBTCxLQUFpQixDQUFyQixFQUF3QixLQUFLakYsZUFBTDtBQUMzQixpQkFGRDs7QUFJQTdTLHdCQUFRbEksU0FBUixDQUFrQmlnQixjQUFsQixHQUFtQyxZQUFXO0FBQzFDLHlCQUFLQyxjQUFMLEdBQXNCMWEsU0FBdEI7QUFDSCxpQkFGRDs7QUFJQTBDLHdCQUFRbEksU0FBUixDQUFrQmdmLGNBQWxCLEdBQW1DLFlBQVc7QUFDMUMsMkJBQU8sS0FBS21CLFNBQUwsTUFBb0IsQ0FBQyxLQUFLQyxZQUFMLEVBQTVCO0FBQ0gsaUJBRkQ7O0FBSUFsWSx3QkFBUWxJLFNBQVIsQ0FBa0JxZ0IsYUFBbEIsR0FBa0MsWUFBVztBQUN6QywyQkFBTyxLQUFLRixTQUFMLE1BQW9CLENBQUMsS0FBS0csV0FBTCxFQUE1QjtBQUNILGlCQUZEOztBQUlBcFksd0JBQVFsSSxTQUFSLENBQWtCdWdCLGlCQUFsQixHQUFzQyxVQUFTQyxnQkFBVCxFQUEyQkMsWUFBM0IsRUFBeUM7QUFDM0Usd0JBQUkzSCxLQUFLdk4sT0FBTCxDQUFhaVYsZ0JBQWIsQ0FBSixFQUFvQztBQUNoQyw2QkFBSyxJQUFJbmhCLElBQUksQ0FBYixFQUFnQkEsSUFBSW1oQixpQkFBaUJqaEIsTUFBckMsRUFBNkMsRUFBRUYsQ0FBL0MsRUFBa0Q7QUFDOUMsaUNBQUtraEIsaUJBQUwsQ0FBdUJDLGlCQUFpQm5oQixDQUFqQixDQUF2QixFQUE0Q29oQixZQUE1QztBQUNIO0FBQ0oscUJBSkQsTUFJTyxJQUFJRCxxQkFBcUJoYixTQUF6QixFQUFvQztBQUN2Qyw0QkFBSSxPQUFPZ2IsZ0JBQVAsS0FBNEIsVUFBaEMsRUFBNEM7QUFDeEMsZ0NBQUksQ0FBQ0MsWUFBTCxFQUFtQjtBQUNmLG9DQUFJOWlCLElBQUk2Z0IsU0FBU2dDLGdCQUFULEVBQTJCcmdCLElBQTNCLENBQWdDLEtBQUttYyxXQUFMLEVBQWhDLENBQVI7QUFDQSxvQ0FBSTNlLE1BQU04Z0IsUUFBVixFQUFvQjtBQUNoQix5Q0FBS2lDLGlCQUFMLENBQXVCL2lCLEVBQUVBLENBQXpCO0FBQ0ErZ0IsMENBQU1yRSxVQUFOLENBQWlCMWMsRUFBRUEsQ0FBbkI7QUFDSDtBQUNKO0FBQ0oseUJBUkQsTUFRTztBQUNINmlCLDZDQUFpQkcsZ0JBQWpCLENBQWtDLElBQWxDO0FBQ0g7QUFDSjtBQUNKLGlCQWxCRDs7QUFvQkF6WSx3QkFBUWxJLFNBQVIsQ0FBa0I0ZixlQUFsQixHQUFvQyxZQUFXO0FBQzNDLHdCQUFJWSxtQkFBbUIsS0FBS0ksU0FBTCxFQUF2QjtBQUNBLHlCQUFLWCxjQUFMO0FBQ0F2QiwwQkFBTTdELE1BQU4sQ0FBYSxLQUFLMEYsaUJBQWxCLEVBQXFDLElBQXJDLEVBQTJDQyxnQkFBM0M7QUFDSCxpQkFKRDs7QUFNQXRZLHdCQUFRbEksU0FBUixDQUFrQjZnQix1QkFBbEIsR0FBNEMsWUFBVztBQUNuRCx3QkFBSSxLQUFLN0IsY0FBTCxFQUFKLEVBQTJCO0FBQ3ZCLDZCQUFLdUIsaUJBQUwsQ0FBdUIsS0FBS0ssU0FBTCxFQUF2QixFQUF5QyxJQUF6QztBQUNBLDZCQUFLWCxjQUFMO0FBQ0g7QUFDSixpQkFMRDs7QUFPQS9YLHdCQUFRbEksU0FBUixDQUFrQjJnQixnQkFBbEIsR0FBcUMsWUFBVztBQUM1Qyx5QkFBSy9CLE1BQUw7QUFDSCxpQkFGRDtBQUlDLGFBL0hEO0FBaUlDLFNBbklrQixFQW1JakIsRUFBQyxVQUFTLEVBQVYsRUFuSWlCLENBelk2dUIsRUE0Z0IvdUIsR0FBRSxDQUFDLFVBQVMzRyxPQUFULEVBQWlCcGEsTUFBakIsRUFBd0JDLE9BQXhCLEVBQWdDO0FBQ3BEOztBQUNBRCxtQkFBT0MsT0FBUCxHQUFpQixVQUFTZ2pCLFdBQVQsRUFBc0I7QUFDdkMsb0JBQUloSSxPQUFPYixRQUFRLFFBQVIsQ0FBWDtBQUNBLG9CQUFJOEksVUFBVTlJLFFBQVEsT0FBUixFQUFpQnpSLElBQS9CO0FBQ0Esb0JBQUlnWSxXQUFXMUYsS0FBSzBGLFFBQXBCO0FBQ0Esb0JBQUlDLFdBQVczRixLQUFLMkYsUUFBcEI7O0FBRUEseUJBQVN1QyxXQUFULENBQXFCQyxTQUFyQixFQUFnQ0MsRUFBaEMsRUFBb0N4TSxPQUFwQyxFQUE2QztBQUN6QywyQkFBTyxVQUFTL1csQ0FBVCxFQUFZO0FBQ2YsNEJBQUl3akIsVUFBVXpNLFFBQVE0SCxXQUFSLEVBQWQ7QUFDQThFLHVDQUFlLEtBQUssSUFBSS9oQixJQUFJLENBQWIsRUFBZ0JBLElBQUk0aEIsVUFBVTFoQixNQUE5QixFQUFzQyxFQUFFRixDQUF4QyxFQUEyQztBQUN0RCxnQ0FBSWdpQixPQUFPSixVQUFVNWhCLENBQVYsQ0FBWDs7QUFFQSxnQ0FBSWdpQixTQUFTcE0sS0FBVCxJQUNDb00sUUFBUSxJQUFSLElBQWdCQSxLQUFLcmhCLFNBQUwsWUFBMEJpVixLQUQvQyxFQUN1RDtBQUNuRCxvQ0FBSXRYLGFBQWEwakIsSUFBakIsRUFBdUI7QUFDbkIsMkNBQU83QyxTQUFTMEMsRUFBVCxFQUFhL2dCLElBQWIsQ0FBa0JnaEIsT0FBbEIsRUFBMkJ4akIsQ0FBM0IsQ0FBUDtBQUNIO0FBQ0osNkJBTEQsTUFLTyxJQUFJLE9BQU8wakIsSUFBUCxLQUFnQixVQUFwQixFQUFnQztBQUNuQyxvQ0FBSUMsbUJBQW1COUMsU0FBUzZDLElBQVQsRUFBZWxoQixJQUFmLENBQW9CZ2hCLE9BQXBCLEVBQTZCeGpCLENBQTdCLENBQXZCO0FBQ0Esb0NBQUkyakIscUJBQXFCN0MsUUFBekIsRUFBbUM7QUFDL0IsMkNBQU82QyxnQkFBUDtBQUNILGlDQUZELE1BRU8sSUFBSUEsZ0JBQUosRUFBc0I7QUFDekIsMkNBQU85QyxTQUFTMEMsRUFBVCxFQUFhL2dCLElBQWIsQ0FBa0JnaEIsT0FBbEIsRUFBMkJ4akIsQ0FBM0IsQ0FBUDtBQUNIO0FBQ0osNkJBUE0sTUFPQSxJQUFJbWIsS0FBS2hhLFFBQUwsQ0FBY25CLENBQWQsQ0FBSixFQUFzQjtBQUN6QixvQ0FBSTZJLE9BQU91YSxRQUFRTSxJQUFSLENBQVg7QUFDQSxxQ0FBSyxJQUFJRSxJQUFJLENBQWIsRUFBZ0JBLElBQUkvYSxLQUFLakgsTUFBekIsRUFBaUMsRUFBRWdpQixDQUFuQyxFQUFzQztBQUNsQyx3Q0FBSTloQixNQUFNK0csS0FBSythLENBQUwsQ0FBVjtBQUNBLHdDQUFJRixLQUFLNWhCLEdBQUwsS0FBYTlCLEVBQUU4QixHQUFGLENBQWpCLEVBQXlCO0FBQ3JCLGlEQUFTMmhCLGFBQVQ7QUFDSDtBQUNKO0FBQ0QsdUNBQU81QyxTQUFTMEMsRUFBVCxFQUFhL2dCLElBQWIsQ0FBa0JnaEIsT0FBbEIsRUFBMkJ4akIsQ0FBM0IsQ0FBUDtBQUNIO0FBQ0o7QUFDRCwrQkFBT21qQixXQUFQO0FBQ0gscUJBN0JEO0FBOEJIOztBQUVELHVCQUFPRSxXQUFQO0FBQ0MsYUF4Q0Q7QUEwQ0MsU0E1Q2tCLEVBNENqQixFQUFDLFNBQVEsRUFBVCxFQUFZLFVBQVMsRUFBckIsRUE1Q2lCLENBNWdCNnVCLEVBd2pCcHVCLEdBQUUsQ0FBQyxVQUFTL0ksT0FBVCxFQUFpQnBhLE1BQWpCLEVBQXdCQyxPQUF4QixFQUFnQztBQUMvRDs7QUFDQUQsbUJBQU9DLE9BQVAsR0FBaUIsVUFBU29LLE9BQVQsRUFBa0I7QUFDbkMsb0JBQUlzWixrQkFBa0IsS0FBdEI7QUFDQSxvQkFBSUMsZUFBZSxFQUFuQjs7QUFFQXZaLHdCQUFRbEksU0FBUixDQUFrQjBoQixlQUFsQixHQUFvQyxZQUFXLENBQUUsQ0FBakQ7QUFDQXhaLHdCQUFRbEksU0FBUixDQUFrQjJoQixZQUFsQixHQUFpQyxZQUFXLENBQUUsQ0FBOUM7QUFDQXpaLHdCQUFRbEksU0FBUixDQUFrQjRoQixXQUFsQixHQUFnQyxZQUFXO0FBQUMsMkJBQU8sSUFBUDtBQUFhLGlCQUF6RDtBQUNBMVosd0JBQVEyWixZQUFSLEdBQXVCM1osUUFBUWxJLFNBQVIsQ0FBa0I2aEIsWUFBbEIsR0FBaUMsWUFBVyxDQUFFLENBQXJFOztBQUVBLHlCQUFTQyxPQUFULEdBQW1CO0FBQ2YseUJBQUtDLE1BQUwsR0FBYyxJQUFJRCxRQUFRRSxhQUFaLENBQTBCQyxhQUExQixDQUFkO0FBQ0g7QUFDREgsd0JBQVE5aEIsU0FBUixDQUFrQjJoQixZQUFsQixHQUFpQyxZQUFZO0FBQ3pDLHdCQUFJLEtBQUtJLE1BQUwsS0FBZ0J2YyxTQUFwQixFQUErQjtBQUMzQiw2QkFBS3VjLE1BQUwsQ0FBWUwsZUFBWixHQUE4QixJQUE5QjtBQUNBRCxxQ0FBYXBYLElBQWIsQ0FBa0IsS0FBSzBYLE1BQXZCO0FBQ0g7QUFDSixpQkFMRDs7QUFPQUQsd0JBQVE5aEIsU0FBUixDQUFrQjRoQixXQUFsQixHQUFnQyxZQUFZO0FBQ3hDLHdCQUFJLEtBQUtHLE1BQUwsS0FBZ0J2YyxTQUFwQixFQUErQjtBQUMzQiw0QkFBSTBjLFFBQVFULGFBQWF4WCxHQUFiLEVBQVo7QUFDQSw0QkFBSXNPLE1BQU0ySixNQUFNUixlQUFoQjtBQUNBUSw4QkFBTVIsZUFBTixHQUF3QixJQUF4QjtBQUNBLCtCQUFPbkosR0FBUDtBQUNIO0FBQ0QsMkJBQU8sSUFBUDtBQUNILGlCQVJEOztBQVVBLHlCQUFTNEosYUFBVCxHQUF5QjtBQUNyQix3QkFBSVgsZUFBSixFQUFxQixPQUFPLElBQUlNLE9BQUosRUFBUDtBQUN4Qjs7QUFFRCx5QkFBU0csV0FBVCxHQUF1QjtBQUNuQix3QkFBSWpZLFlBQVl5WCxhQUFhbGlCLE1BQWIsR0FBc0IsQ0FBdEM7QUFDQSx3QkFBSXlLLGFBQWEsQ0FBakIsRUFBb0I7QUFDaEIsK0JBQU95WCxhQUFhelgsU0FBYixDQUFQO0FBQ0g7QUFDRCwyQkFBT3hFLFNBQVA7QUFDSDtBQUNEc2Msd0JBQVFFLGFBQVIsR0FBd0IsSUFBeEI7QUFDQUYsd0JBQVE3akIsTUFBUixHQUFpQmtrQixhQUFqQjtBQUNBTCx3QkFBUU0seUJBQVIsR0FBb0MsWUFBVyxDQUFFLENBQWpEO0FBQ0FOLHdCQUFRTyx1QkFBUixHQUFrQyxZQUFXO0FBQ3pDLHdCQUFJQyxzQkFBc0JwYSxRQUFRbEksU0FBUixDQUFrQjJoQixZQUE1QztBQUNBLHdCQUFJWSxxQkFBcUJyYSxRQUFRbEksU0FBUixDQUFrQjRoQixXQUEzQztBQUNBLHdCQUFJWSxzQkFBc0J0YSxRQUFRMlosWUFBbEM7QUFDQSx3QkFBSVksc0JBQXNCdmEsUUFBUWxJLFNBQVIsQ0FBa0I2aEIsWUFBNUM7QUFDQSx3QkFBSWEseUJBQXlCeGEsUUFBUWxJLFNBQVIsQ0FBa0IwaEIsZUFBL0M7QUFDQUksNEJBQVFNLHlCQUFSLEdBQW9DLFlBQVc7QUFDM0NsYSxnQ0FBUWxJLFNBQVIsQ0FBa0IyaEIsWUFBbEIsR0FBaUNXLG1CQUFqQztBQUNBcGEsZ0NBQVFsSSxTQUFSLENBQWtCNGhCLFdBQWxCLEdBQWdDVyxrQkFBaEM7QUFDQXJhLGdDQUFRMlosWUFBUixHQUF1QlcsbUJBQXZCO0FBQ0F0YSxnQ0FBUWxJLFNBQVIsQ0FBa0I2aEIsWUFBbEIsR0FBaUNZLG1CQUFqQztBQUNBdmEsZ0NBQVFsSSxTQUFSLENBQWtCMGhCLGVBQWxCLEdBQW9DZ0Isc0JBQXBDO0FBQ0FsQiwwQ0FBa0IsS0FBbEI7QUFDSCxxQkFQRDtBQVFBQSxzQ0FBa0IsSUFBbEI7QUFDQXRaLDRCQUFRbEksU0FBUixDQUFrQjJoQixZQUFsQixHQUFpQ0csUUFBUTloQixTQUFSLENBQWtCMmhCLFlBQW5EO0FBQ0F6Wiw0QkFBUWxJLFNBQVIsQ0FBa0I0aEIsV0FBbEIsR0FBZ0NFLFFBQVE5aEIsU0FBUixDQUFrQjRoQixXQUFsRDtBQUNBMVosNEJBQVEyWixZQUFSLEdBQXVCM1osUUFBUWxJLFNBQVIsQ0FBa0I2aEIsWUFBbEIsR0FBaUNJLFdBQXhEO0FBQ0EvWiw0QkFBUWxJLFNBQVIsQ0FBa0IwaEIsZUFBbEIsR0FBb0MsWUFBVztBQUMzQyw0QkFBSWlCLE1BQU0sS0FBS2QsWUFBTCxFQUFWO0FBQ0EsNEJBQUljLE9BQU9BLElBQUlqQixlQUFKLElBQXVCLElBQWxDLEVBQXdDaUIsSUFBSWpCLGVBQUosR0FBc0IsSUFBdEI7QUFDM0MscUJBSEQ7QUFJSCxpQkF0QkQ7QUF1QkEsdUJBQU9JLE9BQVA7QUFDQyxhQW5FRDtBQXFFQyxTQXZFNkIsRUF1RTVCLEVBdkU0QixDQXhqQmt1QixFQStuQjF2QixHQUFFLENBQUMsVUFBUzdKLE9BQVQsRUFBaUJwYSxNQUFqQixFQUF3QkMsT0FBeEIsRUFBZ0M7QUFDekM7O0FBQ0FELG1CQUFPQyxPQUFQLEdBQWlCLFVBQVNvSyxPQUFULEVBQWtCNFosT0FBbEIsRUFBMkI7QUFDNUMsb0JBQUljLFlBQVkxYSxRQUFRMmEsVUFBeEI7QUFDQSxvQkFBSW5FLFFBQVF4VyxRQUFReVcsTUFBcEI7QUFDQSxvQkFBSW1FLFVBQVU3SyxRQUFRLFVBQVIsRUFBb0I2SyxPQUFsQztBQUNBLG9CQUFJaEssT0FBT2IsUUFBUSxRQUFSLENBQVg7QUFDQSxvQkFBSThLLGlCQUFpQmpLLEtBQUtpSyxjQUExQjtBQUNBLG9CQUFJQyx5QkFBSjtBQUNBLG9CQUFJQywwQkFBSjtBQUNBLG9CQUFJQyx1QkFDQSwwREFESjtBQUVBLG9CQUFJQyxtQkFBbUIsNEJBQXZCO0FBQ0Esb0JBQUlDLG1CQUFtQixpQ0FBdkI7QUFDQSxvQkFBSUMsb0JBQW9CLElBQXhCO0FBQ0Esb0JBQUlDLGNBQWMsSUFBbEI7QUFDQSxvQkFBSUMsb0JBQW9CLEtBQXhCO0FBQ0Esb0JBQUlDLFlBQUo7QUFDQSxvQkFBSUMsWUFBWSxDQUFDLEVBQUUzSyxLQUFLeEMsR0FBTCxDQUFTLGdCQUFULEtBQThCLENBQTlCLEtBQ00sUUFDQXdDLEtBQUt4QyxHQUFMLENBQVMsZ0JBQVQsQ0FEQSxJQUVBd0MsS0FBS3hDLEdBQUwsQ0FBUyxVQUFULE1BQXlCLGFBSC9CLENBQUYsQ0FBakI7O0FBS0Esb0JBQUlvTixXQUFXLENBQUMsRUFBRTVLLEtBQUt4QyxHQUFMLENBQVMsbUJBQVQsS0FBaUMsQ0FBakMsS0FDYm1OLGFBQWEzSyxLQUFLeEMsR0FBTCxDQUFTLG1CQUFULENBREEsQ0FBRixDQUFoQjs7QUFHQSxvQkFBSWtMLGtCQUFrQixDQUFDLEVBQUUxSSxLQUFLeEMsR0FBTCxDQUFTLDRCQUFULEtBQTBDLENBQTFDLEtBQ3BCbU4sYUFBYTNLLEtBQUt4QyxHQUFMLENBQVMsNEJBQVQsQ0FETyxDQUFGLENBQXZCOztBQUdBLG9CQUFJcU4sbUJBQW1CN0ssS0FBS3hDLEdBQUwsQ0FBUyw2QkFBVCxLQUEyQyxDQUEzQyxLQUNsQm9OLFlBQVksQ0FBQyxDQUFDNUssS0FBS3hDLEdBQUwsQ0FBUyw2QkFBVCxDQURJLENBQXZCOztBQUdBcE8sd0JBQVFsSSxTQUFSLENBQWtCNGpCLDJCQUFsQixHQUFnRCxZQUFXO0FBQ3ZELHdCQUFJMUgsU0FBUyxLQUFLTyxPQUFMLEVBQWI7QUFDQVAsMkJBQU9GLFNBQVAsR0FBcUJFLE9BQU9GLFNBQVAsR0FBb0IsQ0FBQyxPQUF0QixHQUNGLE1BRGxCO0FBRUgsaUJBSkQ7O0FBTUE5VCx3QkFBUWxJLFNBQVIsQ0FBa0I2akIsK0JBQWxCLEdBQW9ELFlBQVk7QUFDNUQsd0JBQUksQ0FBQyxLQUFLN0gsU0FBTCxHQUFpQixNQUFsQixNQUE4QixDQUFsQyxFQUFxQztBQUNyQyx5QkFBSzhILHdCQUFMO0FBQ0FwRiwwQkFBTTlELFdBQU4sQ0FBa0IsS0FBS21KLHlCQUF2QixFQUFrRCxJQUFsRCxFQUF3RHZlLFNBQXhEO0FBQ0gsaUJBSkQ7O0FBTUEwQyx3QkFBUWxJLFNBQVIsQ0FBa0Jna0Isa0NBQWxCLEdBQXVELFlBQVk7QUFDL0RDLHVDQUFtQixrQkFBbkIsRUFDOEJqQix5QkFEOUIsRUFDeUR4ZCxTQUR6RCxFQUNvRSxJQURwRTtBQUVILGlCQUhEOztBQUtBMEMsd0JBQVFsSSxTQUFSLENBQWtCa2tCLHdCQUFsQixHQUE2QyxZQUFXO0FBQ3BELHlCQUFLbEksU0FBTCxHQUFpQixLQUFLQSxTQUFMLEdBQWlCLFNBQWxDO0FBQ0gsaUJBRkQ7O0FBSUE5VCx3QkFBUWxJLFNBQVIsQ0FBa0Jta0IscUJBQWxCLEdBQTBDLFlBQVc7QUFDakQsMkJBQU8sQ0FBQyxLQUFLbkksU0FBTCxHQUFpQixTQUFsQixNQUFpQyxDQUF4QztBQUNILGlCQUZEOztBQUlBOVQsd0JBQVFsSSxTQUFSLENBQWtCK2pCLHlCQUFsQixHQUE4QyxZQUFZO0FBQ3RELHdCQUFJLEtBQUtLLHFCQUFMLEVBQUosRUFBa0M7QUFDOUIsNEJBQUlDLFNBQVMsS0FBS0MsYUFBTCxFQUFiO0FBQ0EsNkJBQUtDLGdDQUFMO0FBQ0FOLDJDQUFtQixvQkFBbkIsRUFDOEJoQiwwQkFEOUIsRUFDMERvQixNQUQxRCxFQUNrRSxJQURsRTtBQUVIO0FBQ0osaUJBUEQ7O0FBU0FuYyx3QkFBUWxJLFNBQVIsQ0FBa0J1a0IsZ0NBQWxCLEdBQXFELFlBQVk7QUFDN0QseUJBQUt2SSxTQUFMLEdBQWlCLEtBQUtBLFNBQUwsR0FBaUIsTUFBbEM7QUFDSCxpQkFGRDs7QUFJQTlULHdCQUFRbEksU0FBUixDQUFrQndrQixrQ0FBbEIsR0FBdUQsWUFBWTtBQUMvRCx5QkFBS3hJLFNBQUwsR0FBaUIsS0FBS0EsU0FBTCxHQUFrQixDQUFDLE1BQXBDO0FBQ0gsaUJBRkQ7O0FBSUE5VCx3QkFBUWxJLFNBQVIsQ0FBa0J5a0IsNkJBQWxCLEdBQWtELFlBQVk7QUFDMUQsMkJBQU8sQ0FBQyxLQUFLekksU0FBTCxHQUFpQixNQUFsQixJQUE0QixDQUFuQztBQUNILGlCQUZEOztBQUlBOVQsd0JBQVFsSSxTQUFSLENBQWtCOGpCLHdCQUFsQixHQUE2QyxZQUFZO0FBQ3JELHlCQUFLOUgsU0FBTCxHQUFpQixLQUFLQSxTQUFMLEdBQWlCLE9BQWxDO0FBQ0gsaUJBRkQ7O0FBSUE5VCx3QkFBUWxJLFNBQVIsQ0FBa0Iwa0IsMEJBQWxCLEdBQStDLFlBQVk7QUFDdkQseUJBQUsxSSxTQUFMLEdBQWlCLEtBQUtBLFNBQUwsR0FBa0IsQ0FBQyxPQUFwQztBQUNBLHdCQUFJLEtBQUt5SSw2QkFBTCxFQUFKLEVBQTBDO0FBQ3RDLDZCQUFLRCxrQ0FBTDtBQUNBLDZCQUFLUixrQ0FBTDtBQUNIO0FBQ0osaUJBTkQ7O0FBUUE5Yix3QkFBUWxJLFNBQVIsQ0FBa0Jva0IscUJBQWxCLEdBQTBDLFlBQVk7QUFDbEQsMkJBQU8sQ0FBQyxLQUFLcEksU0FBTCxHQUFpQixPQUFsQixJQUE2QixDQUFwQztBQUNILGlCQUZEOztBQUlBOVQsd0JBQVFsSSxTQUFSLENBQWtCOGUsS0FBbEIsR0FBMEIsVUFBU3hNLE9BQVQsRUFBa0JxUyxpQkFBbEIsRUFBcUNqUSxPQUFyQyxFQUE4QztBQUNwRSwyQkFBT2tRLEtBQUt0UyxPQUFMLEVBQWNxUyxpQkFBZCxFQUFpQ2pRLFdBQVcsSUFBNUMsQ0FBUDtBQUNILGlCQUZEOztBQUlBeE0sd0JBQVEyYyw0QkFBUixHQUF1QyxVQUFVeGtCLEVBQVYsRUFBYztBQUNqRCx3QkFBSXlrQixTQUFTbEMsV0FBYjtBQUNBSyxpREFDSSxPQUFPNWlCLEVBQVAsS0FBYyxVQUFkLEdBQTRCeWtCLFdBQVcsSUFBWCxHQUNRemtCLEVBRFIsR0FDYXlZLEtBQUtpTSxVQUFMLENBQWdCRCxNQUFoQixFQUF3QnprQixFQUF4QixDQUR6QyxHQUUyQm1GLFNBSC9CO0FBSUgsaUJBTkQ7O0FBUUEwQyx3QkFBUThjLDJCQUFSLEdBQXNDLFVBQVUza0IsRUFBVixFQUFjO0FBQ2hELHdCQUFJeWtCLFNBQVNsQyxXQUFiO0FBQ0FJLGdEQUNJLE9BQU8zaUIsRUFBUCxLQUFjLFVBQWQsR0FBNEJ5a0IsV0FBVyxJQUFYLEdBQ1F6a0IsRUFEUixHQUNheVksS0FBS2lNLFVBQUwsQ0FBZ0JELE1BQWhCLEVBQXdCemtCLEVBQXhCLENBRHpDLEdBRTJCbUYsU0FIL0I7QUFJSCxpQkFORDs7QUFRQSxvQkFBSXlmLHlCQUF5QixrQ0FBVyxDQUFFLENBQTFDO0FBQ0EvYyx3QkFBUXNaLGVBQVIsR0FBMEIsWUFBWTtBQUNsQyx3QkFBSTlDLE1BQU0zRSxlQUFOLE1BQTJCLENBQUNySCxPQUFPOE8sZUFBdkMsRUFBd0Q7QUFDcEQsOEJBQU0sSUFBSXZNLEtBQUosQ0FBVSxvR0FBVixDQUFOO0FBQ0g7QUFDRCx3QkFBSSxDQUFDdkMsT0FBTzhPLGVBQVIsSUFBMkIwRCw0QkFBL0IsRUFBNkQ7QUFDekQsNEJBQUlDLDRCQUE0QmpkLFFBQVFsSSxTQUFSLENBQWtCb2xCLGtCQUFsRDtBQUNBLDRCQUFJQywyQkFBMkJuZCxRQUFRbEksU0FBUixDQUFrQjBnQixpQkFBakQ7QUFDQWhPLCtCQUFPOE8sZUFBUCxHQUF5QixJQUF6QjtBQUNBeUQsaURBQXlCLGtDQUFXO0FBQ2hDLGdDQUFJdkcsTUFBTTNFLGVBQU4sTUFBMkIsQ0FBQ3JILE9BQU84TyxlQUF2QyxFQUF3RDtBQUNwRCxzQ0FBTSxJQUFJdk0sS0FBSixDQUFVLG9HQUFWLENBQU47QUFDSDtBQUNEL00sb0NBQVFsSSxTQUFSLENBQWtCb2xCLGtCQUFsQixHQUF1Q0QseUJBQXZDO0FBQ0FqZCxvQ0FBUWxJLFNBQVIsQ0FBa0IwZ0IsaUJBQWxCLEdBQXNDMkUsd0JBQXRDO0FBQ0F2RCxvQ0FBUU0seUJBQVI7QUFDQTFELGtDQUFNOUUsZ0JBQU47QUFDQWxILG1DQUFPOE8sZUFBUCxHQUF5QixLQUF6QjtBQUNILHlCQVREO0FBVUF0WixnQ0FBUWxJLFNBQVIsQ0FBa0JvbEIsa0JBQWxCLEdBQXVDRSxnQ0FBdkM7QUFDQXBkLGdDQUFRbEksU0FBUixDQUFrQjBnQixpQkFBbEIsR0FBc0M2RSwrQkFBdEM7QUFDQXpELGdDQUFRTyx1QkFBUjtBQUNBM0QsOEJBQU03RSw0QkFBTjtBQUNIO0FBQ0osaUJBdkJEOztBQXlCQTNSLHdCQUFRc2Qsa0JBQVIsR0FBNkIsWUFBWTtBQUNyQywyQkFBTzlTLE9BQU84TyxlQUFQLElBQTBCMEQsNEJBQWpDO0FBQ0gsaUJBRkQ7O0FBSUEsb0JBQUlPLGVBQWdCLFlBQVc7QUFDM0Isd0JBQUk7QUFDQSw0QkFBSSxPQUFPQyxXQUFQLEtBQXVCLFVBQTNCLEVBQXVDO0FBQ25DLGdDQUFJQyxRQUFRLElBQUlELFdBQUosQ0FBZ0IsYUFBaEIsQ0FBWjtBQUNBNU0saUNBQUt4YSxNQUFMLENBQVlzbkIsYUFBWixDQUEwQkQsS0FBMUI7QUFDQSxtQ0FBTyxVQUFTM08sSUFBVCxFQUFlMk8sS0FBZixFQUFzQjtBQUN6QixvQ0FBSUUsV0FBVyxJQUFJSCxXQUFKLENBQWdCMU8sS0FBSzhPLFdBQUwsRUFBaEIsRUFBb0M7QUFDL0NDLDRDQUFRSixLQUR1QztBQUUvQ0ssZ0RBQVk7QUFGbUMsaUNBQXBDLENBQWY7QUFJQSx1Q0FBTyxDQUFDbE4sS0FBS3hhLE1BQUwsQ0FBWXNuQixhQUFaLENBQTBCQyxRQUExQixDQUFSO0FBQ0gsNkJBTkQ7QUFPSCx5QkFWRCxNQVVPLElBQUksT0FBT0ksS0FBUCxLQUFpQixVQUFyQixFQUFpQztBQUNwQyxnQ0FBSU4sUUFBUSxJQUFJTSxLQUFKLENBQVUsYUFBVixDQUFaO0FBQ0FuTixpQ0FBS3hhLE1BQUwsQ0FBWXNuQixhQUFaLENBQTBCRCxLQUExQjtBQUNBLG1DQUFPLFVBQVMzTyxJQUFULEVBQWUyTyxLQUFmLEVBQXNCO0FBQ3pCLG9DQUFJRSxXQUFXLElBQUlJLEtBQUosQ0FBVWpQLEtBQUs4TyxXQUFMLEVBQVYsRUFBOEI7QUFDekNFLGdEQUFZO0FBRDZCLGlDQUE5QixDQUFmO0FBR0FILHlDQUFTRSxNQUFULEdBQWtCSixLQUFsQjtBQUNBLHVDQUFPLENBQUM3TSxLQUFLeGEsTUFBTCxDQUFZc25CLGFBQVosQ0FBMEJDLFFBQTFCLENBQVI7QUFDSCw2QkFORDtBQU9ILHlCQVZNLE1BVUE7QUFDSCxnQ0FBSUYsUUFBUU8sU0FBU0MsV0FBVCxDQUFxQixhQUFyQixDQUFaO0FBQ0FSLGtDQUFNUyxlQUFOLENBQXNCLGlCQUF0QixFQUF5QyxLQUF6QyxFQUFnRCxJQUFoRCxFQUFzRCxFQUF0RDtBQUNBdE4saUNBQUt4YSxNQUFMLENBQVlzbkIsYUFBWixDQUEwQkQsS0FBMUI7QUFDQSxtQ0FBTyxVQUFTM08sSUFBVCxFQUFlMk8sS0FBZixFQUFzQjtBQUN6QixvQ0FBSUUsV0FBV0ssU0FBU0MsV0FBVCxDQUFxQixhQUFyQixDQUFmO0FBQ0FOLHlDQUFTTyxlQUFULENBQXlCcFAsS0FBSzhPLFdBQUwsRUFBekIsRUFBNkMsS0FBN0MsRUFBb0QsSUFBcEQsRUFDSUgsS0FESjtBQUVBLHVDQUFPLENBQUM3TSxLQUFLeGEsTUFBTCxDQUFZc25CLGFBQVosQ0FBMEJDLFFBQTFCLENBQVI7QUFDSCw2QkFMRDtBQU1IO0FBQ0oscUJBaENELENBZ0NFLE9BQU9sb0IsQ0FBUCxFQUFVLENBQUU7QUFDZCwyQkFBTyxZQUFXO0FBQ2QsK0JBQU8sS0FBUDtBQUNILHFCQUZEO0FBR0gsaUJBckNrQixFQUFuQjs7QUF1Q0Esb0JBQUkwb0Isa0JBQW1CLFlBQVc7QUFDOUIsd0JBQUl2TixLQUFLbUIsTUFBVCxFQUFpQjtBQUNiLCtCQUFPLFlBQVc7QUFDZCxtQ0FBT3RXLFFBQVFnUSxJQUFSLENBQWE5VCxLQUFiLENBQW1COEQsT0FBbkIsRUFBNEJyRSxTQUE1QixDQUFQO0FBQ0gseUJBRkQ7QUFHSCxxQkFKRCxNQUlPO0FBQ0gsNEJBQUksQ0FBQ3daLEtBQUt4YSxNQUFWLEVBQWtCO0FBQ2QsbUNBQU8sWUFBVztBQUNkLHVDQUFPLEtBQVA7QUFDSCw2QkFGRDtBQUdIO0FBQ0QsK0JBQU8sVUFBUzBZLElBQVQsRUFBZTtBQUNsQixnQ0FBSXlHLGFBQWEsT0FBT3pHLEtBQUs4TyxXQUFMLEVBQXhCO0FBQ0EsZ0NBQUlRLFNBQVN4TixLQUFLeGEsTUFBTCxDQUFZbWYsVUFBWixDQUFiO0FBQ0EsZ0NBQUksQ0FBQzZJLE1BQUwsRUFBYSxPQUFPLEtBQVA7QUFDYkEsbUNBQU96bUIsS0FBUCxDQUFhaVosS0FBS3hhLE1BQWxCLEVBQTBCLEdBQUdFLEtBQUgsQ0FBUzJCLElBQVQsQ0FBY2IsU0FBZCxFQUF5QixDQUF6QixDQUExQjtBQUNBLG1DQUFPLElBQVA7QUFDSCx5QkFORDtBQU9IO0FBQ0osaUJBbkJxQixFQUF0Qjs7QUFxQkEseUJBQVNpbkIsbUNBQVQsQ0FBNkN2UCxJQUE3QyxFQUFtRHRDLE9BQW5ELEVBQTREO0FBQ3hELDJCQUFPLEVBQUNBLFNBQVNBLE9BQVYsRUFBUDtBQUNIOztBQUVELG9CQUFJOFIseUJBQXlCO0FBQ3pCQyxvQ0FBZ0JGLG1DQURTO0FBRXpCRyxzQ0FBa0JILG1DQUZPO0FBR3pCSSxxQ0FBaUJKLG1DQUhRO0FBSXpCSyxxQ0FBaUJMLG1DQUpRO0FBS3pCTSxzQ0FBa0JOLG1DQUxPO0FBTXpCTyxvQ0FBZ0Isd0JBQVM5UCxJQUFULEVBQWV0QyxPQUFmLEVBQXdCcUssS0FBeEIsRUFBK0I7QUFDM0MsK0JBQU8sRUFBQ3JLLFNBQVNBLE9BQVYsRUFBbUJxSyxPQUFPQSxLQUExQixFQUFQO0FBQ0gscUJBUndCO0FBU3pCZ0ksNkJBQVMsaUJBQVMvUCxJQUFULEVBQWUrUCxRQUFmLEVBQXdCO0FBQzdCLCtCQUFPLEVBQUNBLFNBQVNBLFFBQVYsRUFBUDtBQUNILHFCQVh3QjtBQVl6QkMsd0NBQW9CLDRCQUFVaFEsSUFBVixFQUFnQnFOLE1BQWhCLEVBQXdCM1AsT0FBeEIsRUFBaUM7QUFDakQsK0JBQU8sRUFBQzJQLFFBQVFBLE1BQVQsRUFBaUIzUCxTQUFTQSxPQUExQixFQUFQO0FBQ0gscUJBZHdCO0FBZXpCdVMsc0NBQWtCVjtBQWZPLGlCQUE3Qjs7QUFrQkEsb0JBQUlXLGtCQUFrQixTQUFsQkEsZUFBa0IsQ0FBVWxRLElBQVYsRUFBZ0I7QUFDbEMsd0JBQUltUSxtQkFBbUIsS0FBdkI7QUFDQSx3QkFBSTtBQUNBQSwyQ0FBbUJkLGdCQUFnQnhtQixLQUFoQixDQUFzQixJQUF0QixFQUE0QlAsU0FBNUIsQ0FBbkI7QUFDSCxxQkFGRCxDQUVFLE9BQU8zQixDQUFQLEVBQVU7QUFDUitnQiw4QkFBTXJFLFVBQU4sQ0FBaUIxYyxDQUFqQjtBQUNBd3BCLDJDQUFtQixJQUFuQjtBQUNIOztBQUVELHdCQUFJQyxnQkFBZ0IsS0FBcEI7QUFDQSx3QkFBSTtBQUNBQSx3Q0FBZ0IzQixhQUFhek8sSUFBYixFQUNKd1AsdUJBQXVCeFAsSUFBdkIsRUFBNkJuWCxLQUE3QixDQUFtQyxJQUFuQyxFQUF5Q1AsU0FBekMsQ0FESSxDQUFoQjtBQUVILHFCQUhELENBR0UsT0FBTzNCLENBQVAsRUFBVTtBQUNSK2dCLDhCQUFNckUsVUFBTixDQUFpQjFjLENBQWpCO0FBQ0F5cEIsd0NBQWdCLElBQWhCO0FBQ0g7O0FBRUQsMkJBQU9BLGlCQUFpQkQsZ0JBQXhCO0FBQ0gsaUJBbkJEOztBQXFCQWpmLHdCQUFRd0ssTUFBUixHQUFpQixVQUFTMlUsSUFBVCxFQUFlO0FBQzVCQSwyQkFBT3RvQixPQUFPc29CLElBQVAsQ0FBUDtBQUNBLHdCQUFJLHFCQUFxQkEsSUFBekIsRUFBK0I7QUFDM0IsNEJBQUlBLEtBQUs3RixlQUFULEVBQTBCO0FBQ3RCdFosb0NBQVFzWixlQUFSO0FBQ0gseUJBRkQsTUFFTyxJQUFJLENBQUM2RixLQUFLN0YsZUFBTixJQUF5QnRaLFFBQVFzZCxrQkFBUixFQUE3QixFQUEyRDtBQUM5RFA7QUFDSDtBQUNKO0FBQ0Qsd0JBQUksY0FBY29DLElBQWxCLEVBQXdCO0FBQ3BCLDRCQUFJQyxpQkFBaUJELEtBQUszRCxRQUExQjtBQUNBaFIsK0JBQU9nUixRQUFQLEdBQWtCLENBQUMsQ0FBQzRELGNBQXBCO0FBQ0EzRCwyQ0FBbUJqUixPQUFPZ1IsUUFBMUI7O0FBRUEsNEJBQUk1SyxLQUFLaGEsUUFBTCxDQUFjd29CLGNBQWQsQ0FBSixFQUFtQztBQUMvQixnQ0FBSSxzQkFBc0JBLGNBQTFCLEVBQTBDO0FBQ3RDM0QsbURBQW1CLENBQUMsQ0FBQzJELGVBQWUzRCxnQkFBcEM7QUFDSDtBQUNKO0FBQ0o7QUFDRCx3QkFBSSxrQkFBa0IwRCxJQUFsQixJQUEwQkEsS0FBS3hJLFlBQS9CLElBQStDLENBQUNuTSxPQUFPbU0sWUFBM0QsRUFBeUU7QUFDckUsNEJBQUlILE1BQU0zRSxlQUFOLEVBQUosRUFBNkI7QUFDekIsa0NBQU0sSUFBSTlFLEtBQUosQ0FDRixzREFERSxDQUFOO0FBRUg7QUFDRC9NLGdDQUFRbEksU0FBUixDQUFrQnVuQixzQkFBbEIsR0FDSUMsaUNBREo7QUFFQXRmLGdDQUFRbEksU0FBUixDQUFrQm9jLGNBQWxCLEdBQW1DcUwseUJBQW5DO0FBQ0F2ZixnQ0FBUWxJLFNBQVIsQ0FBa0I0Z0IsU0FBbEIsR0FBOEI4RyxvQkFBOUI7QUFDQXhmLGdDQUFRbEksU0FBUixDQUFrQjJjLFlBQWxCLEdBQWlDZ0wsdUJBQWpDO0FBQ0F6ZixnQ0FBUWxJLFNBQVIsQ0FBa0I0bkIsMkJBQWxCLEdBQ0lDLHNDQURKO0FBRUEzZixnQ0FBUWxJLFNBQVIsQ0FBa0I4bkIsUUFBbEIsR0FBNkJDLG1CQUE3QjtBQUNBMUwsaURBQXdCb0wseUJBQXhCO0FBQ0EvVSwrQkFBT21NLFlBQVAsR0FBc0IsSUFBdEI7QUFDSDtBQUNELHdCQUFJLGdCQUFnQndJLElBQXBCLEVBQTBCO0FBQ3RCLDRCQUFJQSxLQUFLVyxVQUFMLElBQW1CLENBQUN0VixPQUFPc1YsVUFBL0IsRUFBMkM7QUFDdkN0VixtQ0FBT3NWLFVBQVAsR0FBb0IsSUFBcEI7QUFDQTlmLG9DQUFRbEksU0FBUixDQUFrQmlvQixVQUFsQixHQUErQmYsZUFBL0I7QUFDSCx5QkFIRCxNQUdPLElBQUksQ0FBQ0csS0FBS1csVUFBTixJQUFvQnRWLE9BQU9zVixVQUEvQixFQUEyQztBQUM5Q3RWLG1DQUFPc1YsVUFBUCxHQUFvQixLQUFwQjtBQUNBOWYsb0NBQVFsSSxTQUFSLENBQWtCaW9CLFVBQWxCLEdBQStCQyxnQkFBL0I7QUFDSDtBQUNKO0FBQ0QsMkJBQU9oZ0IsT0FBUDtBQUNILGlCQTlDRDs7QUFnREEseUJBQVNnZ0IsZ0JBQVQsR0FBNEI7QUFBRSwyQkFBTyxLQUFQO0FBQWU7O0FBRTdDaGdCLHdCQUFRbEksU0FBUixDQUFrQmlvQixVQUFsQixHQUErQkMsZ0JBQS9CO0FBQ0FoZ0Isd0JBQVFsSSxTQUFSLENBQWtCOG5CLFFBQWxCLEdBQTZCLFVBQVNLLFFBQVQsRUFBbUJwWCxPQUFuQixFQUE0QnNCLE1BQTVCLEVBQW9DO0FBQzdELHdCQUFJO0FBQ0E4VixpQ0FBU3BYLE9BQVQsRUFBa0JzQixNQUFsQjtBQUNILHFCQUZELENBRUUsT0FBTzFVLENBQVAsRUFBVTtBQUNSLCtCQUFPQSxDQUFQO0FBQ0g7QUFDSixpQkFORDtBQU9BdUssd0JBQVFsSSxTQUFSLENBQWtCNGdCLFNBQWxCLEdBQThCLFlBQVksQ0FBRSxDQUE1QztBQUNBMVksd0JBQVFsSSxTQUFSLENBQWtCMmMsWUFBbEIsR0FBaUMsVUFBVXlMLE9BQVYsRUFBbUI7QUFBRTtBQUFHLGlCQUF6RDtBQUNBbGdCLHdCQUFRbEksU0FBUixDQUFrQjRuQiwyQkFBbEIsR0FBZ0QsVUFBU1MsUUFBVCxFQUFtQjtBQUMvRDtBQUNILGlCQUZEO0FBR0FuZ0Isd0JBQVFsSSxTQUFSLENBQWtCb2xCLGtCQUFsQixHQUF1QyxZQUFZLENBQUUsQ0FBckQ7QUFDQWxkLHdCQUFRbEksU0FBUixDQUFrQjBnQixpQkFBbEIsR0FBc0MsWUFBWSxDQUFFLENBQXBEO0FBQ0F4WSx3QkFBUWxJLFNBQVIsQ0FBa0J1bkIsc0JBQWxCLEdBQTJDLFlBQVcsQ0FBRSxDQUF4RDtBQUNBcmYsd0JBQVFsSSxTQUFSLENBQWtCb2MsY0FBbEIsR0FBbUMsVUFBVWlELE1BQVYsRUFBa0JpSixLQUFsQixFQUF5QjtBQUN4RDtBQUNBO0FBQ0gsaUJBSEQ7O0FBS0EseUJBQVNQLG1CQUFULENBQTZCSSxRQUE3QixFQUF1Q3BYLE9BQXZDLEVBQWdEc0IsTUFBaEQsRUFBd0Q7QUFDcEQsd0JBQUlxQyxVQUFVLElBQWQ7QUFDQSx3QkFBSTtBQUNBeVQsaUNBQVNwWCxPQUFULEVBQWtCc0IsTUFBbEIsRUFBMEIsVUFBU2dXLFFBQVQsRUFBbUI7QUFDekMsZ0NBQUksT0FBT0EsUUFBUCxLQUFvQixVQUF4QixFQUFvQztBQUNoQyxzQ0FBTSxJQUFJMVYsU0FBSixDQUFjLHVDQUNBbUcsS0FBS2pZLFFBQUwsQ0FBY3duQixRQUFkLENBRGQsQ0FBTjtBQUVIO0FBQ0QzVCxvQ0FBUWtULDJCQUFSLENBQW9DUyxRQUFwQztBQUNILHlCQU5EO0FBT0gscUJBUkQsQ0FRRSxPQUFPMXFCLENBQVAsRUFBVTtBQUNSLCtCQUFPQSxDQUFQO0FBQ0g7QUFDSjs7QUFFRCx5QkFBU2txQixzQ0FBVCxDQUFnRFEsUUFBaEQsRUFBMEQ7QUFDdEQsd0JBQUksQ0FBQyxLQUFLckosY0FBTCxFQUFMLEVBQTRCLE9BQU8sSUFBUDs7QUFFNUIsd0JBQUl1SixtQkFBbUIsS0FBSzNILFNBQUwsRUFBdkI7QUFDQSx3QkFBSTJILHFCQUFxQi9pQixTQUF6QixFQUFvQztBQUNoQyw0QkFBSXNULEtBQUt2TixPQUFMLENBQWFnZCxnQkFBYixDQUFKLEVBQW9DO0FBQ2hDQSw2Q0FBaUJsZSxJQUFqQixDQUFzQmdlLFFBQXRCO0FBQ0gseUJBRkQsTUFFTztBQUNILGlDQUFLMUwsWUFBTCxDQUFrQixDQUFDNEwsZ0JBQUQsRUFBbUJGLFFBQW5CLENBQWxCO0FBQ0g7QUFDSixxQkFORCxNQU1PO0FBQ0gsNkJBQUsxTCxZQUFMLENBQWtCMEwsUUFBbEI7QUFDSDtBQUNKOztBQUVELHlCQUFTWCxvQkFBVCxHQUFnQztBQUM1QiwyQkFBTyxLQUFLeEgsY0FBWjtBQUNIOztBQUVELHlCQUFTeUgsdUJBQVQsQ0FBaUNVLFFBQWpDLEVBQTJDO0FBQ3ZDLHlCQUFLbkksY0FBTCxHQUFzQm1JLFFBQXRCO0FBQ0g7O0FBRUQseUJBQVNiLGlDQUFULEdBQTZDO0FBQ3pDLHlCQUFLbEksbUJBQUwsR0FBMkI5WixTQUEzQjtBQUNBLHlCQUFLMGEsY0FBTCxHQUFzQjFhLFNBQXRCO0FBQ0g7O0FBRUQseUJBQVNpaUIseUJBQVQsQ0FBbUNwSSxNQUFuQyxFQUEyQ2lKLEtBQTNDLEVBQWtEO0FBQzlDLHdCQUFJLENBQUNBLFFBQVEsQ0FBVCxNQUFnQixDQUFwQixFQUF1QjtBQUNuQiw2QkFBS2hKLG1CQUFMLEdBQTJCRCxNQUEzQjtBQUNBLDRCQUFJbUosNEJBQTRCbkosT0FBT0ksMEJBQXZDO0FBQ0EsNEJBQUkrSSw4QkFBOEJoakIsU0FBbEMsRUFBNkM7QUFDekNnakIsd0RBQTRCLENBQTVCO0FBQ0g7QUFDRG5KLCtCQUFPSSwwQkFBUCxHQUFvQytJLDRCQUE0QixDQUFoRTtBQUNIO0FBQ0Qsd0JBQUksQ0FBQ0YsUUFBUSxDQUFULE1BQWdCLENBQWhCLElBQXFCakosT0FBT3hDLFFBQVAsRUFBekIsRUFBNEM7QUFDeEMsNkJBQUtILFdBQUwsQ0FBaUIyQyxPQUFPekMsUUFBeEI7QUFDSDtBQUNKOztBQUVELHlCQUFTNkwsb0JBQVQsQ0FBOEJwSixNQUE5QixFQUFzQ2lKLEtBQXRDLEVBQTZDO0FBQ3pDLHdCQUFJLENBQUNBLFFBQVEsQ0FBVCxNQUFnQixDQUFoQixJQUFxQmpKLE9BQU94QyxRQUFQLEVBQXpCLEVBQTRDO0FBQ3hDLDZCQUFLSCxXQUFMLENBQWlCMkMsT0FBT3pDLFFBQXhCO0FBQ0g7QUFDSjtBQUNELG9CQUFJUCx5QkFBd0JvTSxvQkFBNUI7O0FBRUEseUJBQVNsTSxtQkFBVCxHQUE4QjtBQUMxQix3QkFBSWhFLE1BQU0sS0FBS3FFLFFBQWY7QUFDQSx3QkFBSXJFLFFBQVEvUyxTQUFaLEVBQXVCO0FBQ25CLDRCQUFJK1MsZUFBZXJRLE9BQW5CLEVBQTRCO0FBQ3hCLGdDQUFJcVEsSUFBSW1RLFdBQUosRUFBSixFQUF1QjtBQUNuQix1Q0FBT25RLElBQUluVSxLQUFKLEVBQVA7QUFDSCw2QkFGRCxNQUVPO0FBQ0gsdUNBQU9vQixTQUFQO0FBQ0g7QUFDSjtBQUNKO0FBQ0QsMkJBQU8rUyxHQUFQO0FBQ0g7O0FBRUQseUJBQVMrTSxnQ0FBVCxHQUE0QztBQUN4Qyx5QkFBS3ZELE1BQUwsR0FBYyxJQUFJQyxhQUFKLENBQWtCLEtBQUtILFlBQUwsRUFBbEIsQ0FBZDtBQUNIOztBQUVELHlCQUFTMEQsK0JBQVQsQ0FBeUNoVCxLQUF6QyxFQUFnRG9XLFVBQWhELEVBQTREO0FBQ3hELHdCQUFJNUYsZUFBZXhRLEtBQWYsQ0FBSixFQUEyQjtBQUN2Qiw0QkFBSTJQLFFBQVEsS0FBS0gsTUFBakI7QUFDQSw0QkFBSUcsVUFBVTFjLFNBQWQsRUFBeUI7QUFDckIsZ0NBQUltakIsVUFBSixFQUFnQnpHLFFBQVFBLE1BQU0wRyxPQUFkO0FBQ25CO0FBQ0QsNEJBQUkxRyxVQUFVMWMsU0FBZCxFQUF5QjtBQUNyQjBjLGtDQUFNMkcsZ0JBQU4sQ0FBdUJ0VyxLQUF2QjtBQUNILHlCQUZELE1BRU8sSUFBSSxDQUFDQSxNQUFNdVcsZ0JBQVgsRUFBNkI7QUFDaEMsZ0NBQUlDLFNBQVNDLHFCQUFxQnpXLEtBQXJCLENBQWI7QUFDQXVHLGlDQUFLbVEsaUJBQUwsQ0FBdUIxVyxLQUF2QixFQUE4QixPQUE5QixFQUNJd1csT0FBT3pXLE9BQVAsR0FBaUIsSUFBakIsR0FBd0J5VyxPQUFPemMsS0FBUCxDQUFhNGMsSUFBYixDQUFrQixJQUFsQixDQUQ1QjtBQUVBcFEsaUNBQUttUSxpQkFBTCxDQUF1QjFXLEtBQXZCLEVBQThCLGtCQUE5QixFQUFrRCxJQUFsRDtBQUNIO0FBQ0o7QUFDSjs7QUFFRCx5QkFBUzRXLHFCQUFULENBQStCQyxXQUEvQixFQUE0QzNDLGNBQTVDLEVBQTREelAsSUFBNUQsRUFBa0V0QyxPQUFsRSxFQUMrQjJLLE1BRC9CLEVBQ3VDO0FBQ25DLHdCQUFJK0osZ0JBQWdCNWpCLFNBQWhCLElBQTZCaWhCLG1CQUFtQixJQUFoRCxJQUNBOUMsZ0JBREosRUFDc0I7QUFDbEIsNEJBQUl0RSxXQUFXN1osU0FBWCxJQUF3QjZaLE9BQU84RSxxQkFBUCxFQUE1QixFQUE0RDtBQUM1RCw0QkFBSSxDQUFDelAsUUFBUXNILFNBQVIsR0FBb0IsS0FBckIsTUFBZ0MsQ0FBcEMsRUFBdUM7O0FBRXZDLDRCQUFJaEYsSUFBSixFQUFVQSxPQUFPQSxPQUFPLEdBQWQ7QUFDViw0QkFBSXFTLGNBQWMsRUFBbEI7QUFDQSw0QkFBSUMsY0FBYyxFQUFsQjtBQUNBLDRCQUFJN0MsZUFBZTFFLE1BQW5CLEVBQTJCO0FBQ3ZCLGdDQUFJd0gsYUFBYTlDLGVBQWUxRSxNQUFmLENBQXNCelYsS0FBdEIsQ0FBNEJrZCxLQUE1QixDQUFrQyxJQUFsQyxDQUFqQjtBQUNBLGdDQUFJbGQsUUFBUW1kLFdBQVdGLFVBQVgsQ0FBWjtBQUNBLGlDQUFLLElBQUlscUIsSUFBSWlOLE1BQU0vTSxNQUFOLEdBQWUsQ0FBNUIsRUFBK0JGLEtBQUssQ0FBcEMsRUFBdUMsRUFBRUEsQ0FBekMsRUFBNEM7QUFDeEMsb0NBQUlxcUIsT0FBT3BkLE1BQU1qTixDQUFOLENBQVg7QUFDQSxvQ0FBSSxDQUFDOGpCLGlCQUFpQnJWLElBQWpCLENBQXNCNGIsSUFBdEIsQ0FBTCxFQUFrQztBQUM5Qix3Q0FBSUMsY0FBY0QsS0FBS0UsS0FBTCxDQUFXeEcsZ0JBQVgsQ0FBbEI7QUFDQSx3Q0FBSXVHLFdBQUosRUFBaUI7QUFDYk4sc0RBQWUsUUFBUU0sWUFBWSxDQUFaLENBQVIsR0FDWCxHQURXLEdBQ0xBLFlBQVksQ0FBWixDQURLLEdBQ1ksR0FEWixHQUNrQkEsWUFBWSxDQUFaLENBRGxCLEdBQ21DLEdBRGxEO0FBRUg7QUFDRDtBQUNIO0FBQ0o7O0FBRUQsZ0NBQUlyZCxNQUFNL00sTUFBTixHQUFlLENBQW5CLEVBQXNCO0FBQ2xCLG9DQUFJc3FCLGdCQUFnQnZkLE1BQU0sQ0FBTixDQUFwQjtBQUNBLHFDQUFLLElBQUlqTixJQUFJLENBQWIsRUFBZ0JBLElBQUlrcUIsV0FBV2hxQixNQUEvQixFQUF1QyxFQUFFRixDQUF6QyxFQUE0Qzs7QUFFeEMsd0NBQUlrcUIsV0FBV2xxQixDQUFYLE1BQWtCd3FCLGFBQXRCLEVBQXFDO0FBQ2pDLDRDQUFJeHFCLElBQUksQ0FBUixFQUFXO0FBQ1BpcUIsMERBQWMsT0FBT0MsV0FBV2xxQixJQUFJLENBQWYsQ0FBckI7QUFDSDtBQUNEO0FBQ0g7QUFDSjtBQUVKO0FBQ0o7QUFDRCw0QkFBSXlxQixNQUFNLGdDQUFnQzlTLElBQWhDLEdBQ04sVUFETSxHQUNPcVMsV0FEUCxHQUNxQixnQ0FEckIsR0FFTiwwQkFGTSxHQUdOQyxXQUhKO0FBSUE1VSxnQ0FBUW9LLEtBQVIsQ0FBY2dMLEdBQWQsRUFBbUIsSUFBbkIsRUFBeUJyRCxjQUF6QjtBQUNIO0FBQ0o7O0FBRUQseUJBQVNzRCxVQUFULENBQW9CL1MsSUFBcEIsRUFBMEJnVCxXQUExQixFQUF1QztBQUNuQyx3QkFBSTFYLFVBQVUwRSxPQUNWLHlEQURKO0FBRUEsd0JBQUlnVCxXQUFKLEVBQWlCMVgsV0FBVyxVQUFVMFgsV0FBVixHQUF3QixXQUFuQztBQUNqQiwyQkFBT3BGLEtBQUt0UyxPQUFMLENBQVA7QUFDSDs7QUFFRCx5QkFBU3NTLElBQVQsQ0FBY3RTLE9BQWQsRUFBdUJxUyxpQkFBdkIsRUFBMENqUSxPQUExQyxFQUFtRDtBQUMvQyx3QkFBSSxDQUFDaEMsT0FBT2dSLFFBQVosRUFBc0I7QUFDdEIsd0JBQUlxRCxVQUFVLElBQUlqRSxPQUFKLENBQVl4USxPQUFaLENBQWQ7QUFDQSx3QkFBSXFRLEdBQUo7QUFDQSx3QkFBSWdDLGlCQUFKLEVBQXVCO0FBQ25CalEsZ0NBQVFnTSxpQkFBUixDQUEwQnFHLE9BQTFCO0FBQ0gscUJBRkQsTUFFTyxJQUFJclUsT0FBTzhPLGVBQVAsS0FBMkJtQixNQUFNemEsUUFBUTJaLFlBQVIsRUFBakMsQ0FBSixFQUE4RDtBQUNqRWMsNEJBQUlrRyxnQkFBSixDQUFxQjlCLE9BQXJCO0FBQ0gscUJBRk0sTUFFQTtBQUNILDRCQUFJZ0MsU0FBU0MscUJBQXFCakMsT0FBckIsQ0FBYjtBQUNBQSxnQ0FBUXphLEtBQVIsR0FBZ0J5YyxPQUFPelcsT0FBUCxHQUFpQixJQUFqQixHQUF3QnlXLE9BQU96YyxLQUFQLENBQWE0YyxJQUFiLENBQWtCLElBQWxCLENBQXhDO0FBQ0g7O0FBRUQsd0JBQUksQ0FBQ2hDLGdCQUFnQixTQUFoQixFQUEyQkgsT0FBM0IsQ0FBTCxFQUEwQztBQUN0Q2tELDBDQUFrQmxELE9BQWxCLEVBQTJCLEVBQTNCLEVBQStCLElBQS9CO0FBQ0g7QUFDSjs7QUFFRCx5QkFBU21ELGdCQUFULENBQTBCNVgsT0FBMUIsRUFBbUM2WCxNQUFuQyxFQUEyQztBQUN2Qyx5QkFBSyxJQUFJOXFCLElBQUksQ0FBYixFQUFnQkEsSUFBSThxQixPQUFPNXFCLE1BQVAsR0FBZ0IsQ0FBcEMsRUFBdUMsRUFBRUYsQ0FBekMsRUFBNEM7QUFDeEM4cUIsK0JBQU85cUIsQ0FBUCxFQUFVZ0wsSUFBVixDQUFlLHNCQUFmO0FBQ0E4ZiwrQkFBTzlxQixDQUFQLElBQVk4cUIsT0FBTzlxQixDQUFQLEVBQVU2cEIsSUFBVixDQUFlLElBQWYsQ0FBWjtBQUNIO0FBQ0Qsd0JBQUk3cEIsSUFBSThxQixPQUFPNXFCLE1BQWYsRUFBdUI7QUFDbkI0cUIsK0JBQU85cUIsQ0FBUCxJQUFZOHFCLE9BQU85cUIsQ0FBUCxFQUFVNnBCLElBQVYsQ0FBZSxJQUFmLENBQVo7QUFDSDtBQUNELDJCQUFPNVcsVUFBVSxJQUFWLEdBQWlCNlgsT0FBT2pCLElBQVAsQ0FBWSxJQUFaLENBQXhCO0FBQ0g7O0FBRUQseUJBQVNrQiwyQkFBVCxDQUFxQ0QsTUFBckMsRUFBNkM7QUFDekMseUJBQUssSUFBSTlxQixJQUFJLENBQWIsRUFBZ0JBLElBQUk4cUIsT0FBTzVxQixNQUEzQixFQUFtQyxFQUFFRixDQUFyQyxFQUF3QztBQUNwQyw0QkFBSThxQixPQUFPOXFCLENBQVAsRUFBVUUsTUFBVixLQUFxQixDQUFyQixJQUNFRixJQUFJLENBQUosR0FBUThxQixPQUFPNXFCLE1BQWhCLElBQTJCNHFCLE9BQU85cUIsQ0FBUCxFQUFVLENBQVYsTUFBaUI4cUIsT0FBTzlxQixJQUFFLENBQVQsRUFBWSxDQUFaLENBRGpELEVBQ2tFO0FBQzlEOHFCLG1DQUFPN2lCLE1BQVAsQ0FBY2pJLENBQWQsRUFBaUIsQ0FBakI7QUFDQUE7QUFDSDtBQUNKO0FBQ0o7O0FBRUQseUJBQVNnckIsaUJBQVQsQ0FBMkJGLE1BQTNCLEVBQW1DO0FBQy9CLHdCQUFJRyxVQUFVSCxPQUFPLENBQVAsQ0FBZDtBQUNBLHlCQUFLLElBQUk5cUIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJOHFCLE9BQU81cUIsTUFBM0IsRUFBbUMsRUFBRUYsQ0FBckMsRUFBd0M7QUFDcEMsNEJBQUlxYSxPQUFPeVEsT0FBTzlxQixDQUFQLENBQVg7QUFDQSw0QkFBSWtyQixtQkFBbUJELFFBQVEvcUIsTUFBUixHQUFpQixDQUF4QztBQUNBLDRCQUFJaXJCLGtCQUFrQkYsUUFBUUMsZ0JBQVIsQ0FBdEI7QUFDQSw0QkFBSUUsc0JBQXNCLENBQUMsQ0FBM0I7O0FBRUEsNkJBQUssSUFBSWxKLElBQUk3SCxLQUFLbmEsTUFBTCxHQUFjLENBQTNCLEVBQThCZ2lCLEtBQUssQ0FBbkMsRUFBc0MsRUFBRUEsQ0FBeEMsRUFBMkM7QUFDdkMsZ0NBQUk3SCxLQUFLNkgsQ0FBTCxNQUFZaUosZUFBaEIsRUFBaUM7QUFDN0JDLHNEQUFzQmxKLENBQXRCO0FBQ0E7QUFDSDtBQUNKOztBQUVELDZCQUFLLElBQUlBLElBQUlrSixtQkFBYixFQUFrQ2xKLEtBQUssQ0FBdkMsRUFBMEMsRUFBRUEsQ0FBNUMsRUFBK0M7QUFDM0MsZ0NBQUltSSxPQUFPaFEsS0FBSzZILENBQUwsQ0FBWDtBQUNBLGdDQUFJK0ksUUFBUUMsZ0JBQVIsTUFBOEJiLElBQWxDLEVBQXdDO0FBQ3BDWSx3Q0FBUXJnQixHQUFSO0FBQ0FzZ0I7QUFDSCw2QkFIRCxNQUdPO0FBQ0g7QUFDSDtBQUNKO0FBQ0RELGtDQUFVNVEsSUFBVjtBQUNIO0FBQ0o7O0FBRUQseUJBQVMrUCxVQUFULENBQW9CbmQsS0FBcEIsRUFBMkI7QUFDdkIsd0JBQUlpTSxNQUFNLEVBQVY7QUFDQSx5QkFBSyxJQUFJbFosSUFBSSxDQUFiLEVBQWdCQSxJQUFJaU4sTUFBTS9NLE1BQTFCLEVBQWtDLEVBQUVGLENBQXBDLEVBQXVDO0FBQ25DLDRCQUFJcXFCLE9BQU9wZCxNQUFNak4sQ0FBTixDQUFYO0FBQ0EsNEJBQUlxckIsY0FBYywyQkFBMkJoQixJQUEzQixJQUNkckcsa0JBQWtCdlYsSUFBbEIsQ0FBdUI0YixJQUF2QixDQURKO0FBRUEsNEJBQUlpQixrQkFBa0JELGVBQWVFLGFBQWFsQixJQUFiLENBQXJDO0FBQ0EsNEJBQUlnQixlQUFlLENBQUNDLGVBQXBCLEVBQXFDO0FBQ2pDLGdDQUFJcEgscUJBQXFCbUcsS0FBS21CLE1BQUwsQ0FBWSxDQUFaLE1BQW1CLEdBQTVDLEVBQWlEO0FBQzdDbkIsdUNBQU8sU0FBU0EsSUFBaEI7QUFDSDtBQUNEblIsZ0NBQUlsTyxJQUFKLENBQVNxZixJQUFUO0FBQ0g7QUFDSjtBQUNELDJCQUFPblIsR0FBUDtBQUNIOztBQUVELHlCQUFTdVMsa0JBQVQsQ0FBNEJ2WSxLQUE1QixFQUFtQztBQUMvQix3QkFBSWpHLFFBQVFpRyxNQUFNakcsS0FBTixDQUFZbE0sT0FBWixDQUFvQixPQUFwQixFQUE2QixFQUE3QixFQUFpQ29wQixLQUFqQyxDQUF1QyxJQUF2QyxDQUFaO0FBQ0EseUJBQUssSUFBSW5xQixJQUFJLENBQWIsRUFBZ0JBLElBQUlpTixNQUFNL00sTUFBMUIsRUFBa0MsRUFBRUYsQ0FBcEMsRUFBdUM7QUFDbkMsNEJBQUlxcUIsT0FBT3BkLE1BQU1qTixDQUFOLENBQVg7QUFDQSw0QkFBSSwyQkFBMkJxcUIsSUFBM0IsSUFBbUNyRyxrQkFBa0J2VixJQUFsQixDQUF1QjRiLElBQXZCLENBQXZDLEVBQXFFO0FBQ2pFO0FBQ0g7QUFDSjtBQUNELHdCQUFJcnFCLElBQUksQ0FBSixJQUFTa1QsTUFBTXlFLElBQU4sSUFBYyxhQUEzQixFQUEwQztBQUN0QzFLLGdDQUFRQSxNQUFNOU4sS0FBTixDQUFZYSxDQUFaLENBQVI7QUFDSDtBQUNELDJCQUFPaU4sS0FBUDtBQUNIOztBQUVELHlCQUFTMGMsb0JBQVQsQ0FBOEJ6VyxLQUE5QixFQUFxQztBQUNqQyx3QkFBSWpHLFFBQVFpRyxNQUFNakcsS0FBbEI7QUFDQSx3QkFBSWdHLFVBQVVDLE1BQU0xUixRQUFOLEVBQWQ7QUFDQXlMLDRCQUFRLE9BQU9BLEtBQVAsS0FBaUIsUUFBakIsSUFBNkJBLE1BQU0vTSxNQUFOLEdBQWUsQ0FBNUMsR0FDTXVyQixtQkFBbUJ2WSxLQUFuQixDQUROLEdBQ2tDLENBQUMsc0JBQUQsQ0FEMUM7QUFFQSwyQkFBTztBQUNIRCxpQ0FBU0EsT0FETjtBQUVIaEcsK0JBQU9pRyxNQUFNeUUsSUFBTixJQUFjLGFBQWQsR0FBOEIxSyxLQUE5QixHQUFzQ21kLFdBQVduZCxLQUFYO0FBRjFDLHFCQUFQO0FBSUg7O0FBRUQseUJBQVMyZCxpQkFBVCxDQUEyQjFYLEtBQTNCLEVBQWtDNkQsS0FBbEMsRUFBeUMyVSxNQUF6QyxFQUFpRDtBQUM3Qyx3QkFBSSxPQUFPQyxPQUFQLEtBQW1CLFdBQXZCLEVBQW9DO0FBQ2hDLDRCQUFJMVksT0FBSjtBQUNBLDRCQUFJd0csS0FBS2hhLFFBQUwsQ0FBY3lULEtBQWQsQ0FBSixFQUEwQjtBQUN0QixnQ0FBSWpHLFFBQVFpRyxNQUFNakcsS0FBbEI7QUFDQWdHLHNDQUFVOEQsUUFBUWtOLFlBQVloWCxLQUFaLEVBQW1CaUcsS0FBbkIsQ0FBbEI7QUFDSCx5QkFIRCxNQUdPO0FBQ0hELHNDQUFVOEQsUUFBUW5XLE9BQU9zUyxLQUFQLENBQWxCO0FBQ0g7QUFDRCw0QkFBSSxPQUFPaVIsWUFBUCxLQUF3QixVQUE1QixFQUF3QztBQUNwQ0EseUNBQWFsUixPQUFiLEVBQXNCeVksTUFBdEI7QUFDSCx5QkFGRCxNQUVPLElBQUksT0FBT0MsUUFBUUMsR0FBZixLQUF1QixVQUF2QixJQUNQLFFBQU9ELFFBQVFDLEdBQWYsTUFBdUIsUUFEcEIsRUFDOEI7QUFDakNELG9DQUFRQyxHQUFSLENBQVkzWSxPQUFaO0FBQ0g7QUFDSjtBQUNKOztBQUVELHlCQUFTMlIsa0JBQVQsQ0FBNEJqTixJQUE1QixFQUFrQ2tVLFlBQWxDLEVBQWdEN0csTUFBaEQsRUFBd0QzUCxPQUF4RCxFQUFpRTtBQUM3RCx3QkFBSXlXLGtCQUFrQixLQUF0QjtBQUNBLHdCQUFJO0FBQ0EsNEJBQUksT0FBT0QsWUFBUCxLQUF3QixVQUE1QixFQUF3QztBQUNwQ0MsOENBQWtCLElBQWxCO0FBQ0EsZ0NBQUluVSxTQUFTLGtCQUFiLEVBQWlDO0FBQzdCa1UsNkNBQWF4VyxPQUFiO0FBQ0gsNkJBRkQsTUFFTztBQUNId1csNkNBQWE3RyxNQUFiLEVBQXFCM1AsT0FBckI7QUFDSDtBQUNKO0FBQ0oscUJBVEQsQ0FTRSxPQUFPL1csQ0FBUCxFQUFVO0FBQ1IrZ0IsOEJBQU1yRSxVQUFOLENBQWlCMWMsQ0FBakI7QUFDSDs7QUFFRCx3QkFBSXFaLFNBQVMsb0JBQWIsRUFBbUM7QUFDL0IsNEJBQUksQ0FBQ2tRLGdCQUFnQmxRLElBQWhCLEVBQXNCcU4sTUFBdEIsRUFBOEIzUCxPQUE5QixDQUFELElBQTJDLENBQUN5VyxlQUFoRCxFQUFpRTtBQUM3RGxCLDhDQUFrQjVGLE1BQWxCLEVBQTBCLHNCQUExQjtBQUNIO0FBQ0oscUJBSkQsTUFJTztBQUNINkMsd0NBQWdCbFEsSUFBaEIsRUFBc0J0QyxPQUF0QjtBQUNIO0FBQ0o7O0FBRUQseUJBQVMwVyxjQUFULENBQXdCbnNCLEdBQXhCLEVBQTZCO0FBQ3pCLHdCQUFJaUIsR0FBSjtBQUNBLHdCQUFJLE9BQU9qQixHQUFQLEtBQWUsVUFBbkIsRUFBK0I7QUFDM0JpQiw4QkFBTSxnQkFDRGpCLElBQUkrWCxJQUFKLElBQVksV0FEWCxJQUVGLEdBRko7QUFHSCxxQkFKRCxNQUlPO0FBQ0g5Vyw4QkFBTWpCLE9BQU8sT0FBT0EsSUFBSTRCLFFBQVgsS0FBd0IsVUFBL0IsR0FDQTVCLElBQUk0QixRQUFKLEVBREEsR0FDaUJpWSxLQUFLalksUUFBTCxDQUFjNUIsR0FBZCxDQUR2QjtBQUVBLDRCQUFJb3NCLG1CQUFtQiwyQkFBdkI7QUFDQSw0QkFBSUEsaUJBQWlCdmQsSUFBakIsQ0FBc0I1TixHQUF0QixDQUFKLEVBQWdDO0FBQzVCLGdDQUFJO0FBQ0Esb0NBQUlvckIsU0FBU0MsS0FBS0MsU0FBTCxDQUFldnNCLEdBQWYsQ0FBYjtBQUNBaUIsc0NBQU1vckIsTUFBTjtBQUNILDZCQUhELENBSUEsT0FBTTN0QixDQUFOLEVBQVMsQ0FFUjtBQUNKO0FBQ0QsNEJBQUl1QyxJQUFJWCxNQUFKLEtBQWUsQ0FBbkIsRUFBc0I7QUFDbEJXLGtDQUFNLGVBQU47QUFDSDtBQUNKO0FBQ0QsMkJBQVEsT0FBT3VyQixLQUFLdnJCLEdBQUwsQ0FBUCxHQUFtQixvQkFBM0I7QUFDSDs7QUFFRCx5QkFBU3VyQixJQUFULENBQWN2ckIsR0FBZCxFQUFtQjtBQUNmLHdCQUFJd3JCLFdBQVcsRUFBZjtBQUNBLHdCQUFJeHJCLElBQUlYLE1BQUosR0FBYW1zQixRQUFqQixFQUEyQjtBQUN2QiwrQkFBT3hyQixHQUFQO0FBQ0g7QUFDRCwyQkFBT0EsSUFBSXlyQixNQUFKLENBQVcsQ0FBWCxFQUFjRCxXQUFXLENBQXpCLElBQThCLEtBQXJDO0FBQ0g7O0FBRUQseUJBQVN4RywwQkFBVCxHQUFzQztBQUNsQywyQkFBTyxPQUFPMEcsaUJBQVAsS0FBNkIsVUFBcEM7QUFDSDs7QUFFRCxvQkFBSWhCLGVBQWUsd0JBQVc7QUFBRSwyQkFBTyxLQUFQO0FBQWUsaUJBQS9DO0FBQ0Esb0JBQUlpQixxQkFBcUIsdUNBQXpCO0FBQ0EseUJBQVNDLGFBQVQsQ0FBdUJwQyxJQUF2QixFQUE2QjtBQUN6Qix3QkFBSXFDLFVBQVVyQyxLQUFLRSxLQUFMLENBQVdpQyxrQkFBWCxDQUFkO0FBQ0Esd0JBQUlFLE9BQUosRUFBYTtBQUNULCtCQUFPO0FBQ0hDLHNDQUFVRCxRQUFRLENBQVIsQ0FEUDtBQUVIckMsa0NBQU11QyxTQUFTRixRQUFRLENBQVIsQ0FBVCxFQUFxQixFQUFyQjtBQUZILHlCQUFQO0FBSUg7QUFDSjs7QUFFRCx5QkFBU0csU0FBVCxDQUFtQnZULGNBQW5CLEVBQW1Dd1QsYUFBbkMsRUFBa0Q7QUFDOUMsd0JBQUksQ0FBQ2pILDRCQUFMLEVBQW1DO0FBQ25DLHdCQUFJa0gsa0JBQWtCelQsZUFBZXJNLEtBQWYsQ0FBcUJrZCxLQUFyQixDQUEyQixJQUEzQixDQUF0QjtBQUNBLHdCQUFJNkMsaUJBQWlCRixjQUFjN2YsS0FBZCxDQUFvQmtkLEtBQXBCLENBQTBCLElBQTFCLENBQXJCO0FBQ0Esd0JBQUk4QyxhQUFhLENBQUMsQ0FBbEI7QUFDQSx3QkFBSXRpQixZQUFZLENBQUMsQ0FBakI7QUFDQSx3QkFBSXVpQixhQUFKO0FBQ0Esd0JBQUlDLFlBQUo7QUFDQSx5QkFBSyxJQUFJbnRCLElBQUksQ0FBYixFQUFnQkEsSUFBSStzQixnQkFBZ0I3c0IsTUFBcEMsRUFBNEMsRUFBRUYsQ0FBOUMsRUFBaUQ7QUFDN0MsNEJBQUkrRixTQUFTMG1CLGNBQWNNLGdCQUFnQi9zQixDQUFoQixDQUFkLENBQWI7QUFDQSw0QkFBSStGLE1BQUosRUFBWTtBQUNSbW5CLDRDQUFnQm5uQixPQUFPNG1CLFFBQXZCO0FBQ0FNLHlDQUFhbG5CLE9BQU9za0IsSUFBcEI7QUFDQTtBQUNIO0FBQ0o7QUFDRCx5QkFBSyxJQUFJcnFCLElBQUksQ0FBYixFQUFnQkEsSUFBSWd0QixlQUFlOXNCLE1BQW5DLEVBQTJDLEVBQUVGLENBQTdDLEVBQWdEO0FBQzVDLDRCQUFJK0YsU0FBUzBtQixjQUFjTyxlQUFlaHRCLENBQWYsQ0FBZCxDQUFiO0FBQ0EsNEJBQUkrRixNQUFKLEVBQVk7QUFDUm9uQiwyQ0FBZXBuQixPQUFPNG1CLFFBQXRCO0FBQ0FoaUIsd0NBQVk1RSxPQUFPc2tCLElBQW5CO0FBQ0E7QUFDSDtBQUNKO0FBQ0Qsd0JBQUk0QyxhQUFhLENBQWIsSUFBa0J0aUIsWUFBWSxDQUE5QixJQUFtQyxDQUFDdWlCLGFBQXBDLElBQXFELENBQUNDLFlBQXRELElBQ0FELGtCQUFrQkMsWUFEbEIsSUFDa0NGLGNBQWN0aUIsU0FEcEQsRUFDK0Q7QUFDM0Q7QUFDSDs7QUFFRDRnQixtQ0FBZSxzQkFBU2xCLElBQVQsRUFBZTtBQUMxQiw0QkFBSXhHLHFCQUFxQnBWLElBQXJCLENBQTBCNGIsSUFBMUIsQ0FBSixFQUFxQyxPQUFPLElBQVA7QUFDckMsNEJBQUkrQyxPQUFPWCxjQUFjcEMsSUFBZCxDQUFYO0FBQ0EsNEJBQUkrQyxJQUFKLEVBQVU7QUFDTixnQ0FBSUEsS0FBS1QsUUFBTCxLQUFrQk8sYUFBbEIsSUFDQ0QsY0FBY0csS0FBSy9DLElBQW5CLElBQTJCK0MsS0FBSy9DLElBQUwsSUFBYTFmLFNBRDdDLEVBQ3lEO0FBQ3JELHVDQUFPLElBQVA7QUFDSDtBQUNKO0FBQ0QsK0JBQU8sS0FBUDtBQUNILHFCQVZEO0FBV0g7O0FBRUQseUJBQVNnWSxhQUFULENBQXVCM0MsTUFBdkIsRUFBK0I7QUFDM0IseUJBQUt1SixPQUFMLEdBQWV2SixNQUFmO0FBQ0EseUJBQUtxTixnQkFBTCxHQUF3QixDQUF4QjtBQUNBLHdCQUFJbnRCLFNBQVMsS0FBS3lnQixPQUFMLEdBQWUsS0FBS1gsV0FBVzdaLFNBQVgsR0FBdUIsQ0FBdkIsR0FBMkI2WixPQUFPVyxPQUF2QyxDQUE1QjtBQUNBNEwsc0NBQWtCLElBQWxCLEVBQXdCNUosYUFBeEI7QUFDQSx3QkFBSXppQixTQUFTLEVBQWIsRUFBaUIsS0FBS290QixPQUFMO0FBQ3BCO0FBQ0Q3VCxxQkFBSzhULFFBQUwsQ0FBYzVLLGFBQWQsRUFBNkIvTSxLQUE3QjtBQUNBNk0sd0JBQVFFLGFBQVIsR0FBd0JBLGFBQXhCOztBQUVBQSw4QkFBY2hpQixTQUFkLENBQXdCMnNCLE9BQXhCLEdBQWtDLFlBQVc7QUFDekMsd0JBQUlwdEIsU0FBUyxLQUFLeWdCLE9BQWxCO0FBQ0Esd0JBQUl6Z0IsU0FBUyxDQUFiLEVBQWdCO0FBQ2hCLHdCQUFJc3RCLFFBQVEsRUFBWjtBQUNBLHdCQUFJQyxlQUFlLEVBQW5COztBQUVBLHlCQUFLLElBQUl6dEIsSUFBSSxDQUFSLEVBQVcwdEIsT0FBTyxJQUF2QixFQUE2QkEsU0FBU3ZuQixTQUF0QyxFQUFpRCxFQUFFbkcsQ0FBbkQsRUFBc0Q7QUFDbER3dEIsOEJBQU14aUIsSUFBTixDQUFXMGlCLElBQVg7QUFDQUEsK0JBQU9BLEtBQUtuRSxPQUFaO0FBQ0g7QUFDRHJwQiw2QkFBUyxLQUFLeWdCLE9BQUwsR0FBZTNnQixDQUF4QjtBQUNBLHlCQUFLLElBQUlBLElBQUlFLFNBQVMsQ0FBdEIsRUFBeUJGLEtBQUssQ0FBOUIsRUFBaUMsRUFBRUEsQ0FBbkMsRUFBc0M7QUFDbEMsNEJBQUlpTixRQUFRdWdCLE1BQU14dEIsQ0FBTixFQUFTaU4sS0FBckI7QUFDQSw0QkFBSXdnQixhQUFheGdCLEtBQWIsTUFBd0I5RyxTQUE1QixFQUF1QztBQUNuQ3NuQix5Q0FBYXhnQixLQUFiLElBQXNCak4sQ0FBdEI7QUFDSDtBQUNKO0FBQ0QseUJBQUssSUFBSUEsSUFBSSxDQUFiLEVBQWdCQSxJQUFJRSxNQUFwQixFQUE0QixFQUFFRixDQUE5QixFQUFpQztBQUM3Qiw0QkFBSTJ0QixlQUFlSCxNQUFNeHRCLENBQU4sRUFBU2lOLEtBQTVCO0FBQ0EsNEJBQUk5TCxRQUFRc3NCLGFBQWFFLFlBQWIsQ0FBWjtBQUNBLDRCQUFJeHNCLFVBQVVnRixTQUFWLElBQXVCaEYsVUFBVW5CLENBQXJDLEVBQXdDO0FBQ3BDLGdDQUFJbUIsUUFBUSxDQUFaLEVBQWU7QUFDWHFzQixzQ0FBTXJzQixRQUFRLENBQWQsRUFBaUJvb0IsT0FBakIsR0FBMkJwakIsU0FBM0I7QUFDQXFuQixzQ0FBTXJzQixRQUFRLENBQWQsRUFBaUJ3ZixPQUFqQixHQUEyQixDQUEzQjtBQUNIO0FBQ0Q2TSxrQ0FBTXh0QixDQUFOLEVBQVN1cEIsT0FBVCxHQUFtQnBqQixTQUFuQjtBQUNBcW5CLGtDQUFNeHRCLENBQU4sRUFBUzJnQixPQUFULEdBQW1CLENBQW5CO0FBQ0EsZ0NBQUlpTixnQkFBZ0I1dEIsSUFBSSxDQUFKLEdBQVF3dEIsTUFBTXh0QixJQUFJLENBQVYsQ0FBUixHQUF1QixJQUEzQzs7QUFFQSxnQ0FBSW1CLFFBQVFqQixTQUFTLENBQXJCLEVBQXdCO0FBQ3BCMHRCLDhDQUFjckUsT0FBZCxHQUF3QmlFLE1BQU1yc0IsUUFBUSxDQUFkLENBQXhCO0FBQ0F5c0IsOENBQWNyRSxPQUFkLENBQXNCK0QsT0FBdEI7QUFDQU0sOENBQWNqTixPQUFkLEdBQ0lpTixjQUFjckUsT0FBZCxDQUFzQjVJLE9BQXRCLEdBQWdDLENBRHBDO0FBRUgsNkJBTEQsTUFLTztBQUNIaU4sOENBQWNyRSxPQUFkLEdBQXdCcGpCLFNBQXhCO0FBQ0F5bkIsOENBQWNqTixPQUFkLEdBQXdCLENBQXhCO0FBQ0g7QUFDRCxnQ0FBSWtOLHFCQUFxQkQsY0FBY2pOLE9BQWQsR0FBd0IsQ0FBakQ7QUFDQSxpQ0FBSyxJQUFJdUIsSUFBSWxpQixJQUFJLENBQWpCLEVBQW9Ca2lCLEtBQUssQ0FBekIsRUFBNEIsRUFBRUEsQ0FBOUIsRUFBaUM7QUFDN0JzTCxzQ0FBTXRMLENBQU4sRUFBU3ZCLE9BQVQsR0FBbUJrTixrQkFBbkI7QUFDQUE7QUFDSDtBQUNEO0FBQ0g7QUFDSjtBQUNKLGlCQTlDRDs7QUFnREFsTCw4QkFBY2hpQixTQUFkLENBQXdCNm9CLGdCQUF4QixHQUEyQyxVQUFTdFcsS0FBVCxFQUFnQjtBQUN2RCx3QkFBSUEsTUFBTXVXLGdCQUFWLEVBQTRCO0FBQzVCLHlCQUFLNkQsT0FBTDtBQUNBLHdCQUFJNUQsU0FBU0MscUJBQXFCelcsS0FBckIsQ0FBYjtBQUNBLHdCQUFJRCxVQUFVeVcsT0FBT3pXLE9BQXJCO0FBQ0Esd0JBQUk2WCxTQUFTLENBQUNwQixPQUFPemMsS0FBUixDQUFiOztBQUVBLHdCQUFJNFYsUUFBUSxJQUFaO0FBQ0EsMkJBQU9BLFVBQVUxYyxTQUFqQixFQUE0QjtBQUN4QjJrQiwrQkFBTzlmLElBQVAsQ0FBWW9mLFdBQVd2SCxNQUFNNVYsS0FBTixDQUFZa2QsS0FBWixDQUFrQixJQUFsQixDQUFYLENBQVo7QUFDQXRILGdDQUFRQSxNQUFNMEcsT0FBZDtBQUNIO0FBQ0R5QixzQ0FBa0JGLE1BQWxCO0FBQ0FDLGdEQUE0QkQsTUFBNUI7QUFDQXJSLHlCQUFLbVEsaUJBQUwsQ0FBdUIxVyxLQUF2QixFQUE4QixPQUE5QixFQUF1QzJYLGlCQUFpQjVYLE9BQWpCLEVBQTBCNlgsTUFBMUIsQ0FBdkM7QUFDQXJSLHlCQUFLbVEsaUJBQUwsQ0FBdUIxVyxLQUF2QixFQUE4QixrQkFBOUIsRUFBa0QsSUFBbEQ7QUFDSCxpQkFoQkQ7O0FBa0JBLG9CQUFJcVosb0JBQXFCLFNBQVN1QixjQUFULEdBQTBCO0FBQy9DLHdCQUFJQyxzQkFBc0IsV0FBMUI7QUFDQSx3QkFBSUMsbUJBQW1CLFNBQW5CQSxnQkFBbUIsQ0FBUy9nQixLQUFULEVBQWdCaUcsS0FBaEIsRUFBdUI7QUFDMUMsNEJBQUksT0FBT2pHLEtBQVAsS0FBaUIsUUFBckIsRUFBK0IsT0FBT0EsS0FBUDs7QUFFL0IsNEJBQUlpRyxNQUFNeUUsSUFBTixLQUFleFIsU0FBZixJQUNBK00sTUFBTUQsT0FBTixLQUFrQjlNLFNBRHRCLEVBQ2lDO0FBQzdCLG1DQUFPK00sTUFBTTFSLFFBQU4sRUFBUDtBQUNIO0FBQ0QsK0JBQU91cUIsZUFBZTdZLEtBQWYsQ0FBUDtBQUNILHFCQVJEOztBQVVBLHdCQUFJLE9BQU8wQyxNQUFNcVksZUFBYixLQUFpQyxRQUFqQyxJQUNBLE9BQU9yWSxNQUFNMlcsaUJBQWIsS0FBbUMsVUFEdkMsRUFDbUQ7QUFDL0MzVyw4QkFBTXFZLGVBQU4sSUFBeUIsQ0FBekI7QUFDQWpLLDRDQUFvQitKLG1CQUFwQjtBQUNBOUosc0NBQWMrSixnQkFBZDtBQUNBLDRCQUFJekIsb0JBQW9CM1csTUFBTTJXLGlCQUE5Qjs7QUFFQWhCLHVDQUFlLHNCQUFTbEIsSUFBVCxFQUFlO0FBQzFCLG1DQUFPeEcscUJBQXFCcFYsSUFBckIsQ0FBMEI0YixJQUExQixDQUFQO0FBQ0gseUJBRkQ7QUFHQSwrQkFBTyxVQUFTblAsUUFBVCxFQUFtQmdULFdBQW5CLEVBQWdDO0FBQ25DdFksa0NBQU1xWSxlQUFOLElBQXlCLENBQXpCO0FBQ0ExQiw4Q0FBa0JyUixRQUFsQixFQUE0QmdULFdBQTVCO0FBQ0F0WSxrQ0FBTXFZLGVBQU4sSUFBeUIsQ0FBekI7QUFDSCx5QkFKRDtBQUtIO0FBQ0Qsd0JBQUlFLE1BQU0sSUFBSXZZLEtBQUosRUFBVjs7QUFFQSx3QkFBSSxPQUFPdVksSUFBSWxoQixLQUFYLEtBQXFCLFFBQXJCLElBQ0FraEIsSUFBSWxoQixLQUFKLENBQVVrZCxLQUFWLENBQWdCLElBQWhCLEVBQXNCLENBQXRCLEVBQXlCaUUsT0FBekIsQ0FBaUMsaUJBQWpDLEtBQXVELENBRDNELEVBQzhEO0FBQzFEcEssNENBQW9CLEdBQXBCO0FBQ0FDLHNDQUFjK0osZ0JBQWQ7QUFDQTlKLDRDQUFvQixJQUFwQjtBQUNBLCtCQUFPLFNBQVNxSSxpQkFBVCxDQUEyQnZYLENBQTNCLEVBQThCO0FBQ2pDQSw4QkFBRS9ILEtBQUYsR0FBVSxJQUFJMkksS0FBSixHQUFZM0ksS0FBdEI7QUFDSCx5QkFGRDtBQUdIOztBQUVELHdCQUFJb2hCLGtCQUFKO0FBQ0Esd0JBQUk7QUFBRSw4QkFBTSxJQUFJelksS0FBSixFQUFOO0FBQW9CLHFCQUExQixDQUNBLE9BQU10WCxDQUFOLEVBQVM7QUFDTCt2Qiw2Q0FBc0IsV0FBVy92QixDQUFqQztBQUNIO0FBQ0Qsd0JBQUksRUFBRSxXQUFXNnZCLEdBQWIsS0FBcUJFLGtCQUFyQixJQUNBLE9BQU96WSxNQUFNcVksZUFBYixLQUFpQyxRQURyQyxFQUMrQztBQUMzQ2pLLDRDQUFvQitKLG1CQUFwQjtBQUNBOUosc0NBQWMrSixnQkFBZDtBQUNBLCtCQUFPLFNBQVN6QixpQkFBVCxDQUEyQnZYLENBQTNCLEVBQThCO0FBQ2pDWSxrQ0FBTXFZLGVBQU4sSUFBeUIsQ0FBekI7QUFDQSxnQ0FBSTtBQUFFLHNDQUFNLElBQUlyWSxLQUFKLEVBQU47QUFBb0IsNkJBQTFCLENBQ0EsT0FBTXRYLENBQU4sRUFBUztBQUFFMFcsa0NBQUUvSCxLQUFGLEdBQVUzTyxFQUFFMk8sS0FBWjtBQUFvQjtBQUMvQjJJLGtDQUFNcVksZUFBTixJQUF5QixDQUF6QjtBQUNILHlCQUxEO0FBTUg7O0FBRURoSyxrQ0FBYyxxQkFBU2hYLEtBQVQsRUFBZ0JpRyxLQUFoQixFQUF1QjtBQUNqQyw0QkFBSSxPQUFPakcsS0FBUCxLQUFpQixRQUFyQixFQUErQixPQUFPQSxLQUFQOztBQUUvQiw0QkFBSSxDQUFDLFFBQU9pRyxLQUFQLHlDQUFPQSxLQUFQLE9BQWlCLFFBQWpCLElBQ0QsT0FBT0EsS0FBUCxLQUFpQixVQURqQixLQUVBQSxNQUFNeUUsSUFBTixLQUFleFIsU0FGZixJQUdBK00sTUFBTUQsT0FBTixLQUFrQjlNLFNBSHRCLEVBR2lDO0FBQzdCLG1DQUFPK00sTUFBTTFSLFFBQU4sRUFBUDtBQUNIO0FBQ0QsK0JBQU91cUIsZUFBZTdZLEtBQWYsQ0FBUDtBQUNILHFCQVZEOztBQVlBLDJCQUFPLElBQVA7QUFFSCxpQkF2RXVCLENBdUVyQixFQXZFcUIsQ0FBeEI7O0FBeUVBLG9CQUFJLE9BQU95WSxPQUFQLEtBQW1CLFdBQW5CLElBQWtDLE9BQU9BLFFBQVFwRyxJQUFmLEtBQXdCLFdBQTlELEVBQTJFO0FBQ3ZFcEIsbUNBQWUsc0JBQVVsUixPQUFWLEVBQW1CO0FBQzlCMFksZ0NBQVFwRyxJQUFSLENBQWF0UyxPQUFiO0FBQ0gscUJBRkQ7QUFHQSx3QkFBSXdHLEtBQUttQixNQUFMLElBQWV0VyxRQUFRdVcsTUFBUixDQUFleVQsS0FBbEMsRUFBeUM7QUFDckNuSyx1Q0FBZSxzQkFBU2xSLE9BQVQsRUFBa0J5WSxNQUFsQixFQUEwQjtBQUNyQyxnQ0FBSTZDLFFBQVE3QyxTQUFTLFVBQVQsR0FBd0IsVUFBcEM7QUFDQUMsb0NBQVFwRyxJQUFSLENBQWFnSixRQUFRdGIsT0FBUixHQUFrQixXQUEvQjtBQUNILHlCQUhEO0FBSUgscUJBTEQsTUFLTyxJQUFJLENBQUN3RyxLQUFLbUIsTUFBTixJQUFnQixPQUFRLElBQUloRixLQUFKLEdBQVkzSSxLQUFwQixLQUErQixRQUFuRCxFQUE2RDtBQUNoRWtYLHVDQUFlLHNCQUFTbFIsT0FBVCxFQUFrQnlZLE1BQWxCLEVBQTBCO0FBQ3JDQyxvQ0FBUXBHLElBQVIsQ0FBYSxPQUFPdFMsT0FBcEIsRUFDWXlZLFNBQVMsbUJBQVQsR0FBK0IsWUFEM0M7QUFFSCx5QkFIRDtBQUlIO0FBQ0o7O0FBRUQsb0JBQUlyWSxTQUFTO0FBQ1RnUiw4QkFBVUEsUUFERDtBQUVUbEMscUNBQWlCLEtBRlI7QUFHVDNDLGtDQUFjLEtBSEw7QUFJVG1KLGdDQUFZO0FBSkgsaUJBQWI7O0FBT0Esb0JBQUl4RyxlQUFKLEVBQXFCdFosUUFBUXNaLGVBQVI7O0FBRXJCLHVCQUFPO0FBQ0hBLHFDQUFpQiwyQkFBVztBQUN4QiwrQkFBTzlPLE9BQU84TyxlQUFkO0FBQ0gscUJBSEU7QUFJSGtDLDhCQUFVLG9CQUFXO0FBQ2pCLCtCQUFPaFIsT0FBT2dSLFFBQWQ7QUFDSCxxQkFORTtBQU9IN0Usa0NBQWMsd0JBQVc7QUFDckIsK0JBQU9uTSxPQUFPbU0sWUFBZDtBQUNILHFCQVRFO0FBVUhtSixnQ0FBWSxzQkFBVztBQUNuQiwrQkFBT3RWLE9BQU9zVixVQUFkO0FBQ0gscUJBWkU7QUFhSDNMLDJDQUF1QixpQ0FBVztBQUM5QiwrQkFBT0Esc0JBQVA7QUFDSCxxQkFmRTtBQWdCSEUsd0NBQW9CLDhCQUFXO0FBQzNCLCtCQUFPQSxtQkFBUDtBQUNILHFCQWxCRTtBQW1CSDRNLDJDQUF1QkEscUJBbkJwQjtBQW9CSCtDLCtCQUFXQSxTQXBCUjtBQXFCSHRILDBCQUFNQSxJQXJCSDtBQXNCSG1GLGdDQUFZQSxVQXRCVDtBQXVCSC9ILG1DQUFlQSxhQXZCWjtBQXdCSHlELGtDQUFjQSxZQXhCWDtBQXlCSFkscUNBQWlCQTtBQXpCZCxpQkFBUDtBQTJCQyxhQWw1QkQ7QUFvNUJDLFNBdDVCTyxFQXM1Qk4sRUFBQyxZQUFXLEVBQVosRUFBZSxVQUFTLEVBQXhCLEVBdDVCTSxDQS9uQnd2QixFQXFoRGp1QixJQUFHLENBQUMsVUFBU3BPLE9BQVQsRUFBaUJwYSxNQUFqQixFQUF3QkMsT0FBeEIsRUFBZ0M7QUFDbkU7O0FBQ0FELG1CQUFPQyxPQUFQLEdBQWlCLFVBQVNvSyxPQUFULEVBQWtCO0FBQ25DLHlCQUFTMmxCLFFBQVQsR0FBb0I7QUFDaEIsMkJBQU8sS0FBS3pwQixLQUFaO0FBQ0g7QUFDRCx5QkFBUzBwQixPQUFULEdBQW1CO0FBQ2YsMEJBQU0sS0FBS3pKLE1BQVg7QUFDSDs7QUFFRG5jLHdCQUFRbEksU0FBUixDQUFrQixRQUFsQixJQUNBa0ksUUFBUWxJLFNBQVIsQ0FBa0IrdEIsVUFBbEIsR0FBK0IsVUFBVTNwQixLQUFWLEVBQWlCO0FBQzVDLHdCQUFJQSxpQkFBaUI4RCxPQUFyQixFQUE4QjlELE1BQU13ZiwyQkFBTjtBQUM5QiwyQkFBTyxLQUFLOUgsS0FBTCxDQUNIK1IsUUFERyxFQUNPcm9CLFNBRFAsRUFDa0JBLFNBRGxCLEVBQzZCLEVBQUNwQixPQUFPQSxLQUFSLEVBRDdCLEVBQzZDb0IsU0FEN0MsQ0FBUDtBQUVILGlCQUxEOztBQU9BMEMsd0JBQVFsSSxTQUFSLENBQWtCLE9BQWxCLElBQ0FrSSxRQUFRbEksU0FBUixDQUFrQmd1QixTQUFsQixHQUE4QixVQUFVM0osTUFBVixFQUFrQjtBQUM1QywyQkFBTyxLQUFLdkksS0FBTCxDQUNIZ1MsT0FERyxFQUNNdG9CLFNBRE4sRUFDaUJBLFNBRGpCLEVBQzRCLEVBQUM2ZSxRQUFRQSxNQUFULEVBRDVCLEVBQzhDN2UsU0FEOUMsQ0FBUDtBQUVILGlCQUpEOztBQU1BMEMsd0JBQVFsSSxTQUFSLENBQWtCaXVCLFVBQWxCLEdBQStCLFVBQVU1SixNQUFWLEVBQWtCO0FBQzdDLHdCQUFJL2tCLFVBQVVDLE1BQVYsSUFBb0IsQ0FBeEIsRUFBMkI7QUFDdkIsK0JBQU8sS0FBS3VjLEtBQUwsQ0FDSHRXLFNBREcsRUFDUXNvQixPQURSLEVBQ2lCdG9CLFNBRGpCLEVBQzRCLEVBQUM2ZSxRQUFRQSxNQUFULEVBRDVCLEVBQzhDN2UsU0FEOUMsQ0FBUDtBQUVILHFCQUhELE1BR087QUFDSCw0QkFBSTBvQixVQUFVNXVCLFVBQVUsQ0FBVixDQUFkO0FBQ0EsNEJBQUk4b0IsVUFBVSxTQUFWQSxPQUFVLEdBQVc7QUFBQyxrQ0FBTThGLE9BQU47QUFBZSx5QkFBekM7QUFDQSwrQkFBTyxLQUFLQyxNQUFMLENBQVk5SixNQUFaLEVBQW9CK0QsT0FBcEIsQ0FBUDtBQUNIO0FBQ0osaUJBVEQ7O0FBV0FsZ0Isd0JBQVFsSSxTQUFSLENBQWtCb3VCLFdBQWxCLEdBQWdDLFVBQVVocUIsS0FBVixFQUFpQjtBQUM3Qyx3QkFBSTlFLFVBQVVDLE1BQVYsSUFBb0IsQ0FBeEIsRUFBMkI7QUFDdkIsNEJBQUk2RSxpQkFBaUI4RCxPQUFyQixFQUE4QjlELE1BQU13ZiwyQkFBTjtBQUM5QiwrQkFBTyxLQUFLOUgsS0FBTCxDQUNIdFcsU0FERyxFQUNRcW9CLFFBRFIsRUFDa0Jyb0IsU0FEbEIsRUFDNkIsRUFBQ3BCLE9BQU9BLEtBQVIsRUFEN0IsRUFDNkNvQixTQUQ3QyxDQUFQO0FBRUgscUJBSkQsTUFJTztBQUNILDRCQUFJNm9CLFNBQVMvdUIsVUFBVSxDQUFWLENBQWI7QUFDQSw0QkFBSSt1QixrQkFBa0JubUIsT0FBdEIsRUFBK0JtbUIsT0FBT3pLLDJCQUFQO0FBQy9CLDRCQUFJd0UsVUFBVSxTQUFWQSxPQUFVLEdBQVc7QUFBQyxtQ0FBT2lHLE1BQVA7QUFBZSx5QkFBekM7QUFDQSwrQkFBTyxLQUFLRixNQUFMLENBQVkvcEIsS0FBWixFQUFtQmdrQixPQUFuQixDQUFQO0FBQ0g7QUFDSixpQkFYRDtBQVlDLGFBNUNEO0FBOENDLFNBaERpQyxFQWdEaEMsRUFoRGdDLENBcmhEOHRCLEVBcWtEMXZCLElBQUcsQ0FBQyxVQUFTblEsT0FBVCxFQUFpQnBhLE1BQWpCLEVBQXdCQyxPQUF4QixFQUFnQztBQUMxQzs7QUFDQUQsbUJBQU9DLE9BQVAsR0FBaUIsVUFBU29LLE9BQVQsRUFBa0JpVCxRQUFsQixFQUE0QjtBQUM3QyxvQkFBSW1ULGdCQUFnQnBtQixRQUFRcW1CLE1BQTVCO0FBQ0Esb0JBQUlDLGFBQWF0bUIsUUFBUXVtQixHQUF6Qjs7QUFFQSx5QkFBU0MsY0FBVCxHQUEwQjtBQUN0QiwyQkFBT0YsV0FBVyxJQUFYLENBQVA7QUFDSDs7QUFFRCx5QkFBU0csZ0JBQVQsQ0FBMEJyVyxRQUExQixFQUFvQ2pZLEVBQXBDLEVBQXdDO0FBQ3BDLDJCQUFPaXVCLGNBQWNoVyxRQUFkLEVBQXdCalksRUFBeEIsRUFBNEI4YSxRQUE1QixFQUFzQ0EsUUFBdEMsQ0FBUDtBQUNIOztBQUVEalQsd0JBQVFsSSxTQUFSLENBQWtCdkIsSUFBbEIsR0FBeUIsVUFBVTRCLEVBQVYsRUFBYztBQUNuQywyQkFBT2l1QixjQUFjLElBQWQsRUFBb0JqdUIsRUFBcEIsRUFBd0I4YSxRQUF4QixFQUFrQyxDQUFsQyxFQUNJVyxLQURKLENBQ1U0UyxjQURWLEVBQzBCbHBCLFNBRDFCLEVBQ3FDQSxTQURyQyxFQUNnRCxJQURoRCxFQUNzREEsU0FEdEQsQ0FBUDtBQUVILGlCQUhEOztBQUtBMEMsd0JBQVFsSSxTQUFSLENBQWtCNHVCLFNBQWxCLEdBQThCLFVBQVV2dUIsRUFBVixFQUFjO0FBQ3hDLDJCQUFPaXVCLGNBQWMsSUFBZCxFQUFvQmp1QixFQUFwQixFQUF3QjhhLFFBQXhCLEVBQWtDQSxRQUFsQyxDQUFQO0FBQ0gsaUJBRkQ7O0FBSUFqVCx3QkFBUXpKLElBQVIsR0FBZSxVQUFVNlosUUFBVixFQUFvQmpZLEVBQXBCLEVBQXdCO0FBQ25DLDJCQUFPaXVCLGNBQWNoVyxRQUFkLEVBQXdCalksRUFBeEIsRUFBNEI4YSxRQUE1QixFQUFzQyxDQUF0QyxFQUNJVyxLQURKLENBQ1U0UyxjQURWLEVBQzBCbHBCLFNBRDFCLEVBQ3FDQSxTQURyQyxFQUNnRDhTLFFBRGhELEVBQzBEOVMsU0FEMUQsQ0FBUDtBQUVILGlCQUhEOztBQUtBMEMsd0JBQVEwbUIsU0FBUixHQUFvQkQsZ0JBQXBCO0FBQ0MsYUEzQkQ7QUE4QkMsU0FoQ1EsRUFnQ1AsRUFoQ08sQ0Fya0R1dkIsRUFxbUQxdkIsSUFBRyxDQUFDLFVBQVMxVyxPQUFULEVBQWlCcGEsTUFBakIsRUFBd0JDLE9BQXhCLEVBQWdDO0FBQzFDOztBQUNBLGdCQUFJK3dCLE1BQU01VyxRQUFRLE9BQVIsQ0FBVjtBQUNBLGdCQUFJNlcsZUFBZUQsSUFBSUUsTUFBdkI7QUFDQSxnQkFBSWpXLE9BQU9iLFFBQVEsUUFBUixDQUFYO0FBQ0EsZ0JBQUkyVSxXQUFXOVQsS0FBSzhULFFBQXBCO0FBQ0EsZ0JBQUkzRCxvQkFBb0JuUSxLQUFLbVEsaUJBQTdCOztBQUVBLHFCQUFTK0YsUUFBVCxDQUFrQkMsWUFBbEIsRUFBZ0NDLGNBQWhDLEVBQWdEO0FBQzVDLHlCQUFTQyxRQUFULENBQWtCN2MsT0FBbEIsRUFBMkI7QUFDdkIsd0JBQUksRUFBRSxnQkFBZ0I2YyxRQUFsQixDQUFKLEVBQWlDLE9BQU8sSUFBSUEsUUFBSixDQUFhN2MsT0FBYixDQUFQO0FBQ2pDMlcsc0NBQWtCLElBQWxCLEVBQXdCLFNBQXhCLEVBQ0ksT0FBTzNXLE9BQVAsS0FBbUIsUUFBbkIsR0FBOEJBLE9BQTlCLEdBQXdDNGMsY0FENUM7QUFFQWpHLHNDQUFrQixJQUFsQixFQUF3QixNQUF4QixFQUFnQ2dHLFlBQWhDO0FBQ0Esd0JBQUloYSxNQUFNMlcsaUJBQVYsRUFBNkI7QUFDekIzVyw4QkFBTTJXLGlCQUFOLENBQXdCLElBQXhCLEVBQThCLEtBQUt2YyxXQUFuQztBQUNILHFCQUZELE1BRU87QUFDSDRGLDhCQUFNOVUsSUFBTixDQUFXLElBQVg7QUFDSDtBQUNKO0FBQ0R5c0IseUJBQVN1QyxRQUFULEVBQW1CbGEsS0FBbkI7QUFDQSx1QkFBT2thLFFBQVA7QUFDSDs7QUFFRCxnQkFBSUMsVUFBSixFQUFnQkMsV0FBaEI7QUFDQSxnQkFBSXZNLFVBQVVrTSxTQUFTLFNBQVQsRUFBb0IsU0FBcEIsQ0FBZDtBQUNBLGdCQUFJTSxvQkFBb0JOLFNBQVMsbUJBQVQsRUFBOEIsb0JBQTlCLENBQXhCO0FBQ0EsZ0JBQUlPLGVBQWVQLFNBQVMsY0FBVCxFQUF5QixlQUF6QixDQUFuQjtBQUNBLGdCQUFJUSxpQkFBaUJSLFNBQVMsZ0JBQVQsRUFBMkIsaUJBQTNCLENBQXJCO0FBQ0EsZ0JBQUk7QUFDQUksNkJBQWF6YyxTQUFiO0FBQ0EwYyw4QkFBY0ksVUFBZDtBQUNILGFBSEQsQ0FHRSxPQUFNOXhCLENBQU4sRUFBUztBQUNQeXhCLDZCQUFhSixTQUFTLFdBQVQsRUFBc0IsWUFBdEIsQ0FBYjtBQUNBSyw4QkFBY0wsU0FBUyxZQUFULEVBQXVCLGFBQXZCLENBQWQ7QUFDSDs7QUFFRCxnQkFBSXBiLFVBQVUsQ0FBQywyREFDWCwrREFEVSxFQUN1RDRWLEtBRHZELENBQzZELEdBRDdELENBQWQ7O0FBR0EsaUJBQUssSUFBSW5xQixJQUFJLENBQWIsRUFBZ0JBLElBQUl1VSxRQUFRclUsTUFBNUIsRUFBb0MsRUFBRUYsQ0FBdEMsRUFBeUM7QUFDckMsb0JBQUksT0FBT2lCLE1BQU1OLFNBQU4sQ0FBZ0I0VCxRQUFRdlUsQ0FBUixDQUFoQixDQUFQLEtBQXVDLFVBQTNDLEVBQXVEO0FBQ25EbXdCLG1DQUFleHZCLFNBQWYsQ0FBeUI0VCxRQUFRdlUsQ0FBUixDQUF6QixJQUF1Q2lCLE1BQU1OLFNBQU4sQ0FBZ0I0VCxRQUFRdlUsQ0FBUixDQUFoQixDQUF2QztBQUNIO0FBQ0o7O0FBRUR3dkIsZ0JBQUkzYixjQUFKLENBQW1Cc2MsZUFBZXh2QixTQUFsQyxFQUE2QyxRQUE3QyxFQUF1RDtBQUNuRG9FLHVCQUFPLENBRDRDO0FBRW5EaVAsOEJBQWMsS0FGcUM7QUFHbkRFLDBCQUFVLElBSHlDO0FBSW5ERCw0QkFBWTtBQUp1QyxhQUF2RDtBQU1Ba2MsMkJBQWV4dkIsU0FBZixDQUF5QixlQUF6QixJQUE0QyxJQUE1QztBQUNBLGdCQUFJMHZCLFFBQVEsQ0FBWjtBQUNBRiwyQkFBZXh2QixTQUFmLENBQXlCYSxRQUF6QixHQUFvQyxZQUFXO0FBQzNDLG9CQUFJOHVCLFNBQVNydkIsTUFBTW92QixRQUFRLENBQVIsR0FBWSxDQUFsQixFQUFxQnhHLElBQXJCLENBQTBCLEdBQTFCLENBQWI7QUFDQSxvQkFBSTNRLE1BQU0sT0FBT29YLE1BQVAsR0FBZ0Isb0JBQWhCLEdBQXVDLElBQWpEO0FBQ0FEO0FBQ0FDLHlCQUFTcnZCLE1BQU1vdkIsUUFBUSxDQUFSLEdBQVksQ0FBbEIsRUFBcUJ4RyxJQUFyQixDQUEwQixHQUExQixDQUFUO0FBQ0EscUJBQUssSUFBSTdwQixJQUFJLENBQWIsRUFBZ0JBLElBQUksS0FBS0UsTUFBekIsRUFBaUMsRUFBRUYsQ0FBbkMsRUFBc0M7QUFDbEMsd0JBQUlhLE1BQU0sS0FBS2IsQ0FBTCxNQUFZLElBQVosR0FBbUIsMkJBQW5CLEdBQWlELEtBQUtBLENBQUwsSUFBVSxFQUFyRTtBQUNBLHdCQUFJdXdCLFFBQVExdkIsSUFBSXNwQixLQUFKLENBQVUsSUFBVixDQUFaO0FBQ0EseUJBQUssSUFBSWpJLElBQUksQ0FBYixFQUFnQkEsSUFBSXFPLE1BQU1yd0IsTUFBMUIsRUFBa0MsRUFBRWdpQixDQUFwQyxFQUF1QztBQUNuQ3FPLDhCQUFNck8sQ0FBTixJQUFXb08sU0FBU0MsTUFBTXJPLENBQU4sQ0FBcEI7QUFDSDtBQUNEcmhCLDBCQUFNMHZCLE1BQU0xRyxJQUFOLENBQVcsSUFBWCxDQUFOO0FBQ0EzUSwyQkFBT3JZLE1BQU0sSUFBYjtBQUNIO0FBQ0R3dkI7QUFDQSx1QkFBT25YLEdBQVA7QUFDSCxhQWhCRDs7QUFrQkEscUJBQVNzWCxnQkFBVCxDQUEwQnZkLE9BQTFCLEVBQW1DO0FBQy9CLG9CQUFJLEVBQUUsZ0JBQWdCdWQsZ0JBQWxCLENBQUosRUFDSSxPQUFPLElBQUlBLGdCQUFKLENBQXFCdmQsT0FBckIsQ0FBUDtBQUNKMlcsa0NBQWtCLElBQWxCLEVBQXdCLE1BQXhCLEVBQWdDLGtCQUFoQztBQUNBQSxrQ0FBa0IsSUFBbEIsRUFBd0IsU0FBeEIsRUFBbUMzVyxPQUFuQztBQUNBLHFCQUFLd2QsS0FBTCxHQUFheGQsT0FBYjtBQUNBLHFCQUFLLGVBQUwsSUFBd0IsSUFBeEI7O0FBRUEsb0JBQUlBLG1CQUFtQjJDLEtBQXZCLEVBQThCO0FBQzFCZ1Usc0NBQWtCLElBQWxCLEVBQXdCLFNBQXhCLEVBQW1DM1csUUFBUUEsT0FBM0M7QUFDQTJXLHNDQUFrQixJQUFsQixFQUF3QixPQUF4QixFQUFpQzNXLFFBQVFoRyxLQUF6QztBQUNILGlCQUhELE1BR08sSUFBSTJJLE1BQU0yVyxpQkFBVixFQUE2QjtBQUNoQzNXLDBCQUFNMlcsaUJBQU4sQ0FBd0IsSUFBeEIsRUFBOEIsS0FBS3ZjLFdBQW5DO0FBQ0g7QUFFSjtBQUNEdWQscUJBQVNpRCxnQkFBVCxFQUEyQjVhLEtBQTNCOztBQUVBLGdCQUFJOGEsYUFBYTlhLE1BQU0sd0JBQU4sQ0FBakI7QUFDQSxnQkFBSSxDQUFDOGEsVUFBTCxFQUFpQjtBQUNiQSw2QkFBYWpCLGFBQWE7QUFDdEJRLHVDQUFtQkEsaUJBREc7QUFFdEJDLGtDQUFjQSxZQUZRO0FBR3RCTSxzQ0FBa0JBLGdCQUhJO0FBSXRCRyxvQ0FBZ0JILGdCQUpNO0FBS3RCTCxvQ0FBZ0JBO0FBTE0saUJBQWIsQ0FBYjtBQU9BWCxvQkFBSTNiLGNBQUosQ0FBbUIrQixLQUFuQixFQUEwQix3QkFBMUIsRUFBb0Q7QUFDaEQ3USwyQkFBTzJyQixVQUR5QztBQUVoRHhjLDhCQUFVLEtBRnNDO0FBR2hERCxnQ0FBWSxLQUhvQztBQUloREQsa0NBQWM7QUFKa0MsaUJBQXBEO0FBTUg7O0FBRUR4VixtQkFBT0MsT0FBUCxHQUFpQjtBQUNibVgsdUJBQU9BLEtBRE07QUFFYnRDLDJCQUFXeWMsVUFGRTtBQUdiSyw0QkFBWUosV0FIQztBQUliQyxtQ0FBbUJTLFdBQVdULGlCQUpqQjtBQUtiTyxrQ0FBa0JFLFdBQVdGLGdCQUxoQjtBQU1iTiw4QkFBY1EsV0FBV1IsWUFOWjtBQU9iQyxnQ0FBZ0JPLFdBQVdQLGNBUGQ7QUFRYjFNLHlCQUFTQTtBQVJJLGFBQWpCO0FBV0MsU0F0SFEsRUFzSFAsRUFBQyxTQUFRLEVBQVQsRUFBWSxVQUFTLEVBQXJCLEVBdEhPLENBcm1EdXZCLEVBMnREcHVCLElBQUcsQ0FBQyxVQUFTN0ssT0FBVCxFQUFpQnBhLE1BQWpCLEVBQXdCQyxPQUF4QixFQUFnQztBQUNoRSxnQkFBSW15QixRQUFTLFlBQVU7QUFDbkI7O0FBQ0EsdUJBQU8sU0FBU3pxQixTQUFoQjtBQUNILGFBSFcsRUFBWjs7QUFLQSxnQkFBSXlxQixLQUFKLEVBQVc7QUFDUHB5Qix1QkFBT0MsT0FBUCxHQUFpQjtBQUNiaXhCLDRCQUFRaHdCLE9BQU9nd0IsTUFERjtBQUViN2Isb0NBQWdCblUsT0FBT21VLGNBRlY7QUFHYmdkLG1DQUFlbnhCLE9BQU9veEIsd0JBSFQ7QUFJYjNwQiwwQkFBTXpILE9BQU95SCxJQUpBO0FBS2I0cEIsMkJBQU9yeEIsT0FBT3N4QixtQkFMRDtBQU1ibHBCLG9DQUFnQnBJLE9BQU9vSSxjQU5WO0FBT2JvRSw2QkFBU2pMLE1BQU1pTCxPQVBGO0FBUWIwa0IsMkJBQU9BLEtBUk07QUFTYkssd0NBQW9CLDRCQUFTcnhCLEdBQVQsRUFBY3N4QixJQUFkLEVBQW9CO0FBQ3BDLDRCQUFJbmQsYUFBYXJVLE9BQU9veEIsd0JBQVAsQ0FBZ0NseEIsR0FBaEMsRUFBcUNzeEIsSUFBckMsQ0FBakI7QUFDQSwrQkFBTyxDQUFDLEVBQUUsQ0FBQ25kLFVBQUQsSUFBZUEsV0FBV0csUUFBMUIsSUFBc0NILFdBQVdsUCxHQUFuRCxDQUFSO0FBQ0g7QUFaWSxpQkFBakI7QUFjSCxhQWZELE1BZU87QUFDSCxvQkFBSW9GLE1BQU0sR0FBRzFJLGNBQWI7QUFDQSxvQkFBSVYsTUFBTSxHQUFHVyxRQUFiO0FBQ0Esb0JBQUl5TSxRQUFRLEdBQUcrQixXQUFILENBQWVyUCxTQUEzQjs7QUFFQSxvQkFBSXd3QixhQUFhLFNBQWJBLFVBQWEsQ0FBVW5jLENBQVYsRUFBYTtBQUMxQix3QkFBSWtFLE1BQU0sRUFBVjtBQUNBLHlCQUFLLElBQUk5WSxHQUFULElBQWdCNFUsQ0FBaEIsRUFBbUI7QUFDZiw0QkFBSS9LLElBQUluSixJQUFKLENBQVNrVSxDQUFULEVBQVk1VSxHQUFaLENBQUosRUFBc0I7QUFDbEI4WSxnQ0FBSWxPLElBQUosQ0FBUzVLLEdBQVQ7QUFDSDtBQUNKO0FBQ0QsMkJBQU84WSxHQUFQO0FBQ0gsaUJBUkQ7O0FBVUEsb0JBQUlrWSxzQkFBc0IsU0FBdEJBLG1CQUFzQixDQUFTcGMsQ0FBVCxFQUFZNVUsR0FBWixFQUFpQjtBQUN2QywyQkFBTyxFQUFDMkUsT0FBT2lRLEVBQUU1VSxHQUFGLENBQVIsRUFBUDtBQUNILGlCQUZEOztBQUlBLG9CQUFJaXhCLHVCQUF1QixTQUF2QkEsb0JBQXVCLENBQVVyYyxDQUFWLEVBQWE1VSxHQUFiLEVBQWtCa3hCLElBQWxCLEVBQXdCO0FBQy9DdGMsc0JBQUU1VSxHQUFGLElBQVNreEIsS0FBS3ZzQixLQUFkO0FBQ0EsMkJBQU9pUSxDQUFQO0FBQ0gsaUJBSEQ7O0FBS0Esb0JBQUl1YyxlQUFlLFNBQWZBLFlBQWUsQ0FBVTN4QixHQUFWLEVBQWU7QUFDOUIsMkJBQU9BLEdBQVA7QUFDSCxpQkFGRDs7QUFJQSxvQkFBSTR4Qix1QkFBdUIsU0FBdkJBLG9CQUF1QixDQUFVNXhCLEdBQVYsRUFBZTtBQUN0Qyx3QkFBSTtBQUNBLCtCQUFPRixPQUFPRSxHQUFQLEVBQVlvUSxXQUFaLENBQXdCclAsU0FBL0I7QUFDSCxxQkFGRCxDQUdBLE9BQU9yQyxDQUFQLEVBQVU7QUFDTiwrQkFBTzJQLEtBQVA7QUFDSDtBQUNKLGlCQVBEOztBQVNBLG9CQUFJd2pCLGVBQWUsU0FBZkEsWUFBZSxDQUFVN3hCLEdBQVYsRUFBZTtBQUM5Qix3QkFBSTtBQUNBLCtCQUFPaUIsSUFBSUMsSUFBSixDQUFTbEIsR0FBVCxNQUFrQixnQkFBekI7QUFDSCxxQkFGRCxDQUdBLE9BQU10QixDQUFOLEVBQVM7QUFDTCwrQkFBTyxLQUFQO0FBQ0g7QUFDSixpQkFQRDs7QUFTQUUsdUJBQU9DLE9BQVAsR0FBaUI7QUFDYnlOLDZCQUFTdWxCLFlBREk7QUFFYnRxQiwwQkFBTWdxQixVQUZPO0FBR2JKLDJCQUFPSSxVQUhNO0FBSWJ0ZCxvQ0FBZ0J3ZCxvQkFKSDtBQUtiUixtQ0FBZU8sbUJBTEY7QUFNYjFCLDRCQUFRNkIsWUFOSztBQU9ienBCLG9DQUFnQjBwQixvQkFQSDtBQVFiWiwyQkFBT0EsS0FSTTtBQVNiSyx3Q0FBb0IsOEJBQVc7QUFDM0IsK0JBQU8sSUFBUDtBQUNIO0FBWFksaUJBQWpCO0FBYUg7QUFFQSxTQWxGOEIsRUFrRjdCLEVBbEY2QixDQTN0RGl1QixFQTZ5RDF2QixJQUFHLENBQUMsVUFBU3JZLE9BQVQsRUFBaUJwYSxNQUFqQixFQUF3QkMsT0FBeEIsRUFBZ0M7QUFDMUM7O0FBQ0FELG1CQUFPQyxPQUFQLEdBQWlCLFVBQVNvSyxPQUFULEVBQWtCaVQsUUFBbEIsRUFBNEI7QUFDN0Msb0JBQUk0VixhQUFhN29CLFFBQVF4SixHQUF6Qjs7QUFFQXdKLHdCQUFRbEksU0FBUixDQUFrQmd4QixNQUFsQixHQUEyQixVQUFVM3dCLEVBQVYsRUFBY3lSLE9BQWQsRUFBdUI7QUFDOUMsMkJBQU9pZixXQUFXLElBQVgsRUFBaUIxd0IsRUFBakIsRUFBcUJ5UixPQUFyQixFQUE4QnFKLFFBQTlCLENBQVA7QUFDSCxpQkFGRDs7QUFJQWpULHdCQUFROG9CLE1BQVIsR0FBaUIsVUFBVTFZLFFBQVYsRUFBb0JqWSxFQUFwQixFQUF3QnlSLE9BQXhCLEVBQWlDO0FBQzlDLDJCQUFPaWYsV0FBV3pZLFFBQVgsRUFBcUJqWSxFQUFyQixFQUF5QnlSLE9BQXpCLEVBQWtDcUosUUFBbEMsQ0FBUDtBQUNILGlCQUZEO0FBR0MsYUFWRDtBQVlDLFNBZFEsRUFjUCxFQWRPLENBN3lEdXZCLEVBMnpEMXZCLElBQUcsQ0FBQyxVQUFTbEQsT0FBVCxFQUFpQnBhLE1BQWpCLEVBQXdCQyxPQUF4QixFQUFnQztBQUMxQzs7QUFDQUQsbUJBQU9DLE9BQVAsR0FBaUIsVUFBU29LLE9BQVQsRUFBa0JrVCxtQkFBbEIsRUFBdUMwRixXQUF2QyxFQUFvRDtBQUNyRSxvQkFBSWhJLE9BQU9iLFFBQVEsUUFBUixDQUFYO0FBQ0Esb0JBQUlxWCxvQkFBb0JwbkIsUUFBUW9uQixpQkFBaEM7QUFDQSxvQkFBSTdRLFdBQVczRixLQUFLMkYsUUFBcEI7QUFDQSxvQkFBSXVDLGNBQWMvSSxRQUFRLGdCQUFSLEVBQTBCNkksV0FBMUIsQ0FBbEI7O0FBRUEseUJBQVNtUSx5QkFBVCxDQUFtQ3ZjLE9BQW5DLEVBQTRDdkQsSUFBNUMsRUFBa0RpWCxPQUFsRCxFQUEyRDtBQUN2RCx5QkFBSzFULE9BQUwsR0FBZUEsT0FBZjtBQUNBLHlCQUFLdkQsSUFBTCxHQUFZQSxJQUFaO0FBQ0EseUJBQUtpWCxPQUFMLEdBQWVBLE9BQWY7QUFDQSx5QkFBSzhJLE1BQUwsR0FBYyxLQUFkO0FBQ0EseUJBQUtDLGFBQUwsR0FBcUIsSUFBckI7QUFDSDs7QUFFREYsMENBQTBCanhCLFNBQTFCLENBQW9Db3hCLGdCQUFwQyxHQUF1RCxZQUFXO0FBQzlELDJCQUFPLEtBQUtqZ0IsSUFBTCxLQUFjLENBQXJCO0FBQ0gsaUJBRkQ7O0FBSUEseUJBQVNrZ0IsNEJBQVQsQ0FBc0NDLGNBQXRDLEVBQXNEO0FBQ2xELHlCQUFLQSxjQUFMLEdBQXNCQSxjQUF0QjtBQUNIOztBQUVERCw2Q0FBNkJyeEIsU0FBN0IsQ0FBdUMyZ0IsZ0JBQXZDLEdBQTBELFlBQVc7QUFDakU0USxnQ0FBWSxLQUFLRCxjQUFqQjtBQUNILGlCQUZEOztBQUlBLHlCQUFTQyxXQUFULENBQXFCNU8sR0FBckIsRUFBMEIwQixNQUExQixFQUFrQztBQUM5Qix3QkFBSTFCLElBQUl3TyxhQUFKLElBQXFCLElBQXpCLEVBQStCO0FBQzNCLDRCQUFJN3hCLFVBQVVDLE1BQVYsR0FBbUIsQ0FBdkIsRUFBMEI7QUFDdEJvakIsZ0NBQUl3TyxhQUFKLENBQWtCMVYsT0FBbEIsQ0FBMEI0SSxNQUExQjtBQUNILHlCQUZELE1BRU87QUFDSDFCLGdDQUFJd08sYUFBSixDQUFrQnRSLE9BQWxCO0FBQ0g7QUFDRDhDLDRCQUFJd08sYUFBSixHQUFvQixJQUFwQjtBQUNBLCtCQUFPLElBQVA7QUFDSDtBQUNELDJCQUFPLEtBQVA7QUFDSDs7QUFFRCx5QkFBU0ssT0FBVCxHQUFtQjtBQUNmLDJCQUFPRixlQUFlbnhCLElBQWYsQ0FBb0IsSUFBcEIsRUFBMEIsS0FBS3VVLE9BQUwsQ0FBYStILE9BQWIsR0FBdUI2SCxhQUF2QixFQUExQixDQUFQO0FBQ0g7QUFDRCx5QkFBU21OLElBQVQsQ0FBY3BOLE1BQWQsRUFBc0I7QUFDbEIsd0JBQUlrTixZQUFZLElBQVosRUFBa0JsTixNQUFsQixDQUFKLEVBQStCO0FBQy9CNUYsNkJBQVM5Z0IsQ0FBVCxHQUFhMG1CLE1BQWI7QUFDQSwyQkFBTzVGLFFBQVA7QUFDSDtBQUNELHlCQUFTNlMsY0FBVCxDQUF3QkksYUFBeEIsRUFBdUM7QUFDbkMsd0JBQUloZCxVQUFVLEtBQUtBLE9BQW5CO0FBQ0Esd0JBQUkwVCxVQUFVLEtBQUtBLE9BQW5COztBQUVBLHdCQUFJLENBQUMsS0FBSzhJLE1BQVYsRUFBa0I7QUFDZCw2QkFBS0EsTUFBTCxHQUFjLElBQWQ7QUFDQSw0QkFBSTNZLE1BQU0sS0FBSzZZLGdCQUFMLEtBQ0poSixRQUFRam9CLElBQVIsQ0FBYXVVLFFBQVE0SCxXQUFSLEVBQWIsQ0FESSxHQUVKOEwsUUFBUWpvQixJQUFSLENBQWF1VSxRQUFRNEgsV0FBUixFQUFiLEVBQW9Db1YsYUFBcEMsQ0FGTjtBQUdBLDRCQUFJblosUUFBUXVJLFdBQVosRUFBeUI7QUFDckIsbUNBQU92SSxHQUFQO0FBQ0gseUJBRkQsTUFFTyxJQUFJQSxRQUFRL1MsU0FBWixFQUF1QjtBQUMxQmtQLG9DQUFRd1Asd0JBQVI7QUFDQSxnQ0FBSTFILGVBQWVwQixvQkFBb0I3QyxHQUFwQixFQUF5QjdELE9BQXpCLENBQW5CO0FBQ0EsZ0NBQUk4SCx3QkFBd0J0VSxPQUE1QixFQUFxQztBQUNqQyxvQ0FBSSxLQUFLaXBCLGFBQUwsSUFBc0IsSUFBMUIsRUFBZ0M7QUFDNUIsd0NBQUkzVSxhQUFhNEQsWUFBYixFQUFKLEVBQWlDO0FBQzdCLDRDQUFJaUUsU0FDQSxJQUFJaUwsaUJBQUosQ0FBc0IsNEJBQXRCLENBREo7QUFFQTVhLGdEQUFRZ00saUJBQVIsQ0FBMEIyRCxNQUExQjtBQUNBNUYsaURBQVM5Z0IsQ0FBVCxHQUFhMG1CLE1BQWI7QUFDQSwrQ0FBTzVGLFFBQVA7QUFDSCxxQ0FORCxNQU1PLElBQUlqQyxhQUFhMkQsU0FBYixFQUFKLEVBQThCO0FBQ2pDM0QscURBQWFvTCwyQkFBYixDQUNJLElBQUl5Siw0QkFBSixDQUFpQyxJQUFqQyxDQURKO0FBRUg7QUFDSjtBQUNELHVDQUFPN1UsYUFBYVYsS0FBYixDQUNIMFYsT0FERyxFQUNNQyxJQUROLEVBQ1lqc0IsU0FEWixFQUN1QixJQUR2QixFQUM2QkEsU0FEN0IsQ0FBUDtBQUVIO0FBQ0o7QUFDSjs7QUFFRCx3QkFBSWtQLFFBQVFpZCxVQUFSLEVBQUosRUFBMEI7QUFDdEJKLG9DQUFZLElBQVo7QUFDQTlTLGlDQUFTOWdCLENBQVQsR0FBYSt6QixhQUFiO0FBQ0EsK0JBQU9qVCxRQUFQO0FBQ0gscUJBSkQsTUFJTztBQUNIOFMsb0NBQVksSUFBWjtBQUNBLCtCQUFPRyxhQUFQO0FBQ0g7QUFDSjs7QUFFRHhwQix3QkFBUWxJLFNBQVIsQ0FBa0I0eEIsWUFBbEIsR0FBaUMsVUFBU3hKLE9BQVQsRUFBa0JqWCxJQUFsQixFQUF3QnlELE9BQXhCLEVBQWlDNmMsSUFBakMsRUFBdUM7QUFDcEUsd0JBQUksT0FBT3JKLE9BQVAsS0FBbUIsVUFBdkIsRUFBbUMsT0FBTyxLQUFLelQsSUFBTCxFQUFQO0FBQ25DLDJCQUFPLEtBQUttSCxLQUFMLENBQVdsSCxPQUFYLEVBQ1c2YyxJQURYLEVBRVdqc0IsU0FGWCxFQUdXLElBQUl5ckIseUJBQUosQ0FBOEIsSUFBOUIsRUFBb0M5ZixJQUFwQyxFQUEwQ2lYLE9BQTFDLENBSFgsRUFJVzVpQixTQUpYLENBQVA7QUFLSCxpQkFQRDs7QUFTQTBDLHdCQUFRbEksU0FBUixDQUFrQjZ4QixNQUFsQixHQUNBM3BCLFFBQVFsSSxTQUFSLENBQWtCLFNBQWxCLElBQStCLFVBQVVvb0IsT0FBVixFQUFtQjtBQUM5QywyQkFBTyxLQUFLd0osWUFBTCxDQUFrQnhKLE9BQWxCLEVBQ2tCLENBRGxCLEVBRWtCa0osY0FGbEIsRUFHa0JBLGNBSGxCLENBQVA7QUFJSCxpQkFORDs7QUFTQXBwQix3QkFBUWxJLFNBQVIsQ0FBa0I4eEIsR0FBbEIsR0FBd0IsVUFBVTFKLE9BQVYsRUFBbUI7QUFDdkMsMkJBQU8sS0FBS3dKLFlBQUwsQ0FBa0J4SixPQUFsQixFQUEyQixDQUEzQixFQUE4QmtKLGNBQTlCLENBQVA7QUFDSCxpQkFGRDs7QUFJQXBwQix3QkFBUWxJLFNBQVIsQ0FBa0IreEIsUUFBbEIsR0FBNkIsVUFBVUMsa0JBQVYsRUFBOEI7QUFDdkQsd0JBQUloYyxNQUFNMVcsVUFBVUMsTUFBcEI7QUFDQSx3QkFBR3lXLFFBQVEsQ0FBWCxFQUFjO0FBQ1YsK0JBQU8sS0FBSzRiLFlBQUwsQ0FBa0JJLGtCQUFsQixFQUNrQixDQURsQixFQUVrQnhzQixTQUZsQixFQUdrQjhyQixjQUhsQixDQUFQO0FBSUgscUJBTEQsTUFLTztBQUNGLDRCQUFJVyxpQkFBaUIsSUFBSTN4QixLQUFKLENBQVUwVixNQUFNLENBQWhCLENBQXJCO0FBQUEsNEJBQ0d1TCxJQUFJLENBRFA7QUFBQSw0QkFDVWxpQixDQURWO0FBRUQsNkJBQUtBLElBQUksQ0FBVCxFQUFZQSxJQUFJMlcsTUFBTSxDQUF0QixFQUF5QixFQUFFM1csQ0FBM0IsRUFBOEI7QUFDMUIsZ0NBQUlnaUIsT0FBTy9oQixVQUFVRCxDQUFWLENBQVg7QUFDQSxnQ0FBSXlaLEtBQUtoYSxRQUFMLENBQWN1aUIsSUFBZCxDQUFKLEVBQXlCO0FBQ3JCNFEsK0NBQWUxUSxHQUFmLElBQXNCRixJQUF0QjtBQUNILDZCQUZELE1BRU87QUFDSCx1Q0FBT25aLFFBQVFtSyxNQUFSLENBQWUsSUFBSU0sU0FBSixDQUNsQixtQ0FDRSw4QkFERixHQUNtQ21HLEtBQUtpRixXQUFMLENBQWlCc0QsSUFBakIsQ0FGakIsQ0FBZixDQUFQO0FBSUg7QUFDSjtBQUNENFEsdUNBQWUxeUIsTUFBZixHQUF3QmdpQixDQUF4QjtBQUNBLDRCQUFJNkcsVUFBVTlvQixVQUFVRCxDQUFWLENBQWQ7QUFDQSwrQkFBTyxLQUFLdXlCLFlBQUwsQ0FBa0I1USxZQUFZaVIsY0FBWixFQUE0QjdKLE9BQTVCLEVBQXFDLElBQXJDLENBQWxCLEVBQ2tCLENBRGxCLEVBRWtCNWlCLFNBRmxCLEVBR2tCOHJCLGNBSGxCLENBQVA7QUFJSDtBQUVKLGlCQTdCRDs7QUErQkEsdUJBQU9MLHlCQUFQO0FBQ0MsYUFoSkQ7QUFrSkMsU0FwSlEsRUFvSlAsRUFBQyxrQkFBaUIsQ0FBbEIsRUFBb0IsVUFBUyxFQUE3QixFQXBKTyxDQTN6RHV2QixFQSs4RDV0QixJQUFHLENBQUMsVUFBU2haLE9BQVQsRUFBaUJwYSxNQUFqQixFQUF3QkMsT0FBeEIsRUFBZ0M7QUFDeEU7O0FBQ0FELG1CQUFPQyxPQUFQLEdBQWlCLFVBQVNvSyxPQUFULEVBQ1NxVyxZQURULEVBRVNwRCxRQUZULEVBR1NDLG1CQUhULEVBSVM4VyxTQUpULEVBS1M3VyxLQUxULEVBS2dCO0FBQ2pDLG9CQUFJOFcsU0FBU2xhLFFBQVEsVUFBUixDQUFiO0FBQ0Esb0JBQUl0RixZQUFZd2YsT0FBT3hmLFNBQXZCO0FBQ0Esb0JBQUltRyxPQUFPYixRQUFRLFFBQVIsQ0FBWDtBQUNBLG9CQUFJd0csV0FBVzNGLEtBQUsyRixRQUFwQjtBQUNBLG9CQUFJRCxXQUFXMUYsS0FBSzBGLFFBQXBCO0FBQ0Esb0JBQUk0VCxnQkFBZ0IsRUFBcEI7O0FBRUEseUJBQVNDLHVCQUFULENBQWlDanVCLEtBQWpDLEVBQXdDZ3VCLGFBQXhDLEVBQXVERSxXQUF2RCxFQUFvRTtBQUNoRSx5QkFBSyxJQUFJanpCLElBQUksQ0FBYixFQUFnQkEsSUFBSSt5QixjQUFjN3lCLE1BQWxDLEVBQTBDLEVBQUVGLENBQTVDLEVBQStDO0FBQzNDaXpCLG9DQUFZM1EsWUFBWjtBQUNBLDRCQUFJdmMsU0FBU29aLFNBQVM0VCxjQUFjL3lCLENBQWQsQ0FBVCxFQUEyQitFLEtBQTNCLENBQWI7QUFDQWt1QixvQ0FBWTFRLFdBQVo7QUFDQSw0QkFBSXhjLFdBQVdxWixRQUFmLEVBQXlCO0FBQ3JCNlQsd0NBQVkzUSxZQUFaO0FBQ0EsZ0NBQUlwSixNQUFNclEsUUFBUW1LLE1BQVIsQ0FBZW9NLFNBQVM5Z0IsQ0FBeEIsQ0FBVjtBQUNBMjBCLHdDQUFZMVEsV0FBWjtBQUNBLG1DQUFPckosR0FBUDtBQUNIO0FBQ0QsNEJBQUlpRSxlQUFlcEIsb0JBQW9CaFcsTUFBcEIsRUFBNEJrdEIsV0FBNUIsQ0FBbkI7QUFDQSw0QkFBSTlWLHdCQUF3QnRVLE9BQTVCLEVBQXFDLE9BQU9zVSxZQUFQO0FBQ3hDO0FBQ0QsMkJBQU8sSUFBUDtBQUNIOztBQUVELHlCQUFTK1YsWUFBVCxDQUFzQkMsaUJBQXRCLEVBQXlDalksUUFBekMsRUFBbURrWSxZQUFuRCxFQUFpRW5tQixLQUFqRSxFQUF3RTtBQUNwRSx3QkFBSStPLE1BQU13RCxZQUFOLEVBQUosRUFBMEI7QUFDdEIsNEJBQUk2VCxXQUFXLElBQUl4cUIsT0FBSixDQUFZaVQsUUFBWixDQUFmO0FBQ0EsNEJBQUl3WCxrQkFBa0IsS0FBS0EsZUFBTCxHQUF1QixJQUFJenFCLE9BQUosQ0FBWWlULFFBQVosQ0FBN0M7QUFDQSw2QkFBS3lYLFFBQUwsR0FBZ0JGLFNBQVNiLE1BQVQsQ0FBZ0IsWUFBVztBQUN2QyxtQ0FBT2MsZUFBUDtBQUNILHlCQUZlLENBQWhCO0FBR0FELGlDQUFTdE4sa0JBQVQ7QUFDQXNOLGlDQUFTL1YsWUFBVCxDQUFzQixJQUF0QjtBQUNILHFCQVJELE1BUU87QUFDSCw0QkFBSWpJLFVBQVUsS0FBS2tlLFFBQUwsR0FBZ0IsSUFBSTFxQixPQUFKLENBQVlpVCxRQUFaLENBQTlCO0FBQ0F6RyxnQ0FBUTBRLGtCQUFSO0FBQ0g7QUFDRCx5QkFBS3lOLE1BQUwsR0FBY3ZtQixLQUFkO0FBQ0EseUJBQUt3bUIsa0JBQUwsR0FBMEJOLGlCQUExQjtBQUNBLHlCQUFLTyxTQUFMLEdBQWlCeFksUUFBakI7QUFDQSx5QkFBS3lZLFVBQUwsR0FBa0J4dEIsU0FBbEI7QUFDQSx5QkFBS3l0QixjQUFMLEdBQXNCLE9BQU9SLFlBQVAsS0FBd0IsVUFBeEIsR0FDaEIsQ0FBQ0EsWUFBRCxFQUFlM3lCLE1BQWYsQ0FBc0JzeUIsYUFBdEIsQ0FEZ0IsR0FFaEJBLGFBRk47QUFHQSx5QkFBS2MsZUFBTCxHQUF1QixJQUF2QjtBQUNBLHlCQUFLQyxrQkFBTCxHQUEwQixLQUExQjtBQUNIO0FBQ0RyYSxxQkFBSzhULFFBQUwsQ0FBYzJGLFlBQWQsRUFBNEJMLFNBQTVCOztBQUVBSyw2QkFBYXZ5QixTQUFiLENBQXVCb3pCLFdBQXZCLEdBQXFDLFlBQVc7QUFDNUMsMkJBQU8sS0FBS1IsUUFBTCxLQUFrQixJQUF6QjtBQUNILGlCQUZEOztBQUlBTCw2QkFBYXZ5QixTQUFiLENBQXVCcXpCLFFBQXZCLEdBQWtDLFlBQVc7QUFDekMseUJBQUtULFFBQUwsR0FBZ0IsS0FBS0ksVUFBTCxHQUFrQixJQUFsQztBQUNBLHdCQUFJM1gsTUFBTXdELFlBQU4sTUFBd0IsS0FBSzhULGVBQUwsS0FBeUIsSUFBckQsRUFBMkQ7QUFDdkQsNkJBQUtBLGVBQUwsQ0FBcUJXLFFBQXJCO0FBQ0EsNkJBQUtYLGVBQUwsR0FBdUIsSUFBdkI7QUFDSDtBQUNKLGlCQU5EOztBQVFBSiw2QkFBYXZ5QixTQUFiLENBQXVCdXpCLGlCQUF2QixHQUEyQyxZQUFXO0FBQ2xELHdCQUFJLEtBQUtILFdBQUwsRUFBSixFQUF3QjtBQUN4Qix3QkFBSUksbUJBQW1CLE9BQU8sS0FBS1IsVUFBTCxDQUFnQixRQUFoQixDQUFQLEtBQXFDLFdBQTVEOztBQUVBLHdCQUFJNXRCLE1BQUo7QUFDQSx3QkFBSSxDQUFDb3VCLGdCQUFMLEVBQXVCO0FBQ25CLDRCQUFJblAsU0FBUyxJQUFJbmMsUUFBUW9uQixpQkFBWixDQUNULDhCQURTLENBQWI7QUFFQXBuQixnQ0FBUXVyQixTQUFSLENBQWtCQyxjQUFsQixHQUFtQ3JQLE1BQW5DO0FBQ0EsNkJBQUt1TyxRQUFMLENBQWNsUyxpQkFBZCxDQUFnQzJELE1BQWhDO0FBQ0EsNkJBQUt1TyxRQUFMLENBQWNqUixZQUFkO0FBQ0F2YyxpQ0FBU29aLFNBQVMsS0FBS3dVLFVBQUwsQ0FBZ0IsT0FBaEIsQ0FBVCxFQUFtQzd5QixJQUFuQyxDQUF3QyxLQUFLNnlCLFVBQTdDLEVBQ3dDM08sTUFEeEMsQ0FBVDtBQUVBLDZCQUFLdU8sUUFBTCxDQUFjaFIsV0FBZDtBQUNILHFCQVRELE1BU087QUFDSCw2QkFBS2dSLFFBQUwsQ0FBY2pSLFlBQWQ7QUFDQXZjLGlDQUFTb1osU0FBUyxLQUFLd1UsVUFBTCxDQUFnQixRQUFoQixDQUFULEVBQW9DN3lCLElBQXBDLENBQXlDLEtBQUs2eUIsVUFBOUMsRUFDeUN4dEIsU0FEekMsQ0FBVDtBQUVBLDZCQUFLb3RCLFFBQUwsQ0FBY2hSLFdBQWQ7QUFDSDtBQUNELHlCQUFLdVIsa0JBQUwsR0FBMEIsSUFBMUI7QUFDQSx5QkFBS0QsZUFBTCxHQUF1QixJQUF2QjtBQUNBLHlCQUFLUyxTQUFMLENBQWV2dUIsTUFBZjtBQUNILGlCQXZCRDs7QUF5QkFtdEIsNkJBQWF2eUIsU0FBYixDQUF1QjR6QixpQkFBdkIsR0FBMkMsVUFBU3h2QixLQUFULEVBQWdCO0FBQ3ZELHlCQUFLOHVCLGVBQUwsR0FBdUIsSUFBdkI7QUFDQSx5QkFBS04sUUFBTCxDQUFjalIsWUFBZDtBQUNBLHdCQUFJdmMsU0FBU29aLFNBQVMsS0FBS3dVLFVBQUwsQ0FBZ0JhLElBQXpCLEVBQStCMXpCLElBQS9CLENBQW9DLEtBQUs2eUIsVUFBekMsRUFBcUQ1dUIsS0FBckQsQ0FBYjtBQUNBLHlCQUFLd3VCLFFBQUwsQ0FBY2hSLFdBQWQ7QUFDQSx5QkFBSytSLFNBQUwsQ0FBZXZ1QixNQUFmO0FBQ0gsaUJBTkQ7O0FBUUFtdEIsNkJBQWF2eUIsU0FBYixDQUF1Qjh6QixnQkFBdkIsR0FBMEMsVUFBU3pQLE1BQVQsRUFBaUI7QUFDdkQseUJBQUs2TyxlQUFMLEdBQXVCLElBQXZCO0FBQ0EseUJBQUtOLFFBQUwsQ0FBY2xTLGlCQUFkLENBQWdDMkQsTUFBaEM7QUFDQSx5QkFBS3VPLFFBQUwsQ0FBY2pSLFlBQWQ7QUFDQSx3QkFBSXZjLFNBQVNvWixTQUFTLEtBQUt3VSxVQUFMLENBQWdCLE9BQWhCLENBQVQsRUFDUjd5QixJQURRLENBQ0gsS0FBSzZ5QixVQURGLEVBQ2MzTyxNQURkLENBQWI7QUFFQSx5QkFBS3VPLFFBQUwsQ0FBY2hSLFdBQWQ7QUFDQSx5QkFBSytSLFNBQUwsQ0FBZXZ1QixNQUFmO0FBQ0gsaUJBUkQ7O0FBVUFtdEIsNkJBQWF2eUIsU0FBYixDQUF1QjJnQixnQkFBdkIsR0FBMEMsWUFBVztBQUNqRCx3QkFBSSxLQUFLdVMsZUFBTCxZQUFnQ2hyQixPQUFwQyxFQUE2QztBQUN6Qyw0QkFBSXdNLFVBQVUsS0FBS3dlLGVBQW5CO0FBQ0EsNkJBQUtBLGVBQUwsR0FBdUIsSUFBdkI7QUFDQXhlLGdDQUFRa0ssTUFBUjtBQUNIO0FBQ0osaUJBTkQ7O0FBUUEyVCw2QkFBYXZ5QixTQUFiLENBQXVCMFUsT0FBdkIsR0FBaUMsWUFBWTtBQUN6QywyQkFBTyxLQUFLa2UsUUFBWjtBQUNILGlCQUZEOztBQUlBTCw2QkFBYXZ5QixTQUFiLENBQXVCK3pCLElBQXZCLEdBQThCLFlBQVk7QUFDdEMseUJBQUtmLFVBQUwsR0FBa0IsS0FBS0Ysa0JBQUwsQ0FBd0IzeUIsSUFBeEIsQ0FBNkIsS0FBSzR5QixTQUFsQyxDQUFsQjtBQUNBLHlCQUFLQSxTQUFMLEdBQ0ksS0FBS0Qsa0JBQUwsR0FBMEJ0dEIsU0FEOUI7QUFFQSx5QkFBS291QixpQkFBTCxDQUF1QnB1QixTQUF2QjtBQUNILGlCQUxEOztBQU9BK3NCLDZCQUFhdnlCLFNBQWIsQ0FBdUIyekIsU0FBdkIsR0FBbUMsVUFBVXZ1QixNQUFWLEVBQWtCO0FBQ2pELHdCQUFJc1AsVUFBVSxLQUFLa2UsUUFBbkI7QUFDQSx3QkFBSXh0QixXQUFXcVosUUFBZixFQUF5QjtBQUNyQiw2QkFBSzRVLFFBQUw7QUFDQSw0QkFBSSxLQUFLRixrQkFBVCxFQUE2QjtBQUN6QixtQ0FBT3plLFFBQVFrSyxNQUFSLEVBQVA7QUFDSCx5QkFGRCxNQUVPO0FBQ0gsbUNBQU9sSyxRQUFRc2YsZUFBUixDQUF3QjV1QixPQUFPekgsQ0FBL0IsRUFBa0MsS0FBbEMsQ0FBUDtBQUNIO0FBQ0o7O0FBRUQsd0JBQUl5RyxRQUFRZ0IsT0FBT2hCLEtBQW5CO0FBQ0Esd0JBQUlnQixPQUFPNnVCLElBQVAsS0FBZ0IsSUFBcEIsRUFBMEI7QUFDdEIsNkJBQUtaLFFBQUw7QUFDQSw0QkFBSSxLQUFLRixrQkFBVCxFQUE2QjtBQUN6QixtQ0FBT3plLFFBQVFrSyxNQUFSLEVBQVA7QUFDSCx5QkFGRCxNQUVPO0FBQ0gsbUNBQU9sSyxRQUFRdUgsZ0JBQVIsQ0FBeUI3WCxLQUF6QixDQUFQO0FBQ0g7QUFDSixxQkFQRCxNQU9PO0FBQ0gsNEJBQUlvWSxlQUFlcEIsb0JBQW9CaFgsS0FBcEIsRUFBMkIsS0FBS3d1QixRQUFoQyxDQUFuQjtBQUNBLDRCQUFJLEVBQUVwVyx3QkFBd0J0VSxPQUExQixDQUFKLEVBQXdDO0FBQ3BDc1UsMkNBQ0k2Vix3QkFBd0I3VixZQUF4QixFQUN3QixLQUFLeVcsY0FEN0IsRUFFd0IsS0FBS0wsUUFGN0IsQ0FESjtBQUlBLGdDQUFJcFcsaUJBQWlCLElBQXJCLEVBQTJCO0FBQ3ZCLHFDQUFLc1gsZ0JBQUwsQ0FDSSxJQUFJbmhCLFNBQUosQ0FDSSxvR0FBb0h2UyxPQUFwSCxDQUE0SCxJQUE1SCxFQUFrSUgsT0FBT21FLEtBQVAsQ0FBbEksSUFDQSxtQkFEQSxHQUVBLEtBQUt5dUIsTUFBTCxDQUFZckosS0FBWixDQUFrQixJQUFsQixFQUF3QmhyQixLQUF4QixDQUE4QixDQUE5QixFQUFpQyxDQUFDLENBQWxDLEVBQXFDMHFCLElBQXJDLENBQTBDLElBQTFDLENBSEosQ0FESjtBQU9BO0FBQ0g7QUFDSjtBQUNEMU0sdUNBQWVBLGFBQWFDLE9BQWIsRUFBZjtBQUNBLDRCQUFJeVgsV0FBVzFYLGFBQWFSLFNBQTVCO0FBQ0E7QUFDQSw0QkFBSyxDQUFDa1ksV0FBVyxRQUFaLE1BQTBCLENBQS9CLEVBQW1DO0FBQy9CLGlDQUFLaEIsZUFBTCxHQUF1QjFXLFlBQXZCO0FBQ0FBLHlDQUFhMlgsTUFBYixDQUFvQixJQUFwQixFQUEwQixJQUExQjtBQUNILHlCQUhELE1BR08sSUFBSyxDQUFDRCxXQUFXLFFBQVosTUFBMEIsQ0FBL0IsRUFBbUM7QUFDdENoc0Isb0NBQVF5VyxNQUFSLENBQWU5RCxNQUFmLENBQ0ksS0FBSytZLGlCQURULEVBQzRCLElBRDVCLEVBQ2tDcFgsYUFBYTZSLE1BQWIsRUFEbEM7QUFHSCx5QkFKTSxNQUlBLElBQUssQ0FBQzZGLFdBQVcsUUFBWixNQUEwQixDQUEvQixFQUFtQztBQUN0Q2hzQixvQ0FBUXlXLE1BQVIsQ0FBZTlELE1BQWYsQ0FDSSxLQUFLaVosZ0JBRFQsRUFDMkIsSUFEM0IsRUFDaUN0WCxhQUFhMFIsT0FBYixFQURqQztBQUdILHlCQUpNLE1BSUE7QUFDSCxpQ0FBS3FGLGlCQUFMO0FBQ0g7QUFDSjtBQUNKLGlCQXZERDs7QUF5REFyckIsd0JBQVF1ckIsU0FBUixHQUFvQixVQUFVakIsaUJBQVYsRUFBNkIxZ0IsT0FBN0IsRUFBc0M7QUFDdEQsd0JBQUksT0FBTzBnQixpQkFBUCxLQUE2QixVQUFqQyxFQUE2QztBQUN6Qyw4QkFBTSxJQUFJN2YsU0FBSixDQUFjLHdFQUFkLENBQU47QUFDSDtBQUNELHdCQUFJOGYsZUFBZTF6QixPQUFPK1MsT0FBUCxFQUFnQjJnQixZQUFuQztBQUNBLHdCQUFJMkIsZ0JBQWdCN0IsWUFBcEI7QUFDQSx3QkFBSWptQixRQUFRLElBQUkySSxLQUFKLEdBQVkzSSxLQUF4QjtBQUNBLDJCQUFPLFlBQVk7QUFDZiw0QkFBSStuQixZQUFZN0Isa0JBQWtCM3lCLEtBQWxCLENBQXdCLElBQXhCLEVBQThCUCxTQUE5QixDQUFoQjtBQUNBLDRCQUFJZzFCLFFBQVEsSUFBSUYsYUFBSixDQUFrQjV1QixTQUFsQixFQUE2QkEsU0FBN0IsRUFBd0NpdEIsWUFBeEMsRUFDa0JubUIsS0FEbEIsQ0FBWjtBQUVBLDRCQUFJaU0sTUFBTStiLE1BQU01ZixPQUFOLEVBQVY7QUFDQTRmLDhCQUFNdEIsVUFBTixHQUFtQnFCLFNBQW5CO0FBQ0FDLDhCQUFNVixpQkFBTixDQUF3QnB1QixTQUF4QjtBQUNBLCtCQUFPK1MsR0FBUDtBQUNILHFCQVJEO0FBU0gsaUJBaEJEOztBQWtCQXJRLHdCQUFRdXJCLFNBQVIsQ0FBa0JjLGVBQWxCLEdBQW9DLFVBQVNsMEIsRUFBVCxFQUFhO0FBQzdDLHdCQUFJLE9BQU9BLEVBQVAsS0FBYyxVQUFsQixFQUE4QjtBQUMxQiw4QkFBTSxJQUFJc1MsU0FBSixDQUFjLGtDQUFrQ21HLEtBQUtpRixXQUFMLENBQWlCMWQsRUFBakIsQ0FBaEQsQ0FBTjtBQUNIO0FBQ0QreEIsa0NBQWMvbkIsSUFBZCxDQUFtQmhLLEVBQW5CO0FBQ0gsaUJBTEQ7O0FBT0E2SCx3QkFBUW9zQixLQUFSLEdBQWdCLFVBQVU5QixpQkFBVixFQUE2QjtBQUN6Q25YLDBCQUFNME8sVUFBTixDQUFpQixpQkFBakIsRUFBb0MscUJBQXBDO0FBQ0Esd0JBQUksT0FBT3lJLGlCQUFQLEtBQTZCLFVBQWpDLEVBQTZDO0FBQ3pDLCtCQUFPalUsYUFBYSx3RUFBYixDQUFQO0FBQ0g7QUFDRCx3QkFBSStWLFFBQVEsSUFBSS9CLFlBQUosQ0FBaUJDLGlCQUFqQixFQUFvQyxJQUFwQyxDQUFaO0FBQ0Esd0JBQUlqYSxNQUFNK2IsTUFBTTVmLE9BQU4sRUFBVjtBQUNBNGYsMEJBQU1QLElBQU4sQ0FBVzdyQixRQUFRb3NCLEtBQW5CO0FBQ0EsMkJBQU8vYixHQUFQO0FBQ0gsaUJBVEQ7QUFVQyxhQTdORDtBQStOQyxTQWpPc0MsRUFpT3JDLEVBQUMsWUFBVyxFQUFaLEVBQWUsVUFBUyxFQUF4QixFQWpPcUMsQ0EvOER5dEIsRUFnckVqdUIsSUFBRyxDQUFDLFVBQVNOLE9BQVQsRUFBaUJwYSxNQUFqQixFQUF3QkMsT0FBeEIsRUFBZ0M7QUFDbkU7O0FBQ0FELG1CQUFPQyxPQUFQLEdBQ0EsVUFBU29LLE9BQVQsRUFBa0JvVyxZQUFsQixFQUFnQ2xELG1CQUFoQyxFQUFxREQsUUFBckQsRUFBK0R1RCxLQUEvRCxFQUNTa0UsU0FEVCxFQUNvQjtBQUNwQixvQkFBSTlKLE9BQU9iLFFBQVEsUUFBUixDQUFYO0FBQ0Esb0JBQUltRixjQUFjdEUsS0FBS3NFLFdBQXZCO0FBQ0Esb0JBQUlvQixXQUFXMUYsS0FBSzBGLFFBQXBCO0FBQ0Esb0JBQUlDLFdBQVczRixLQUFLMkYsUUFBcEI7QUFDQSxvQkFBSXBNLE1BQUo7O0FBRUEsb0JBQUksS0FBSixFQUFXO0FBQ1gsd0JBQUkrSyxXQUFKLEVBQWlCO0FBQ2IsNEJBQUlvWCxlQUFlLFNBQWZBLFlBQWUsQ0FBU24xQixDQUFULEVBQVk7QUFDM0IsbUNBQU8sSUFBSTVCLFFBQUosQ0FBYSxPQUFiLEVBQXNCLFFBQXRCLEVBQWdDOzs7O2FBQUEsQ0FJakMyQyxPQUppQyxDQUl6QixRQUp5QixFQUlmZixDQUplLENBQWhDLENBQVA7QUFLSCx5QkFORDs7QUFRQSw0QkFBSW8xQixnQkFBZ0IsU0FBaEJBLGFBQWdCLENBQVNwMUIsQ0FBVCxFQUFZO0FBQzVCLG1DQUFPLElBQUk1QixRQUFKLENBQWEsU0FBYixFQUF3QixRQUF4QixFQUFrQzs7O2FBQUEsQ0FHbkMyQyxPQUhtQyxDQUczQixRQUgyQixFQUdqQmYsQ0FIaUIsQ0FBbEMsQ0FBUDtBQUlILHlCQUxEOztBQU9BLDRCQUFJcTFCLHNCQUFzQixTQUF0QkEsbUJBQXNCLENBQVNDLEtBQVQsRUFBZ0I7QUFDdEMsZ0NBQUl6bkIsUUFBUSxJQUFJNU0sS0FBSixDQUFVcTBCLEtBQVYsQ0FBWjtBQUNBLGlDQUFLLElBQUl0MUIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJNk4sTUFBTTNOLE1BQTFCLEVBQWtDLEVBQUVGLENBQXBDLEVBQXVDO0FBQ25DNk4sc0NBQU03TixDQUFOLElBQVcsWUFBWUEsSUFBRSxDQUFkLENBQVg7QUFDSDtBQUNELGdDQUFJdTFCLGFBQWExbkIsTUFBTWdjLElBQU4sQ0FBVyxLQUFYLElBQW9CLFVBQXJDO0FBQ0EsZ0NBQUkyTCxtQkFBa0IsbUJBQW1CM25CLE1BQU14TyxHQUFOLENBQVUsVUFBUzZ4QixJQUFULEVBQWU7QUFDOUQsdUNBQU87MkJBQUEsR0FDV0EsSUFEWCxHQUNrQjs7OzthQUR6QjtBQU1ILDZCQVB3QyxFQU90Q3JILElBUHNDLENBT2pDLElBUGlDLENBQXpDO0FBUUEsZ0NBQUk0TCxrQkFBa0I1bkIsTUFBTWdjLElBQU4sQ0FBVyxJQUFYLENBQXRCO0FBQ0EsZ0NBQUlsUyxPQUFPLFlBQVkyZCxLQUF2Qjs7QUFHQSxnQ0FBSXpjLE9BQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1NBQVg7O0FBd0NBQSxtQ0FBT0EsS0FBSzlYLE9BQUwsQ0FBYSxjQUFiLEVBQTZCNFcsSUFBN0IsRUFDRjVXLE9BREUsQ0FDTSxlQUROLEVBQ3VCdTBCLEtBRHZCLEVBRUZ2MEIsT0FGRSxDQUVNLHlCQUZOLEVBRWlDMDBCLGVBRmpDLEVBR0YxMEIsT0FIRSxDQUdNLG9CQUhOLEVBRzRCdzBCLFVBSDVCLEVBSUZ4MEIsT0FKRSxDQUlNLHVCQUpOLEVBSStCeTBCLGdCQUovQixDQUFQOztBQU1BLG1DQUFPLElBQUlwM0IsUUFBSixDQUFhLFVBQWIsRUFBeUIsVUFBekIsRUFBcUMsU0FBckMsRUFBZ0QsT0FBaEQsRUFBeUR5YSxJQUF6RCxFQUNhc0csUUFEYixFQUN1QkMsUUFEdkIsRUFDaUN2VyxPQURqQyxFQUMwQ3dXLEtBRDFDLENBQVA7QUFFSCx5QkFsRUQ7O0FBb0VBLDRCQUFJcVcsZ0JBQWdCLEVBQXBCO0FBQ0EsNEJBQUlDLGdCQUFnQixFQUFwQjtBQUNBLDRCQUFJQyxpQkFBaUIsRUFBckI7O0FBRUEsNkJBQUssSUFBSTUxQixJQUFJLENBQWIsRUFBZ0JBLElBQUksQ0FBcEIsRUFBdUIsRUFBRUEsQ0FBekIsRUFBNEI7QUFDeEIwMUIsMENBQWMxcUIsSUFBZCxDQUFtQnFxQixvQkFBb0JyMUIsSUFBSSxDQUF4QixDQUFuQjtBQUNBMjFCLDBDQUFjM3FCLElBQWQsQ0FBbUJtcUIsYUFBYW4xQixJQUFJLENBQWpCLENBQW5CO0FBQ0E0MUIsMkNBQWU1cUIsSUFBZixDQUFvQm9xQixjQUFjcDFCLElBQUksQ0FBbEIsQ0FBcEI7QUFDSDs7QUFFRGdULGlDQUFTLGdCQUFVZ1MsTUFBVixFQUFrQjtBQUN2QixpQ0FBSzVJLE9BQUwsQ0FBYTRJLE1BQWI7QUFDSCx5QkFGRDtBQUdIO0FBQUM7O0FBRUZuYyx3QkFBUWdoQixJQUFSLEdBQWUsWUFBWTtBQUN2Qix3QkFBSWdNLE9BQU81MUIsVUFBVUMsTUFBVixHQUFtQixDQUE5QjtBQUNBLHdCQUFJYyxFQUFKO0FBQ0Esd0JBQUk2MEIsT0FBTyxDQUFQLElBQVksT0FBTzUxQixVQUFVNDFCLElBQVYsQ0FBUCxLQUEyQixVQUEzQyxFQUF1RDtBQUNuRDcwQiw2QkFBS2YsVUFBVTQxQixJQUFWLENBQUw7QUFDQSw0QkFBSSxLQUFKLEVBQVc7QUFDUCxnQ0FBSUEsUUFBUSxDQUFSLElBQWE5WCxXQUFqQixFQUE4QjtBQUMxQixvQ0FBSTdFLE1BQU0sSUFBSXJRLE9BQUosQ0FBWWlULFFBQVosQ0FBVjtBQUNBNUMsb0NBQUk2TSxrQkFBSjtBQUNBLG9DQUFJK1AsY0FBY0osY0FBY0csT0FBTyxDQUFyQixDQUFsQjtBQUNBLG9DQUFJRSxTQUFTLElBQUlELFdBQUosQ0FBZ0I5MEIsRUFBaEIsQ0FBYjtBQUNBLG9DQUFJZzFCLFlBQVlMLGFBQWhCOztBQUVBLHFDQUFLLElBQUkzMUIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJNjFCLElBQXBCLEVBQTBCLEVBQUU3MUIsQ0FBNUIsRUFBK0I7QUFDM0Isd0NBQUltZCxlQUFlcEIsb0JBQW9COWIsVUFBVUQsQ0FBVixDQUFwQixFQUFrQ2taLEdBQWxDLENBQW5CO0FBQ0Esd0NBQUlpRSx3QkFBd0J0VSxPQUE1QixFQUFxQztBQUNqQ3NVLHVEQUFlQSxhQUFhQyxPQUFiLEVBQWY7QUFDQSw0Q0FBSXlYLFdBQVcxWCxhQUFhUixTQUE1QjtBQUNBO0FBQ0EsNENBQUssQ0FBQ2tZLFdBQVcsUUFBWixNQUEwQixDQUEvQixFQUFtQztBQUMvQjFYLHlEQUFhVixLQUFiLENBQW1CdVosVUFBVWgyQixDQUFWLENBQW5CLEVBQWlDZ1QsTUFBakMsRUFDbUI3TSxTQURuQixFQUM4QitTLEdBRDlCLEVBQ21DNmMsTUFEbkM7QUFFQUgsMkRBQWU1MUIsQ0FBZixFQUFrQm1kLFlBQWxCLEVBQWdDNFksTUFBaEM7QUFDQUEsbURBQU9FLFdBQVAsR0FBcUIsS0FBckI7QUFDSCx5Q0FMRCxNQUtPLElBQUssQ0FBQ3BCLFdBQVcsUUFBWixNQUEwQixDQUEvQixFQUFtQztBQUN0Q21CLHNEQUFVaDJCLENBQVYsRUFBYWMsSUFBYixDQUFrQm9ZLEdBQWxCLEVBQ2tCaUUsYUFBYTZSLE1BQWIsRUFEbEIsRUFDeUMrRyxNQUR6QztBQUVILHlDQUhNLE1BR0EsSUFBSyxDQUFDbEIsV0FBVyxRQUFaLE1BQTBCLENBQS9CLEVBQW1DO0FBQ3RDM2IsZ0RBQUlrRCxPQUFKLENBQVllLGFBQWEwUixPQUFiLEVBQVo7QUFDSCx5Q0FGTSxNQUVBO0FBQ0gzVixnREFBSXNILE9BQUo7QUFDSDtBQUNKLHFDQWpCRCxNQWlCTztBQUNId1Ysa0RBQVVoMkIsQ0FBVixFQUFhYyxJQUFiLENBQWtCb1ksR0FBbEIsRUFBdUJpRSxZQUF2QixFQUFxQzRZLE1BQXJDO0FBQ0g7QUFDSjs7QUFFRCxvQ0FBSSxDQUFDN2MsSUFBSWdkLGFBQUosRUFBTCxFQUEwQjtBQUN0Qix3Q0FBSUgsT0FBT0UsV0FBWCxFQUF3QjtBQUNwQiw0Q0FBSXhRLFNBQVNsQyxXQUFiO0FBQ0EsNENBQUlrQyxXQUFXLElBQWYsRUFBcUI7QUFDakJzUSxtREFBTy8wQixFQUFQLEdBQVl5WSxLQUFLaU0sVUFBTCxDQUFnQkQsTUFBaEIsRUFBd0JzUSxPQUFPLzBCLEVBQS9CLENBQVo7QUFDSDtBQUNKO0FBQ0RrWSx3Q0FBSWlkLG1CQUFKO0FBQ0FqZCx3Q0FBSW9FLFlBQUosQ0FBaUJ5WSxNQUFqQjtBQUNIO0FBQ0QsdUNBQU83YyxHQUFQO0FBQ0g7QUFDSjtBQUNKO0FBQ0Qsd0JBQUkvVCxPQUFPLEdBQUdoRyxLQUFILENBQVMyQixJQUFULENBQWNiLFNBQWQsQ0FBWCxDQUFvQztBQUNwQyx3QkFBSWUsRUFBSixFQUFRbUUsS0FBS3lGLEdBQUw7QUFDUix3QkFBSXNPLE1BQU0sSUFBSStGLFlBQUosQ0FBaUI5WixJQUFqQixFQUF1QmtRLE9BQXZCLEVBQVY7QUFDQSwyQkFBT3JVLE9BQU9tRixTQUFQLEdBQW1CK1MsSUFBSWtkLE1BQUosQ0FBV3AxQixFQUFYLENBQW5CLEdBQW9Da1ksR0FBM0M7QUFDSCxpQkF2REQ7QUF5REMsYUF0S0Q7QUF3S0MsU0ExS2lDLEVBMEtoQyxFQUFDLFVBQVMsRUFBVixFQTFLZ0MsQ0FockU4dEIsRUEwMUUvdUIsSUFBRyxDQUFDLFVBQVNOLE9BQVQsRUFBaUJwYSxNQUFqQixFQUF3QkMsT0FBeEIsRUFBZ0M7QUFDckQ7O0FBQ0FELG1CQUFPQyxPQUFQLEdBQWlCLFVBQVNvSyxPQUFULEVBQ1NvVyxZQURULEVBRVNDLFlBRlQsRUFHU25ELG1CQUhULEVBSVNELFFBSlQsRUFLU0UsS0FMVCxFQUtnQjtBQUNqQyxvQkFBSXVILFlBQVkxYSxRQUFRMmEsVUFBeEI7QUFDQSxvQkFBSS9KLE9BQU9iLFFBQVEsUUFBUixDQUFYO0FBQ0Esb0JBQUl1RyxXQUFXMUYsS0FBSzBGLFFBQXBCO0FBQ0Esb0JBQUlDLFdBQVczRixLQUFLMkYsUUFBcEI7QUFDQSxvQkFBSUMsUUFBUXhXLFFBQVF5VyxNQUFwQjs7QUFFQSx5QkFBUytXLG1CQUFULENBQTZCcGQsUUFBN0IsRUFBdUNqWSxFQUF2QyxFQUEyQ3MxQixLQUEzQyxFQUFrREMsT0FBbEQsRUFBMkQ7QUFDdkQseUJBQUtDLFlBQUwsQ0FBa0J2ZCxRQUFsQjtBQUNBLHlCQUFLc2EsUUFBTCxDQUFjeE4sa0JBQWQ7QUFDQSx3QkFBSU4sU0FBU2xDLFdBQWI7QUFDQSx5QkFBS2tULFNBQUwsR0FBaUJoUixXQUFXLElBQVgsR0FBa0J6a0IsRUFBbEIsR0FBdUJ5WSxLQUFLaU0sVUFBTCxDQUFnQkQsTUFBaEIsRUFBd0J6a0IsRUFBeEIsQ0FBeEM7QUFDQSx5QkFBSzAxQixnQkFBTCxHQUF3QkgsWUFBWXphLFFBQVosR0FDbEIsSUFBSTdhLEtBQUosQ0FBVSxLQUFLZixNQUFMLEVBQVYsQ0FEa0IsR0FFbEIsSUFGTjtBQUdBLHlCQUFLeTJCLE1BQUwsR0FBY0wsS0FBZDtBQUNBLHlCQUFLTSxTQUFMLEdBQWlCLENBQWpCO0FBQ0EseUJBQUtDLE1BQUwsR0FBYyxFQUFkO0FBQ0F4WCwwQkFBTTdELE1BQU4sQ0FBYSxLQUFLc2IsVUFBbEIsRUFBOEIsSUFBOUIsRUFBb0Mzd0IsU0FBcEM7QUFDSDtBQUNEc1QscUJBQUs4VCxRQUFMLENBQWM4SSxtQkFBZCxFQUFtQ3BYLFlBQW5DOztBQUVBb1gsb0NBQW9CMTFCLFNBQXBCLENBQThCbTJCLFVBQTlCLEdBQTJDLFlBQVc7QUFDbEQseUJBQUtDLE1BQUwsQ0FBWTV3QixTQUFaLEVBQXVCLENBQUMsQ0FBeEI7QUFDSCxpQkFGRDs7QUFJQWt3QixvQ0FBb0IxMUIsU0FBcEIsQ0FBOEJxMkIsS0FBOUIsR0FBc0MsWUFBWSxDQUFFLENBQXBEOztBQUVBWCxvQ0FBb0IxMUIsU0FBcEIsQ0FBOEI0ekIsaUJBQTlCLEdBQWtELFVBQVV4dkIsS0FBVixFQUFpQjVELEtBQWpCLEVBQXdCO0FBQ3RFLHdCQUFJcUUsU0FBUyxLQUFLeXhCLE9BQWxCO0FBQ0Esd0JBQUkvMkIsU0FBUyxLQUFLQSxNQUFMLEVBQWI7QUFDQSx3QkFBSWczQixrQkFBa0IsS0FBS1IsZ0JBQTNCO0FBQ0Esd0JBQUlKLFFBQVEsS0FBS0ssTUFBakI7O0FBRUEsd0JBQUl4MUIsUUFBUSxDQUFaLEVBQWU7QUFDWEEsZ0NBQVNBLFFBQVEsQ0FBQyxDQUFWLEdBQWUsQ0FBdkI7QUFDQXFFLCtCQUFPckUsS0FBUCxJQUFnQjRELEtBQWhCO0FBQ0EsNEJBQUl1eEIsU0FBUyxDQUFiLEVBQWdCO0FBQ1osaUNBQUtNLFNBQUw7QUFDQSxpQ0FBS2piLFdBQUw7QUFDQSxnQ0FBSSxLQUFLb1ksV0FBTCxFQUFKLEVBQXdCLE9BQU8sSUFBUDtBQUMzQjtBQUNKLHFCQVJELE1BUU87QUFDSCw0QkFBSXVDLFNBQVMsQ0FBVCxJQUFjLEtBQUtNLFNBQUwsSUFBa0JOLEtBQXBDLEVBQTJDO0FBQ3ZDOXdCLG1DQUFPckUsS0FBUCxJQUFnQjRELEtBQWhCO0FBQ0EsaUNBQUs4eEIsTUFBTCxDQUFZN3JCLElBQVosQ0FBaUI3SixLQUFqQjtBQUNBLG1DQUFPLEtBQVA7QUFDSDtBQUNELDRCQUFJKzFCLG9CQUFvQixJQUF4QixFQUE4QkEsZ0JBQWdCLzFCLEtBQWhCLElBQXlCNEQsS0FBekI7O0FBRTlCLDRCQUFJc1EsVUFBVSxLQUFLa2UsUUFBbkI7QUFDQSw0QkFBSTdmLFdBQVcsS0FBSytpQixTQUFwQjtBQUNBLDRCQUFJdmIsV0FBVzdGLFFBQVE0SCxXQUFSLEVBQWY7QUFDQTVILGdDQUFRaU4sWUFBUjtBQUNBLDRCQUFJcEosTUFBTWlHLFNBQVN6TCxRQUFULEVBQW1CNVMsSUFBbkIsQ0FBd0JvYSxRQUF4QixFQUFrQ25XLEtBQWxDLEVBQXlDNUQsS0FBekMsRUFBZ0RqQixNQUFoRCxDQUFWO0FBQ0EsNEJBQUlrbkIsaUJBQWlCL1IsUUFBUWtOLFdBQVIsRUFBckI7QUFDQXZHLDhCQUFNOE4scUJBQU4sQ0FDSTVRLEdBREosRUFFSWtPLGNBRkosRUFHSThQLG9CQUFvQixJQUFwQixHQUEyQixnQkFBM0IsR0FBOEMsYUFIbEQsRUFJSTdoQixPQUpKO0FBTUEsNEJBQUk2RCxRQUFRa0csUUFBWixFQUFzQjtBQUNsQixpQ0FBS2hELE9BQUwsQ0FBYWxELElBQUk1YSxDQUFqQjtBQUNBLG1DQUFPLElBQVA7QUFDSDs7QUFFRCw0QkFBSTZlLGVBQWVwQixvQkFBb0I3QyxHQUFwQixFQUF5QixLQUFLcWEsUUFBOUIsQ0FBbkI7QUFDQSw0QkFBSXBXLHdCQUF3QnRVLE9BQTVCLEVBQXFDO0FBQ2pDc1UsMkNBQWVBLGFBQWFDLE9BQWIsRUFBZjtBQUNBLGdDQUFJeVgsV0FBVzFYLGFBQWFSLFNBQTVCO0FBQ0E7QUFDQSxnQ0FBSyxDQUFDa1ksV0FBVyxRQUFaLE1BQTBCLENBQS9CLEVBQW1DO0FBQy9CLG9DQUFJeUIsU0FBUyxDQUFiLEVBQWdCLEtBQUtNLFNBQUw7QUFDaEJweEIsdUNBQU9yRSxLQUFQLElBQWdCZ2MsWUFBaEI7QUFDQUEsNkNBQWEyWCxNQUFiLENBQW9CLElBQXBCLEVBQTBCLENBQUMzekIsUUFBUSxDQUFULElBQWMsQ0FBQyxDQUF6QztBQUNBLHVDQUFPLEtBQVA7QUFDSCw2QkFMRCxNQUtPLElBQUssQ0FBQzB6QixXQUFXLFFBQVosTUFBMEIsQ0FBL0IsRUFBbUM7QUFDdEMzYixzQ0FBTWlFLGFBQWE2UixNQUFiLEVBQU47QUFDSCw2QkFGTSxNQUVBLElBQUssQ0FBQzZGLFdBQVcsUUFBWixNQUEwQixDQUEvQixFQUFtQztBQUN0QyxxQ0FBS3pZLE9BQUwsQ0FBYWUsYUFBYTBSLE9BQWIsRUFBYjtBQUNBLHVDQUFPLElBQVA7QUFDSCw2QkFITSxNQUdBO0FBQ0gscUNBQUtyTyxPQUFMO0FBQ0EsdUNBQU8sSUFBUDtBQUNIO0FBQ0o7QUFDRGhiLCtCQUFPckUsS0FBUCxJQUFnQitYLEdBQWhCO0FBQ0g7QUFDRCx3QkFBSWllLGdCQUFnQixFQUFFLEtBQUtDLGNBQTNCO0FBQ0Esd0JBQUlELGlCQUFpQmozQixNQUFyQixFQUE2QjtBQUN6Qiw0QkFBSWczQixvQkFBb0IsSUFBeEIsRUFBOEI7QUFDMUIsaUNBQUtYLE9BQUwsQ0FBYS93QixNQUFiLEVBQXFCMHhCLGVBQXJCO0FBQ0gseUJBRkQsTUFFTztBQUNILGlDQUFLRyxRQUFMLENBQWM3eEIsTUFBZDtBQUNIO0FBQ0QsK0JBQU8sSUFBUDtBQUNIO0FBQ0QsMkJBQU8sS0FBUDtBQUNILGlCQXZFRDs7QUF5RUE2d0Isb0NBQW9CMTFCLFNBQXBCLENBQThCZ2IsV0FBOUIsR0FBNEMsWUFBWTtBQUNwRCx3QkFBSXZGLFFBQVEsS0FBS3lnQixNQUFqQjtBQUNBLHdCQUFJUCxRQUFRLEtBQUtLLE1BQWpCO0FBQ0Esd0JBQUlueEIsU0FBUyxLQUFLeXhCLE9BQWxCO0FBQ0EsMkJBQU83Z0IsTUFBTWxXLE1BQU4sR0FBZSxDQUFmLElBQW9CLEtBQUswMkIsU0FBTCxHQUFpQk4sS0FBNUMsRUFBbUQ7QUFDL0MsNEJBQUksS0FBS3ZDLFdBQUwsRUFBSixFQUF3QjtBQUN4Qiw0QkFBSTV5QixRQUFRaVYsTUFBTXhMLEdBQU4sRUFBWjtBQUNBLDZCQUFLMnBCLGlCQUFMLENBQXVCL3VCLE9BQU9yRSxLQUFQLENBQXZCLEVBQXNDQSxLQUF0QztBQUNIO0FBQ0osaUJBVEQ7O0FBV0FrMUIsb0NBQW9CMTFCLFNBQXBCLENBQThCNDFCLE9BQTlCLEdBQXdDLFVBQVVlLFFBQVYsRUFBb0I5eEIsTUFBcEIsRUFBNEI7QUFDaEUsd0JBQUltUixNQUFNblIsT0FBT3RGLE1BQWpCO0FBQ0Esd0JBQUlnWixNQUFNLElBQUlqWSxLQUFKLENBQVUwVixHQUFWLENBQVY7QUFDQSx3QkFBSXVMLElBQUksQ0FBUjtBQUNBLHlCQUFLLElBQUlsaUIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJMlcsR0FBcEIsRUFBeUIsRUFBRTNXLENBQTNCLEVBQThCO0FBQzFCLDRCQUFJczNCLFNBQVN0M0IsQ0FBVCxDQUFKLEVBQWlCa1osSUFBSWdKLEdBQUosSUFBVzFjLE9BQU94RixDQUFQLENBQVg7QUFDcEI7QUFDRGtaLHdCQUFJaFosTUFBSixHQUFhZ2lCLENBQWI7QUFDQSx5QkFBS21WLFFBQUwsQ0FBY25lLEdBQWQ7QUFDSCxpQkFURDs7QUFXQW1kLG9DQUFvQjExQixTQUFwQixDQUE4QnUyQixlQUE5QixHQUFnRCxZQUFZO0FBQ3hELDJCQUFPLEtBQUtSLGdCQUFaO0FBQ0gsaUJBRkQ7O0FBSUEseUJBQVNyM0IsR0FBVCxDQUFhNFosUUFBYixFQUF1QmpZLEVBQXZCLEVBQTJCeVIsT0FBM0IsRUFBb0M4akIsT0FBcEMsRUFBNkM7QUFDekMsd0JBQUksT0FBT3YxQixFQUFQLEtBQWMsVUFBbEIsRUFBOEI7QUFDMUIsK0JBQU9rZSxhQUFhLGtDQUFrQ3pGLEtBQUtpRixXQUFMLENBQWlCMWQsRUFBakIsQ0FBL0MsQ0FBUDtBQUNIOztBQUVELHdCQUFJczFCLFFBQVEsQ0FBWjtBQUNBLHdCQUFJN2pCLFlBQVl0TSxTQUFoQixFQUEyQjtBQUN2Qiw0QkFBSSxRQUFPc00sT0FBUCx5Q0FBT0EsT0FBUCxPQUFtQixRQUFuQixJQUErQkEsWUFBWSxJQUEvQyxFQUFxRDtBQUNqRCxnQ0FBSSxPQUFPQSxRQUFROGtCLFdBQWYsS0FBK0IsUUFBbkMsRUFBNkM7QUFDekMsdUNBQU8xdUIsUUFBUW1LLE1BQVIsQ0FDSCxJQUFJTSxTQUFKLENBQWMsOENBQ0VtRyxLQUFLaUYsV0FBTCxDQUFpQmpNLFFBQVE4a0IsV0FBekIsQ0FEaEIsQ0FERyxDQUFQO0FBR0g7QUFDRGpCLG9DQUFRN2pCLFFBQVE4a0IsV0FBaEI7QUFDSCx5QkFQRCxNQU9PO0FBQ0gsbUNBQU8xdUIsUUFBUW1LLE1BQVIsQ0FBZSxJQUFJTSxTQUFKLENBQ04sa0RBQ0NtRyxLQUFLaUYsV0FBTCxDQUFpQmpNLE9BQWpCLENBRkssQ0FBZixDQUFQO0FBR0g7QUFDSjtBQUNENmpCLDRCQUFRLE9BQU9BLEtBQVAsS0FBaUIsUUFBakIsSUFDSmtCLFNBQVNsQixLQUFULENBREksSUFDZUEsU0FBUyxDQUR4QixHQUM0QkEsS0FENUIsR0FDb0MsQ0FENUM7QUFFQSwyQkFBTyxJQUFJRCxtQkFBSixDQUF3QnBkLFFBQXhCLEVBQWtDalksRUFBbEMsRUFBc0NzMUIsS0FBdEMsRUFBNkNDLE9BQTdDLEVBQXNEbGhCLE9BQXRELEVBQVA7QUFDSDs7QUFFRHhNLHdCQUFRbEksU0FBUixDQUFrQnRCLEdBQWxCLEdBQXdCLFVBQVUyQixFQUFWLEVBQWN5UixPQUFkLEVBQXVCO0FBQzNDLDJCQUFPcFQsSUFBSSxJQUFKLEVBQVUyQixFQUFWLEVBQWN5UixPQUFkLEVBQXVCLElBQXZCLENBQVA7QUFDSCxpQkFGRDs7QUFJQTVKLHdCQUFReEosR0FBUixHQUFjLFVBQVU0WixRQUFWLEVBQW9CalksRUFBcEIsRUFBd0J5UixPQUF4QixFQUFpQzhqQixPQUFqQyxFQUEwQztBQUNwRCwyQkFBT2wzQixJQUFJNFosUUFBSixFQUFjalksRUFBZCxFQUFrQnlSLE9BQWxCLEVBQTJCOGpCLE9BQTNCLENBQVA7QUFDSCxpQkFGRDtBQUtDLGFBdEtEO0FBd0tDLFNBMUttQixFQTBLbEIsRUFBQyxVQUFTLEVBQVYsRUExS2tCLENBMTFFNHVCLEVBb2dGL3VCLElBQUcsQ0FBQyxVQUFTM2QsT0FBVCxFQUFpQnBhLE1BQWpCLEVBQXdCQyxPQUF4QixFQUFnQztBQUNyRDs7QUFDQUQsbUJBQU9DLE9BQVAsR0FDQSxVQUFTb0ssT0FBVCxFQUFrQmlULFFBQWxCLEVBQTRCQyxtQkFBNUIsRUFBaURtRCxZQUFqRCxFQUErRGxELEtBQS9ELEVBQXNFO0FBQ3RFLG9CQUFJdkMsT0FBT2IsUUFBUSxRQUFSLENBQVg7QUFDQSxvQkFBSXVHLFdBQVcxRixLQUFLMEYsUUFBcEI7O0FBRUF0Vyx3QkFBUW9lLE1BQVIsR0FBaUIsVUFBVWptQixFQUFWLEVBQWM7QUFDM0Isd0JBQUksT0FBT0EsRUFBUCxLQUFjLFVBQWxCLEVBQThCO0FBQzFCLDhCQUFNLElBQUk2SCxRQUFReUssU0FBWixDQUFzQixrQ0FBa0NtRyxLQUFLaUYsV0FBTCxDQUFpQjFkLEVBQWpCLENBQXhELENBQU47QUFDSDtBQUNELDJCQUFPLFlBQVk7QUFDZiw0QkFBSWtZLE1BQU0sSUFBSXJRLE9BQUosQ0FBWWlULFFBQVosQ0FBVjtBQUNBNUMsNEJBQUk2TSxrQkFBSjtBQUNBN00sNEJBQUlvSixZQUFKO0FBQ0EsNEJBQUl2ZCxRQUFRb2EsU0FBU25lLEVBQVQsRUFBYVIsS0FBYixDQUFtQixJQUFuQixFQUF5QlAsU0FBekIsQ0FBWjtBQUNBLDRCQUFJbW5CLGlCQUFpQmxPLElBQUlxSixXQUFKLEVBQXJCO0FBQ0F2Ryw4QkFBTThOLHFCQUFOLENBQ0kva0IsS0FESixFQUNXcWlCLGNBRFgsRUFDMkIsZ0JBRDNCLEVBQzZDbE8sR0FEN0M7QUFFQUEsNEJBQUl1ZSxxQkFBSixDQUEwQjF5QixLQUExQjtBQUNBLCtCQUFPbVUsR0FBUDtBQUNILHFCQVZEO0FBV0gsaUJBZkQ7O0FBaUJBclEsd0JBQVE2dUIsT0FBUixHQUFrQjd1QixRQUFRLEtBQVIsSUFBaUIsVUFBVTdILEVBQVYsRUFBYztBQUM3Qyx3QkFBSSxPQUFPQSxFQUFQLEtBQWMsVUFBbEIsRUFBOEI7QUFDMUIsK0JBQU9rZSxhQUFhLGtDQUFrQ3pGLEtBQUtpRixXQUFMLENBQWlCMWQsRUFBakIsQ0FBL0MsQ0FBUDtBQUNIO0FBQ0Qsd0JBQUlrWSxNQUFNLElBQUlyUSxPQUFKLENBQVlpVCxRQUFaLENBQVY7QUFDQTVDLHdCQUFJNk0sa0JBQUo7QUFDQTdNLHdCQUFJb0osWUFBSjtBQUNBLHdCQUFJdmQsS0FBSjtBQUNBLHdCQUFJOUUsVUFBVUMsTUFBVixHQUFtQixDQUF2QixFQUEwQjtBQUN0QjhiLDhCQUFNME8sVUFBTixDQUFpQiwrQ0FBakI7QUFDQSw0QkFBSWhrQixNQUFNekcsVUFBVSxDQUFWLENBQVY7QUFDQSw0QkFBSXFqQixNQUFNcmpCLFVBQVUsQ0FBVixDQUFWO0FBQ0E4RSxnQ0FBUTBVLEtBQUt2TixPQUFMLENBQWF4RixHQUFiLElBQW9CeVksU0FBU25lLEVBQVQsRUFBYVIsS0FBYixDQUFtQjhpQixHQUFuQixFQUF3QjVjLEdBQXhCLENBQXBCLEdBQ29CeVksU0FBU25lLEVBQVQsRUFBYUYsSUFBYixDQUFrQndpQixHQUFsQixFQUF1QjVjLEdBQXZCLENBRDVCO0FBRUgscUJBTkQsTUFNTztBQUNIM0IsZ0NBQVFvYSxTQUFTbmUsRUFBVCxHQUFSO0FBQ0g7QUFDRCx3QkFBSW9tQixpQkFBaUJsTyxJQUFJcUosV0FBSixFQUFyQjtBQUNBdkcsMEJBQU04TixxQkFBTixDQUNJL2tCLEtBREosRUFDV3FpQixjQURYLEVBQzJCLGFBRDNCLEVBQzBDbE8sR0FEMUM7QUFFQUEsd0JBQUl1ZSxxQkFBSixDQUEwQjF5QixLQUExQjtBQUNBLDJCQUFPbVUsR0FBUDtBQUNILGlCQXRCRDs7QUF3QkFyUSx3QkFBUWxJLFNBQVIsQ0FBa0I4MkIscUJBQWxCLEdBQTBDLFVBQVUxeUIsS0FBVixFQUFpQjtBQUN2RCx3QkFBSUEsVUFBVTBVLEtBQUsyRixRQUFuQixFQUE2QjtBQUN6Qiw2QkFBS3VWLGVBQUwsQ0FBcUI1dkIsTUFBTXpHLENBQTNCLEVBQThCLEtBQTlCO0FBQ0gscUJBRkQsTUFFTztBQUNILDZCQUFLc2UsZ0JBQUwsQ0FBc0I3WCxLQUF0QixFQUE2QixJQUE3QjtBQUNIO0FBQ0osaUJBTkQ7QUFPQyxhQXJERDtBQXVEQyxTQXpEbUIsRUF5RGxCLEVBQUMsVUFBUyxFQUFWLEVBekRrQixDQXBnRjR1QixFQTZqRi91QixJQUFHLENBQUMsVUFBUzZULE9BQVQsRUFBaUJwYSxNQUFqQixFQUF3QkMsT0FBeEIsRUFBZ0M7QUFDckQ7O0FBQ0EsZ0JBQUlnYixPQUFPYixRQUFRLFFBQVIsQ0FBWDtBQUNBLGdCQUFJK2UsbUJBQW1CbGUsS0FBS2tlLGdCQUE1QjtBQUNBLGdCQUFJN0UsU0FBU2xhLFFBQVEsVUFBUixDQUFiO0FBQ0EsZ0JBQUk0WCxtQkFBbUJzQyxPQUFPdEMsZ0JBQTlCO0FBQ0EsZ0JBQUloQixNQUFNNVcsUUFBUSxPQUFSLENBQVY7O0FBRUEscUJBQVNnZixjQUFULENBQXdCaDRCLEdBQXhCLEVBQTZCO0FBQ3pCLHVCQUFPQSxlQUFlZ1csS0FBZixJQUNINFosSUFBSTFuQixjQUFKLENBQW1CbEksR0FBbkIsTUFBNEJnVyxNQUFNalYsU0FEdEM7QUFFSDs7QUFFRCxnQkFBSWszQixZQUFZLGdDQUFoQjtBQUNBLHFCQUFTQyxzQkFBVCxDQUFnQ2w0QixHQUFoQyxFQUFxQztBQUNqQyxvQkFBSXNaLEdBQUo7QUFDQSxvQkFBSTBlLGVBQWVoNEIsR0FBZixDQUFKLEVBQXlCO0FBQ3JCc1osMEJBQU0sSUFBSXNYLGdCQUFKLENBQXFCNXdCLEdBQXJCLENBQU47QUFDQXNaLHdCQUFJdkIsSUFBSixHQUFXL1gsSUFBSStYLElBQWY7QUFDQXVCLHdCQUFJakcsT0FBSixHQUFjclQsSUFBSXFULE9BQWxCO0FBQ0FpRyx3QkFBSWpNLEtBQUosR0FBWXJOLElBQUlxTixLQUFoQjtBQUNBLHdCQUFJOUYsT0FBT3FvQixJQUFJcm9CLElBQUosQ0FBU3ZILEdBQVQsQ0FBWDtBQUNBLHlCQUFLLElBQUlJLElBQUksQ0FBYixFQUFnQkEsSUFBSW1ILEtBQUtqSCxNQUF6QixFQUFpQyxFQUFFRixDQUFuQyxFQUFzQztBQUNsQyw0QkFBSUksTUFBTStHLEtBQUtuSCxDQUFMLENBQVY7QUFDQSw0QkFBSSxDQUFDNjNCLFVBQVVwcEIsSUFBVixDQUFlck8sR0FBZixDQUFMLEVBQTBCO0FBQ3RCOFksZ0NBQUk5WSxHQUFKLElBQVdSLElBQUlRLEdBQUosQ0FBWDtBQUNIO0FBQ0o7QUFDRCwyQkFBTzhZLEdBQVA7QUFDSDtBQUNETyxxQkFBS3NlLDhCQUFMLENBQW9DbjRCLEdBQXBDO0FBQ0EsdUJBQU9BLEdBQVA7QUFDSDs7QUFFRCxxQkFBU280QixrQkFBVCxDQUE0QjNpQixPQUE1QixFQUFxQzRpQixTQUFyQyxFQUFnRDtBQUM1Qyx1QkFBTyxVQUFTOUosR0FBVCxFQUFjcHBCLEtBQWQsRUFBcUI7QUFDeEIsd0JBQUlzUSxZQUFZLElBQWhCLEVBQXNCO0FBQ3RCLHdCQUFJOFksR0FBSixFQUFTO0FBQ0wsNEJBQUkrSixVQUFVSix1QkFBdUJILGlCQUFpQnhKLEdBQWpCLENBQXZCLENBQWQ7QUFDQTlZLGdDQUFRZ00saUJBQVIsQ0FBMEI2VyxPQUExQjtBQUNBN2lCLGdDQUFRK0csT0FBUixDQUFnQjhiLE9BQWhCO0FBQ0gscUJBSkQsTUFJTyxJQUFJLENBQUNELFNBQUwsRUFBZ0I7QUFDbkI1aUIsZ0NBQVE0ZSxRQUFSLENBQWlCbHZCLEtBQWpCO0FBQ0gscUJBRk0sTUFFQTtBQUNILDRCQUFJSSxPQUFPLEdBQUdoRyxLQUFILENBQVMyQixJQUFULENBQWNiLFNBQWQsRUFBeUIsQ0FBekIsQ0FBWCxDQUF1QztBQUN2Q29WLGdDQUFRNGUsUUFBUixDQUFpQjl1QixJQUFqQjtBQUNIO0FBQ0RrUSw4QkFBVSxJQUFWO0FBQ0gsaUJBYkQ7QUFjSDs7QUFFRDdXLG1CQUFPQyxPQUFQLEdBQWlCdTVCLGtCQUFqQjtBQUVDLFNBckRtQixFQXFEbEIsRUFBQyxZQUFXLEVBQVosRUFBZSxTQUFRLEVBQXZCLEVBQTBCLFVBQVMsRUFBbkMsRUFyRGtCLENBN2pGNHVCLEVBa25GdHRCLElBQUcsQ0FBQyxVQUFTcGYsT0FBVCxFQUFpQnBhLE1BQWpCLEVBQXdCQyxPQUF4QixFQUFnQztBQUM5RTs7QUFDQUQsbUJBQU9DLE9BQVAsR0FBaUIsVUFBU29LLE9BQVQsRUFBa0I7QUFDbkMsb0JBQUk0USxPQUFPYixRQUFRLFFBQVIsQ0FBWDtBQUNBLG9CQUFJeUcsUUFBUXhXLFFBQVF5VyxNQUFwQjtBQUNBLG9CQUFJSCxXQUFXMUYsS0FBSzBGLFFBQXBCO0FBQ0Esb0JBQUlDLFdBQVczRixLQUFLMkYsUUFBcEI7O0FBRUEseUJBQVMrWSxhQUFULENBQXVCaDRCLEdBQXZCLEVBQTRCaTRCLFFBQTVCLEVBQXNDO0FBQ2xDLHdCQUFJL2lCLFVBQVUsSUFBZDtBQUNBLHdCQUFJLENBQUNvRSxLQUFLdk4sT0FBTCxDQUFhL0wsR0FBYixDQUFMLEVBQXdCLE9BQU9rNEIsZUFBZXYzQixJQUFmLENBQW9CdVUsT0FBcEIsRUFBNkJsVixHQUE3QixFQUFrQ2k0QixRQUFsQyxDQUFQO0FBQ3hCLHdCQUFJbGYsTUFDQWlHLFNBQVNpWixRQUFULEVBQW1CNTNCLEtBQW5CLENBQXlCNlUsUUFBUTRILFdBQVIsRUFBekIsRUFBZ0QsQ0FBQyxJQUFELEVBQU94YyxNQUFQLENBQWNOLEdBQWQsQ0FBaEQsQ0FESjtBQUVBLHdCQUFJK1ksUUFBUWtHLFFBQVosRUFBc0I7QUFDbEJDLDhCQUFNckUsVUFBTixDQUFpQjlCLElBQUk1YSxDQUFyQjtBQUNIO0FBQ0o7O0FBRUQseUJBQVMrNUIsY0FBVCxDQUF3Qmw0QixHQUF4QixFQUE2Qmk0QixRQUE3QixFQUF1QztBQUNuQyx3QkFBSS9pQixVQUFVLElBQWQ7QUFDQSx3QkFBSTZGLFdBQVc3RixRQUFRNEgsV0FBUixFQUFmO0FBQ0Esd0JBQUkvRCxNQUFNL1ksUUFBUWdHLFNBQVIsR0FDSmdaLFNBQVNpWixRQUFULEVBQW1CdDNCLElBQW5CLENBQXdCb2EsUUFBeEIsRUFBa0MsSUFBbEMsQ0FESSxHQUVKaUUsU0FBU2laLFFBQVQsRUFBbUJ0M0IsSUFBbkIsQ0FBd0JvYSxRQUF4QixFQUFrQyxJQUFsQyxFQUF3Qy9hLEdBQXhDLENBRk47QUFHQSx3QkFBSStZLFFBQVFrRyxRQUFaLEVBQXNCO0FBQ2xCQyw4QkFBTXJFLFVBQU4sQ0FBaUI5QixJQUFJNWEsQ0FBckI7QUFDSDtBQUNKO0FBQ0QseUJBQVNnNkIsWUFBVCxDQUFzQnRULE1BQXRCLEVBQThCb1QsUUFBOUIsRUFBd0M7QUFDcEMsd0JBQUkvaUIsVUFBVSxJQUFkO0FBQ0Esd0JBQUksQ0FBQzJQLE1BQUwsRUFBYTtBQUNULDRCQUFJdVQsWUFBWSxJQUFJM2lCLEtBQUosQ0FBVW9QLFNBQVMsRUFBbkIsQ0FBaEI7QUFDQXVULGtDQUFVOUgsS0FBVixHQUFrQnpMLE1BQWxCO0FBQ0FBLGlDQUFTdVQsU0FBVDtBQUNIO0FBQ0Qsd0JBQUlyZixNQUFNaUcsU0FBU2laLFFBQVQsRUFBbUJ0M0IsSUFBbkIsQ0FBd0J1VSxRQUFRNEgsV0FBUixFQUF4QixFQUErQytILE1BQS9DLENBQVY7QUFDQSx3QkFBSTlMLFFBQVFrRyxRQUFaLEVBQXNCO0FBQ2xCQyw4QkFBTXJFLFVBQU4sQ0FBaUI5QixJQUFJNWEsQ0FBckI7QUFDSDtBQUNKOztBQUVEdUssd0JBQVFsSSxTQUFSLENBQWtCNjNCLFVBQWxCLEdBQStCM3ZCLFFBQVFsSSxTQUFSLENBQWtCODNCLE9BQWxCLEdBQTRCLFVBQVVMLFFBQVYsRUFDVTNsQixPQURWLEVBQ21CO0FBQzFFLHdCQUFJLE9BQU8ybEIsUUFBUCxJQUFtQixVQUF2QixFQUFtQztBQUMvQiw0QkFBSU0sVUFBVUwsY0FBZDtBQUNBLDRCQUFJNWxCLFlBQVl0TSxTQUFaLElBQXlCekcsT0FBTytTLE9BQVAsRUFBZ0IyakIsTUFBN0MsRUFBcUQ7QUFDakRzQyxzQ0FBVVAsYUFBVjtBQUNIO0FBQ0QsNkJBQUsxYixLQUFMLENBQ0lpYyxPQURKLEVBRUlKLFlBRkosRUFHSW55QixTQUhKLEVBSUksSUFKSixFQUtJaXlCLFFBTEo7QUFPSDtBQUNELDJCQUFPLElBQVA7QUFDSCxpQkFoQkQ7QUFpQkMsYUF4REQ7QUEwREMsU0E1RDRDLEVBNEQzQyxFQUFDLFVBQVMsRUFBVixFQTVEMkMsQ0FsbkZtdEIsRUE4cUYvdUIsSUFBRyxDQUFDLFVBQVN4ZixPQUFULEVBQWlCcGEsTUFBakIsRUFBd0JDLE9BQXhCLEVBQWdDO0FBQ3JEOztBQUNBRCxtQkFBT0MsT0FBUCxHQUFpQixZQUFXO0FBQzVCLG9CQUFJazZCLDBCQUEwQixTQUExQkEsdUJBQTBCLEdBQVk7QUFDdEMsMkJBQU8sSUFBSXJsQixTQUFKLENBQWMscUVBQWQsQ0FBUDtBQUNILGlCQUZEO0FBR0Esb0JBQUlzbEIsaUJBQWlCLFNBQWpCQSxjQUFpQixHQUFXO0FBQzVCLDJCQUFPLElBQUkvdkIsUUFBUWd3QixpQkFBWixDQUE4QixLQUFLemIsT0FBTCxFQUE5QixDQUFQO0FBQ0gsaUJBRkQ7QUFHQSxvQkFBSThCLGVBQWUsU0FBZkEsWUFBZSxDQUFTdUwsR0FBVCxFQUFjO0FBQzdCLDJCQUFPNWhCLFFBQVFtSyxNQUFSLENBQWUsSUFBSU0sU0FBSixDQUFjbVgsR0FBZCxDQUFmLENBQVA7QUFDSCxpQkFGRDtBQUdBLHlCQUFTb0ksU0FBVCxHQUFxQixDQUFFO0FBQ3ZCLG9CQUFJaUcsb0JBQW9CLEVBQXhCO0FBQ0Esb0JBQUlyZixPQUFPYixRQUFRLFFBQVIsQ0FBWDs7QUFFQSxvQkFBSTJLLFNBQUo7QUFDQSxvQkFBSTlKLEtBQUttQixNQUFULEVBQWlCO0FBQ2IySSxnQ0FBWSxxQkFBVztBQUNuQiw0QkFBSXJLLE1BQU01VSxRQUFRbWhCLE1BQWxCO0FBQ0EsNEJBQUl2TSxRQUFRL1MsU0FBWixFQUF1QitTLE1BQU0sSUFBTjtBQUN2QiwrQkFBT0EsR0FBUDtBQUNILHFCQUpEO0FBS0gsaUJBTkQsTUFNTztBQUNIcUssZ0NBQVkscUJBQVc7QUFDbkIsK0JBQU8sSUFBUDtBQUNILHFCQUZEO0FBR0g7QUFDRDlKLHFCQUFLbVEsaUJBQUwsQ0FBdUIvZ0IsT0FBdkIsRUFBZ0MsWUFBaEMsRUFBOEMwYSxTQUE5Qzs7QUFFQSxvQkFBSWlNLE1BQU01VyxRQUFRLE9BQVIsQ0FBVjtBQUNBLG9CQUFJYyxRQUFRZCxRQUFRLFNBQVIsQ0FBWjtBQUNBLG9CQUFJeUcsUUFBUSxJQUFJM0YsS0FBSixFQUFaO0FBQ0E4VixvQkFBSTNiLGNBQUosQ0FBbUJoTCxPQUFuQixFQUE0QixRQUE1QixFQUFzQyxFQUFDOUQsT0FBT3NhLEtBQVIsRUFBdEM7QUFDQSxvQkFBSXlULFNBQVNsYSxRQUFRLFVBQVIsQ0FBYjtBQUNBLG9CQUFJdEYsWUFBWXpLLFFBQVF5SyxTQUFSLEdBQW9Cd2YsT0FBT3hmLFNBQTNDO0FBQ0F6Syx3QkFBUXVuQixVQUFSLEdBQXFCMEMsT0FBTzFDLFVBQTVCO0FBQ0Esb0JBQUlILG9CQUFvQnBuQixRQUFRb25CLGlCQUFSLEdBQTRCNkMsT0FBTzdDLGlCQUEzRDtBQUNBcG5CLHdCQUFRcW5CLFlBQVIsR0FBdUI0QyxPQUFPNUMsWUFBOUI7QUFDQXJuQix3QkFBUTJuQixnQkFBUixHQUEyQnNDLE9BQU90QyxnQkFBbEM7QUFDQTNuQix3QkFBUThuQixjQUFSLEdBQXlCbUMsT0FBT3RDLGdCQUFoQztBQUNBM25CLHdCQUFRc25CLGNBQVIsR0FBeUIyQyxPQUFPM0MsY0FBaEM7QUFDQSxvQkFBSXJVLFdBQVcsU0FBWEEsUUFBVyxHQUFVLENBQUUsQ0FBM0I7QUFDQSxvQkFBSWlkLFFBQVEsRUFBWjtBQUNBLG9CQUFJdFgsY0FBYyxFQUFsQjtBQUNBLG9CQUFJMUYsc0JBQXNCbkQsUUFBUSxhQUFSLEVBQXVCL1AsT0FBdkIsRUFBZ0NpVCxRQUFoQyxDQUExQjtBQUNBLG9CQUFJbUQsZUFDQXJHLFFBQVEsaUJBQVIsRUFBMkIvUCxPQUEzQixFQUFvQ2lULFFBQXBDLEVBQzJCQyxtQkFEM0IsRUFDZ0RtRCxZQURoRCxFQUM4RDJULFNBRDlELENBREo7QUFHQSxvQkFBSXBRLFVBQVU3SixRQUFRLFdBQVIsRUFBcUIvUCxPQUFyQixDQUFkO0FBQ0M7QUFDRCxvQkFBSWlhLGdCQUFnQkwsUUFBUTdqQixNQUE1QjtBQUNBLG9CQUFJb2QsUUFBUXBELFFBQVEsaUJBQVIsRUFBMkIvUCxPQUEzQixFQUFvQzRaLE9BQXBDLENBQVo7QUFDQSxvQkFBSUUsZ0JBQWdCM0csTUFBTTJHLGFBQTFCO0FBQ0Esb0JBQUlpUCw0QkFDQWhaLFFBQVEsV0FBUixFQUFxQi9QLE9BQXJCLEVBQThCa1QsbUJBQTlCLEVBQW1EMEYsV0FBbkQsQ0FESjtBQUVBLG9CQUFJRSxjQUFjL0ksUUFBUSxnQkFBUixFQUEwQjZJLFdBQTFCLENBQWxCO0FBQ0Esb0JBQUl1VyxxQkFBcUJwZixRQUFRLFlBQVIsQ0FBekI7QUFDQSxvQkFBSXdHLFdBQVczRixLQUFLMkYsUUFBcEI7QUFDQSxvQkFBSUQsV0FBVzFGLEtBQUswRixRQUFwQjtBQUNBLHlCQUFTNlosS0FBVCxDQUFlajFCLElBQWYsRUFBcUIra0IsUUFBckIsRUFBK0I7QUFDM0Isd0JBQUkva0IsUUFBUSxJQUFSLElBQWdCQSxLQUFLaU0sV0FBTCxLQUFxQm5ILE9BQXpDLEVBQWtEO0FBQzlDLDhCQUFNLElBQUl5SyxTQUFKLENBQWMsc0ZBQWQsQ0FBTjtBQUNIO0FBQ0Qsd0JBQUksT0FBT3dWLFFBQVAsS0FBb0IsVUFBeEIsRUFBb0M7QUFDaEMsOEJBQU0sSUFBSXhWLFNBQUosQ0FBYyxrQ0FBa0NtRyxLQUFLaUYsV0FBTCxDQUFpQm9LLFFBQWpCLENBQWhELENBQU47QUFDSDtBQUVKOztBQUVELHlCQUFTamdCLE9BQVQsQ0FBaUJpZ0IsUUFBakIsRUFBMkI7QUFDdkIsd0JBQUlBLGFBQWFoTixRQUFqQixFQUEyQjtBQUN2QmtkLDhCQUFNLElBQU4sRUFBWWxRLFFBQVo7QUFDSDtBQUNELHlCQUFLbk0sU0FBTCxHQUFpQixDQUFqQjtBQUNBLHlCQUFLc2Msb0JBQUwsR0FBNEI5eUIsU0FBNUI7QUFDQSx5QkFBSyt5QixrQkFBTCxHQUEwQi95QixTQUExQjtBQUNBLHlCQUFLZ3pCLFNBQUwsR0FBaUJoekIsU0FBakI7QUFDQSx5QkFBS2l6QixVQUFMLEdBQWtCanpCLFNBQWxCO0FBQ0EseUJBQUtrekIsb0JBQUwsQ0FBMEJ2USxRQUExQjtBQUNBLHlCQUFLekcsZUFBTDtBQUNBLHlCQUFLdUcsVUFBTCxDQUFnQixnQkFBaEIsRUFBa0MsSUFBbEM7QUFDSDs7QUFFRC9mLHdCQUFRbEksU0FBUixDQUFrQmEsUUFBbEIsR0FBNkIsWUFBWTtBQUNyQywyQkFBTyxrQkFBUDtBQUNILGlCQUZEOztBQUlBcUgsd0JBQVFsSSxTQUFSLENBQWtCbXVCLE1BQWxCLEdBQTJCam1CLFFBQVFsSSxTQUFSLENBQWtCLE9BQWxCLElBQTZCLFVBQVVLLEVBQVYsRUFBYztBQUNsRSx3QkFBSTJWLE1BQU0xVyxVQUFVQyxNQUFwQjtBQUNBLHdCQUFJeVcsTUFBTSxDQUFWLEVBQWE7QUFDVCw0QkFBSWljLGlCQUFpQixJQUFJM3hCLEtBQUosQ0FBVTBWLE1BQU0sQ0FBaEIsQ0FBckI7QUFBQSw0QkFDSXVMLElBQUksQ0FEUjtBQUFBLDRCQUNXbGlCLENBRFg7QUFFQSw2QkFBS0EsSUFBSSxDQUFULEVBQVlBLElBQUkyVyxNQUFNLENBQXRCLEVBQXlCLEVBQUUzVyxDQUEzQixFQUE4QjtBQUMxQixnQ0FBSWdpQixPQUFPL2hCLFVBQVVELENBQVYsQ0FBWDtBQUNBLGdDQUFJeVosS0FBS2hhLFFBQUwsQ0FBY3VpQixJQUFkLENBQUosRUFBeUI7QUFDckI0USwrQ0FBZTFRLEdBQWYsSUFBc0JGLElBQXRCO0FBQ0gsNkJBRkQsTUFFTztBQUNILHVDQUFPOUMsYUFBYSxnQ0FDaEIsOEJBRGdCLEdBQ2lCekYsS0FBS2lGLFdBQUwsQ0FBaUJzRCxJQUFqQixDQUQ5QixDQUFQO0FBRUg7QUFDSjtBQUNENFEsdUNBQWUxeUIsTUFBZixHQUF3QmdpQixDQUF4QjtBQUNBbGhCLDZCQUFLZixVQUFVRCxDQUFWLENBQUw7QUFDQSwrQkFBTyxLQUFLc1YsSUFBTCxDQUFVblAsU0FBVixFQUFxQndiLFlBQVlpUixjQUFaLEVBQTRCNXhCLEVBQTVCLEVBQWdDLElBQWhDLENBQXJCLENBQVA7QUFDSDtBQUNELDJCQUFPLEtBQUtzVSxJQUFMLENBQVVuUCxTQUFWLEVBQXFCbkYsRUFBckIsQ0FBUDtBQUNILGlCQW5CRDs7QUFxQkE2SCx3QkFBUWxJLFNBQVIsQ0FBa0IyNEIsT0FBbEIsR0FBNEIsWUFBWTtBQUNwQywyQkFBTyxLQUFLN2MsS0FBTCxDQUFXbWMsY0FBWCxFQUNIQSxjQURHLEVBQ2F6eUIsU0FEYixFQUN3QixJQUR4QixFQUM4QkEsU0FEOUIsQ0FBUDtBQUVILGlCQUhEOztBQUtBMEMsd0JBQVFsSSxTQUFSLENBQWtCMlUsSUFBbEIsR0FBeUIsVUFBVWlrQixVQUFWLEVBQXNCQyxTQUF0QixFQUFpQztBQUN0RCx3QkFBSXhkLE1BQU1xSSxRQUFOLE1BQW9CcGtCLFVBQVVDLE1BQVYsR0FBbUIsQ0FBdkMsSUFDQSxPQUFPcTVCLFVBQVAsS0FBc0IsVUFEdEIsSUFFQSxPQUFPQyxTQUFQLEtBQXFCLFVBRnpCLEVBRXFDO0FBQ2pDLDRCQUFJL08sTUFBTSxvREFDRmhSLEtBQUtpRixXQUFMLENBQWlCNmEsVUFBakIsQ0FEUjtBQUVBLDRCQUFJdDVCLFVBQVVDLE1BQVYsR0FBbUIsQ0FBdkIsRUFBMEI7QUFDdEJ1cUIsbUNBQU8sT0FBT2hSLEtBQUtpRixXQUFMLENBQWlCOGEsU0FBakIsQ0FBZDtBQUNIO0FBQ0QsNkJBQUsvWixLQUFMLENBQVdnTCxHQUFYO0FBQ0g7QUFDRCwyQkFBTyxLQUFLaE8sS0FBTCxDQUFXOGMsVUFBWCxFQUF1QkMsU0FBdkIsRUFBa0NyekIsU0FBbEMsRUFBNkNBLFNBQTdDLEVBQXdEQSxTQUF4RCxDQUFQO0FBQ0gsaUJBWkQ7O0FBY0EwQyx3QkFBUWxJLFNBQVIsQ0FBa0JpMEIsSUFBbEIsR0FBeUIsVUFBVTJFLFVBQVYsRUFBc0JDLFNBQXRCLEVBQWlDO0FBQ3RELHdCQUFJbmtCLFVBQ0EsS0FBS29ILEtBQUwsQ0FBVzhjLFVBQVgsRUFBdUJDLFNBQXZCLEVBQWtDcnpCLFNBQWxDLEVBQTZDQSxTQUE3QyxFQUF3REEsU0FBeEQsQ0FESjtBQUVBa1AsNEJBQVFva0IsV0FBUjtBQUNILGlCQUpEOztBQU1BNXdCLHdCQUFRbEksU0FBUixDQUFrQnkxQixNQUFsQixHQUEyQixVQUFVcDFCLEVBQVYsRUFBYztBQUNyQyx3QkFBSSxPQUFPQSxFQUFQLEtBQWMsVUFBbEIsRUFBOEI7QUFDMUIsK0JBQU9rZSxhQUFhLGtDQUFrQ3pGLEtBQUtpRixXQUFMLENBQWlCMWQsRUFBakIsQ0FBL0MsQ0FBUDtBQUNIO0FBQ0QsMkJBQU8sS0FBS291QixHQUFMLEdBQVczUyxLQUFYLENBQWlCemIsRUFBakIsRUFBcUJtRixTQUFyQixFQUFnQ0EsU0FBaEMsRUFBMkM0eUIsS0FBM0MsRUFBa0Q1eUIsU0FBbEQsQ0FBUDtBQUNILGlCQUxEOztBQU9BMEMsd0JBQVFsSSxTQUFSLENBQWtCKzRCLE1BQWxCLEdBQTJCLFlBQVk7QUFDbkMsd0JBQUl4Z0IsTUFBTTtBQUNObVEscUNBQWEsS0FEUDtBQUVOaUosb0NBQVksS0FGTjtBQUdOcUgsMENBQWtCeHpCLFNBSFo7QUFJTnl6Qix5Q0FBaUJ6ekI7QUFKWCxxQkFBVjtBQU1BLHdCQUFJLEtBQUtrakIsV0FBTCxFQUFKLEVBQXdCO0FBQ3BCblEsNEJBQUl5Z0IsZ0JBQUosR0FBdUIsS0FBSzUwQixLQUFMLEVBQXZCO0FBQ0FtVSw0QkFBSW1RLFdBQUosR0FBa0IsSUFBbEI7QUFDSCxxQkFIRCxNQUdPLElBQUksS0FBS2lKLFVBQUwsRUFBSixFQUF1QjtBQUMxQnBaLDRCQUFJMGdCLGVBQUosR0FBc0IsS0FBSzVVLE1BQUwsRUFBdEI7QUFDQTlMLDRCQUFJb1osVUFBSixHQUFpQixJQUFqQjtBQUNIO0FBQ0QsMkJBQU9wWixHQUFQO0FBQ0gsaUJBZkQ7O0FBaUJBclEsd0JBQVFsSSxTQUFSLENBQWtCeXVCLEdBQWxCLEdBQXdCLFlBQVk7QUFDaEMsd0JBQUludkIsVUFBVUMsTUFBVixHQUFtQixDQUF2QixFQUEwQjtBQUN0Qiw2QkFBS3VmLEtBQUwsQ0FBVyxzREFBWDtBQUNIO0FBQ0QsMkJBQU8sSUFBSVIsWUFBSixDQUFpQixJQUFqQixFQUF1QjVKLE9BQXZCLEVBQVA7QUFDSCxpQkFMRDs7QUFPQXhNLHdCQUFRbEksU0FBUixDQUFrQnVTLEtBQWxCLEdBQTBCLFVBQVVsUyxFQUFWLEVBQWM7QUFDcEMsMkJBQU8sS0FBSzh0QixNQUFMLENBQVlyVixLQUFLb2dCLHVCQUFqQixFQUEwQzc0QixFQUExQyxDQUFQO0FBQ0gsaUJBRkQ7O0FBSUE2SCx3QkFBUWl4QixpQkFBUixHQUE0QnQ3QixPQUFPQyxPQUFuQzs7QUFFQW9LLHdCQUFRa3hCLEVBQVIsR0FBYSxVQUFVNTVCLEdBQVYsRUFBZTtBQUN4QiwyQkFBT0EsZUFBZTBJLE9BQXRCO0FBQ0gsaUJBRkQ7O0FBSUFBLHdCQUFRbXhCLFFBQVIsR0FBbUJueEIsUUFBUW94QixZQUFSLEdBQXVCLFVBQVNqNUIsRUFBVCxFQUFhO0FBQ25ELHdCQUFJa1ksTUFBTSxJQUFJclEsT0FBSixDQUFZaVQsUUFBWixDQUFWO0FBQ0E1Qyx3QkFBSTZNLGtCQUFKO0FBQ0Esd0JBQUlrUyxZQUFZaDRCLFVBQVVDLE1BQVYsR0FBbUIsQ0FBbkIsR0FBdUIsQ0FBQyxDQUFDUixPQUFPTyxVQUFVLENBQVYsQ0FBUCxFQUFxQmc0QixTQUE5QyxHQUN1QixLQUR2QztBQUVBLHdCQUFJbHlCLFNBQVNvWixTQUFTbmUsRUFBVCxFQUFhZzNCLG1CQUFtQjllLEdBQW5CLEVBQXdCK2UsU0FBeEIsQ0FBYixDQUFiO0FBQ0Esd0JBQUlseUIsV0FBV3FaLFFBQWYsRUFBeUI7QUFDckJsRyw0QkFBSXliLGVBQUosQ0FBb0I1dUIsT0FBT3pILENBQTNCLEVBQThCLElBQTlCO0FBQ0g7QUFDRCx3QkFBSSxDQUFDNGEsSUFBSWdkLGFBQUosRUFBTCxFQUEwQmhkLElBQUlpZCxtQkFBSjtBQUMxQiwyQkFBT2pkLEdBQVA7QUFDSCxpQkFYRDs7QUFhQXJRLHdCQUFRdW1CLEdBQVIsR0FBYyxVQUFVblcsUUFBVixFQUFvQjtBQUM5QiwyQkFBTyxJQUFJZ0csWUFBSixDQUFpQmhHLFFBQWpCLEVBQTJCNUQsT0FBM0IsRUFBUDtBQUNILGlCQUZEOztBQUlBeE0sd0JBQVFxeEIsSUFBUixHQUFlLFVBQVV0NkIsR0FBVixFQUFlO0FBQzFCLHdCQUFJc1osTUFBTTZDLG9CQUFvQm5jLEdBQXBCLENBQVY7QUFDQSx3QkFBSSxFQUFFc1osZUFBZXJRLE9BQWpCLENBQUosRUFBK0I7QUFDM0JxUSw4QkFBTSxJQUFJclEsT0FBSixDQUFZaVQsUUFBWixDQUFOO0FBQ0E1Qyw0QkFBSTZNLGtCQUFKO0FBQ0E3TSw0QkFBSWloQixhQUFKO0FBQ0FqaEIsNEJBQUlnZ0Isa0JBQUosR0FBeUJ0NUIsR0FBekI7QUFDSDtBQUNELDJCQUFPc1osR0FBUDtBQUNILGlCQVREOztBQVdBclEsd0JBQVE2SSxPQUFSLEdBQWtCN0ksUUFBUXV4QixTQUFSLEdBQW9CdnhCLFFBQVFxeEIsSUFBOUM7O0FBRUFyeEIsd0JBQVFtSyxNQUFSLEdBQWlCbkssUUFBUXd4QixRQUFSLEdBQW1CLFVBQVVyVixNQUFWLEVBQWtCO0FBQ2xELHdCQUFJOUwsTUFBTSxJQUFJclEsT0FBSixDQUFZaVQsUUFBWixDQUFWO0FBQ0E1Qyx3QkFBSTZNLGtCQUFKO0FBQ0E3TSx3QkFBSXliLGVBQUosQ0FBb0IzUCxNQUFwQixFQUE0QixJQUE1QjtBQUNBLDJCQUFPOUwsR0FBUDtBQUNILGlCQUxEOztBQU9BclEsd0JBQVF1UixZQUFSLEdBQXVCLFVBQVNwWixFQUFULEVBQWE7QUFDaEMsd0JBQUksT0FBT0EsRUFBUCxLQUFjLFVBQWxCLEVBQThCO0FBQzFCLDhCQUFNLElBQUlzUyxTQUFKLENBQWMsa0NBQWtDbUcsS0FBS2lGLFdBQUwsQ0FBaUIxZCxFQUFqQixDQUFoRCxDQUFOO0FBQ0g7QUFDRCwyQkFBT3FlLE1BQU1qRixZQUFOLENBQW1CcFosRUFBbkIsQ0FBUDtBQUNILGlCQUxEOztBQU9BNkgsd0JBQVFsSSxTQUFSLENBQWtCOGIsS0FBbEIsR0FBMEIsVUFDdEI4YyxVQURzQixFQUV0QkMsU0FGc0IsRUFHdEJyZCxDQUhzQixFQUdoQmpCLFFBSGdCLEVBSXRCb2YsWUFKc0IsRUFLeEI7QUFDRSx3QkFBSUMsbUJBQW1CRCxpQkFBaUJuMEIsU0FBeEM7QUFDQSx3QkFBSWtQLFVBQVVrbEIsbUJBQW1CRCxZQUFuQixHQUFrQyxJQUFJenhCLE9BQUosQ0FBWWlULFFBQVosQ0FBaEQ7QUFDQSx3QkFBSWUsU0FBUyxLQUFLTyxPQUFMLEVBQWI7QUFDQSx3QkFBSXlYLFdBQVdoWSxPQUFPRixTQUF0Qjs7QUFFQSx3QkFBSSxDQUFDNGQsZ0JBQUwsRUFBdUI7QUFDbkJsbEIsZ0NBQVEwSCxjQUFSLENBQXVCLElBQXZCLEVBQTZCLENBQTdCO0FBQ0ExSCxnQ0FBUTBRLGtCQUFSO0FBQ0EsNEJBQUk3SyxhQUFhL1UsU0FBYixJQUNDLENBQUMsS0FBS3dXLFNBQUwsR0FBaUIsT0FBbEIsTUFBK0IsQ0FEcEMsRUFDd0M7QUFDcEMsZ0NBQUksRUFBRSxDQUFDa1ksV0FBVyxRQUFaLE1BQTBCLENBQTVCLENBQUosRUFBb0M7QUFDaEMzWiwyQ0FBVyxLQUFLK0IsV0FBTCxFQUFYO0FBQ0gsNkJBRkQsTUFFTztBQUNIL0IsMkNBQVcyQixXQUFXLElBQVgsR0FBa0IxVyxTQUFsQixHQUE4QixLQUFLb1gsUUFBOUM7QUFDSDtBQUNKO0FBQ0QsNkJBQUtxTCxVQUFMLENBQWdCLGdCQUFoQixFQUFrQyxJQUFsQyxFQUF3Q3ZULE9BQXhDO0FBQ0g7O0FBRUQsd0JBQUlvUSxTQUFTbEMsV0FBYjtBQUNBLHdCQUFJLEVBQUUsQ0FBQ3NSLFdBQVcsUUFBWixNQUEwQixDQUE1QixDQUFKLEVBQW9DO0FBQ2hDLDRCQUFJOUwsT0FBSjtBQUFBLDRCQUFhaGtCLEtBQWI7QUFBQSw0QkFBb0J5MUIsVUFBVTNkLE9BQU80ZCxpQkFBckM7QUFDQSw0QkFBSyxDQUFDNUYsV0FBVyxRQUFaLE1BQTBCLENBQS9CLEVBQW1DO0FBQy9COXZCLG9DQUFROFgsT0FBT3FjLGtCQUFmO0FBQ0FuUSxzQ0FBVXdRLFVBQVY7QUFDSCx5QkFIRCxNQUdPLElBQUssQ0FBQzFFLFdBQVcsUUFBWixNQUEwQixDQUEvQixFQUFtQztBQUN0Qzl2QixvQ0FBUThYLE9BQU9vYyxvQkFBZjtBQUNBbFEsc0NBQVV5USxTQUFWO0FBQ0EzYyxtQ0FBT3dJLDBCQUFQO0FBQ0gseUJBSk0sTUFJQTtBQUNIbVYsc0NBQVUzZCxPQUFPNmQsc0NBQWpCO0FBQ0EzMUIsb0NBQVEsSUFBSWtyQixpQkFBSixDQUFzQiw0QkFBdEIsQ0FBUjtBQUNBcFQsbUNBQU93RSxpQkFBUCxDQUF5QnRjLEtBQXpCO0FBQ0Fna0Isc0NBQVV5USxTQUFWO0FBQ0g7O0FBRURuYSw4QkFBTTdELE1BQU4sQ0FBYWdmLE9BQWIsRUFBc0IzZCxNQUF0QixFQUE4QjtBQUMxQmtNLHFDQUFTdEQsV0FBVyxJQUFYLEdBQWtCc0QsT0FBbEIsR0FDRixPQUFPQSxPQUFQLEtBQW1CLFVBQW5CLElBQ0N0UCxLQUFLaU0sVUFBTCxDQUFnQkQsTUFBaEIsRUFBd0JzRCxPQUF4QixDQUhrQjtBQUkxQjFULHFDQUFTQSxPQUppQjtBQUsxQjZGLHNDQUFVQSxRQUxnQjtBQU0xQm5XLG1DQUFPQTtBQU5tQix5QkFBOUI7QUFRSCxxQkF4QkQsTUF3Qk87QUFDSDhYLCtCQUFPOGQsYUFBUCxDQUFxQnBCLFVBQXJCLEVBQWlDQyxTQUFqQyxFQUE0Q25rQixPQUE1QyxFQUFxRDZGLFFBQXJELEVBQStEdUssTUFBL0Q7QUFDSDs7QUFFRCwyQkFBT3BRLE9BQVA7QUFDSCxpQkF2REQ7O0FBeURBeE0sd0JBQVFsSSxTQUFSLENBQWtCZ2dCLE9BQWxCLEdBQTRCLFlBQVk7QUFDcEMsMkJBQU8sS0FBS2hFLFNBQUwsR0FBaUIsS0FBeEI7QUFDSCxpQkFGRDs7QUFJQTlULHdCQUFRbEksU0FBUixDQUFrQnUxQixhQUFsQixHQUFrQyxZQUFZO0FBQzFDLDJCQUFPLENBQUMsS0FBS3ZaLFNBQUwsR0FBaUIsU0FBbEIsTUFBaUMsQ0FBeEM7QUFDSCxpQkFGRDs7QUFJQTlULHdCQUFRbEksU0FBUixDQUFrQmtmLFlBQWxCLEdBQWlDLFlBQVk7QUFDekMsMkJBQU8sQ0FBQyxLQUFLbEQsU0FBTCxHQUFpQixRQUFsQixNQUFnQyxRQUF2QztBQUNILGlCQUZEOztBQUlBOVQsd0JBQVFsSSxTQUFSLENBQWtCaTZCLFVBQWxCLEdBQStCLFVBQVVqa0IsR0FBVixFQUFlO0FBQzFDLHlCQUFLZ0csU0FBTCxHQUFrQixLQUFLQSxTQUFMLEdBQWlCLENBQUMsS0FBbkIsR0FDWmhHLE1BQU0sS0FEWDtBQUVILGlCQUhEOztBQUtBOU4sd0JBQVFsSSxTQUFSLENBQWtCdzVCLGFBQWxCLEdBQWtDLFlBQVk7QUFDMUMseUJBQUt4ZCxTQUFMLEdBQWlCLEtBQUtBLFNBQUwsR0FBaUIsUUFBbEM7QUFDQSx5QkFBS2lNLFVBQUwsQ0FBZ0Isa0JBQWhCLEVBQW9DLElBQXBDO0FBQ0gsaUJBSEQ7O0FBS0EvZix3QkFBUWxJLFNBQVIsQ0FBa0JrNkIsWUFBbEIsR0FBaUMsWUFBWTtBQUN6Qyx5QkFBS2xlLFNBQUwsR0FBaUIsS0FBS0EsU0FBTCxHQUFpQixRQUFsQztBQUNBLHlCQUFLaU0sVUFBTCxDQUFnQixpQkFBaEIsRUFBbUMsSUFBbkM7QUFDSCxpQkFIRDs7QUFLQS9mLHdCQUFRbEksU0FBUixDQUFrQm02QixhQUFsQixHQUFrQyxZQUFZO0FBQzFDLHlCQUFLbmUsU0FBTCxHQUFpQixLQUFLQSxTQUFMLEdBQWlCLFFBQWxDO0FBQ0EseUJBQUtpTSxVQUFMLENBQWdCLGlCQUFoQixFQUFtQyxJQUFuQztBQUNILGlCQUhEOztBQUtBL2Ysd0JBQVFsSSxTQUFSLENBQWtCODRCLFdBQWxCLEdBQWdDLFlBQVk7QUFDeEMseUJBQUs5YyxTQUFMLEdBQWlCLEtBQUtBLFNBQUwsR0FBaUIsT0FBbEM7QUFDSCxpQkFGRDs7QUFJQTlULHdCQUFRbEksU0FBUixDQUFrQm82QixRQUFsQixHQUE2QixZQUFZO0FBQ3JDLDJCQUFPLENBQUMsS0FBS3BlLFNBQUwsR0FBaUIsT0FBbEIsSUFBNkIsQ0FBcEM7QUFDSCxpQkFGRDs7QUFJQTlULHdCQUFRbEksU0FBUixDQUFrQnE2QixlQUFsQixHQUFvQyxZQUFXO0FBQzNDLHlCQUFLcmUsU0FBTCxHQUFpQixLQUFLQSxTQUFMLEdBQWtCLENBQUMsS0FBcEM7QUFDSCxpQkFGRDs7QUFJQTlULHdCQUFRbEksU0FBUixDQUFrQjhmLGFBQWxCLEdBQWtDLFlBQVc7QUFDekMseUJBQUs5RCxTQUFMLEdBQWlCLEtBQUtBLFNBQUwsR0FBaUIsS0FBbEM7QUFDQSx5QkFBS2lNLFVBQUwsQ0FBZ0Isa0JBQWhCLEVBQW9DLElBQXBDO0FBQ0gsaUJBSEQ7O0FBS0EvZix3QkFBUWxJLFNBQVIsQ0FBa0J1ZixtQkFBbEIsR0FBd0MsWUFBVztBQUMvQyx5QkFBS3ZELFNBQUwsR0FBaUIsS0FBS0EsU0FBTCxHQUFpQixPQUFsQztBQUNILGlCQUZEOztBQUlBOVQsd0JBQVFsSSxTQUFSLENBQWtCdzFCLG1CQUFsQixHQUF3QyxZQUFXO0FBQy9DLHdCQUFJOVcsTUFBTS9FLGtCQUFOLEVBQUosRUFBZ0M7QUFDaEMseUJBQUtxQyxTQUFMLEdBQWlCLEtBQUtBLFNBQUwsR0FBaUIsU0FBbEM7QUFDSCxpQkFIRDs7QUFLQTlULHdCQUFRbEksU0FBUixDQUFrQnM2QixXQUFsQixHQUFnQyxVQUFVOTVCLEtBQVYsRUFBaUI7QUFDN0Msd0JBQUkrWCxNQUFNL1gsVUFBVSxDQUFWLEdBQWMsS0FBS2k0QixVQUFuQixHQUFnQyxLQUNsQ2o0QixRQUFRLENBQVIsR0FBWSxDQUFaLEdBQWdCLENBRGtCLENBQTFDO0FBRUEsd0JBQUkrWCxRQUFRNGYsaUJBQVosRUFBK0I7QUFDM0IsK0JBQU8zeUIsU0FBUDtBQUNILHFCQUZELE1BRU8sSUFBSStTLFFBQVEvUyxTQUFSLElBQXFCLEtBQUtxWCxRQUFMLEVBQXpCLEVBQTBDO0FBQzdDLCtCQUFPLEtBQUtQLFdBQUwsRUFBUDtBQUNIO0FBQ0QsMkJBQU8vRCxHQUFQO0FBQ0gsaUJBVEQ7O0FBV0FyUSx3QkFBUWxJLFNBQVIsQ0FBa0J1NkIsVUFBbEIsR0FBK0IsVUFBVS81QixLQUFWLEVBQWlCO0FBQzVDLDJCQUFPLEtBQ0NBLFFBQVEsQ0FBUixHQUFZLENBQVosR0FBZ0IsQ0FEakIsQ0FBUDtBQUVILGlCQUhEOztBQUtBMEgsd0JBQVFsSSxTQUFSLENBQWtCdzZCLHFCQUFsQixHQUEwQyxVQUFVaDZCLEtBQVYsRUFBaUI7QUFDdkQsMkJBQU8sS0FDQ0EsUUFBUSxDQUFSLEdBQVksQ0FBWixHQUFnQixDQURqQixDQUFQO0FBRUgsaUJBSEQ7O0FBS0EwSCx3QkFBUWxJLFNBQVIsQ0FBa0J5NkIsbUJBQWxCLEdBQXdDLFVBQVVqNkIsS0FBVixFQUFpQjtBQUNyRCwyQkFBTyxLQUNDQSxRQUFRLENBQVIsR0FBWSxDQUFaLEdBQWdCLENBRGpCLENBQVA7QUFFSCxpQkFIRDs7QUFLQTBILHdCQUFRbEksU0FBUixDQUFrQnNjLFdBQWxCLEdBQWdDLFlBQVcsQ0FBRSxDQUE3Qzs7QUFFQXBVLHdCQUFRbEksU0FBUixDQUFrQjA2QixpQkFBbEIsR0FBc0MsVUFBVUMsUUFBVixFQUFvQjtBQUN0RCx3QkFBSXpHLFdBQVd5RyxTQUFTM2UsU0FBeEI7QUFDQSx3QkFBSTRlLFVBQVVELFNBQVNyQyxvQkFBdkI7QUFDQSx3QkFBSWptQixTQUFTc29CLFNBQVNwQyxrQkFBdEI7QUFDQSx3QkFBSTdqQixVQUFVaW1CLFNBQVNuQyxTQUF2QjtBQUNBLHdCQUFJamUsV0FBV29nQixTQUFTTCxXQUFULENBQXFCLENBQXJCLENBQWY7QUFDQSx3QkFBSS9mLGFBQWEvVSxTQUFqQixFQUE0QitVLFdBQVc0ZCxpQkFBWDtBQUM1Qix5QkFBSzZCLGFBQUwsQ0FBbUJZLE9BQW5CLEVBQTRCdm9CLE1BQTVCLEVBQW9DcUMsT0FBcEMsRUFBNkM2RixRQUE3QyxFQUF1RCxJQUF2RDtBQUNILGlCQVJEOztBQVVBclMsd0JBQVFsSSxTQUFSLENBQWtCNjZCLGtCQUFsQixHQUF1QyxVQUFVRixRQUFWLEVBQW9CbjZCLEtBQXBCLEVBQTJCO0FBQzlELHdCQUFJbzZCLFVBQVVELFNBQVNILHFCQUFULENBQStCaDZCLEtBQS9CLENBQWQ7QUFDQSx3QkFBSTZSLFNBQVNzb0IsU0FBU0YsbUJBQVQsQ0FBNkJqNkIsS0FBN0IsQ0FBYjtBQUNBLHdCQUFJa1UsVUFBVWltQixTQUFTSixVQUFULENBQW9CLzVCLEtBQXBCLENBQWQ7QUFDQSx3QkFBSStaLFdBQVdvZ0IsU0FBU0wsV0FBVCxDQUFxQjk1QixLQUFyQixDQUFmO0FBQ0Esd0JBQUkrWixhQUFhL1UsU0FBakIsRUFBNEIrVSxXQUFXNGQsaUJBQVg7QUFDNUIseUJBQUs2QixhQUFMLENBQW1CWSxPQUFuQixFQUE0QnZvQixNQUE1QixFQUFvQ3FDLE9BQXBDLEVBQTZDNkYsUUFBN0MsRUFBdUQsSUFBdkQ7QUFDSCxpQkFQRDs7QUFTQXJTLHdCQUFRbEksU0FBUixDQUFrQmc2QixhQUFsQixHQUFrQyxVQUM5QlksT0FEOEIsRUFFOUJ2b0IsTUFGOEIsRUFHOUJxQyxPQUg4QixFQUk5QjZGLFFBSjhCLEVBSzlCdUssTUFMOEIsRUFNaEM7QUFDRSx3QkFBSXRrQixRQUFRLEtBQUt3ZixPQUFMLEVBQVo7O0FBRUEsd0JBQUl4ZixTQUFTLFFBQVEsQ0FBckIsRUFBd0I7QUFDcEJBLGdDQUFRLENBQVI7QUFDQSw2QkFBS3k1QixVQUFMLENBQWdCLENBQWhCO0FBQ0g7O0FBRUQsd0JBQUl6NUIsVUFBVSxDQUFkLEVBQWlCO0FBQ2IsNkJBQUtnNEIsU0FBTCxHQUFpQjlqQixPQUFqQjtBQUNBLDZCQUFLK2pCLFVBQUwsR0FBa0JsZSxRQUFsQjtBQUNBLDRCQUFJLE9BQU9xZ0IsT0FBUCxLQUFtQixVQUF2QixFQUFtQztBQUMvQixpQ0FBS3RDLG9CQUFMLEdBQ0l4VCxXQUFXLElBQVgsR0FBa0I4VixPQUFsQixHQUE0QjloQixLQUFLaU0sVUFBTCxDQUFnQkQsTUFBaEIsRUFBd0I4VixPQUF4QixDQURoQztBQUVIO0FBQ0QsNEJBQUksT0FBT3ZvQixNQUFQLEtBQWtCLFVBQXRCLEVBQWtDO0FBQzlCLGlDQUFLa21CLGtCQUFMLEdBQ0l6VCxXQUFXLElBQVgsR0FBa0J6UyxNQUFsQixHQUEyQnlHLEtBQUtpTSxVQUFMLENBQWdCRCxNQUFoQixFQUF3QnpTLE1BQXhCLENBRC9CO0FBRUg7QUFDSixxQkFYRCxNQVdPO0FBQ0gsNEJBQUl5QixPQUFPdFQsUUFBUSxDQUFSLEdBQVksQ0FBdkI7QUFDQSw2QkFBS3NULE9BQU8sQ0FBWixJQUFpQlksT0FBakI7QUFDQSw2QkFBS1osT0FBTyxDQUFaLElBQWlCeUcsUUFBakI7QUFDQSw0QkFBSSxPQUFPcWdCLE9BQVAsS0FBbUIsVUFBdkIsRUFBbUM7QUFDL0IsaUNBQUs5bUIsT0FBTyxDQUFaLElBQ0lnUixXQUFXLElBQVgsR0FBa0I4VixPQUFsQixHQUE0QjloQixLQUFLaU0sVUFBTCxDQUFnQkQsTUFBaEIsRUFBd0I4VixPQUF4QixDQURoQztBQUVIO0FBQ0QsNEJBQUksT0FBT3ZvQixNQUFQLEtBQWtCLFVBQXRCLEVBQWtDO0FBQzlCLGlDQUFLeUIsT0FBTyxDQUFaLElBQ0lnUixXQUFXLElBQVgsR0FBa0J6UyxNQUFsQixHQUEyQnlHLEtBQUtpTSxVQUFMLENBQWdCRCxNQUFoQixFQUF3QnpTLE1BQXhCLENBRC9CO0FBRUg7QUFDSjtBQUNELHlCQUFLNG5CLFVBQUwsQ0FBZ0J6NUIsUUFBUSxDQUF4QjtBQUNBLDJCQUFPQSxLQUFQO0FBQ0gsaUJBeENEOztBQTBDQTBILHdCQUFRbEksU0FBUixDQUFrQm0wQixNQUFsQixHQUEyQixVQUFVMkcsU0FBVixFQUFxQi8wQixHQUFyQixFQUEwQjtBQUNqRCx5QkFBS2kwQixhQUFMLENBQW1CeDBCLFNBQW5CLEVBQThCQSxTQUE5QixFQUF5Q08sR0FBekMsRUFBOEMrMEIsU0FBOUMsRUFBeUQsSUFBekQ7QUFDSCxpQkFGRDs7QUFJQTV5Qix3QkFBUWxJLFNBQVIsQ0FBa0JpYyxnQkFBbEIsR0FBcUMsVUFBUzdYLEtBQVQsRUFBZ0IyMkIsVUFBaEIsRUFBNEI7QUFDN0Qsd0JBQUssQ0FBQyxLQUFLL2UsU0FBTCxHQUFpQixTQUFsQixNQUFpQyxDQUF0QyxFQUEwQztBQUMxQyx3QkFBSTVYLFVBQVUsSUFBZCxFQUNJLE9BQU8sS0FBSzR2QixlQUFMLENBQXFCZ0UseUJBQXJCLEVBQWdELEtBQWhELENBQVA7QUFDSix3QkFBSXhiLGVBQWVwQixvQkFBb0JoWCxLQUFwQixFQUEyQixJQUEzQixDQUFuQjtBQUNBLHdCQUFJLEVBQUVvWSx3QkFBd0J0VSxPQUExQixDQUFKLEVBQXdDLE9BQU8sS0FBS29yQixRQUFMLENBQWNsdkIsS0FBZCxDQUFQOztBQUV4Qyx3QkFBSTIyQixVQUFKLEVBQWdCLEtBQUszZSxjQUFMLENBQW9CSSxZQUFwQixFQUFrQyxDQUFsQzs7QUFFaEIsd0JBQUk5SCxVQUFVOEgsYUFBYUMsT0FBYixFQUFkOztBQUVBLHdCQUFJL0gsWUFBWSxJQUFoQixFQUFzQjtBQUNsQiw2QkFBSytHLE9BQUwsQ0FBYXVjLHlCQUFiO0FBQ0E7QUFDSDs7QUFFRCx3QkFBSTlELFdBQVd4ZixRQUFRc0gsU0FBdkI7QUFDQSx3QkFBSyxDQUFDa1ksV0FBVyxRQUFaLE1BQTBCLENBQS9CLEVBQW1DO0FBQy9CLDRCQUFJbGUsTUFBTSxLQUFLZ0ssT0FBTCxFQUFWO0FBQ0EsNEJBQUloSyxNQUFNLENBQVYsRUFBYXRCLFFBQVFnbUIsaUJBQVIsQ0FBMEIsSUFBMUI7QUFDYiw2QkFBSyxJQUFJcjdCLElBQUksQ0FBYixFQUFnQkEsSUFBSTJXLEdBQXBCLEVBQXlCLEVBQUUzVyxDQUEzQixFQUE4QjtBQUMxQnFWLG9DQUFRbW1CLGtCQUFSLENBQTJCLElBQTNCLEVBQWlDeDdCLENBQWpDO0FBQ0g7QUFDRCw2QkFBSzg2QixhQUFMO0FBQ0EsNkJBQUtGLFVBQUwsQ0FBZ0IsQ0FBaEI7QUFDQSw2QkFBS2UsWUFBTCxDQUFrQnRtQixPQUFsQjtBQUNILHFCQVRELE1BU08sSUFBSyxDQUFDd2YsV0FBVyxRQUFaLE1BQTBCLENBQS9CLEVBQW1DO0FBQ3RDLDZCQUFLWixRQUFMLENBQWM1ZSxRQUFRMlosTUFBUixFQUFkO0FBQ0gscUJBRk0sTUFFQSxJQUFLLENBQUM2RixXQUFXLFFBQVosTUFBMEIsQ0FBL0IsRUFBbUM7QUFDdEMsNkJBQUt6WSxPQUFMLENBQWEvRyxRQUFRd1osT0FBUixFQUFiO0FBQ0gscUJBRk0sTUFFQTtBQUNILDRCQUFJN0osU0FBUyxJQUFJaUwsaUJBQUosQ0FBc0IsNEJBQXRCLENBQWI7QUFDQTVhLGdDQUFRZ00saUJBQVIsQ0FBMEIyRCxNQUExQjtBQUNBLDZCQUFLNUksT0FBTCxDQUFhNEksTUFBYjtBQUNIO0FBQ0osaUJBbkNEOztBQXFDQW5jLHdCQUFRbEksU0FBUixDQUFrQmcwQixlQUFsQixHQUNBLFVBQVMzUCxNQUFULEVBQWlCNFcsV0FBakIsRUFBOEJDLHNCQUE5QixFQUFzRDtBQUNsRCx3QkFBSWhaLFFBQVFwSixLQUFLcWlCLGlCQUFMLENBQXVCOVcsTUFBdkIsQ0FBWjtBQUNBLHdCQUFJK1csV0FBV2xaLFVBQVVtQyxNQUF6QjtBQUNBLHdCQUFJLENBQUMrVyxRQUFELElBQWEsQ0FBQ0Ysc0JBQWQsSUFBd0M3ZixNQUFNcUksUUFBTixFQUE1QyxFQUE4RDtBQUMxRCw0QkFBSXBSLFVBQVUsOENBQ1Z3RyxLQUFLaUYsV0FBTCxDQUFpQnNHLE1BQWpCLENBREo7QUFFQSw2QkFBS3ZGLEtBQUwsQ0FBV3hNLE9BQVgsRUFBb0IsSUFBcEI7QUFDSDtBQUNELHlCQUFLb08saUJBQUwsQ0FBdUJ3QixLQUF2QixFQUE4QitZLGNBQWNHLFFBQWQsR0FBeUIsS0FBdkQ7QUFDQSx5QkFBSzNmLE9BQUwsQ0FBYTRJLE1BQWI7QUFDSCxpQkFYRDs7QUFhQW5jLHdCQUFRbEksU0FBUixDQUFrQjA0QixvQkFBbEIsR0FBeUMsVUFBVXZRLFFBQVYsRUFBb0I7QUFDekQsd0JBQUlBLGFBQWFoTixRQUFqQixFQUEyQjtBQUMzQix3QkFBSXpHLFVBQVUsSUFBZDtBQUNBLHlCQUFLMFEsa0JBQUw7QUFDQSx5QkFBS3pELFlBQUw7QUFDQSx3QkFBSXNaLGNBQWMsSUFBbEI7QUFDQSx3QkFBSXBqQixJQUFJLEtBQUtpUSxRQUFMLENBQWNLLFFBQWQsRUFBd0IsVUFBUy9qQixLQUFULEVBQWdCO0FBQzVDc1EsZ0NBQVF1SCxnQkFBUixDQUF5QjdYLEtBQXpCO0FBQ0gscUJBRk8sRUFFTCxVQUFVaWdCLE1BQVYsRUFBa0I7QUFDakIzUCxnQ0FBUXNmLGVBQVIsQ0FBd0IzUCxNQUF4QixFQUFnQzRXLFdBQWhDO0FBQ0gscUJBSk8sQ0FBUjtBQUtBQSxrQ0FBYyxLQUFkO0FBQ0EseUJBQUtyWixXQUFMOztBQUVBLHdCQUFJL0osTUFBTXJTLFNBQVYsRUFBcUI7QUFDakJrUCxnQ0FBUXNmLGVBQVIsQ0FBd0JuYyxDQUF4QixFQUEyQixJQUEzQjtBQUNIO0FBQ0osaUJBakJEOztBQW1CQTNQLHdCQUFRbEksU0FBUixDQUFrQnE3Qix5QkFBbEIsR0FBOEMsVUFDMUNqVCxPQUQwQyxFQUNqQzdOLFFBRGlDLEVBQ3ZCblcsS0FEdUIsRUFDaEJzUSxPQURnQixFQUU1QztBQUNFLHdCQUFJd2YsV0FBV3hmLFFBQVFzSCxTQUF2QjtBQUNBLHdCQUFLLENBQUNrWSxXQUFXLEtBQVosTUFBdUIsQ0FBNUIsRUFBZ0M7QUFDaEN4Ziw0QkFBUWlOLFlBQVI7QUFDQSx3QkFBSTJaLENBQUo7QUFDQSx3QkFBSS9nQixhQUFhNmQsS0FBakIsRUFBd0I7QUFDcEIsNEJBQUksQ0FBQ2gwQixLQUFELElBQVUsT0FBT0EsTUFBTTdFLE1BQWIsS0FBd0IsUUFBdEMsRUFBZ0Q7QUFDNUMrN0IsZ0NBQUk3YyxRQUFKO0FBQ0E2Yyw4QkFBRTM5QixDQUFGLEdBQU0sSUFBSWdWLFNBQUosQ0FBYyxtQ0FDSW1HLEtBQUtpRixXQUFMLENBQWlCM1osS0FBakIsQ0FEbEIsQ0FBTjtBQUVILHlCQUpELE1BSU87QUFDSGszQixnQ0FBSTljLFNBQVM0SixPQUFULEVBQWtCdm9CLEtBQWxCLENBQXdCLEtBQUt5YyxXQUFMLEVBQXhCLEVBQTRDbFksS0FBNUMsQ0FBSjtBQUNIO0FBQ0oscUJBUkQsTUFRTztBQUNIazNCLDRCQUFJOWMsU0FBUzRKLE9BQVQsRUFBa0Jqb0IsSUFBbEIsQ0FBdUJvYSxRQUF2QixFQUFpQ25XLEtBQWpDLENBQUo7QUFDSDtBQUNELHdCQUFJcWlCLGlCQUFpQi9SLFFBQVFrTixXQUFSLEVBQXJCO0FBQ0FzUywrQkFBV3hmLFFBQVFzSCxTQUFuQjtBQUNBLHdCQUFLLENBQUNrWSxXQUFXLEtBQVosTUFBdUIsQ0FBNUIsRUFBZ0M7O0FBRWhDLHdCQUFJb0gsTUFBTXhhLFdBQVYsRUFBdUI7QUFDbkJwTSxnQ0FBUStHLE9BQVIsQ0FBZ0JyWCxLQUFoQjtBQUNILHFCQUZELE1BRU8sSUFBSWszQixNQUFNN2MsUUFBVixFQUFvQjtBQUN2Qi9KLGdDQUFRc2YsZUFBUixDQUF3QnNILEVBQUUzOUIsQ0FBMUIsRUFBNkIsS0FBN0I7QUFDSCxxQkFGTSxNQUVBO0FBQ0gwZCw4QkFBTThOLHFCQUFOLENBQTRCbVMsQ0FBNUIsRUFBK0I3VSxjQUEvQixFQUErQyxFQUEvQyxFQUFvRC9SLE9BQXBELEVBQTZELElBQTdEO0FBQ0FBLGdDQUFRdUgsZ0JBQVIsQ0FBeUJxZixDQUF6QjtBQUNIO0FBQ0osaUJBOUJEOztBQWdDQXB6Qix3QkFBUWxJLFNBQVIsQ0FBa0J5YyxPQUFsQixHQUE0QixZQUFXO0FBQ25DLHdCQUFJbEUsTUFBTSxJQUFWO0FBQ0EsMkJBQU9BLElBQUkyRyxZQUFKLEVBQVA7QUFBMkIzRyw4QkFBTUEsSUFBSTRHLFNBQUosRUFBTjtBQUEzQixxQkFDQSxPQUFPNUcsR0FBUDtBQUNILGlCQUpEOztBQU1BclEsd0JBQVFsSSxTQUFSLENBQWtCbWYsU0FBbEIsR0FBOEIsWUFBVztBQUNyQywyQkFBTyxLQUFLb1osa0JBQVo7QUFDSCxpQkFGRDs7QUFJQXJ3Qix3QkFBUWxJLFNBQVIsQ0FBa0JnN0IsWUFBbEIsR0FBaUMsVUFBU3RtQixPQUFULEVBQWtCO0FBQy9DLHlCQUFLNmpCLGtCQUFMLEdBQTBCN2pCLE9BQTFCO0FBQ0gsaUJBRkQ7O0FBSUF4TSx3QkFBUWxJLFNBQVIsQ0FBa0J1N0IsY0FBbEIsR0FBbUMsVUFBUzdtQixPQUFULEVBQWtCMFQsT0FBbEIsRUFBMkI3TixRQUEzQixFQUFxQ25XLEtBQXJDLEVBQTRDO0FBQzNFLHdCQUFJbzNCLFlBQVk5bUIsbUJBQW1CeE0sT0FBbkM7QUFDQSx3QkFBSWdzQixXQUFXLEtBQUtsWSxTQUFwQjtBQUNBLHdCQUFJeWYsa0JBQW1CLENBQUN2SCxXQUFXLFNBQVosTUFBMkIsQ0FBbEQ7QUFDQSx3QkFBSyxDQUFDQSxXQUFXLEtBQVosTUFBdUIsQ0FBNUIsRUFBZ0M7QUFDNUIsNEJBQUlzSCxTQUFKLEVBQWU5bUIsUUFBUW1NLHVCQUFSOztBQUVmLDRCQUFJdEcsb0JBQW9CMFcseUJBQXBCLElBQ0ExVyxTQUFTNlcsZ0JBQVQsRUFESixFQUNpQztBQUM3QjdXLHFDQUFTNFcsYUFBVCxHQUF5QnpjLE9BQXpCO0FBQ0EsZ0NBQUk4SixTQUFTNEosT0FBVCxFQUFrQmpvQixJQUFsQixDQUF1Qm9hLFFBQXZCLEVBQWlDblcsS0FBakMsTUFBNENxYSxRQUFoRCxFQUEwRDtBQUN0RC9KLHdDQUFRK0csT0FBUixDQUFnQmdELFNBQVM5Z0IsQ0FBekI7QUFDSDtBQUNKLHlCQU5ELE1BTU8sSUFBSXlxQixZQUFZNlAsY0FBaEIsRUFBZ0M7QUFDbkN2akIsb0NBQVE0ZSxRQUFSLENBQWlCMkUsZUFBZTkzQixJQUFmLENBQW9Cb2EsUUFBcEIsQ0FBakI7QUFDSCx5QkFGTSxNQUVBLElBQUlBLG9CQUFvQjJYLFNBQXhCLEVBQW1DO0FBQ3RDM1gscUNBQVNnWixpQkFBVCxDQUEyQjdlLE9BQTNCO0FBQ0gseUJBRk0sTUFFQSxJQUFJOG1CLGFBQWE5bUIsbUJBQW1CNEosWUFBcEMsRUFBa0Q7QUFDckQ1SixvQ0FBUW1MLE9BQVI7QUFDSCx5QkFGTSxNQUVBO0FBQ0h0RixxQ0FBU3FFLE1BQVQ7QUFDSDtBQUNKLHFCQWxCRCxNQWtCTyxJQUFJLE9BQU93SixPQUFQLEtBQW1CLFVBQXZCLEVBQW1DO0FBQ3RDLDRCQUFJLENBQUNvVCxTQUFMLEVBQWdCO0FBQ1pwVCxvQ0FBUWpvQixJQUFSLENBQWFvYSxRQUFiLEVBQXVCblcsS0FBdkIsRUFBOEJzUSxPQUE5QjtBQUNILHlCQUZELE1BRU87QUFDSCxnQ0FBSSttQixlQUFKLEVBQXFCL21CLFFBQVE4Z0IsbUJBQVI7QUFDckIsaUNBQUs2Rix5QkFBTCxDQUErQmpULE9BQS9CLEVBQXdDN04sUUFBeEMsRUFBa0RuVyxLQUFsRCxFQUF5RHNRLE9BQXpEO0FBQ0g7QUFDSixxQkFQTSxNQU9BLElBQUk2RixvQkFBb0IyWCxTQUF4QixFQUFtQztBQUN0Qyw0QkFBSSxDQUFDM1gsU0FBUzZZLFdBQVQsRUFBTCxFQUE2QjtBQUN6QixnQ0FBSyxDQUFDYyxXQUFXLFFBQVosTUFBMEIsQ0FBL0IsRUFBbUM7QUFDL0IzWix5Q0FBU3FaLGlCQUFULENBQTJCeHZCLEtBQTNCLEVBQWtDc1EsT0FBbEM7QUFDSCw2QkFGRCxNQUVPO0FBQ0g2Rix5Q0FBU3VaLGdCQUFULENBQTBCMXZCLEtBQTFCLEVBQWlDc1EsT0FBakM7QUFDSDtBQUNKO0FBQ0oscUJBUk0sTUFRQSxJQUFJOG1CLFNBQUosRUFBZTtBQUNsQiw0QkFBSUMsZUFBSixFQUFxQi9tQixRQUFROGdCLG1CQUFSO0FBQ3JCLDRCQUFLLENBQUN0QixXQUFXLFFBQVosTUFBMEIsQ0FBL0IsRUFBbUM7QUFDL0J4ZixvQ0FBUTRlLFFBQVIsQ0FBaUJsdkIsS0FBakI7QUFDSCx5QkFGRCxNQUVPO0FBQ0hzUSxvQ0FBUStHLE9BQVIsQ0FBZ0JyWCxLQUFoQjtBQUNIO0FBQ0o7QUFDSixpQkE3Q0Q7O0FBK0NBOEQsd0JBQVFsSSxTQUFSLENBQWtCKzVCLHNDQUFsQixHQUEyRCxVQUFTcFgsR0FBVCxFQUFjO0FBQ3JFLHdCQUFJeUYsVUFBVXpGLElBQUl5RixPQUFsQjtBQUNBLHdCQUFJMVQsVUFBVWlPLElBQUlqTyxPQUFsQjtBQUNBLHdCQUFJNkYsV0FBV29JLElBQUlwSSxRQUFuQjtBQUNBLHdCQUFJblcsUUFBUXVlLElBQUl2ZSxLQUFoQjtBQUNBLHdCQUFJLE9BQU9na0IsT0FBUCxLQUFtQixVQUF2QixFQUFtQztBQUMvQiw0QkFBSSxFQUFFMVQsbUJBQW1CeE0sT0FBckIsQ0FBSixFQUFtQztBQUMvQmtnQixvQ0FBUWpvQixJQUFSLENBQWFvYSxRQUFiLEVBQXVCblcsS0FBdkIsRUFBOEJzUSxPQUE5QjtBQUNILHlCQUZELE1BRU87QUFDSCxpQ0FBSzJtQix5QkFBTCxDQUErQmpULE9BQS9CLEVBQXdDN04sUUFBeEMsRUFBa0RuVyxLQUFsRCxFQUF5RHNRLE9BQXpEO0FBQ0g7QUFDSixxQkFORCxNQU1PLElBQUlBLG1CQUFtQnhNLE9BQXZCLEVBQWdDO0FBQ25Dd00sZ0NBQVErRyxPQUFSLENBQWdCclgsS0FBaEI7QUFDSDtBQUNKLGlCQWREOztBQWdCQThELHdCQUFRbEksU0FBUixDQUFrQjg1QixpQkFBbEIsR0FBc0MsVUFBU25YLEdBQVQsRUFBYztBQUNoRCx5QkFBSzRZLGNBQUwsQ0FBb0I1WSxJQUFJak8sT0FBeEIsRUFBaUNpTyxJQUFJeUYsT0FBckMsRUFBOEN6RixJQUFJcEksUUFBbEQsRUFBNERvSSxJQUFJdmUsS0FBaEU7QUFDSCxpQkFGRDs7QUFJQThELHdCQUFRbEksU0FBUixDQUFrQjA3QixlQUFsQixHQUFvQyxVQUFTdFQsT0FBVCxFQUFrQmhrQixLQUFsQixFQUF5Qjh2QixRQUF6QixFQUFtQztBQUNuRSx3QkFBSXhmLFVBQVUsS0FBSzhqQixTQUFuQjtBQUNBLHdCQUFJamUsV0FBVyxLQUFLK2YsV0FBTCxDQUFpQixDQUFqQixDQUFmO0FBQ0EseUJBQUs5QixTQUFMLEdBQWlCaHpCLFNBQWpCO0FBQ0EseUJBQUtpekIsVUFBTCxHQUFrQmp6QixTQUFsQjtBQUNBLHlCQUFLKzFCLGNBQUwsQ0FBb0I3bUIsT0FBcEIsRUFBNkIwVCxPQUE3QixFQUFzQzdOLFFBQXRDLEVBQWdEblcsS0FBaEQ7QUFDSCxpQkFORDs7QUFRQThELHdCQUFRbEksU0FBUixDQUFrQjI3Qix5QkFBbEIsR0FBOEMsVUFBU243QixLQUFULEVBQWdCO0FBQzFELHdCQUFJc1QsT0FBT3RULFFBQVEsQ0FBUixHQUFZLENBQXZCO0FBQ0EseUJBQUtzVCxPQUFPLENBQVosSUFDQSxLQUFLQSxPQUFPLENBQVosSUFDQSxLQUFLQSxPQUFPLENBQVosSUFDQSxLQUFLQSxPQUFPLENBQVosSUFBaUJ0TyxTQUhqQjtBQUlILGlCQU5EOztBQVFBMEMsd0JBQVFsSSxTQUFSLENBQWtCc3pCLFFBQWxCLEdBQTZCLFVBQVVsdkIsS0FBVixFQUFpQjtBQUMxQyx3QkFBSTh2QixXQUFXLEtBQUtsWSxTQUFwQjtBQUNBLHdCQUFLLENBQUNrWSxXQUFXLFNBQVosTUFBMkIsRUFBaEMsRUFBcUM7QUFDckMsd0JBQUk5dkIsVUFBVSxJQUFkLEVBQW9CO0FBQ2hCLDRCQUFJb3BCLE1BQU13Syx5QkFBVjtBQUNBLDZCQUFLdFgsaUJBQUwsQ0FBdUI4TSxHQUF2QjtBQUNBLCtCQUFPLEtBQUsvUixPQUFMLENBQWErUixHQUFiLENBQVA7QUFDSDtBQUNELHlCQUFLZ00sYUFBTDtBQUNBLHlCQUFLakIsa0JBQUwsR0FBMEJuMEIsS0FBMUI7O0FBRUEsd0JBQUksQ0FBQzh2QixXQUFXLEtBQVosSUFBcUIsQ0FBekIsRUFBNEI7QUFDeEIsNEJBQUssQ0FBQ0EsV0FBVyxTQUFaLE1BQTJCLENBQWhDLEVBQW9DO0FBQ2hDLGlDQUFLblosZUFBTDtBQUNILHlCQUZELE1BRU87QUFDSDJELGtDQUFNNUQsY0FBTixDQUFxQixJQUFyQjtBQUNIO0FBQ0o7QUFDSixpQkFsQkQ7O0FBb0JBNVMsd0JBQVFsSSxTQUFSLENBQWtCeWIsT0FBbEIsR0FBNEIsVUFBVTRJLE1BQVYsRUFBa0I7QUFDMUMsd0JBQUk2UCxXQUFXLEtBQUtsWSxTQUFwQjtBQUNBLHdCQUFLLENBQUNrWSxXQUFXLFNBQVosTUFBMkIsRUFBaEMsRUFBcUM7QUFDckMseUJBQUtnRyxZQUFMO0FBQ0EseUJBQUs1QixvQkFBTCxHQUE0QmpVLE1BQTVCOztBQUVBLHdCQUFJLEtBQUsrVixRQUFMLEVBQUosRUFBcUI7QUFDakIsK0JBQU8xYixNQUFNMUUsVUFBTixDQUFpQnFLLE1BQWpCLEVBQXlCdkwsS0FBS21CLE1BQTlCLENBQVA7QUFDSDs7QUFFRCx3QkFBSSxDQUFDaWEsV0FBVyxLQUFaLElBQXFCLENBQXpCLEVBQTRCO0FBQ3hCeFYsOEJBQU01RCxjQUFOLENBQXFCLElBQXJCO0FBQ0gscUJBRkQsTUFFTztBQUNILDZCQUFLK0ksK0JBQUw7QUFDSDtBQUNKLGlCQWZEOztBQWlCQTNiLHdCQUFRbEksU0FBUixDQUFrQjQ3QixnQkFBbEIsR0FBcUMsVUFBVTVsQixHQUFWLEVBQWU1UixLQUFmLEVBQXNCO0FBQ3ZELHlCQUFLLElBQUkvRSxJQUFJLENBQWIsRUFBZ0JBLElBQUkyVyxHQUFwQixFQUF5QjNXLEdBQXpCLEVBQThCO0FBQzFCLDRCQUFJK29CLFVBQVUsS0FBS29TLHFCQUFMLENBQTJCbjdCLENBQTNCLENBQWQ7QUFDQSw0QkFBSXFWLFVBQVUsS0FBSzZsQixVQUFMLENBQWdCbDdCLENBQWhCLENBQWQ7QUFDQSw0QkFBSWtiLFdBQVcsS0FBSytmLFdBQUwsQ0FBaUJqN0IsQ0FBakIsQ0FBZjtBQUNBLDZCQUFLczhCLHlCQUFMLENBQStCdDhCLENBQS9CO0FBQ0EsNkJBQUtrOEIsY0FBTCxDQUFvQjdtQixPQUFwQixFQUE2QjBULE9BQTdCLEVBQXNDN04sUUFBdEMsRUFBZ0RuVyxLQUFoRDtBQUNIO0FBQ0osaUJBUkQ7O0FBVUE4RCx3QkFBUWxJLFNBQVIsQ0FBa0I2N0IsZUFBbEIsR0FBb0MsVUFBVTdsQixHQUFWLEVBQWVxTyxNQUFmLEVBQXVCO0FBQ3ZELHlCQUFLLElBQUlobEIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJMlcsR0FBcEIsRUFBeUIzVyxHQUF6QixFQUE4QjtBQUMxQiw0QkFBSStvQixVQUFVLEtBQUtxUyxtQkFBTCxDQUF5QnA3QixDQUF6QixDQUFkO0FBQ0EsNEJBQUlxVixVQUFVLEtBQUs2bEIsVUFBTCxDQUFnQmw3QixDQUFoQixDQUFkO0FBQ0EsNEJBQUlrYixXQUFXLEtBQUsrZixXQUFMLENBQWlCajdCLENBQWpCLENBQWY7QUFDQSw2QkFBS3M4Qix5QkFBTCxDQUErQnQ4QixDQUEvQjtBQUNBLDZCQUFLazhCLGNBQUwsQ0FBb0I3bUIsT0FBcEIsRUFBNkIwVCxPQUE3QixFQUFzQzdOLFFBQXRDLEVBQWdEOEosTUFBaEQ7QUFDSDtBQUNKLGlCQVJEOztBQVVBbmMsd0JBQVFsSSxTQUFSLENBQWtCK2EsZUFBbEIsR0FBb0MsWUFBWTtBQUM1Qyx3QkFBSW1aLFdBQVcsS0FBS2xZLFNBQXBCO0FBQ0Esd0JBQUloRyxNQUFPa2UsV0FBVyxLQUF0Qjs7QUFFQSx3QkFBSWxlLE1BQU0sQ0FBVixFQUFhO0FBQ1QsNEJBQUssQ0FBQ2tlLFdBQVcsUUFBWixNQUEwQixDQUEvQixFQUFtQztBQUMvQixnQ0FBSTdQLFNBQVMsS0FBS2lVLG9CQUFsQjtBQUNBLGlDQUFLb0QsZUFBTCxDQUFxQixLQUFLbkQsa0JBQTFCLEVBQThDbFUsTUFBOUMsRUFBc0Q2UCxRQUF0RDtBQUNBLGlDQUFLMkgsZUFBTCxDQUFxQjdsQixHQUFyQixFQUEwQnFPLE1BQTFCO0FBQ0gseUJBSkQsTUFJTztBQUNILGdDQUFJamdCLFFBQVEsS0FBS20wQixrQkFBakI7QUFDQSxpQ0FBS21ELGVBQUwsQ0FBcUIsS0FBS3BELG9CQUExQixFQUFnRGwwQixLQUFoRCxFQUF1RDh2QixRQUF2RDtBQUNBLGlDQUFLMEgsZ0JBQUwsQ0FBc0I1bEIsR0FBdEIsRUFBMkI1UixLQUEzQjtBQUNIO0FBQ0QsNkJBQUs2MUIsVUFBTCxDQUFnQixDQUFoQjtBQUNIO0FBQ0QseUJBQUsxUyxzQkFBTDtBQUNILGlCQWpCRDs7QUFtQkFyZix3QkFBUWxJLFNBQVIsQ0FBa0Jza0IsYUFBbEIsR0FBa0MsWUFBVztBQUN6Qyx3QkFBSTRQLFdBQVcsS0FBS2xZLFNBQXBCO0FBQ0Esd0JBQUssQ0FBQ2tZLFdBQVcsUUFBWixNQUEwQixDQUEvQixFQUFtQztBQUMvQiwrQkFBTyxLQUFLcUUsa0JBQVo7QUFDSCxxQkFGRCxNQUVPLElBQUssQ0FBQ3JFLFdBQVcsUUFBWixNQUEwQixDQUEvQixFQUFtQztBQUN0QywrQkFBTyxLQUFLb0Usb0JBQVo7QUFDSDtBQUNKLGlCQVBEOztBQVNBLHlCQUFTd0QsWUFBVCxDQUFzQnA3QixDQUF0QixFQUF5QjtBQUFDLHlCQUFLZ1UsT0FBTCxDQUFhdUgsZ0JBQWIsQ0FBOEJ2YixDQUE5QjtBQUFrQztBQUM1RCx5QkFBU3E3QixXQUFULENBQXFCcjdCLENBQXJCLEVBQXdCO0FBQUMseUJBQUtnVSxPQUFMLENBQWFzZixlQUFiLENBQTZCdHpCLENBQTdCLEVBQWdDLEtBQWhDO0FBQXdDOztBQUVqRXdILHdCQUFROHpCLEtBQVIsR0FBZ0I5ekIsUUFBUSt6QixPQUFSLEdBQWtCLFlBQVc7QUFDekM1Z0IsMEJBQU0wTyxVQUFOLENBQWlCLGVBQWpCLEVBQWtDLGFBQWxDO0FBQ0Esd0JBQUlyVixVQUFVLElBQUl4TSxPQUFKLENBQVlpVCxRQUFaLENBQWQ7QUFDQSwyQkFBTztBQUNIekcsaUNBQVNBLE9BRE47QUFFSDNELGlDQUFTK3FCLFlBRk47QUFHSHpwQixnQ0FBUTBwQjtBQUhMLHFCQUFQO0FBS0gsaUJBUkQ7O0FBVUFqakIscUJBQUttUSxpQkFBTCxDQUF1Qi9nQixPQUF2QixFQUN1QiwwQkFEdkIsRUFFdUI4dkIsdUJBRnZCOztBQUlBL2Ysd0JBQVEsVUFBUixFQUFvQi9QLE9BQXBCLEVBQTZCaVQsUUFBN0IsRUFBdUNDLG1CQUF2QyxFQUE0RG1ELFlBQTVELEVBQ0lsRCxLQURKO0FBRUFwRCx3QkFBUSxRQUFSLEVBQWtCL1AsT0FBbEIsRUFBMkJpVCxRQUEzQixFQUFxQ0MsbUJBQXJDLEVBQTBEQyxLQUExRDtBQUNBcEQsd0JBQVEsVUFBUixFQUFvQi9QLE9BQXBCLEVBQTZCb1csWUFBN0IsRUFBMkNDLFlBQTNDLEVBQXlEbEQsS0FBekQ7QUFDQXBELHdCQUFRLGtCQUFSLEVBQTRCL1AsT0FBNUI7QUFDQStQLHdCQUFRLDBCQUFSLEVBQW9DL1AsT0FBcEM7QUFDQStQLHdCQUFRLFFBQVIsRUFDSS9QLE9BREosRUFDYW9XLFlBRGIsRUFDMkJsRCxtQkFEM0IsRUFDZ0RELFFBRGhELEVBQzBEdUQsS0FEMUQsRUFDaUVrRSxTQURqRTtBQUVBMWEsd0JBQVFBLE9BQVIsR0FBa0JBLE9BQWxCO0FBQ0FBLHdCQUFRc08sT0FBUixHQUFrQixPQUFsQjtBQUNBeUIsd0JBQVEsVUFBUixFQUFvQi9QLE9BQXBCLEVBQTZCb1csWUFBN0IsRUFBMkNDLFlBQTNDLEVBQXlEbkQsbUJBQXpELEVBQThFRCxRQUE5RSxFQUF3RkUsS0FBeEY7QUFDQXBELHdCQUFRLGVBQVIsRUFBeUIvUCxPQUF6QjtBQUNBK1Asd0JBQVEsWUFBUixFQUFzQi9QLE9BQXRCLEVBQStCcVcsWUFBL0IsRUFBNkNuRCxtQkFBN0MsRUFBa0UrRyxhQUFsRSxFQUFpRmhILFFBQWpGLEVBQTJGRSxLQUEzRjtBQUNBcEQsd0JBQVEsYUFBUixFQUF1Qi9QLE9BQXZCLEVBQWdDaVQsUUFBaEMsRUFBMENFLEtBQTFDO0FBQ0FwRCx3QkFBUSxpQkFBUixFQUEyQi9QLE9BQTNCLEVBQW9DcVcsWUFBcEMsRUFBa0RwRCxRQUFsRCxFQUE0REMsbUJBQTVELEVBQWlGOFcsU0FBakYsRUFBNEY3VyxLQUE1RjtBQUNBcEQsd0JBQVEsY0FBUixFQUF3Qi9QLE9BQXhCO0FBQ0ErUCx3QkFBUSxnQkFBUixFQUEwQi9QLE9BQTFCLEVBQW1DaVQsUUFBbkM7QUFDQWxELHdCQUFRLFlBQVIsRUFBc0IvUCxPQUF0QixFQUErQm9XLFlBQS9CLEVBQTZDbEQsbUJBQTdDLEVBQWtFbUQsWUFBbEU7QUFDQXRHLHdCQUFRLFdBQVIsRUFBcUIvUCxPQUFyQixFQUE4QmlULFFBQTlCLEVBQXdDQyxtQkFBeEMsRUFBNkRtRCxZQUE3RDtBQUNBdEcsd0JBQVEsYUFBUixFQUF1Qi9QLE9BQXZCLEVBQWdDb1csWUFBaEMsRUFBOENDLFlBQTlDLEVBQTREbkQsbUJBQTVELEVBQWlGRCxRQUFqRixFQUEyRkUsS0FBM0Y7QUFDQXBELHdCQUFRLGFBQVIsRUFBdUIvUCxPQUF2QixFQUFnQ29XLFlBQWhDLEVBQThDakQsS0FBOUM7QUFDQXBELHdCQUFRLFdBQVIsRUFBcUIvUCxPQUFyQixFQUE4Qm9XLFlBQTlCLEVBQTRDQyxZQUE1QztBQUNBdEcsd0JBQVEsYUFBUixFQUF1Qi9QLE9BQXZCLEVBQWdDaVQsUUFBaEM7QUFDQWxELHdCQUFRLFdBQVIsRUFBcUIvUCxPQUFyQixFQUE4QmlULFFBQTlCO0FBQ0FsRCx3QkFBUSxVQUFSLEVBQW9CL1AsT0FBcEI7O0FBRUk0USxxQkFBS29qQixnQkFBTCxDQUFzQmgwQixPQUF0QjtBQUNBNFEscUJBQUtvakIsZ0JBQUwsQ0FBc0JoMEIsUUFBUWxJLFNBQTlCO0FBQ0EseUJBQVNtOEIsU0FBVCxDQUFtQi8zQixLQUFuQixFQUEwQjtBQUN0Qix3QkFBSWc0QixJQUFJLElBQUlsMEIsT0FBSixDQUFZaVQsUUFBWixDQUFSO0FBQ0FpaEIsc0JBQUU5RCxvQkFBRixHQUF5QmwwQixLQUF6QjtBQUNBZzRCLHNCQUFFN0Qsa0JBQUYsR0FBdUJuMEIsS0FBdkI7QUFDQWc0QixzQkFBRTVELFNBQUYsR0FBY3AwQixLQUFkO0FBQ0FnNEIsc0JBQUUzRCxVQUFGLEdBQWVyMEIsS0FBZjtBQUNIO0FBQ0Q7QUFDQTtBQUNBKzNCLDBCQUFVLEVBQUNua0IsR0FBRyxDQUFKLEVBQVY7QUFDQW1rQiwwQkFBVSxFQUFDRSxHQUFHLENBQUosRUFBVjtBQUNBRiwwQkFBVSxFQUFDRyxHQUFHLENBQUosRUFBVjtBQUNBSCwwQkFBVSxDQUFWO0FBQ0FBLDBCQUFVLFlBQVUsQ0FBRSxDQUF0QjtBQUNBQSwwQkFBVTMyQixTQUFWO0FBQ0EyMkIsMEJBQVUsS0FBVjtBQUNBQSwwQkFBVSxJQUFJajBCLE9BQUosQ0FBWWlULFFBQVosQ0FBVjtBQUNBRSxzQkFBTTZRLFNBQU4sQ0FBZ0JuVCxNQUFNSixjQUF0QixFQUFzQ0csS0FBS3FULGFBQTNDO0FBQ0EsdUJBQU9qa0IsT0FBUDtBQUVILGFBcndCRDtBQXV3QkMsU0F6d0JtQixFQXl3QmxCLEVBQUMsWUFBVyxDQUFaLEVBQWMsV0FBVSxDQUF4QixFQUEwQixVQUFTLENBQW5DLEVBQXFDLGlCQUFnQixDQUFyRCxFQUF1RCxZQUFXLENBQWxFLEVBQW9FLGtCQUFpQixDQUFyRixFQUF1RixhQUFZLENBQW5HLEVBQXFHLG1CQUFrQixDQUF2SCxFQUF5SCxvQkFBbUIsRUFBNUksRUFBK0ksYUFBWSxFQUEzSixFQUE4SixZQUFXLEVBQXpLLEVBQTRLLFNBQVEsRUFBcEwsRUFBdUwsZUFBYyxFQUFyTSxFQUF3TSxhQUFZLEVBQXBOLEVBQXVOLG1CQUFrQixFQUF6TyxFQUE0TyxVQUFTLEVBQXJQLEVBQXdQLFlBQVcsRUFBblEsRUFBc1EsWUFBVyxFQUFqUixFQUFvUixjQUFhLEVBQWpTLEVBQW9TLGdCQUFlLEVBQW5ULEVBQXNULG1CQUFrQixFQUF4VSxFQUEyVSxrQkFBaUIsRUFBNVYsRUFBK1YsY0FBYSxFQUE1VyxFQUErVyxhQUFZLEVBQTNYLEVBQThYLGVBQWMsRUFBNVksRUFBK1ksZUFBYyxFQUE3WixFQUFnYSxhQUFZLEVBQTVhLEVBQSthLDRCQUEyQixFQUExYyxFQUE2YyxlQUFjLEVBQTNkLEVBQThkLGVBQWMsRUFBNWUsRUFBK2UsY0FBYSxFQUE1ZixFQUErZixVQUFTLEVBQXhnQixFQXp3QmtCLENBOXFGNHVCLEVBdTdHalAsSUFBRyxDQUFDLFVBQVMrUCxPQUFULEVBQWlCcGEsTUFBakIsRUFBd0JDLE9BQXhCLEVBQWdDO0FBQ25qQjs7QUFDQUQsbUJBQU9DLE9BQVAsR0FBaUIsVUFBU29LLE9BQVQsRUFBa0JpVCxRQUFsQixFQUE0QkMsbUJBQTVCLEVBQ2JtRCxZQURhLEVBQ0MyVCxTQURELEVBQ1k7QUFDN0Isb0JBQUlwWixPQUFPYixRQUFRLFFBQVIsQ0FBWDtBQUNBLG9CQUFJMU0sVUFBVXVOLEtBQUt2TixPQUFuQjs7QUFFQSx5QkFBU2d4QixpQkFBVCxDQUEyQi84QixHQUEzQixFQUFnQztBQUM1Qiw0QkFBT0EsR0FBUDtBQUNBLDZCQUFLLENBQUMsQ0FBTjtBQUFTLG1DQUFPLEVBQVA7QUFDVCw2QkFBSyxDQUFDLENBQU47QUFBUyxtQ0FBTyxFQUFQO0FBQ1QsNkJBQUssQ0FBQyxDQUFOO0FBQVMsbUNBQU8sSUFBSXlJLEdBQUosRUFBUDtBQUhUO0FBS0g7O0FBRUQseUJBQVNxVyxZQUFULENBQXNCelosTUFBdEIsRUFBOEI7QUFDMUIsd0JBQUk2UCxVQUFVLEtBQUtrZSxRQUFMLEdBQWdCLElBQUkxcUIsT0FBSixDQUFZaVQsUUFBWixDQUE5QjtBQUNBLHdCQUFJdFcsa0JBQWtCcUQsT0FBdEIsRUFBK0I7QUFDM0J3TSxnQ0FBUTBILGNBQVIsQ0FBdUJ2WCxNQUF2QixFQUErQixDQUEvQjtBQUNIO0FBQ0Q2UCw0QkFBUWlJLFlBQVIsQ0FBcUIsSUFBckI7QUFDQSx5QkFBSzJaLE9BQUwsR0FBZXp4QixNQUFmO0FBQ0EseUJBQUttYixPQUFMLEdBQWUsQ0FBZjtBQUNBLHlCQUFLeVcsY0FBTCxHQUFzQixDQUF0QjtBQUNBLHlCQUFLSixLQUFMLENBQVc3d0IsU0FBWCxFQUFzQixDQUFDLENBQXZCO0FBQ0g7QUFDRHNULHFCQUFLOFQsUUFBTCxDQUFjdE8sWUFBZCxFQUE0QjRULFNBQTVCOztBQUVBNVQsNkJBQWF0ZSxTQUFiLENBQXVCVCxNQUF2QixHQUFnQyxZQUFZO0FBQ3hDLDJCQUFPLEtBQUt5Z0IsT0FBWjtBQUNILGlCQUZEOztBQUlBMUIsNkJBQWF0ZSxTQUFiLENBQXVCMFUsT0FBdkIsR0FBaUMsWUFBWTtBQUN6QywyQkFBTyxLQUFLa2UsUUFBWjtBQUNILGlCQUZEOztBQUlBdFUsNkJBQWF0ZSxTQUFiLENBQXVCcTJCLEtBQXZCLEdBQStCLFNBQVMzZCxJQUFULENBQWM4QyxDQUFkLEVBQWlCZ2hCLG1CQUFqQixFQUFzQztBQUNqRSx3QkFBSTMzQixTQUFTdVcsb0JBQW9CLEtBQUtrYixPQUF6QixFQUFrQyxLQUFLMUQsUUFBdkMsQ0FBYjtBQUNBLHdCQUFJL3RCLGtCQUFrQnFELE9BQXRCLEVBQStCO0FBQzNCckQsaUNBQVNBLE9BQU80WCxPQUFQLEVBQVQ7QUFDQSw0QkFBSXlYLFdBQVdydkIsT0FBT21YLFNBQXRCO0FBQ0E7QUFDQSw2QkFBS3NhLE9BQUwsR0FBZXp4QixNQUFmOztBQUVBLDRCQUFLLENBQUNxdkIsV0FBVyxRQUFaLE1BQTBCLENBQS9CLEVBQW1DO0FBQy9CLGlDQUFLdEIsUUFBTCxDQUFjNEMsbUJBQWQ7QUFDQSxtQ0FBTzN3QixPQUFPaVgsS0FBUCxDQUNIcEQsSUFERyxFQUVILEtBQUsrQyxPQUZGLEVBR0hqVyxTQUhHLEVBSUgsSUFKRyxFQUtIZzNCLG1CQUxHLENBQVA7QUFPSCx5QkFURCxNQVNPLElBQUssQ0FBQ3RJLFdBQVcsUUFBWixNQUEwQixDQUEvQixFQUFtQztBQUN0Q3J2QixxQ0FBU0EsT0FBT3dwQixNQUFQLEVBQVQ7QUFDSCx5QkFGTSxNQUVBLElBQUssQ0FBQzZGLFdBQVcsUUFBWixNQUEwQixDQUEvQixFQUFtQztBQUN0QyxtQ0FBTyxLQUFLelksT0FBTCxDQUFhNVcsT0FBT3FwQixPQUFQLEVBQWIsQ0FBUDtBQUNILHlCQUZNLE1BRUE7QUFDSCxtQ0FBTyxLQUFLck8sT0FBTCxFQUFQO0FBQ0g7QUFDSjtBQUNEaGIsNkJBQVNpVSxLQUFLMmpCLE9BQUwsQ0FBYTUzQixNQUFiLENBQVQ7QUFDQSx3QkFBSUEsV0FBVyxJQUFmLEVBQXFCO0FBQ2pCLDRCQUFJMm9CLE1BQU1qUCxhQUNOLHNEQUFzRHpGLEtBQUtpRixXQUFMLENBQWlCbFosTUFBakIsQ0FEaEQsRUFDMEV3ZixNQUQxRSxFQUFWO0FBRUEsNkJBQUt1TyxRQUFMLENBQWNvQixlQUFkLENBQThCeEcsR0FBOUIsRUFBbUMsS0FBbkM7QUFDQTtBQUNIOztBQUVELHdCQUFJM29CLE9BQU90RixNQUFQLEtBQWtCLENBQXRCLEVBQXlCO0FBQ3JCLDRCQUFJaTlCLHdCQUF3QixDQUFDLENBQTdCLEVBQWdDO0FBQzVCLGlDQUFLRSxrQkFBTDtBQUNILHlCQUZELE1BR0s7QUFDRCxpQ0FBS2hHLFFBQUwsQ0FBYzZGLGtCQUFrQkMsbUJBQWxCLENBQWQ7QUFDSDtBQUNEO0FBQ0g7QUFDRCx5QkFBS0csUUFBTCxDQUFjOTNCLE1BQWQ7QUFDSCxpQkEzQ0Q7O0FBNkNBeVosNkJBQWF0ZSxTQUFiLENBQXVCMjhCLFFBQXZCLEdBQWtDLFVBQVM5M0IsTUFBVCxFQUFpQjtBQUMvQyx3QkFBSW1SLE1BQU0sS0FBSzRtQixlQUFMLENBQXFCLzNCLE9BQU90RixNQUE1QixDQUFWO0FBQ0EseUJBQUt5Z0IsT0FBTCxHQUFlaEssR0FBZjtBQUNBLHlCQUFLc2dCLE9BQUwsR0FBZSxLQUFLdUcsZ0JBQUwsS0FBMEIsSUFBSXY4QixLQUFKLENBQVUwVixHQUFWLENBQTFCLEdBQTJDLEtBQUtzZ0IsT0FBL0Q7QUFDQSx3QkFBSWx4QixTQUFTLEtBQUt3dEIsUUFBbEI7QUFDQSx3QkFBSWtLLGFBQWEsS0FBakI7QUFDQSx3QkFBSTVJLFdBQVcsSUFBZjtBQUNBLHlCQUFLLElBQUk3MEIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJMlcsR0FBcEIsRUFBeUIsRUFBRTNXLENBQTNCLEVBQThCO0FBQzFCLDRCQUFJbWQsZUFBZXBCLG9CQUFvQnZXLE9BQU94RixDQUFQLENBQXBCLEVBQStCK0YsTUFBL0IsQ0FBbkI7O0FBRUEsNEJBQUlvWCx3QkFBd0J0VSxPQUE1QixFQUFxQztBQUNqQ3NVLDJDQUFlQSxhQUFhQyxPQUFiLEVBQWY7QUFDQXlYLHVDQUFXMVgsYUFBYVIsU0FBeEI7QUFDSCx5QkFIRCxNQUdPO0FBQ0hrWSx1Q0FBVyxJQUFYO0FBQ0g7O0FBRUQsNEJBQUk0SSxVQUFKLEVBQWdCO0FBQ1osZ0NBQUk1SSxhQUFhLElBQWpCLEVBQXVCO0FBQ25CMVgsNkNBQWFvSCwyQkFBYjtBQUNIO0FBQ0oseUJBSkQsTUFJTyxJQUFJc1EsYUFBYSxJQUFqQixFQUF1QjtBQUMxQixnQ0FBSyxDQUFDQSxXQUFXLFFBQVosTUFBMEIsQ0FBL0IsRUFBbUM7QUFDL0IxWCw2Q0FBYTJYLE1BQWIsQ0FBb0IsSUFBcEIsRUFBMEI5MEIsQ0FBMUI7QUFDQSxxQ0FBS2kzQixPQUFMLENBQWFqM0IsQ0FBYixJQUFrQm1kLFlBQWxCO0FBQ0gsNkJBSEQsTUFHTyxJQUFLLENBQUMwWCxXQUFXLFFBQVosTUFBMEIsQ0FBL0IsRUFBbUM7QUFDdEM0SSw2Q0FBYSxLQUFLbEosaUJBQUwsQ0FBdUJwWCxhQUFhNlIsTUFBYixFQUF2QixFQUE4Q2h2QixDQUE5QyxDQUFiO0FBQ0gsNkJBRk0sTUFFQSxJQUFLLENBQUM2MEIsV0FBVyxRQUFaLE1BQTBCLENBQS9CLEVBQW1DO0FBQ3RDNEksNkNBQWEsS0FBS2hKLGdCQUFMLENBQXNCdFgsYUFBYTBSLE9BQWIsRUFBdEIsRUFBOEM3dUIsQ0FBOUMsQ0FBYjtBQUNILDZCQUZNLE1BRUE7QUFDSHk5Qiw2Q0FBYSxLQUFLdkosaUJBQUwsQ0FBdUJsMEIsQ0FBdkIsQ0FBYjtBQUNIO0FBQ0oseUJBWE0sTUFXQTtBQUNIeTlCLHlDQUFhLEtBQUtsSixpQkFBTCxDQUF1QnBYLFlBQXZCLEVBQXFDbmQsQ0FBckMsQ0FBYjtBQUNIO0FBQ0o7QUFDRCx3QkFBSSxDQUFDeTlCLFVBQUwsRUFBaUIxM0IsT0FBT293QixtQkFBUDtBQUNwQixpQkFyQ0Q7O0FBdUNBbFgsNkJBQWF0ZSxTQUFiLENBQXVCb3pCLFdBQXZCLEdBQXFDLFlBQVk7QUFDN0MsMkJBQU8sS0FBS2tELE9BQUwsS0FBaUIsSUFBeEI7QUFDSCxpQkFGRDs7QUFJQWhZLDZCQUFhdGUsU0FBYixDQUF1QjAyQixRQUF2QixHQUFrQyxVQUFVdHlCLEtBQVYsRUFBaUI7QUFDL0MseUJBQUtreUIsT0FBTCxHQUFlLElBQWY7QUFDQSx5QkFBSzFELFFBQUwsQ0FBY1UsUUFBZCxDQUF1Qmx2QixLQUF2QjtBQUNILGlCQUhEOztBQUtBa2EsNkJBQWF0ZSxTQUFiLENBQXVCNmYsT0FBdkIsR0FBaUMsWUFBVztBQUN4Qyx3QkFBSSxLQUFLdVQsV0FBTCxNQUFzQixDQUFDLEtBQUtSLFFBQUwsQ0FBYzVULGNBQWQsRUFBM0IsRUFBMkQ7QUFDM0QseUJBQUtzWCxPQUFMLEdBQWUsSUFBZjtBQUNBLHlCQUFLMUQsUUFBTCxDQUFjL1MsT0FBZDtBQUNILGlCQUpEOztBQU1BdkIsNkJBQWF0ZSxTQUFiLENBQXVCeWIsT0FBdkIsR0FBaUMsVUFBVTRJLE1BQVYsRUFBa0I7QUFDL0MseUJBQUtpUyxPQUFMLEdBQWUsSUFBZjtBQUNBLHlCQUFLMUQsUUFBTCxDQUFjb0IsZUFBZCxDQUE4QjNQLE1BQTlCLEVBQXNDLEtBQXRDO0FBQ0gsaUJBSEQ7O0FBS0EvRiw2QkFBYXRlLFNBQWIsQ0FBdUI0ekIsaUJBQXZCLEdBQTJDLFVBQVV4dkIsS0FBVixFQUFpQjVELEtBQWpCLEVBQXdCO0FBQy9ELHlCQUFLODFCLE9BQUwsQ0FBYTkxQixLQUFiLElBQXNCNEQsS0FBdEI7QUFDQSx3QkFBSW95QixnQkFBZ0IsRUFBRSxLQUFLQyxjQUEzQjtBQUNBLHdCQUFJRCxpQkFBaUIsS0FBS3hXLE9BQTFCLEVBQW1DO0FBQy9CLDZCQUFLMFcsUUFBTCxDQUFjLEtBQUtKLE9BQW5CO0FBQ0EsK0JBQU8sSUFBUDtBQUNIO0FBQ0QsMkJBQU8sS0FBUDtBQUNILGlCQVJEOztBQVVBaFksNkJBQWF0ZSxTQUFiLENBQXVCdXpCLGlCQUF2QixHQUEyQyxZQUFXO0FBQ2xELHlCQUFLMVQsT0FBTDtBQUNBLDJCQUFPLElBQVA7QUFDSCxpQkFIRDs7QUFLQXZCLDZCQUFhdGUsU0FBYixDQUF1Qjh6QixnQkFBdkIsR0FBMEMsVUFBVXpQLE1BQVYsRUFBa0I7QUFDeEQseUJBQUtvUyxjQUFMO0FBQ0EseUJBQUtoYixPQUFMLENBQWE0SSxNQUFiO0FBQ0EsMkJBQU8sSUFBUDtBQUNILGlCQUpEOztBQU1BL0YsNkJBQWF0ZSxTQUFiLENBQXVCMmdCLGdCQUF2QixHQUEwQyxZQUFXO0FBQ2pELHdCQUFJLEtBQUt5UyxXQUFMLEVBQUosRUFBd0I7QUFDeEIsd0JBQUl2dUIsU0FBUyxLQUFLeXhCLE9BQWxCO0FBQ0EseUJBQUt6VyxPQUFMO0FBQ0Esd0JBQUloYixrQkFBa0JxRCxPQUF0QixFQUErQjtBQUMzQnJELCtCQUFPK1osTUFBUDtBQUNILHFCQUZELE1BRU87QUFDSCw2QkFBSyxJQUFJdmYsSUFBSSxDQUFiLEVBQWdCQSxJQUFJd0YsT0FBT3RGLE1BQTNCLEVBQW1DLEVBQUVGLENBQXJDLEVBQXdDO0FBQ3BDLGdDQUFJd0YsT0FBT3hGLENBQVAsYUFBcUI2SSxPQUF6QixFQUFrQztBQUM5QnJELHVDQUFPeEYsQ0FBUCxFQUFVdWYsTUFBVjtBQUNIO0FBQ0o7QUFDSjtBQUNKLGlCQWJEOztBQWVBTiw2QkFBYXRlLFNBQWIsQ0FBdUI2OEIsZ0JBQXZCLEdBQTBDLFlBQVk7QUFDbEQsMkJBQU8sSUFBUDtBQUNILGlCQUZEOztBQUlBdmUsNkJBQWF0ZSxTQUFiLENBQXVCNDhCLGVBQXZCLEdBQXlDLFVBQVU1bUIsR0FBVixFQUFlO0FBQ3BELDJCQUFPQSxHQUFQO0FBQ0gsaUJBRkQ7O0FBSUEsdUJBQU9zSSxZQUFQO0FBQ0MsYUF2TEQ7QUF5TEMsU0EzTGloQixFQTJMaGhCLEVBQUMsVUFBUyxFQUFWLEVBM0xnaEIsQ0F2N0c4TyxFQWtuSC91QixJQUFHLENBQUMsVUFBU3JHLE9BQVQsRUFBaUJwYSxNQUFqQixFQUF3QkMsT0FBeEIsRUFBZ0M7QUFDckQ7O0FBQ0FELG1CQUFPQyxPQUFQLEdBQWlCLFVBQVNvSyxPQUFULEVBQWtCaVQsUUFBbEIsRUFBNEI7QUFDN0Msb0JBQUk0aEIsT0FBTyxFQUFYO0FBQ0Esb0JBQUlqa0IsT0FBT2IsUUFBUSxRQUFSLENBQVg7QUFDQSxvQkFBSW9mLHFCQUFxQnBmLFFBQVEsWUFBUixDQUF6QjtBQUNBLG9CQUFJK2tCLGVBQWVsa0IsS0FBS2trQixZQUF4QjtBQUNBLG9CQUFJaEcsbUJBQW1CbGUsS0FBS2tlLGdCQUE1QjtBQUNBLG9CQUFJNVosY0FBY3RFLEtBQUtzRSxXQUF2QjtBQUNBLG9CQUFJekssWUFBWXNGLFFBQVEsVUFBUixFQUFvQnRGLFNBQXBDO0FBQ0Esb0JBQUlzcUIsZ0JBQWdCLE9BQXBCO0FBQ0Esb0JBQUlDLHFCQUFxQixFQUFDQyxtQkFBbUIsSUFBcEIsRUFBekI7QUFDQSxvQkFBSUMsY0FBYyxDQUNkLE9BRGMsRUFDRixRQURFLEVBRWQsTUFGYyxFQUdkLFdBSGMsRUFJZCxRQUpjLEVBS2QsUUFMYyxFQU1kLFdBTmMsRUFPZCxtQkFQYyxDQUFsQjtBQVNBLG9CQUFJQyxxQkFBcUIsSUFBSXYyQixNQUFKLENBQVcsU0FBU3MyQixZQUFZbFUsSUFBWixDQUFpQixHQUFqQixDQUFULEdBQWlDLElBQTVDLENBQXpCOztBQUVBLG9CQUFJb1UsZ0JBQWdCLFNBQWhCQSxhQUFnQixDQUFTdG1CLElBQVQsRUFBZTtBQUMvQiwyQkFBTzhCLEtBQUt1RSxZQUFMLENBQWtCckcsSUFBbEIsS0FDSEEsS0FBSzZULE1BQUwsQ0FBWSxDQUFaLE1BQW1CLEdBRGhCLElBRUg3VCxTQUFTLGFBRmI7QUFHSCxpQkFKRDs7QUFNQSx5QkFBU3VtQixXQUFULENBQXFCOTlCLEdBQXJCLEVBQTBCO0FBQ3RCLDJCQUFPLENBQUM0OUIsbUJBQW1CdnZCLElBQW5CLENBQXdCck8sR0FBeEIsQ0FBUjtBQUNIOztBQUVELHlCQUFTKzlCLGFBQVQsQ0FBdUJuOUIsRUFBdkIsRUFBMkI7QUFDdkIsd0JBQUk7QUFDQSwrQkFBT0EsR0FBRzg4QixpQkFBSCxLQUF5QixJQUFoQztBQUNILHFCQUZELENBR0EsT0FBT3gvQixDQUFQLEVBQVU7QUFDTiwrQkFBTyxLQUFQO0FBQ0g7QUFDSjs7QUFFRCx5QkFBUzgvQixjQUFULENBQXdCeCtCLEdBQXhCLEVBQTZCUSxHQUE3QixFQUFrQ2krQixNQUFsQyxFQUEwQztBQUN0Qyx3QkFBSWwrQixNQUFNc1osS0FBSzZrQix3QkFBTCxDQUE4QjErQixHQUE5QixFQUFtQ1EsTUFBTWkrQixNQUF6QyxFQUM4QlIsa0JBRDlCLENBQVY7QUFFQSwyQkFBTzE5QixNQUFNZytCLGNBQWNoK0IsR0FBZCxDQUFOLEdBQTJCLEtBQWxDO0FBQ0g7QUFDRCx5QkFBU28rQixVQUFULENBQW9CcmxCLEdBQXBCLEVBQXlCbWxCLE1BQXpCLEVBQWlDRyxZQUFqQyxFQUErQztBQUMzQyx5QkFBSyxJQUFJeCtCLElBQUksQ0FBYixFQUFnQkEsSUFBSWtaLElBQUloWixNQUF4QixFQUFnQ0YsS0FBSyxDQUFyQyxFQUF3QztBQUNwQyw0QkFBSUksTUFBTThZLElBQUlsWixDQUFKLENBQVY7QUFDQSw0QkFBSXcrQixhQUFhL3ZCLElBQWIsQ0FBa0JyTyxHQUFsQixDQUFKLEVBQTRCO0FBQ3hCLGdDQUFJcStCLHdCQUF3QnIrQixJQUFJVyxPQUFKLENBQVl5OUIsWUFBWixFQUEwQixFQUExQixDQUE1QjtBQUNBLGlDQUFLLElBQUl0YyxJQUFJLENBQWIsRUFBZ0JBLElBQUloSixJQUFJaFosTUFBeEIsRUFBZ0NnaUIsS0FBSyxDQUFyQyxFQUF3QztBQUNwQyxvQ0FBSWhKLElBQUlnSixDQUFKLE1BQVd1YyxxQkFBZixFQUFzQztBQUNsQywwQ0FBTSxJQUFJbnJCLFNBQUosQ0FBYyxxR0FDZnZTLE9BRGUsQ0FDUCxJQURPLEVBQ0RzOUIsTUFEQyxDQUFkLENBQU47QUFFSDtBQUNKO0FBQ0o7QUFDSjtBQUNKOztBQUVELHlCQUFTSyxvQkFBVCxDQUE4QjkrQixHQUE5QixFQUFtQ3krQixNQUFuQyxFQUEyQ0csWUFBM0MsRUFBeUQ3TSxNQUF6RCxFQUFpRTtBQUM3RCx3QkFBSXhxQixPQUFPc1MsS0FBS2tsQixpQkFBTCxDQUF1Qi8rQixHQUF2QixDQUFYO0FBQ0Esd0JBQUlzWixNQUFNLEVBQVY7QUFDQSx5QkFBSyxJQUFJbFosSUFBSSxDQUFiLEVBQWdCQSxJQUFJbUgsS0FBS2pILE1BQXpCLEVBQWlDLEVBQUVGLENBQW5DLEVBQXNDO0FBQ2xDLDRCQUFJSSxNQUFNK0csS0FBS25ILENBQUwsQ0FBVjtBQUNBLDRCQUFJK0UsUUFBUW5GLElBQUlRLEdBQUosQ0FBWjtBQUNBLDRCQUFJdytCLHNCQUFzQmpOLFdBQVdzTSxhQUFYLEdBQ3BCLElBRG9CLEdBQ2JBLGNBQWM3OUIsR0FBZCxFQUFtQjJFLEtBQW5CLEVBQTBCbkYsR0FBMUIsQ0FEYjtBQUVBLDRCQUFJLE9BQU9tRixLQUFQLEtBQWlCLFVBQWpCLElBQ0EsQ0FBQ281QixjQUFjcDVCLEtBQWQsQ0FERCxJQUVBLENBQUNxNUIsZUFBZXgrQixHQUFmLEVBQW9CUSxHQUFwQixFQUF5QmkrQixNQUF6QixDQUZELElBR0ExTSxPQUFPdnhCLEdBQVAsRUFBWTJFLEtBQVosRUFBbUJuRixHQUFuQixFQUF3QmcvQixtQkFBeEIsQ0FISixFQUdrRDtBQUM5QzFsQixnQ0FBSWxPLElBQUosQ0FBUzVLLEdBQVQsRUFBYzJFLEtBQWQ7QUFDSDtBQUNKO0FBQ0R3NUIsK0JBQVdybEIsR0FBWCxFQUFnQm1sQixNQUFoQixFQUF3QkcsWUFBeEI7QUFDQSwyQkFBT3RsQixHQUFQO0FBQ0g7O0FBRUQsb0JBQUkybEIsbUJBQW1CLFNBQW5CQSxnQkFBbUIsQ0FBU2grQixHQUFULEVBQWM7QUFDakMsMkJBQU9BLElBQUlFLE9BQUosQ0FBWSxPQUFaLEVBQXFCLEtBQXJCLENBQVA7QUFDSCxpQkFGRDs7QUFJQSxvQkFBSSs5Qix1QkFBSjtBQUNBLG9CQUFJLEtBQUosRUFBVztBQUNYLHdCQUFJQywwQkFBMEIsU0FBMUJBLHVCQUEwQixDQUFTQyxtQkFBVCxFQUE4QjtBQUN4RCw0QkFBSTlsQixNQUFNLENBQUM4bEIsbUJBQUQsQ0FBVjtBQUNBLDRCQUFJQyxNQUFNejJCLEtBQUtDLEdBQUwsQ0FBUyxDQUFULEVBQVl1MkIsc0JBQXNCLENBQXRCLEdBQTBCLENBQXRDLENBQVY7QUFDQSw2QkFBSSxJQUFJaC9CLElBQUlnL0Isc0JBQXNCLENBQWxDLEVBQXFDaC9CLEtBQUtpL0IsR0FBMUMsRUFBK0MsRUFBRWovQixDQUFqRCxFQUFvRDtBQUNoRGtaLGdDQUFJbE8sSUFBSixDQUFTaEwsQ0FBVDtBQUNIO0FBQ0QsNkJBQUksSUFBSUEsSUFBSWcvQixzQkFBc0IsQ0FBbEMsRUFBcUNoL0IsS0FBSyxDQUExQyxFQUE2QyxFQUFFQSxDQUEvQyxFQUFrRDtBQUM5Q2taLGdDQUFJbE8sSUFBSixDQUFTaEwsQ0FBVDtBQUNIO0FBQ0QsK0JBQU9rWixHQUFQO0FBQ0gscUJBVkQ7O0FBWUEsd0JBQUlnbUIsbUJBQW1CLFNBQW5CQSxnQkFBbUIsQ0FBU0MsYUFBVCxFQUF3QjtBQUMzQywrQkFBTzFsQixLQUFLMmxCLFdBQUwsQ0FBaUJELGFBQWpCLEVBQWdDLE1BQWhDLEVBQXdDLEVBQXhDLENBQVA7QUFDSCxxQkFGRDs7QUFJQSx3QkFBSUUsdUJBQXVCLFNBQXZCQSxvQkFBdUIsQ0FBU0MsY0FBVCxFQUF5QjtBQUNoRCwrQkFBTzdsQixLQUFLMmxCLFdBQUwsQ0FDSDUyQixLQUFLQyxHQUFMLENBQVM2MkIsY0FBVCxFQUF5QixDQUF6QixDQURHLEVBQzBCLE1BRDFCLEVBQ2tDLEVBRGxDLENBQVA7QUFFSCxxQkFIRDs7QUFLQSx3QkFBSUEsaUJBQWlCLFNBQWpCQSxjQUFpQixDQUFTdCtCLEVBQVQsRUFBYTtBQUM5Qiw0QkFBSSxPQUFPQSxHQUFHZCxNQUFWLEtBQXFCLFFBQXpCLEVBQW1DO0FBQy9CLG1DQUFPc0ksS0FBS0MsR0FBTCxDQUFTRCxLQUFLeTJCLEdBQUwsQ0FBU2orQixHQUFHZCxNQUFaLEVBQW9CLE9BQU8sQ0FBM0IsQ0FBVCxFQUF3QyxDQUF4QyxDQUFQO0FBQ0g7QUFDRCwrQkFBTyxDQUFQO0FBQ0gscUJBTEQ7O0FBT0E0K0IsOENBQ0EsaUNBQVNwckIsUUFBVCxFQUFtQndILFFBQW5CLEVBQTZCcWtCLFlBQTdCLEVBQTJDditCLEVBQTNDLEVBQStDbWIsQ0FBL0MsRUFBa0Q4YixTQUFsRCxFQUE2RDtBQUN6RCw0QkFBSXVILG9CQUFvQmgzQixLQUFLQyxHQUFMLENBQVMsQ0FBVCxFQUFZNjJCLGVBQWV0K0IsRUFBZixJQUFxQixDQUFqQyxDQUF4QjtBQUNBLDRCQUFJeStCLGdCQUFnQlYsd0JBQXdCUyxpQkFBeEIsQ0FBcEI7QUFDQSw0QkFBSUUsa0JBQWtCLE9BQU9oc0IsUUFBUCxLQUFvQixRQUFwQixJQUFnQ3dILGFBQWF3aUIsSUFBbkU7O0FBRUEsaUNBQVNpQyw0QkFBVCxDQUFzQ0MsS0FBdEMsRUFBNkM7QUFDekMsZ0NBQUl6NkIsT0FBTys1QixpQkFBaUJVLEtBQWpCLEVBQXdCL1YsSUFBeEIsQ0FBNkIsSUFBN0IsQ0FBWDtBQUNBLGdDQUFJZ1csUUFBUUQsUUFBUSxDQUFSLEdBQVksSUFBWixHQUFtQixFQUEvQjtBQUNBLGdDQUFJMW1CLEdBQUo7QUFDQSxnQ0FBSXdtQixlQUFKLEVBQXFCO0FBQ2pCeG1CLHNDQUFNLHlEQUFOO0FBQ0gsNkJBRkQsTUFFTztBQUNIQSxzQ0FBTWdDLGFBQWEvVSxTQUFiLEdBQ0EsOENBREEsR0FFQSw2REFGTjtBQUdIO0FBQ0QsbUNBQU8rUyxJQUFJblksT0FBSixDQUFZLFVBQVosRUFBd0JvRSxJQUF4QixFQUE4QnBFLE9BQTlCLENBQXNDLElBQXRDLEVBQTRDOCtCLEtBQTVDLENBQVA7QUFDSDs7QUFFRCxpQ0FBU0MsMEJBQVQsR0FBc0M7QUFDbEMsZ0NBQUk1bUIsTUFBTSxFQUFWO0FBQ0EsaUNBQUssSUFBSWxaLElBQUksQ0FBYixFQUFnQkEsSUFBSXkvQixjQUFjdi9CLE1BQWxDLEVBQTBDLEVBQUVGLENBQTVDLEVBQStDO0FBQzNDa1osdUNBQU8sVUFBVXVtQixjQUFjei9CLENBQWQsQ0FBVixHQUE0QixHQUE1QixHQUNIMi9CLDZCQUE2QkYsY0FBY3ovQixDQUFkLENBQTdCLENBREo7QUFFSDs7QUFFRGtaLG1DQUFPOzs7Ozs7Ozs7O1NBQUEsQ0FVTG5ZLE9BVkssQ0FVRyxlQVZILEVBVXFCMitCLGtCQUNGLHFDQURFLEdBRUYseUNBWm5CLENBQVA7QUFhQSxtQ0FBT3htQixHQUFQO0FBQ0g7O0FBRUQsNEJBQUk2bUIsa0JBQWtCLE9BQU9yc0IsUUFBUCxLQUFvQixRQUFwQixHQUNTLDBCQUF3QkEsUUFBeEIsR0FBaUMsU0FEMUMsR0FFUSxJQUY5QjtBQUdBLDRCQUFJc3NCLE9BQU87Ozs7Ozt3REFBQSxHQU00Qy9ILFNBTjVDLEdBTXdEOzs7Ozs7Ozs7Ozs7OztLQUFBLENBY2pFbDNCLE9BZGlFLENBY3pELHFCQWR5RCxFQWNsQysrQiw0QkFka0MsRUFlOUQvK0IsT0FmOEQsQ0FldEQsbUJBZnNELEVBZWpDZy9CLGVBZmlDLENBTm5FO0FBc0JBQywrQkFBT0EsS0FBS2ovQixPQUFMLENBQWEsWUFBYixFQUEyQnMrQixxQkFBcUJHLGlCQUFyQixDQUEzQixDQUFQO0FBQ0EsK0JBQU8sSUFBSXBoQyxRQUFKLENBQWEsU0FBYixFQUNhLElBRGIsRUFFYSxVQUZiLEVBR2EsY0FIYixFQUlhLGtCQUpiLEVBS2Esb0JBTGIsRUFNYSxVQU5iLEVBT2EsVUFQYixFQVFhLG1CQVJiLEVBU2EsVUFUYixFQVVhNGhDLElBVmIsRUFXU24zQixPQVhULEVBWVM3SCxFQVpULEVBYVNrYSxRQWJULEVBY1N5aUIsWUFkVCxFQWVTaEcsZ0JBZlQsRUFnQlNLLGtCQWhCVCxFQWlCU3ZlLEtBQUswRixRQWpCZCxFQWtCUzFGLEtBQUsyRixRQWxCZCxFQW1CUzNGLEtBQUttUSxpQkFuQmQsRUFvQlM5TixRQXBCVCxDQUFQO0FBcUJILHFCQTFGRDtBQTJGQzs7QUFFRCx5QkFBU21rQiwwQkFBVCxDQUFvQ3ZzQixRQUFwQyxFQUE4Q3dILFFBQTlDLEVBQXdEaUIsQ0FBeEQsRUFBMkRuYixFQUEzRCxFQUErRGsvQixFQUEvRCxFQUFtRWpJLFNBQW5FLEVBQThFO0FBQzFFLHdCQUFJa0ksY0FBZSxZQUFXO0FBQUMsK0JBQU8sSUFBUDtBQUFhLHFCQUExQixFQUFsQjtBQUNBLHdCQUFJbFosU0FBU3ZULFFBQWI7QUFDQSx3QkFBSSxPQUFPdVQsTUFBUCxLQUFrQixRQUF0QixFQUFnQztBQUM1QnZULG1DQUFXMVMsRUFBWDtBQUNIO0FBQ0QsNkJBQVNvL0IsV0FBVCxHQUF1QjtBQUNuQiw0QkFBSTFNLFlBQVl4WSxRQUFoQjtBQUNBLDRCQUFJQSxhQUFhd2lCLElBQWpCLEVBQXVCaEssWUFBWSxJQUFaO0FBQ3ZCLDRCQUFJcmUsVUFBVSxJQUFJeE0sT0FBSixDQUFZaVQsUUFBWixDQUFkO0FBQ0F6RyxnQ0FBUTBRLGtCQUFSO0FBQ0EsNEJBQUlsRSxLQUFLLE9BQU9vRixNQUFQLEtBQWtCLFFBQWxCLElBQThCLFNBQVNrWixXQUF2QyxHQUNILEtBQUtsWixNQUFMLENBREcsR0FDWXZULFFBRHJCO0FBRUEsNEJBQUkxUyxLQUFLZzNCLG1CQUFtQjNpQixPQUFuQixFQUE0QjRpQixTQUE1QixDQUFUO0FBQ0EsNEJBQUk7QUFDQXBXLCtCQUFHcmhCLEtBQUgsQ0FBU2t6QixTQUFULEVBQW9CaUssYUFBYTE5QixTQUFiLEVBQXdCZSxFQUF4QixDQUFwQjtBQUNILHlCQUZELENBRUUsT0FBTTFDLENBQU4sRUFBUztBQUNQK1csb0NBQVFzZixlQUFSLENBQXdCZ0QsaUJBQWlCcjVCLENBQWpCLENBQXhCLEVBQTZDLElBQTdDLEVBQW1ELElBQW5EO0FBQ0g7QUFDRCw0QkFBSSxDQUFDK1csUUFBUTZnQixhQUFSLEVBQUwsRUFBOEI3Z0IsUUFBUThnQixtQkFBUjtBQUM5QiwrQkFBTzlnQixPQUFQO0FBQ0g7QUFDRG9FLHlCQUFLbVEsaUJBQUwsQ0FBdUJ3VyxXQUF2QixFQUFvQyxtQkFBcEMsRUFBeUQsSUFBekQ7QUFDQSwyQkFBT0EsV0FBUDtBQUNIOztBQUVELG9CQUFJQyxzQkFBc0J0aUIsY0FDcEIrZ0IsdUJBRG9CLEdBRXBCbUIsMEJBRk47O0FBSUEseUJBQVNLLFlBQVQsQ0FBc0IxZ0MsR0FBdEIsRUFBMkJ5K0IsTUFBM0IsRUFBbUMxTSxNQUFuQyxFQUEyQzRPLFdBQTNDLEVBQXdEdEksU0FBeEQsRUFBbUU7QUFDL0Qsd0JBQUl1RyxlQUFlLElBQUkvMkIsTUFBSixDQUFXbzNCLGlCQUFpQlIsTUFBakIsSUFBMkIsR0FBdEMsQ0FBbkI7QUFDQSx3QkFBSTlwQixVQUNBbXFCLHFCQUFxQjkrQixHQUFyQixFQUEwQnkrQixNQUExQixFQUFrQ0csWUFBbEMsRUFBZ0Q3TSxNQUFoRCxDQURKOztBQUdBLHlCQUFLLElBQUkzeEIsSUFBSSxDQUFSLEVBQVcyVyxNQUFNcEMsUUFBUXJVLE1BQTlCLEVBQXNDRixJQUFJMlcsR0FBMUMsRUFBK0MzVyxLQUFJLENBQW5ELEVBQXNEO0FBQ2xELDRCQUFJSSxNQUFNbVUsUUFBUXZVLENBQVIsQ0FBVjtBQUNBLDRCQUFJZ0IsS0FBS3VULFFBQVF2VSxJQUFFLENBQVYsQ0FBVDtBQUNBLDRCQUFJd2dDLGlCQUFpQnBnQyxNQUFNaStCLE1BQTNCO0FBQ0EsNEJBQUlrQyxnQkFBZ0JGLG1CQUFwQixFQUF5QztBQUNyQ3pnQyxnQ0FBSTRnQyxjQUFKLElBQ0lILG9CQUFvQmpnQyxHQUFwQixFQUF5QnM5QixJQUF6QixFQUErQnQ5QixHQUEvQixFQUFvQ1ksRUFBcEMsRUFBd0NxOUIsTUFBeEMsRUFBZ0RwRyxTQUFoRCxDQURKO0FBRUgseUJBSEQsTUFHTztBQUNILGdDQUFJbUksY0FBY0csWUFBWXYvQixFQUFaLEVBQWdCLFlBQVc7QUFDekMsdUNBQU9xL0Isb0JBQW9CamdDLEdBQXBCLEVBQXlCczlCLElBQXpCLEVBQStCdDlCLEdBQS9CLEVBQ29CWSxFQURwQixFQUN3QnE5QixNQUR4QixFQUNnQ3BHLFNBRGhDLENBQVA7QUFFSCw2QkFIaUIsQ0FBbEI7QUFJQXhlLGlDQUFLbVEsaUJBQUwsQ0FBdUJ3VyxXQUF2QixFQUFvQyxtQkFBcEMsRUFBeUQsSUFBekQ7QUFDQXhnQyxnQ0FBSTRnQyxjQUFKLElBQXNCSixXQUF0QjtBQUNIO0FBQ0o7QUFDRDNtQix5QkFBS29qQixnQkFBTCxDQUFzQmo5QixHQUF0QjtBQUNBLDJCQUFPQSxHQUFQO0FBQ0g7O0FBRUQseUJBQVM2Z0MsU0FBVCxDQUFtQi9zQixRQUFuQixFQUE2QndILFFBQTdCLEVBQXVDK2MsU0FBdkMsRUFBa0Q7QUFDOUMsMkJBQU9vSSxvQkFBb0Izc0IsUUFBcEIsRUFBOEJ3SCxRQUE5QixFQUF3Qy9VLFNBQXhDLEVBQ3FCdU4sUUFEckIsRUFDK0IsSUFEL0IsRUFDcUN1a0IsU0FEckMsQ0FBUDtBQUVIOztBQUVEcHZCLHdCQUFRNDNCLFNBQVIsR0FBb0IsVUFBVXovQixFQUFWLEVBQWN5UixPQUFkLEVBQXVCO0FBQ3ZDLHdCQUFJLE9BQU96UixFQUFQLEtBQWMsVUFBbEIsRUFBOEI7QUFDMUIsOEJBQU0sSUFBSXNTLFNBQUosQ0FBYyxrQ0FBa0NtRyxLQUFLaUYsV0FBTCxDQUFpQjFkLEVBQWpCLENBQWhELENBQU47QUFDSDtBQUNELHdCQUFJbTlCLGNBQWNuOUIsRUFBZCxDQUFKLEVBQXVCO0FBQ25CLCtCQUFPQSxFQUFQO0FBQ0g7QUFDRHlSLDhCQUFVL1MsT0FBTytTLE9BQVAsQ0FBVjtBQUNBLHdCQUFJeUksV0FBV3pJLFFBQVE2SixPQUFSLEtBQW9CblcsU0FBcEIsR0FBZ0N1M0IsSUFBaEMsR0FBdUNqckIsUUFBUTZKLE9BQTlEO0FBQ0Esd0JBQUkyYixZQUFZLENBQUMsQ0FBQ3hsQixRQUFRd2xCLFNBQTFCO0FBQ0Esd0JBQUkvZSxNQUFNdW5CLFVBQVV6L0IsRUFBVixFQUFja2EsUUFBZCxFQUF3QitjLFNBQXhCLENBQVY7QUFDQXhlLHlCQUFLaW5CLGVBQUwsQ0FBcUIxL0IsRUFBckIsRUFBeUJrWSxHQUF6QixFQUE4QmdsQixXQUE5QjtBQUNBLDJCQUFPaGxCLEdBQVA7QUFDSCxpQkFiRDs7QUFlQXJRLHdCQUFReTNCLFlBQVIsR0FBdUIsVUFBVXpqQixNQUFWLEVBQWtCcEssT0FBbEIsRUFBMkI7QUFDOUMsd0JBQUksT0FBT29LLE1BQVAsS0FBa0IsVUFBbEIsSUFBZ0MsUUFBT0EsTUFBUCx5Q0FBT0EsTUFBUCxPQUFrQixRQUF0RCxFQUFnRTtBQUM1RCw4QkFBTSxJQUFJdkosU0FBSixDQUFjLDhGQUFkLENBQU47QUFDSDtBQUNEYiw4QkFBVS9TLE9BQU8rUyxPQUFQLENBQVY7QUFDQSx3QkFBSXdsQixZQUFZLENBQUMsQ0FBQ3hsQixRQUFRd2xCLFNBQTFCO0FBQ0Esd0JBQUlvRyxTQUFTNXJCLFFBQVE0ckIsTUFBckI7QUFDQSx3QkFBSSxPQUFPQSxNQUFQLEtBQWtCLFFBQXRCLEVBQWdDQSxTQUFTVCxhQUFUO0FBQ2hDLHdCQUFJak0sU0FBU2xmLFFBQVFrZixNQUFyQjtBQUNBLHdCQUFJLE9BQU9BLE1BQVAsS0FBa0IsVUFBdEIsRUFBa0NBLFNBQVNzTSxhQUFUO0FBQ2xDLHdCQUFJc0MsY0FBYzl0QixRQUFROHRCLFdBQTFCO0FBQ0Esd0JBQUksT0FBT0EsV0FBUCxLQUF1QixVQUEzQixFQUF1Q0EsY0FBY0YsbUJBQWQ7O0FBRXZDLHdCQUFJLENBQUM1bUIsS0FBS3VFLFlBQUwsQ0FBa0JxZ0IsTUFBbEIsQ0FBTCxFQUFnQztBQUM1Qiw4QkFBTSxJQUFJak8sVUFBSixDQUFlLHFFQUFmLENBQU47QUFDSDs7QUFFRCx3QkFBSWpwQixPQUFPc1MsS0FBS2tsQixpQkFBTCxDQUF1QjloQixNQUF2QixDQUFYO0FBQ0EseUJBQUssSUFBSTdjLElBQUksQ0FBYixFQUFnQkEsSUFBSW1ILEtBQUtqSCxNQUF6QixFQUFpQyxFQUFFRixDQUFuQyxFQUFzQztBQUNsQyw0QkFBSStFLFFBQVE4WCxPQUFPMVYsS0FBS25ILENBQUwsQ0FBUCxDQUFaO0FBQ0EsNEJBQUltSCxLQUFLbkgsQ0FBTCxNQUFZLGFBQVosSUFDQXlaLEtBQUtrbkIsT0FBTCxDQUFhNTdCLEtBQWIsQ0FESixFQUN5QjtBQUNyQnU3Qix5Q0FBYXY3QixNQUFNcEUsU0FBbkIsRUFBOEIwOUIsTUFBOUIsRUFBc0MxTSxNQUF0QyxFQUE4QzRPLFdBQTlDLEVBQ0l0SSxTQURKO0FBRUFxSSx5Q0FBYXY3QixLQUFiLEVBQW9CczVCLE1BQXBCLEVBQTRCMU0sTUFBNUIsRUFBb0M0TyxXQUFwQyxFQUFpRHRJLFNBQWpEO0FBQ0g7QUFDSjs7QUFFRCwyQkFBT3FJLGFBQWF6akIsTUFBYixFQUFxQndoQixNQUFyQixFQUE2QjFNLE1BQTdCLEVBQXFDNE8sV0FBckMsRUFBa0R0SSxTQUFsRCxDQUFQO0FBQ0gsaUJBN0JEO0FBOEJDLGFBdlREO0FBMFRDLFNBNVRtQixFQTRUbEIsRUFBQyxZQUFXLEVBQVosRUFBZSxjQUFhLEVBQTVCLEVBQStCLFVBQVMsRUFBeEMsRUE1VGtCLENBbG5INHVCLEVBODZIanRCLElBQUcsQ0FBQyxVQUFTcmYsT0FBVCxFQUFpQnBhLE1BQWpCLEVBQXdCQyxPQUF4QixFQUFnQztBQUNuRjs7QUFDQUQsbUJBQU9DLE9BQVAsR0FBaUIsVUFDYm9LLE9BRGEsRUFDSm9XLFlBREksRUFDVWxELG1CQURWLEVBQytCbUQsWUFEL0IsRUFDNkM7QUFDOUQsb0JBQUl6RixPQUFPYixRQUFRLFFBQVIsQ0FBWDtBQUNBLG9CQUFJblosV0FBV2dhLEtBQUtoYSxRQUFwQjtBQUNBLG9CQUFJK3ZCLE1BQU01VyxRQUFRLE9BQVIsQ0FBVjtBQUNBLG9CQUFJZ29CLE1BQUo7QUFDQSxvQkFBSSxPQUFPaDRCLEdBQVAsS0FBZSxVQUFuQixFQUErQmc0QixTQUFTaDRCLEdBQVQ7O0FBRS9CLG9CQUFJaTRCLGVBQWdCLFlBQVc7QUFDM0Isd0JBQUkxL0IsUUFBUSxDQUFaO0FBQ0Esd0JBQUltRixPQUFPLENBQVg7O0FBRUEsNkJBQVN3NkIsWUFBVCxDQUFzQi83QixLQUF0QixFQUE2QjNFLEdBQTdCLEVBQWtDO0FBQzlCLDZCQUFLZSxLQUFMLElBQWM0RCxLQUFkO0FBQ0EsNkJBQUs1RCxRQUFRbUYsSUFBYixJQUFxQmxHLEdBQXJCO0FBQ0FlO0FBQ0g7O0FBRUQsMkJBQU8sU0FBUzAvQixZQUFULENBQXNCeGhDLEdBQXRCLEVBQTJCO0FBQzlCaUgsK0JBQU9qSCxJQUFJaUgsSUFBWDtBQUNBbkYsZ0NBQVEsQ0FBUjtBQUNBLDRCQUFJK1gsTUFBTSxJQUFJalksS0FBSixDQUFVNUIsSUFBSWlILElBQUosR0FBVyxDQUFyQixDQUFWO0FBQ0FqSCw0QkFBSWtILE9BQUosQ0FBWXU2QixZQUFaLEVBQTBCNW5CLEdBQTFCO0FBQ0EsK0JBQU9BLEdBQVA7QUFDSCxxQkFORDtBQU9ILGlCQWpCa0IsRUFBbkI7O0FBbUJBLG9CQUFJNm5CLGVBQWUsU0FBZkEsWUFBZSxDQUFTcDNCLE9BQVQsRUFBa0I7QUFDakMsd0JBQUl1UCxNQUFNLElBQUkwbkIsTUFBSixFQUFWO0FBQ0Esd0JBQUkxZ0MsU0FBU3lKLFFBQVF6SixNQUFSLEdBQWlCLENBQWpCLEdBQXFCLENBQWxDO0FBQ0EseUJBQUssSUFBSUYsSUFBSSxDQUFiLEVBQWdCQSxJQUFJRSxNQUFwQixFQUE0QixFQUFFRixDQUE5QixFQUFpQztBQUM3Qiw0QkFBSUksTUFBTXVKLFFBQVF6SixTQUFTRixDQUFqQixDQUFWO0FBQ0EsNEJBQUkrRSxRQUFRNEUsUUFBUTNKLENBQVIsQ0FBWjtBQUNBa1osNEJBQUlyVSxHQUFKLENBQVF6RSxHQUFSLEVBQWEyRSxLQUFiO0FBQ0g7QUFDRCwyQkFBT21VLEdBQVA7QUFDSCxpQkFURDs7QUFXQSx5QkFBUzhuQixzQkFBVCxDQUFnQ3BoQyxHQUFoQyxFQUFxQztBQUNqQyx3QkFBSXFoQyxRQUFRLEtBQVo7QUFDQSx3QkFBSXQzQixPQUFKO0FBQ0Esd0JBQUlpM0IsV0FBV3o2QixTQUFYLElBQXdCdkcsZUFBZWdoQyxNQUEzQyxFQUFtRDtBQUMvQ2ozQixrQ0FBVWszQixhQUFhamhDLEdBQWIsQ0FBVjtBQUNBcWhDLGdDQUFRLElBQVI7QUFDSCxxQkFIRCxNQUdPO0FBQ0gsNEJBQUk5NUIsT0FBT3FvQixJQUFJcm9CLElBQUosQ0FBU3ZILEdBQVQsQ0FBWDtBQUNBLDRCQUFJK1csTUFBTXhQLEtBQUtqSCxNQUFmO0FBQ0F5SixrQ0FBVSxJQUFJMUksS0FBSixDQUFVMFYsTUFBTSxDQUFoQixDQUFWO0FBQ0EsNkJBQUssSUFBSTNXLElBQUksQ0FBYixFQUFnQkEsSUFBSTJXLEdBQXBCLEVBQXlCLEVBQUUzVyxDQUEzQixFQUE4QjtBQUMxQixnQ0FBSUksTUFBTStHLEtBQUtuSCxDQUFMLENBQVY7QUFDQTJKLG9DQUFRM0osQ0FBUixJQUFhSixJQUFJUSxHQUFKLENBQWI7QUFDQXVKLG9DQUFRM0osSUFBSTJXLEdBQVosSUFBbUJ2VyxHQUFuQjtBQUNIO0FBQ0o7QUFDRCx5QkFBS28yQixZQUFMLENBQWtCN3NCLE9BQWxCO0FBQ0EseUJBQUt1M0IsTUFBTCxHQUFjRCxLQUFkO0FBQ0EseUJBQUtsSyxNQUFMLENBQVk1d0IsU0FBWixFQUF1Qjg2QixRQUFRLENBQUMsQ0FBVCxHQUFhLENBQUMsQ0FBckM7QUFDSDtBQUNEeG5CLHFCQUFLOFQsUUFBTCxDQUFjeVQsc0JBQWQsRUFBc0MvaEIsWUFBdEM7O0FBRUEraEIsdUNBQXVCcmdDLFNBQXZCLENBQWlDcTJCLEtBQWpDLEdBQXlDLFlBQVksQ0FBRSxDQUF2RDs7QUFFQWdLLHVDQUF1QnJnQyxTQUF2QixDQUFpQzR6QixpQkFBakMsR0FBcUQsVUFBVXh2QixLQUFWLEVBQWlCNUQsS0FBakIsRUFBd0I7QUFDekUseUJBQUs4MUIsT0FBTCxDQUFhOTFCLEtBQWIsSUFBc0I0RCxLQUF0QjtBQUNBLHdCQUFJb3lCLGdCQUFnQixFQUFFLEtBQUtDLGNBQTNCO0FBQ0Esd0JBQUlELGlCQUFpQixLQUFLeFcsT0FBMUIsRUFBbUM7QUFDL0IsNEJBQUl4Z0IsR0FBSjtBQUNBLDRCQUFJLEtBQUsrZ0MsTUFBVCxFQUFpQjtBQUNiL2dDLGtDQUFNNGdDLGFBQWEsS0FBSzlKLE9BQWxCLENBQU47QUFDSCx5QkFGRCxNQUVPO0FBQ0g5MkIsa0NBQU0sRUFBTjtBQUNBLGdDQUFJZ2hDLFlBQVksS0FBS2poQyxNQUFMLEVBQWhCO0FBQ0EsaUNBQUssSUFBSUYsSUFBSSxDQUFSLEVBQVcyVyxNQUFNLEtBQUt6VyxNQUFMLEVBQXRCLEVBQXFDRixJQUFJMlcsR0FBekMsRUFBOEMsRUFBRTNXLENBQWhELEVBQW1EO0FBQy9DRyxvQ0FBSSxLQUFLODJCLE9BQUwsQ0FBYWozQixJQUFJbWhDLFNBQWpCLENBQUosSUFBbUMsS0FBS2xLLE9BQUwsQ0FBYWozQixDQUFiLENBQW5DO0FBQ0g7QUFDSjtBQUNELDZCQUFLcTNCLFFBQUwsQ0FBY2wzQixHQUFkO0FBQ0EsK0JBQU8sSUFBUDtBQUNIO0FBQ0QsMkJBQU8sS0FBUDtBQUNILGlCQWxCRDs7QUFvQkE2Z0MsdUNBQXVCcmdDLFNBQXZCLENBQWlDNjhCLGdCQUFqQyxHQUFvRCxZQUFZO0FBQzVELDJCQUFPLEtBQVA7QUFDSCxpQkFGRDs7QUFJQXdELHVDQUF1QnJnQyxTQUF2QixDQUFpQzQ4QixlQUFqQyxHQUFtRCxVQUFVNW1CLEdBQVYsRUFBZTtBQUM5RCwyQkFBT0EsT0FBTyxDQUFkO0FBQ0gsaUJBRkQ7O0FBSUEseUJBQVM5SSxLQUFULENBQWVvTCxRQUFmLEVBQXlCO0FBQ3JCLHdCQUFJQyxHQUFKO0FBQ0Esd0JBQUlrb0IsWUFBWXJsQixvQkFBb0I5QyxRQUFwQixDQUFoQjs7QUFFQSx3QkFBSSxDQUFDeFosU0FBUzJoQyxTQUFULENBQUwsRUFBMEI7QUFDdEIsK0JBQU9saUIsYUFBYSwyRUFBYixDQUFQO0FBQ0gscUJBRkQsTUFFTyxJQUFJa2lCLHFCQUFxQnY0QixPQUF6QixFQUFrQztBQUNyQ3FRLDhCQUFNa29CLFVBQVUza0IsS0FBVixDQUNGNVQsUUFBUWdGLEtBRE4sRUFDYTFILFNBRGIsRUFDd0JBLFNBRHhCLEVBQ21DQSxTQURuQyxFQUM4Q0EsU0FEOUMsQ0FBTjtBQUVILHFCQUhNLE1BR0E7QUFDSCtTLDhCQUFNLElBQUk4bkIsc0JBQUosQ0FBMkJJLFNBQTNCLEVBQXNDL3JCLE9BQXRDLEVBQU47QUFDSDs7QUFFRCx3QkFBSStyQixxQkFBcUJ2NEIsT0FBekIsRUFBa0M7QUFDOUJxUSw0QkFBSTZELGNBQUosQ0FBbUJxa0IsU0FBbkIsRUFBOEIsQ0FBOUI7QUFDSDtBQUNELDJCQUFPbG9CLEdBQVA7QUFDSDs7QUFFRHJRLHdCQUFRbEksU0FBUixDQUFrQmtOLEtBQWxCLEdBQTBCLFlBQVk7QUFDbEMsMkJBQU9BLE1BQU0sSUFBTixDQUFQO0FBQ0gsaUJBRkQ7O0FBSUFoRix3QkFBUWdGLEtBQVIsR0FBZ0IsVUFBVW9MLFFBQVYsRUFBb0I7QUFDaEMsMkJBQU9wTCxNQUFNb0wsUUFBTixDQUFQO0FBQ0gsaUJBRkQ7QUFHQyxhQXBIRDtBQXNIQyxTQXhIaUQsRUF3SGhELEVBQUMsU0FBUSxFQUFULEVBQVksVUFBUyxFQUFyQixFQXhIZ0QsQ0E5Nkg4c0IsRUFzaUlwdUIsSUFBRyxDQUFDLFVBQVNMLE9BQVQsRUFBaUJwYSxNQUFqQixFQUF3QkMsT0FBeEIsRUFBZ0M7QUFDaEU7O0FBQ0EscUJBQVM0aUMsU0FBVCxDQUFtQkMsR0FBbkIsRUFBd0JueUIsUUFBeEIsRUFBa0NveUIsR0FBbEMsRUFBdUNDLFFBQXZDLEVBQWlEN3FCLEdBQWpELEVBQXNEO0FBQ2xELHFCQUFLLElBQUl1TCxJQUFJLENBQWIsRUFBZ0JBLElBQUl2TCxHQUFwQixFQUF5QixFQUFFdUwsQ0FBM0IsRUFBOEI7QUFDMUJxZix3QkFBSXJmLElBQUlzZixRQUFSLElBQW9CRixJQUFJcGYsSUFBSS9TLFFBQVIsQ0FBcEI7QUFDQW15Qix3QkFBSXBmLElBQUkvUyxRQUFSLElBQW9CLEtBQUssQ0FBekI7QUFDSDtBQUNKOztBQUVELHFCQUFTcUssS0FBVCxDQUFlaW9CLFFBQWYsRUFBeUI7QUFDckIscUJBQUtDLFNBQUwsR0FBaUJELFFBQWpCO0FBQ0EscUJBQUs5Z0IsT0FBTCxHQUFlLENBQWY7QUFDQSxxQkFBS2doQixNQUFMLEdBQWMsQ0FBZDtBQUNIOztBQUVEbm9CLGtCQUFNN1ksU0FBTixDQUFnQmloQyxtQkFBaEIsR0FBc0MsVUFBVXQ3QixJQUFWLEVBQWdCO0FBQ2xELHVCQUFPLEtBQUtvN0IsU0FBTCxHQUFpQnA3QixJQUF4QjtBQUNILGFBRkQ7O0FBSUFrVCxrQkFBTTdZLFNBQU4sQ0FBZ0IyYSxRQUFoQixHQUEyQixVQUFVNVUsR0FBVixFQUFlO0FBQ3RDLG9CQUFJeEcsU0FBUyxLQUFLQSxNQUFMLEVBQWI7QUFDQSxxQkFBSzJoQyxjQUFMLENBQW9CM2hDLFNBQVMsQ0FBN0I7QUFDQSxvQkFBSUYsSUFBSyxLQUFLMmhDLE1BQUwsR0FBY3poQyxNQUFmLEdBQTBCLEtBQUt3aEMsU0FBTCxHQUFpQixDQUFuRDtBQUNBLHFCQUFLMWhDLENBQUwsSUFBVTBHLEdBQVY7QUFDQSxxQkFBS2lhLE9BQUwsR0FBZXpnQixTQUFTLENBQXhCO0FBQ0gsYUFORDs7QUFRQXNaLGtCQUFNN1ksU0FBTixDQUFnQnFLLElBQWhCLEdBQXVCLFVBQVVoSyxFQUFWLEVBQWNrYSxRQUFkLEVBQXdCeFUsR0FBeEIsRUFBNkI7QUFDaEQsb0JBQUl4RyxTQUFTLEtBQUtBLE1BQUwsS0FBZ0IsQ0FBN0I7QUFDQSxvQkFBSSxLQUFLMGhDLG1CQUFMLENBQXlCMWhDLE1BQXpCLENBQUosRUFBc0M7QUFDbEMseUJBQUtvYixRQUFMLENBQWN0YSxFQUFkO0FBQ0EseUJBQUtzYSxRQUFMLENBQWNKLFFBQWQ7QUFDQSx5QkFBS0ksUUFBTCxDQUFjNVUsR0FBZDtBQUNBO0FBQ0g7QUFDRCxvQkFBSXdiLElBQUksS0FBS3lmLE1BQUwsR0FBY3poQyxNQUFkLEdBQXVCLENBQS9CO0FBQ0EscUJBQUsyaEMsY0FBTCxDQUFvQjNoQyxNQUFwQjtBQUNBLG9CQUFJNGhDLFdBQVcsS0FBS0osU0FBTCxHQUFpQixDQUFoQztBQUNBLHFCQUFNeGYsSUFBSSxDQUFMLEdBQVU0ZixRQUFmLElBQTJCOWdDLEVBQTNCO0FBQ0EscUJBQU1raEIsSUFBSSxDQUFMLEdBQVU0ZixRQUFmLElBQTJCNW1CLFFBQTNCO0FBQ0EscUJBQU1nSCxJQUFJLENBQUwsR0FBVTRmLFFBQWYsSUFBMkJwN0IsR0FBM0I7QUFDQSxxQkFBS2lhLE9BQUwsR0FBZXpnQixNQUFmO0FBQ0gsYUFmRDs7QUFpQkFzWixrQkFBTTdZLFNBQU4sQ0FBZ0JpYixLQUFoQixHQUF3QixZQUFZO0FBQ2hDLG9CQUFJbW1CLFFBQVEsS0FBS0osTUFBakI7QUFBQSxvQkFDSXpvQixNQUFNLEtBQUs2b0IsS0FBTCxDQURWOztBQUdBLHFCQUFLQSxLQUFMLElBQWM1N0IsU0FBZDtBQUNBLHFCQUFLdzdCLE1BQUwsR0FBZUksUUFBUSxDQUFULEdBQWUsS0FBS0wsU0FBTCxHQUFpQixDQUE5QztBQUNBLHFCQUFLL2dCLE9BQUw7QUFDQSx1QkFBT3pILEdBQVA7QUFDSCxhQVJEOztBQVVBTSxrQkFBTTdZLFNBQU4sQ0FBZ0JULE1BQWhCLEdBQXlCLFlBQVk7QUFDakMsdUJBQU8sS0FBS3lnQixPQUFaO0FBQ0gsYUFGRDs7QUFJQW5ILGtCQUFNN1ksU0FBTixDQUFnQmtoQyxjQUFoQixHQUFpQyxVQUFVdjdCLElBQVYsRUFBZ0I7QUFDN0Msb0JBQUksS0FBS283QixTQUFMLEdBQWlCcDdCLElBQXJCLEVBQTJCO0FBQ3ZCLHlCQUFLMDdCLFNBQUwsQ0FBZSxLQUFLTixTQUFMLElBQWtCLENBQWpDO0FBQ0g7QUFDSixhQUpEOztBQU1BbG9CLGtCQUFNN1ksU0FBTixDQUFnQnFoQyxTQUFoQixHQUE0QixVQUFVUCxRQUFWLEVBQW9CO0FBQzVDLG9CQUFJUSxjQUFjLEtBQUtQLFNBQXZCO0FBQ0EscUJBQUtBLFNBQUwsR0FBaUJELFFBQWpCO0FBQ0Esb0JBQUlNLFFBQVEsS0FBS0osTUFBakI7QUFDQSxvQkFBSXpoQyxTQUFTLEtBQUt5Z0IsT0FBbEI7QUFDQSxvQkFBSXVoQixpQkFBa0JILFFBQVE3aEMsTUFBVCxHQUFvQitoQyxjQUFjLENBQXZEO0FBQ0FaLDBCQUFVLElBQVYsRUFBZ0IsQ0FBaEIsRUFBbUIsSUFBbkIsRUFBeUJZLFdBQXpCLEVBQXNDQyxjQUF0QztBQUNILGFBUEQ7O0FBU0ExakMsbUJBQU9DLE9BQVAsR0FBaUIrYSxLQUFqQjtBQUVDLFNBM0U4QixFQTJFN0IsRUEzRTZCLENBdGlJaXVCLEVBaW5JMXZCLElBQUcsQ0FBQyxVQUFTWixPQUFULEVBQWlCcGEsTUFBakIsRUFBd0JDLE9BQXhCLEVBQWdDO0FBQzFDOztBQUNBRCxtQkFBT0MsT0FBUCxHQUFpQixVQUNib0ssT0FEYSxFQUNKaVQsUUFESSxFQUNNQyxtQkFETixFQUMyQm1ELFlBRDNCLEVBQ3lDO0FBQzFELG9CQUFJekYsT0FBT2IsUUFBUSxRQUFSLENBQVg7O0FBRUEsb0JBQUl1cEIsWUFBWSxTQUFaQSxTQUFZLENBQVU5c0IsT0FBVixFQUFtQjtBQUMvQiwyQkFBT0EsUUFBUUMsSUFBUixDQUFhLFVBQVNqUSxLQUFULEVBQWdCO0FBQ2hDLCtCQUFPKzhCLEtBQUsvOEIsS0FBTCxFQUFZZ1EsT0FBWixDQUFQO0FBQ0gscUJBRk0sQ0FBUDtBQUdILGlCQUpEOztBQU1BLHlCQUFTK3NCLElBQVQsQ0FBY25wQixRQUFkLEVBQXdCK0csTUFBeEIsRUFBZ0M7QUFDNUIsd0JBQUk3QyxlQUFlcEIsb0JBQW9COUMsUUFBcEIsQ0FBbkI7O0FBRUEsd0JBQUlrRSx3QkFBd0J0VSxPQUE1QixFQUFxQztBQUNqQywrQkFBT3M1QixVQUFVaGxCLFlBQVYsQ0FBUDtBQUNILHFCQUZELE1BRU87QUFDSGxFLG1DQUFXUSxLQUFLMmpCLE9BQUwsQ0FBYW5rQixRQUFiLENBQVg7QUFDQSw0QkFBSUEsYUFBYSxJQUFqQixFQUNJLE9BQU9pRyxhQUFhLHNEQUFzRHpGLEtBQUtpRixXQUFMLENBQWlCekYsUUFBakIsQ0FBbkUsQ0FBUDtBQUNQOztBQUVELHdCQUFJQyxNQUFNLElBQUlyUSxPQUFKLENBQVlpVCxRQUFaLENBQVY7QUFDQSx3QkFBSWtFLFdBQVc3WixTQUFmLEVBQTBCO0FBQ3RCK1MsNEJBQUk2RCxjQUFKLENBQW1CaUQsTUFBbkIsRUFBMkIsQ0FBM0I7QUFDSDtBQUNELHdCQUFJdWIsVUFBVXJpQixJQUFJK2EsUUFBbEI7QUFDQSx3QkFBSWpoQixTQUFTa0csSUFBSWtELE9BQWpCO0FBQ0EseUJBQUssSUFBSXBjLElBQUksQ0FBUixFQUFXMlcsTUFBTXNDLFNBQVMvWSxNQUEvQixFQUF1Q0YsSUFBSTJXLEdBQTNDLEVBQWdELEVBQUUzVyxDQUFsRCxFQUFxRDtBQUNqRCw0QkFBSUcsTUFBTThZLFNBQVNqWixDQUFULENBQVY7O0FBRUEsNEJBQUlHLFFBQVFnRyxTQUFSLElBQXFCLEVBQUVuRyxLQUFLaVosUUFBUCxDQUF6QixFQUEyQztBQUN2QztBQUNIOztBQUVEcFEsZ0NBQVFxeEIsSUFBUixDQUFhLzVCLEdBQWIsRUFBa0JzYyxLQUFsQixDQUF3QjhlLE9BQXhCLEVBQWlDdm9CLE1BQWpDLEVBQXlDN00sU0FBekMsRUFBb0QrUyxHQUFwRCxFQUF5RCxJQUF6RDtBQUNIO0FBQ0QsMkJBQU9BLEdBQVA7QUFDSDs7QUFFRHJRLHdCQUFRdTVCLElBQVIsR0FBZSxVQUFVbnBCLFFBQVYsRUFBb0I7QUFDL0IsMkJBQU9tcEIsS0FBS25wQixRQUFMLEVBQWU5UyxTQUFmLENBQVA7QUFDSCxpQkFGRDs7QUFJQTBDLHdCQUFRbEksU0FBUixDQUFrQnloQyxJQUFsQixHQUF5QixZQUFZO0FBQ2pDLDJCQUFPQSxLQUFLLElBQUwsRUFBV2o4QixTQUFYLENBQVA7QUFDSCxpQkFGRDtBQUlDLGFBL0NEO0FBaURDLFNBbkRRLEVBbURQLEVBQUMsVUFBUyxFQUFWLEVBbkRPLENBam5JdXZCLEVBb3FJL3VCLElBQUcsQ0FBQyxVQUFTeVMsT0FBVCxFQUFpQnBhLE1BQWpCLEVBQXdCQyxPQUF4QixFQUFnQztBQUNyRDs7QUFDQUQsbUJBQU9DLE9BQVAsR0FBaUIsVUFBU29LLE9BQVQsRUFDU29XLFlBRFQsRUFFU0MsWUFGVCxFQUdTbkQsbUJBSFQsRUFJU0QsUUFKVCxFQUtTRSxLQUxULEVBS2dCO0FBQ2pDLG9CQUFJdUgsWUFBWTFhLFFBQVEyYSxVQUF4QjtBQUNBLG9CQUFJL0osT0FBT2IsUUFBUSxRQUFSLENBQVg7QUFDQSxvQkFBSXVHLFdBQVcxRixLQUFLMEYsUUFBcEI7O0FBRUEseUJBQVNrakIscUJBQVQsQ0FBK0JwcEIsUUFBL0IsRUFBeUNqWSxFQUF6QyxFQUE2Q3NoQyxZQUE3QyxFQUEyREMsS0FBM0QsRUFBa0U7QUFDOUQseUJBQUsvTCxZQUFMLENBQWtCdmQsUUFBbEI7QUFDQSx3QkFBSXdNLFNBQVNsQyxXQUFiO0FBQ0EseUJBQUtpZixHQUFMLEdBQVcvYyxXQUFXLElBQVgsR0FBa0J6a0IsRUFBbEIsR0FBdUJ5WSxLQUFLaU0sVUFBTCxDQUFnQkQsTUFBaEIsRUFBd0J6a0IsRUFBeEIsQ0FBbEM7QUFDQSx3QkFBSXNoQyxpQkFBaUJuOEIsU0FBckIsRUFBZ0M7QUFDNUJtOEIsdUNBQWV6NUIsUUFBUTZJLE9BQVIsQ0FBZ0I0d0IsWUFBaEIsQ0FBZjtBQUNBQSxxQ0FBYS9aLDJCQUFiLENBQXlDLElBQXpDO0FBQ0g7QUFDRCx5QkFBS2thLGFBQUwsR0FBcUJILFlBQXJCO0FBQ0EseUJBQUtJLG1CQUFMLEdBQTJCLElBQTNCO0FBQ0Esd0JBQUdILFVBQVV6bUIsUUFBYixFQUF1QjtBQUNuQiw2QkFBSzZtQixXQUFMLEdBQW1CMWhDLE1BQU0sS0FBSzBmLE9BQVgsQ0FBbkI7QUFDSCxxQkFGRCxNQUVPLElBQUk0aEIsVUFBVSxDQUFkLEVBQWlCO0FBQ3BCLDZCQUFLSSxXQUFMLEdBQW1CLElBQW5CO0FBQ0gscUJBRk0sTUFFQTtBQUNILDZCQUFLQSxXQUFMLEdBQW1CeDhCLFNBQW5CO0FBQ0g7QUFDRCx5QkFBS290QixRQUFMLENBQWN4TixrQkFBZDtBQUNBLHlCQUFLZ1IsTUFBTCxDQUFZNXdCLFNBQVosRUFBdUIsQ0FBQyxDQUF4QjtBQUNIO0FBQ0RzVCxxQkFBSzhULFFBQUwsQ0FBYzhVLHFCQUFkLEVBQXFDcGpCLFlBQXJDOztBQUVBb2pCLHNDQUFzQjFoQyxTQUF0QixDQUFnQ2lpQyxTQUFoQyxHQUE0QyxVQUFTQyxLQUFULEVBQWdCO0FBQ3hELHdCQUFJLEtBQUtGLFdBQUwsS0FBcUJ4OEIsU0FBckIsSUFDQSxLQUFLdzhCLFdBQUwsS0FBcUIsSUFEckIsSUFFQUUsVUFBVS9tQixRQUZkLEVBRXdCO0FBQ3BCLDZCQUFLNm1CLFdBQUwsQ0FBaUIzM0IsSUFBakIsQ0FBc0I2M0IsS0FBdEI7QUFDSDtBQUNKLGlCQU5EOztBQVFBUixzQ0FBc0IxaEMsU0FBdEIsQ0FBZ0NtaUMsYUFBaEMsR0FBZ0QsVUFBUy85QixLQUFULEVBQWdCO0FBQzVELHdCQUFJLEtBQUs0OUIsV0FBTCxLQUFxQixJQUF6QixFQUErQjtBQUMzQiw2QkFBS0EsV0FBTCxDQUFpQjMzQixJQUFqQixDQUFzQmpHLEtBQXRCO0FBQ0g7QUFDRCwyQkFBTyxLQUFLNDlCLFdBQVo7QUFDSCxpQkFMRDs7QUFPQU4sc0NBQXNCMWhDLFNBQXRCLENBQWdDcTJCLEtBQWhDLEdBQXdDLFlBQVcsQ0FBRSxDQUFyRDs7QUFFQXFMLHNDQUFzQjFoQyxTQUF0QixDQUFnQzA4QixrQkFBaEMsR0FBcUQsWUFBVztBQUM1RCx5QkFBS2hHLFFBQUwsQ0FBYyxLQUFLc0wsV0FBTCxLQUFxQng4QixTQUFyQixHQUFpQyxLQUFLdzhCLFdBQXRDLEdBQ2lDLEtBQUtGLGFBRHBEO0FBRUgsaUJBSEQ7O0FBS0FKLHNDQUFzQjFoQyxTQUF0QixDQUFnQzY4QixnQkFBaEMsR0FBbUQsWUFBWTtBQUMzRCwyQkFBTyxLQUFQO0FBQ0gsaUJBRkQ7O0FBSUE2RSxzQ0FBc0IxaEMsU0FBdEIsQ0FBZ0MwMkIsUUFBaEMsR0FBMkMsVUFBU3R5QixLQUFULEVBQWdCO0FBQ3ZELHlCQUFLd3VCLFFBQUwsQ0FBYzNXLGdCQUFkLENBQStCN1gsS0FBL0I7QUFDQSx5QkFBS2t5QixPQUFMLEdBQWUsSUFBZjtBQUNILGlCQUhEOztBQUtBb0wsc0NBQXNCMWhDLFNBQXRCLENBQWdDMmdCLGdCQUFoQyxHQUFtRCxVQUFTeWhCLE1BQVQsRUFBaUI7QUFDaEUsd0JBQUlBLFdBQVcsS0FBS04sYUFBcEIsRUFBbUMsT0FBTyxLQUFLamlCLE9BQUwsRUFBUDtBQUNuQyx3QkFBSSxLQUFLdVQsV0FBTCxFQUFKLEVBQXdCO0FBQ3hCLHlCQUFLaVAsaUJBQUw7QUFDQSx3QkFBSSxLQUFLTixtQkFBTCxZQUFvQzc1QixPQUF4QyxFQUFpRDtBQUM3Qyw2QkFBSzY1QixtQkFBTCxDQUF5Qm5qQixNQUF6QjtBQUNIO0FBQ0Qsd0JBQUksS0FBS2tqQixhQUFMLFlBQThCNTVCLE9BQWxDLEVBQTJDO0FBQ3ZDLDZCQUFLNDVCLGFBQUwsQ0FBbUJsakIsTUFBbkI7QUFDSDtBQUNKLGlCQVZEOztBQVlBOGlCLHNDQUFzQjFoQyxTQUF0QixDQUFnQzI4QixRQUFoQyxHQUEyQyxVQUFVOTNCLE1BQVYsRUFBa0I7QUFDekQseUJBQUt5eEIsT0FBTCxHQUFlenhCLE1BQWY7QUFDQSx3QkFBSVQsS0FBSjtBQUNBLHdCQUFJL0UsQ0FBSjtBQUNBLHdCQUFJRSxTQUFTc0YsT0FBT3RGLE1BQXBCO0FBQ0Esd0JBQUksS0FBS3VpQyxhQUFMLEtBQXVCdDhCLFNBQTNCLEVBQXNDO0FBQ2xDcEIsZ0NBQVEsS0FBSzA5QixhQUFiO0FBQ0F6aUMsNEJBQUksQ0FBSjtBQUNILHFCQUhELE1BR087QUFDSCtFLGdDQUFROEQsUUFBUTZJLE9BQVIsQ0FBZ0JsTSxPQUFPLENBQVAsQ0FBaEIsQ0FBUjtBQUNBeEYsNEJBQUksQ0FBSjtBQUNIOztBQUVELHlCQUFLMGlDLG1CQUFMLEdBQTJCMzlCLEtBQTNCOztBQUVBLHdCQUFJLENBQUNBLE1BQU11dEIsVUFBTixFQUFMLEVBQXlCO0FBQ3JCLCtCQUFPdHlCLElBQUlFLE1BQVgsRUFBbUIsRUFBRUYsQ0FBckIsRUFBd0I7QUFDcEIsZ0NBQUlzakIsTUFBTTtBQUNOdWYsdUNBQU8sSUFERDtBQUVOOTlCLHVDQUFPUyxPQUFPeEYsQ0FBUCxDQUZEO0FBR05tQix1Q0FBT25CLENBSEQ7QUFJTkUsd0NBQVFBLE1BSkY7QUFLTm1GLHVDQUFPO0FBTEQsNkJBQVY7QUFPQU4sb0NBQVFBLE1BQU0wWCxLQUFOLENBQVl3bUIsUUFBWixFQUFzQjk4QixTQUF0QixFQUFpQ0EsU0FBakMsRUFBNENtZCxHQUE1QyxFQUFpRG5kLFNBQWpELENBQVI7QUFDSDtBQUNKOztBQUVELHdCQUFJLEtBQUt3OEIsV0FBTCxLQUFxQng4QixTQUF6QixFQUFvQztBQUNoQ3BCLGdDQUFRQSxNQUNIMFgsS0FERyxDQUNHLEtBQUtxbUIsYUFEUixFQUN1QjM4QixTQUR2QixFQUNrQ0EsU0FEbEMsRUFDNkMsSUFEN0MsRUFDbURBLFNBRG5ELENBQVI7QUFFSDtBQUNEcEIsMEJBQU0wWCxLQUFOLENBQVl5bUIsU0FBWixFQUF1QkEsU0FBdkIsRUFBa0MvOEIsU0FBbEMsRUFBNkNwQixLQUE3QyxFQUFvRCxJQUFwRDtBQUNILGlCQWpDRDs7QUFtQ0E4RCx3QkFBUWxJLFNBQVIsQ0FBa0J1dUIsTUFBbEIsR0FBMkIsVUFBVWx1QixFQUFWLEVBQWNzaEMsWUFBZCxFQUE0QjtBQUNuRCwyQkFBT3BULE9BQU8sSUFBUCxFQUFhbHVCLEVBQWIsRUFBaUJzaEMsWUFBakIsRUFBK0IsSUFBL0IsQ0FBUDtBQUNILGlCQUZEOztBQUlBejVCLHdCQUFRcW1CLE1BQVIsR0FBaUIsVUFBVWpXLFFBQVYsRUFBb0JqWSxFQUFwQixFQUF3QnNoQyxZQUF4QixFQUFzQ0MsS0FBdEMsRUFBNkM7QUFDMUQsMkJBQU9yVCxPQUFPalcsUUFBUCxFQUFpQmpZLEVBQWpCLEVBQXFCc2hDLFlBQXJCLEVBQW1DQyxLQUFuQyxDQUFQO0FBQ0gsaUJBRkQ7O0FBSUEseUJBQVNXLFNBQVQsQ0FBbUJDLGFBQW5CLEVBQWtDOTlCLEtBQWxDLEVBQXlDO0FBQ3JDLHdCQUFJLEtBQUtna0IsV0FBTCxFQUFKLEVBQXdCO0FBQ3BCaGtCLDhCQUFNZ3lCLFFBQU4sQ0FBZThMLGFBQWY7QUFDSCxxQkFGRCxNQUVPO0FBQ0g5OUIsOEJBQU0rVyxPQUFOLENBQWMrbUIsYUFBZDtBQUNIO0FBQ0o7O0FBRUQseUJBQVNqVSxNQUFULENBQWdCalcsUUFBaEIsRUFBMEJqWSxFQUExQixFQUE4QnNoQyxZQUE5QixFQUE0Q0MsS0FBNUMsRUFBbUQ7QUFDL0Msd0JBQUksT0FBT3ZoQyxFQUFQLEtBQWMsVUFBbEIsRUFBOEI7QUFDMUIsK0JBQU9rZSxhQUFhLGtDQUFrQ3pGLEtBQUtpRixXQUFMLENBQWlCMWQsRUFBakIsQ0FBL0MsQ0FBUDtBQUNIO0FBQ0Qsd0JBQUlxRSxRQUFRLElBQUlnOUIscUJBQUosQ0FBMEJwcEIsUUFBMUIsRUFBb0NqWSxFQUFwQyxFQUF3Q3NoQyxZQUF4QyxFQUFzREMsS0FBdEQsQ0FBWjtBQUNBLDJCQUFPbDlCLE1BQU1nUSxPQUFOLEVBQVA7QUFDSDs7QUFFRCx5QkFBUzR0QixRQUFULENBQWtCSixLQUFsQixFQUF5QjtBQUNyQix5QkFBS0EsS0FBTCxHQUFhQSxLQUFiO0FBQ0EseUJBQUt4OUIsS0FBTCxDQUFXdTlCLFNBQVgsQ0FBcUJDLEtBQXJCO0FBQ0Esd0JBQUk5OUIsUUFBUWdYLG9CQUFvQixLQUFLaFgsS0FBekIsRUFBZ0MsS0FBS00sS0FBTCxDQUFXa3VCLFFBQTNDLENBQVo7QUFDQSx3QkFBSXh1QixpQkFBaUI4RCxPQUFyQixFQUE4QjtBQUMxQiw2QkFBS3hELEtBQUwsQ0FBV3E5QixtQkFBWCxHQUFpQzM5QixLQUFqQztBQUNBLCtCQUFPQSxNQUFNMFgsS0FBTixDQUFZMm1CLFFBQVosRUFBc0JqOUIsU0FBdEIsRUFBaUNBLFNBQWpDLEVBQTRDLElBQTVDLEVBQWtEQSxTQUFsRCxDQUFQO0FBQ0gscUJBSEQsTUFHTztBQUNILCtCQUFPaTlCLFNBQVN0aUMsSUFBVCxDQUFjLElBQWQsRUFBb0JpRSxLQUFwQixDQUFQO0FBQ0g7QUFDSjs7QUFFRCx5QkFBU3ErQixRQUFULENBQWtCcitCLEtBQWxCLEVBQXlCO0FBQ3JCLHdCQUFJTSxRQUFRLEtBQUtBLEtBQWpCO0FBQ0Esd0JBQUlnUSxVQUFVaFEsTUFBTWt1QixRQUFwQjtBQUNBLHdCQUFJdnlCLEtBQUttZSxTQUFTOVosTUFBTW05QixHQUFmLENBQVQ7QUFDQW50Qiw0QkFBUWlOLFlBQVI7QUFDQSx3QkFBSXBKLEdBQUo7QUFDQSx3QkFBSTdULE1BQU1zOUIsV0FBTixLQUFzQng4QixTQUExQixFQUFxQztBQUNqQytTLDhCQUFNbFksR0FBR0YsSUFBSCxDQUFRdVUsUUFBUTRILFdBQVIsRUFBUixFQUErQmxZLEtBQS9CLEVBQXNDLEtBQUs1RCxLQUEzQyxFQUFrRCxLQUFLakIsTUFBdkQsQ0FBTjtBQUNILHFCQUZELE1BRU87QUFDSGdaLDhCQUFNbFksR0FBR0YsSUFBSCxDQUFRdVUsUUFBUTRILFdBQVIsRUFBUixFQUNnQixLQUFLNGxCLEtBRHJCLEVBQzRCOTlCLEtBRDVCLEVBQ21DLEtBQUs1RCxLQUR4QyxFQUMrQyxLQUFLakIsTUFEcEQsQ0FBTjtBQUVIO0FBQ0Qsd0JBQUlnWixlQUFlclEsT0FBbkIsRUFBNEI7QUFDeEJ4RCw4QkFBTXE5QixtQkFBTixHQUE0QnhwQixHQUE1QjtBQUNIO0FBQ0Qsd0JBQUlrTyxpQkFBaUIvUixRQUFRa04sV0FBUixFQUFyQjtBQUNBdkcsMEJBQU04TixxQkFBTixDQUNJNVEsR0FESixFQUVJa08sY0FGSixFQUdJL2hCLE1BQU1zOUIsV0FBTixLQUFzQng4QixTQUF0QixHQUFrQyxjQUFsQyxHQUFtRCxnQkFIdkQsRUFJSWtQLE9BSko7QUFNQSwyQkFBTzZELEdBQVA7QUFDSDtBQUNBLGFBMUtEO0FBNEtDLFNBOUttQixFQThLbEIsRUFBQyxVQUFTLEVBQVYsRUE5S2tCLENBcHFJNHVCLEVBazFJL3VCLElBQUcsQ0FBQyxVQUFTTixPQUFULEVBQWlCcGEsTUFBakIsRUFBd0JDLE9BQXhCLEVBQWdDO0FBQ3JEOztBQUNBLGdCQUFJZ2IsT0FBT2IsUUFBUSxRQUFSLENBQVg7QUFDQSxnQkFBSVcsUUFBSjtBQUNBLGdCQUFJOHBCLG1CQUFtQixTQUFuQkEsZ0JBQW1CLEdBQVc7QUFDOUIsc0JBQU0sSUFBSXp0QixLQUFKLENBQVUsZ0VBQVYsQ0FBTjtBQUNILGFBRkQ7QUFHQSxnQkFBSTB0QixnQkFBZ0I3cEIsS0FBSzhwQixnQkFBTCxFQUFwQjtBQUNBLGdCQUFJOXBCLEtBQUttQixNQUFMLElBQWUsT0FBTzRvQixnQkFBUCxLQUE0QixXQUEvQyxFQUE0RDtBQUN4RCxvQkFBSUMscUJBQXFCeGtDLE9BQU95a0MsWUFBaEM7QUFDQSxvQkFBSUMsa0JBQWtCci9CLFFBQVF1UyxRQUE5QjtBQUNBMEMsMkJBQVdFLEtBQUttcUIsWUFBTCxHQUNHLFVBQVM1aUMsRUFBVCxFQUFhO0FBQUV5aUMsdUNBQW1CM2lDLElBQW5CLENBQXdCN0IsTUFBeEIsRUFBZ0MrQixFQUFoQztBQUFzQyxpQkFEeEQsR0FFRyxVQUFTQSxFQUFULEVBQWE7QUFBRTJpQyxvQ0FBZ0I3aUMsSUFBaEIsQ0FBcUJ3RCxPQUFyQixFQUE4QnRELEVBQTlCO0FBQW9DLGlCQUZqRTtBQUdILGFBTkQsTUFNTyxJQUFJLE9BQU9zaUMsYUFBUCxLQUF5QixVQUF6QixJQUNBLE9BQU9BLGNBQWM1eEIsT0FBckIsS0FBaUMsVUFEckMsRUFDaUQ7QUFDcEQsb0JBQUlteUIsZ0JBQWdCUCxjQUFjNXhCLE9BQWQsRUFBcEI7QUFDQTZILDJCQUFXLGtCQUFTdlksRUFBVCxFQUFhO0FBQ3BCNmlDLGtDQUFjdnVCLElBQWQsQ0FBbUJ0VSxFQUFuQjtBQUNILGlCQUZEO0FBR0gsYUFOTSxNQU1BLElBQUssT0FBT3dpQyxnQkFBUCxLQUE0QixXQUE3QixJQUNELEVBQUUsT0FBT2psQyxNQUFQLEtBQWtCLFdBQWxCLElBQ0FBLE9BQU91bEMsU0FEUCxLQUVDdmxDLE9BQU91bEMsU0FBUCxDQUFpQkMsVUFBakIsSUFBK0J4bEMsT0FBT3lsQyxPQUZ2QyxDQUFGLENBREgsRUFHdUQ7QUFDMUR6cUIsMkJBQVksWUFBVztBQUNuQix3QkFBSTBxQixNQUFNcGQsU0FBU3FkLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBVjtBQUNBLHdCQUFJbGMsT0FBTyxFQUFDblYsWUFBWSxJQUFiLEVBQVg7QUFDQSx3QkFBSXN4QixrQkFBa0IsS0FBdEI7QUFDQSx3QkFBSUMsT0FBT3ZkLFNBQVNxZCxhQUFULENBQXVCLEtBQXZCLENBQVg7QUFDQSx3QkFBSUcsS0FBSyxJQUFJYixnQkFBSixDQUFxQixZQUFXO0FBQ3JDUyw0QkFBSUssU0FBSixDQUFjQyxNQUFkLENBQXFCLEtBQXJCO0FBQ0FKLDBDQUFrQixLQUFsQjtBQUNILHFCQUhRLENBQVQ7QUFJQUUsdUJBQUdHLE9BQUgsQ0FBV0osSUFBWCxFQUFpQnBjLElBQWpCOztBQUVBLHdCQUFJeWMsaUJBQWlCLFNBQWpCQSxjQUFpQixHQUFXO0FBQzVCLDRCQUFJTixlQUFKLEVBQXFCO0FBQ3JCQSwwQ0FBa0IsSUFBbEI7QUFDQUMsNkJBQUtFLFNBQUwsQ0FBZUMsTUFBZixDQUFzQixLQUF0QjtBQUNILHFCQUpEOztBQU1BLDJCQUFPLFNBQVNockIsUUFBVCxDQUFrQnZZLEVBQWxCLEVBQXNCO0FBQ3pCLDRCQUFJZ1UsSUFBSSxJQUFJd3VCLGdCQUFKLENBQXFCLFlBQVc7QUFDcEN4dUIsOEJBQUUwdkIsVUFBRjtBQUNBMWpDO0FBQ0gseUJBSE8sQ0FBUjtBQUlBZ1UsMEJBQUV3dkIsT0FBRixDQUFVUCxHQUFWLEVBQWVqYyxJQUFmO0FBQ0F5YztBQUNILHFCQVBEO0FBUUgsaUJBekJVLEVBQVg7QUEwQkgsYUE5Qk0sTUE4QkEsSUFBSSxPQUFPZixZQUFQLEtBQXdCLFdBQTVCLEVBQXlDO0FBQzVDbnFCLDJCQUFXLGtCQUFVdlksRUFBVixFQUFjO0FBQ3JCMGlDLGlDQUFhMWlDLEVBQWI7QUFDSCxpQkFGRDtBQUdILGFBSk0sTUFJQSxJQUFJLE9BQU84VSxVQUFQLEtBQXNCLFdBQTFCLEVBQXVDO0FBQzFDeUQsMkJBQVcsa0JBQVV2WSxFQUFWLEVBQWM7QUFDckI4VSwrQkFBVzlVLEVBQVgsRUFBZSxDQUFmO0FBQ0gsaUJBRkQ7QUFHSCxhQUpNLE1BSUE7QUFDSHVZLDJCQUFXOHBCLGdCQUFYO0FBQ0g7QUFDRDdrQyxtQkFBT0MsT0FBUCxHQUFpQjhhLFFBQWpCO0FBRUMsU0EvRG1CLEVBK0RsQixFQUFDLFVBQVMsRUFBVixFQS9Ea0IsQ0FsMUk0dUIsRUFpNUkvdUIsSUFBRyxDQUFDLFVBQVNYLE9BQVQsRUFBaUJwYSxNQUFqQixFQUF3QkMsT0FBeEIsRUFBZ0M7QUFDckQ7O0FBQ0FELG1CQUFPQyxPQUFQLEdBQ0ksVUFBU29LLE9BQVQsRUFBa0JvVyxZQUFsQixFQUFnQ2pELEtBQWhDLEVBQXVDO0FBQzNDLG9CQUFJNmMsb0JBQW9CaHdCLFFBQVFnd0IsaUJBQWhDO0FBQ0Esb0JBQUlwZixPQUFPYixRQUFRLFFBQVIsQ0FBWDs7QUFFQSx5QkFBUytyQixtQkFBVCxDQUE2Qm4vQixNQUE3QixFQUFxQztBQUNqQyx5QkFBS2d4QixZQUFMLENBQWtCaHhCLE1BQWxCO0FBQ0g7QUFDRGlVLHFCQUFLOFQsUUFBTCxDQUFjb1gsbUJBQWQsRUFBbUMxbEIsWUFBbkM7O0FBRUEwbEIsb0NBQW9CaGtDLFNBQXBCLENBQThCaWtDLGdCQUE5QixHQUFpRCxVQUFVempDLEtBQVYsRUFBaUIwakMsVUFBakIsRUFBNkI7QUFDMUUseUJBQUs1TixPQUFMLENBQWE5MUIsS0FBYixJQUFzQjBqQyxVQUF0QjtBQUNBLHdCQUFJMU4sZ0JBQWdCLEVBQUUsS0FBS0MsY0FBM0I7QUFDQSx3QkFBSUQsaUJBQWlCLEtBQUt4VyxPQUExQixFQUFtQztBQUMvQiw2QkFBSzBXLFFBQUwsQ0FBYyxLQUFLSixPQUFuQjtBQUNBLCtCQUFPLElBQVA7QUFDSDtBQUNELDJCQUFPLEtBQVA7QUFDSCxpQkFSRDs7QUFVQTBOLG9DQUFvQmhrQyxTQUFwQixDQUE4QjR6QixpQkFBOUIsR0FBa0QsVUFBVXh2QixLQUFWLEVBQWlCNUQsS0FBakIsRUFBd0I7QUFDdEUsd0JBQUkrWCxNQUFNLElBQUkyZixpQkFBSixFQUFWO0FBQ0EzZix3QkFBSXlELFNBQUosR0FBZ0IsUUFBaEI7QUFDQXpELHdCQUFJNHJCLGtCQUFKLEdBQXlCLy9CLEtBQXpCO0FBQ0EsMkJBQU8sS0FBSzYvQixnQkFBTCxDQUFzQnpqQyxLQUF0QixFQUE2QitYLEdBQTdCLENBQVA7QUFDSCxpQkFMRDtBQU1BeXJCLG9DQUFvQmhrQyxTQUFwQixDQUE4Qjh6QixnQkFBOUIsR0FBaUQsVUFBVXpQLE1BQVYsRUFBa0I3akIsS0FBbEIsRUFBeUI7QUFDdEUsd0JBQUkrWCxNQUFNLElBQUkyZixpQkFBSixFQUFWO0FBQ0EzZix3QkFBSXlELFNBQUosR0FBZ0IsUUFBaEI7QUFDQXpELHdCQUFJNHJCLGtCQUFKLEdBQXlCOWYsTUFBekI7QUFDQSwyQkFBTyxLQUFLNGYsZ0JBQUwsQ0FBc0J6akMsS0FBdEIsRUFBNkIrWCxHQUE3QixDQUFQO0FBQ0gsaUJBTEQ7O0FBT0FyUSx3QkFBUWs4QixNQUFSLEdBQWlCLFVBQVU5ckIsUUFBVixFQUFvQjtBQUNqQytDLDBCQUFNME8sVUFBTixDQUFpQixXQUFqQixFQUE4QixZQUE5QjtBQUNBLDJCQUFPLElBQUlpYSxtQkFBSixDQUF3QjFyQixRQUF4QixFQUFrQzVELE9BQWxDLEVBQVA7QUFDSCxpQkFIRDs7QUFLQXhNLHdCQUFRbEksU0FBUixDQUFrQm9rQyxNQUFsQixHQUEyQixZQUFZO0FBQ25DLDJCQUFPbDhCLFFBQVFrOEIsTUFBUixDQUFlLElBQWYsQ0FBUDtBQUNILGlCQUZEO0FBR0MsYUF6Q0Q7QUEyQ0MsU0E3Q21CLEVBNkNsQixFQUFDLFVBQVMsRUFBVixFQTdDa0IsQ0FqNUk0dUIsRUE4N0kvdUIsSUFBRyxDQUFDLFVBQVNuc0IsT0FBVCxFQUFpQnBhLE1BQWpCLEVBQXdCQyxPQUF4QixFQUFnQztBQUNyRDs7QUFDQUQsbUJBQU9DLE9BQVAsR0FDQSxVQUFTb0ssT0FBVCxFQUFrQm9XLFlBQWxCLEVBQWdDQyxZQUFoQyxFQUE4QztBQUM5QyxvQkFBSXpGLE9BQU9iLFFBQVEsUUFBUixDQUFYO0FBQ0Esb0JBQUl3WCxhQUFheFgsUUFBUSxVQUFSLEVBQW9Cd1gsVUFBckM7QUFDQSxvQkFBSUQsaUJBQWlCdlgsUUFBUSxVQUFSLEVBQW9CdVgsY0FBekM7QUFDQSxvQkFBSWprQixVQUFVdU4sS0FBS3ZOLE9BQW5CO0FBQ0Esb0JBQUk4NEIsZUFBZSxFQUFuQjs7QUFHQSx5QkFBU2xzQixnQkFBVCxDQUEwQnRULE1BQTFCLEVBQWtDO0FBQzlCLHlCQUFLZ3hCLFlBQUwsQ0FBa0JoeEIsTUFBbEI7QUFDQSx5QkFBS3kvQixRQUFMLEdBQWdCLENBQWhCO0FBQ0EseUJBQUtDLE9BQUwsR0FBZSxLQUFmO0FBQ0EseUJBQUtDLFlBQUwsR0FBb0IsS0FBcEI7QUFDSDtBQUNEMXJCLHFCQUFLOFQsUUFBTCxDQUFjelUsZ0JBQWQsRUFBZ0NtRyxZQUFoQzs7QUFFQW5HLGlDQUFpQm5ZLFNBQWpCLENBQTJCcTJCLEtBQTNCLEdBQW1DLFlBQVk7QUFDM0Msd0JBQUksQ0FBQyxLQUFLbU8sWUFBVixFQUF3QjtBQUNwQjtBQUNIO0FBQ0Qsd0JBQUksS0FBS0YsUUFBTCxLQUFrQixDQUF0QixFQUF5QjtBQUNyQiw2QkFBSzVOLFFBQUwsQ0FBYyxFQUFkO0FBQ0E7QUFDSDtBQUNELHlCQUFLTixNQUFMLENBQVk1d0IsU0FBWixFQUF1QixDQUFDLENBQXhCO0FBQ0Esd0JBQUlpL0Isa0JBQWtCbDVCLFFBQVEsS0FBSytxQixPQUFiLENBQXRCO0FBQ0Esd0JBQUksQ0FBQyxLQUFLbEQsV0FBTCxFQUFELElBQ0FxUixlQURBLElBRUEsS0FBS0gsUUFBTCxHQUFnQixLQUFLSSxtQkFBTCxFQUZwQixFQUVnRDtBQUM1Qyw2QkFBS2pwQixPQUFMLENBQWEsS0FBS2twQixjQUFMLENBQW9CLEtBQUtwbEMsTUFBTCxFQUFwQixDQUFiO0FBQ0g7QUFDSixpQkFmRDs7QUFpQkE0WSxpQ0FBaUJuWSxTQUFqQixDQUEyQjBZLElBQTNCLEdBQWtDLFlBQVk7QUFDMUMseUJBQUs4ckIsWUFBTCxHQUFvQixJQUFwQjtBQUNBLHlCQUFLbk8sS0FBTDtBQUNILGlCQUhEOztBQUtBbGUsaUNBQWlCblksU0FBakIsQ0FBMkJ5WSxTQUEzQixHQUF1QyxZQUFZO0FBQy9DLHlCQUFLOHJCLE9BQUwsR0FBZSxJQUFmO0FBQ0gsaUJBRkQ7O0FBSUFwc0IsaUNBQWlCblksU0FBakIsQ0FBMkI0a0MsT0FBM0IsR0FBcUMsWUFBWTtBQUM3QywyQkFBTyxLQUFLTixRQUFaO0FBQ0gsaUJBRkQ7O0FBSUFuc0IsaUNBQWlCblksU0FBakIsQ0FBMkJ3WSxVQUEzQixHQUF3QyxVQUFVeW1CLEtBQVYsRUFBaUI7QUFDckQseUJBQUtxRixRQUFMLEdBQWdCckYsS0FBaEI7QUFDSCxpQkFGRDs7QUFJQTltQixpQ0FBaUJuWSxTQUFqQixDQUEyQjR6QixpQkFBM0IsR0FBK0MsVUFBVXh2QixLQUFWLEVBQWlCO0FBQzVELHlCQUFLeWdDLGFBQUwsQ0FBbUJ6Z0MsS0FBbkI7QUFDQSx3QkFBSSxLQUFLMGdDLFVBQUwsT0FBc0IsS0FBS0YsT0FBTCxFQUExQixFQUEwQztBQUN0Qyw2QkFBS3RPLE9BQUwsQ0FBYS8yQixNQUFiLEdBQXNCLEtBQUtxbEMsT0FBTCxFQUF0QjtBQUNBLDRCQUFJLEtBQUtBLE9BQUwsT0FBbUIsQ0FBbkIsSUFBd0IsS0FBS0wsT0FBakMsRUFBMEM7QUFDdEMsaUNBQUs3TixRQUFMLENBQWMsS0FBS0osT0FBTCxDQUFhLENBQWIsQ0FBZDtBQUNILHlCQUZELE1BRU87QUFDSCxpQ0FBS0ksUUFBTCxDQUFjLEtBQUtKLE9BQW5CO0FBQ0g7QUFDRCwrQkFBTyxJQUFQO0FBQ0g7QUFDRCwyQkFBTyxLQUFQO0FBRUgsaUJBYkQ7QUFjQW5lLGlDQUFpQm5ZLFNBQWpCLENBQTJCOHpCLGdCQUEzQixHQUE4QyxVQUFVelAsTUFBVixFQUFrQjtBQUM1RCx5QkFBSzBnQixZQUFMLENBQWtCMWdCLE1BQWxCO0FBQ0EsMkJBQU8sS0FBSzJnQixhQUFMLEVBQVA7QUFDSCxpQkFIRDs7QUFLQTdzQixpQ0FBaUJuWSxTQUFqQixDQUEyQnV6QixpQkFBM0IsR0FBK0MsWUFBWTtBQUN2RCx3QkFBSSxLQUFLK0MsT0FBTCxZQUF3QnB1QixPQUF4QixJQUFtQyxLQUFLb3VCLE9BQUwsSUFBZ0IsSUFBdkQsRUFBNkQ7QUFDekQsK0JBQU8sS0FBS3pXLE9BQUwsRUFBUDtBQUNIO0FBQ0QseUJBQUtrbEIsWUFBTCxDQUFrQlYsWUFBbEI7QUFDQSwyQkFBTyxLQUFLVyxhQUFMLEVBQVA7QUFDSCxpQkFORDs7QUFRQTdzQixpQ0FBaUJuWSxTQUFqQixDQUEyQmdsQyxhQUEzQixHQUEyQyxZQUFXO0FBQ2xELHdCQUFJLEtBQUtKLE9BQUwsS0FBaUIsS0FBS0YsbUJBQUwsRUFBckIsRUFBaUQ7QUFDN0MsNEJBQUkvbUMsSUFBSSxJQUFJNnhCLGNBQUosRUFBUjtBQUNBLDZCQUFLLElBQUlud0IsSUFBSSxLQUFLRSxNQUFMLEVBQWIsRUFBNEJGLElBQUksS0FBS2kzQixPQUFMLENBQWEvMkIsTUFBN0MsRUFBcUQsRUFBRUYsQ0FBdkQsRUFBMEQ7QUFDdEQsZ0NBQUksS0FBS2kzQixPQUFMLENBQWFqM0IsQ0FBYixNQUFvQmdsQyxZQUF4QixFQUFzQztBQUNsQzFtQyxrQ0FBRTBNLElBQUYsQ0FBTyxLQUFLaXNCLE9BQUwsQ0FBYWozQixDQUFiLENBQVA7QUFDSDtBQUNKO0FBQ0QsNEJBQUkxQixFQUFFNEIsTUFBRixHQUFXLENBQWYsRUFBa0I7QUFDZCxpQ0FBS2tjLE9BQUwsQ0FBYTlkLENBQWI7QUFDSCx5QkFGRCxNQUVPO0FBQ0gsaUNBQUtraUIsT0FBTDtBQUNIO0FBQ0QsK0JBQU8sSUFBUDtBQUNIO0FBQ0QsMkJBQU8sS0FBUDtBQUNILGlCQWhCRDs7QUFrQkExSCxpQ0FBaUJuWSxTQUFqQixDQUEyQjhrQyxVQUEzQixHQUF3QyxZQUFZO0FBQ2hELDJCQUFPLEtBQUtyTyxjQUFaO0FBQ0gsaUJBRkQ7O0FBSUF0ZSxpQ0FBaUJuWSxTQUFqQixDQUEyQmlsQyxTQUEzQixHQUF1QyxZQUFZO0FBQy9DLDJCQUFPLEtBQUszTyxPQUFMLENBQWEvMkIsTUFBYixHQUFzQixLQUFLQSxNQUFMLEVBQTdCO0FBQ0gsaUJBRkQ7O0FBSUE0WSxpQ0FBaUJuWSxTQUFqQixDQUEyQitrQyxZQUEzQixHQUEwQyxVQUFVMWdCLE1BQVYsRUFBa0I7QUFDeEQseUJBQUtpUyxPQUFMLENBQWFqc0IsSUFBYixDQUFrQmdhLE1BQWxCO0FBQ0gsaUJBRkQ7O0FBSUFsTSxpQ0FBaUJuWSxTQUFqQixDQUEyQjZrQyxhQUEzQixHQUEyQyxVQUFVemdDLEtBQVYsRUFBaUI7QUFDeEQseUJBQUtreUIsT0FBTCxDQUFhLEtBQUtHLGNBQUwsRUFBYixJQUFzQ3J5QixLQUF0QztBQUNILGlCQUZEOztBQUlBK1QsaUNBQWlCblksU0FBakIsQ0FBMkIwa0MsbUJBQTNCLEdBQWlELFlBQVk7QUFDekQsMkJBQU8sS0FBS25sQyxNQUFMLEtBQWdCLEtBQUswbEMsU0FBTCxFQUF2QjtBQUNILGlCQUZEOztBQUlBOXNCLGlDQUFpQm5ZLFNBQWpCLENBQTJCMmtDLGNBQTNCLEdBQTRDLFVBQVUxRixLQUFWLEVBQWlCO0FBQ3pELHdCQUFJM3NCLFVBQVUsdUNBQ04sS0FBS2d5QixRQURDLEdBQ1UsMkJBRFYsR0FDd0NyRixLQUR4QyxHQUNnRCxRQUQ5RDtBQUVBLDJCQUFPLElBQUl4UCxVQUFKLENBQWVuZCxPQUFmLENBQVA7QUFDSCxpQkFKRDs7QUFNQTZGLGlDQUFpQm5ZLFNBQWpCLENBQTJCMDhCLGtCQUEzQixHQUFnRCxZQUFZO0FBQ3hELHlCQUFLamhCLE9BQUwsQ0FBYSxLQUFLa3BCLGNBQUwsQ0FBb0IsQ0FBcEIsQ0FBYjtBQUNILGlCQUZEOztBQUlBLHlCQUFTTyxJQUFULENBQWM1c0IsUUFBZCxFQUF3QnNzQixPQUF4QixFQUFpQztBQUM3Qix3QkFBSSxDQUFDQSxVQUFVLENBQVgsTUFBa0JBLE9BQWxCLElBQTZCQSxVQUFVLENBQTNDLEVBQThDO0FBQzFDLCtCQUFPcm1CLGFBQWEsZ0VBQWIsQ0FBUDtBQUNIO0FBQ0Qsd0JBQUloRyxNQUFNLElBQUlKLGdCQUFKLENBQXFCRyxRQUFyQixDQUFWO0FBQ0Esd0JBQUk1RCxVQUFVNkQsSUFBSTdELE9BQUosRUFBZDtBQUNBNkQsd0JBQUlDLFVBQUosQ0FBZW9zQixPQUFmO0FBQ0Fyc0Isd0JBQUlHLElBQUo7QUFDQSwyQkFBT2hFLE9BQVA7QUFDSDs7QUFFRHhNLHdCQUFRZzlCLElBQVIsR0FBZSxVQUFVNXNCLFFBQVYsRUFBb0Jzc0IsT0FBcEIsRUFBNkI7QUFDeEMsMkJBQU9NLEtBQUs1c0IsUUFBTCxFQUFlc3NCLE9BQWYsQ0FBUDtBQUNILGlCQUZEOztBQUlBMThCLHdCQUFRbEksU0FBUixDQUFrQmtsQyxJQUFsQixHQUF5QixVQUFVTixPQUFWLEVBQW1CO0FBQ3hDLDJCQUFPTSxLQUFLLElBQUwsRUFBV04sT0FBWCxDQUFQO0FBQ0gsaUJBRkQ7O0FBSUExOEIsd0JBQVFrUSxpQkFBUixHQUE0QkQsZ0JBQTVCO0FBQ0MsYUFsSkQ7QUFvSkMsU0F0Sm1CLEVBc0psQixFQUFDLFlBQVcsRUFBWixFQUFlLFVBQVMsRUFBeEIsRUF0SmtCLENBOTdJNHVCLEVBb2xKanVCLElBQUcsQ0FBQyxVQUFTRixPQUFULEVBQWlCcGEsTUFBakIsRUFBd0JDLE9BQXhCLEVBQWdDO0FBQ25FOztBQUNBRCxtQkFBT0MsT0FBUCxHQUFpQixVQUFTb0ssT0FBVCxFQUFrQjtBQUNuQyx5QkFBU2d3QixpQkFBVCxDQUEyQnhqQixPQUEzQixFQUFvQztBQUNoQyx3QkFBSUEsWUFBWWxQLFNBQWhCLEVBQTJCO0FBQ3ZCa1Asa0NBQVVBLFFBQVErSCxPQUFSLEVBQVY7QUFDQSw2QkFBS1QsU0FBTCxHQUFpQnRILFFBQVFzSCxTQUF6QjtBQUNBLDZCQUFLbW9CLGtCQUFMLEdBQTBCenZCLFFBQVE2Z0IsYUFBUixLQUNwQjdnQixRQUFRNFAsYUFBUixFQURvQixHQUNNOWUsU0FEaEM7QUFFSCxxQkFMRCxNQU1LO0FBQ0QsNkJBQUt3VyxTQUFMLEdBQWlCLENBQWpCO0FBQ0EsNkJBQUttb0Isa0JBQUwsR0FBMEIzK0IsU0FBMUI7QUFDSDtBQUNKOztBQUVEMHlCLGtDQUFrQmw0QixTQUFsQixDQUE0QnNrQixhQUE1QixHQUE0QyxZQUFXO0FBQ25ELDJCQUFPLEtBQUs2ZixrQkFBWjtBQUNILGlCQUZEOztBQUlBLG9CQUFJLy9CLFFBQVE4ekIsa0JBQWtCbDRCLFNBQWxCLENBQTRCb0UsS0FBNUIsR0FBb0MsWUFBWTtBQUN4RCx3QkFBSSxDQUFDLEtBQUtza0IsV0FBTCxFQUFMLEVBQXlCO0FBQ3JCLDhCQUFNLElBQUkvVixTQUFKLENBQWMsMkZBQWQsQ0FBTjtBQUNIO0FBQ0QsMkJBQU8sS0FBSzJSLGFBQUwsRUFBUDtBQUNILGlCQUxEOztBQU9BLG9CQUFJRCxTQUFTNlQsa0JBQWtCbDRCLFNBQWxCLENBQTRCdVMsS0FBNUIsR0FDYjJsQixrQkFBa0JsNEIsU0FBbEIsQ0FBNEJxa0IsTUFBNUIsR0FBcUMsWUFBWTtBQUM3Qyx3QkFBSSxDQUFDLEtBQUtzTixVQUFMLEVBQUwsRUFBd0I7QUFDcEIsOEJBQU0sSUFBSWhmLFNBQUosQ0FBYyx5RkFBZCxDQUFOO0FBQ0g7QUFDRCwyQkFBTyxLQUFLMlIsYUFBTCxFQUFQO0FBQ0gsaUJBTkQ7O0FBUUEsb0JBQUlvRSxjQUFjd1Asa0JBQWtCbDRCLFNBQWxCLENBQTRCMG9CLFdBQTVCLEdBQTBDLFlBQVc7QUFDbkUsMkJBQU8sQ0FBQyxLQUFLMU0sU0FBTCxHQUFpQixRQUFsQixNQUFnQyxDQUF2QztBQUNILGlCQUZEOztBQUlBLG9CQUFJMlYsYUFBYXVHLGtCQUFrQmw0QixTQUFsQixDQUE0QjJ4QixVQUE1QixHQUF5QyxZQUFZO0FBQ2xFLDJCQUFPLENBQUMsS0FBSzNWLFNBQUwsR0FBaUIsUUFBbEIsTUFBZ0MsQ0FBdkM7QUFDSCxpQkFGRDs7QUFJQSxvQkFBSW1FLFlBQVkrWCxrQkFBa0JsNEIsU0FBbEIsQ0FBNEJtZ0IsU0FBNUIsR0FBd0MsWUFBWTtBQUNoRSwyQkFBTyxDQUFDLEtBQUtuRSxTQUFMLEdBQWlCLFFBQWxCLE1BQWdDLENBQXZDO0FBQ0gsaUJBRkQ7O0FBSUEsb0JBQUk4Z0IsYUFBYTVFLGtCQUFrQmw0QixTQUFsQixDQUE0Qjg4QixVQUE1QixHQUF5QyxZQUFZO0FBQ2xFLDJCQUFPLENBQUMsS0FBSzlnQixTQUFMLEdBQWlCLFFBQWxCLE1BQWdDLENBQXZDO0FBQ0gsaUJBRkQ7O0FBSUFrYyxrQ0FBa0JsNEIsU0FBbEIsQ0FBNEJzZ0IsV0FBNUIsR0FBMEMsWUFBVztBQUNqRCwyQkFBTyxDQUFDLEtBQUt0RSxTQUFMLEdBQWlCLE9BQWxCLE1BQStCLENBQXRDO0FBQ0gsaUJBRkQ7O0FBSUE5VCx3QkFBUWxJLFNBQVIsQ0FBa0JtbEMsYUFBbEIsR0FBa0MsWUFBVztBQUN6QywyQkFBTyxDQUFDLEtBQUtucEIsU0FBTCxHQUFpQixLQUFsQixNQUE2QixLQUFwQztBQUNILGlCQUZEOztBQUlBOVQsd0JBQVFsSSxTQUFSLENBQWtCb2dCLFlBQWxCLEdBQWlDLFlBQVc7QUFDeEMsMkJBQU8sS0FBSzNELE9BQUwsR0FBZTBvQixhQUFmLEVBQVA7QUFDSCxpQkFGRDs7QUFJQWo5Qix3QkFBUWxJLFNBQVIsQ0FBa0JzZ0IsV0FBbEIsR0FBZ0MsWUFBVztBQUN2QywyQkFBTyxDQUFDLEtBQUs3RCxPQUFMLEdBQWVULFNBQWYsR0FBMkIsT0FBNUIsTUFBeUMsQ0FBaEQ7QUFDSCxpQkFGRDs7QUFJQTlULHdCQUFRbEksU0FBUixDQUFrQm1nQixTQUFsQixHQUE4QixZQUFXO0FBQ3JDLDJCQUFPQSxVQUFVaGdCLElBQVYsQ0FBZSxLQUFLc2MsT0FBTCxFQUFmLENBQVA7QUFDSCxpQkFGRDs7QUFJQXZVLHdCQUFRbEksU0FBUixDQUFrQjJ4QixVQUFsQixHQUErQixZQUFXO0FBQ3RDLDJCQUFPQSxXQUFXeHhCLElBQVgsQ0FBZ0IsS0FBS3NjLE9BQUwsRUFBaEIsQ0FBUDtBQUNILGlCQUZEOztBQUlBdlUsd0JBQVFsSSxTQUFSLENBQWtCMG9CLFdBQWxCLEdBQWdDLFlBQVc7QUFDdkMsMkJBQU9BLFlBQVl2b0IsSUFBWixDQUFpQixLQUFLc2MsT0FBTCxFQUFqQixDQUFQO0FBQ0gsaUJBRkQ7O0FBSUF2VSx3QkFBUWxJLFNBQVIsQ0FBa0I4OEIsVUFBbEIsR0FBK0IsWUFBVztBQUN0QywyQkFBT0EsV0FBVzM4QixJQUFYLENBQWdCLEtBQUtzYyxPQUFMLEVBQWhCLENBQVA7QUFDSCxpQkFGRDs7QUFJQXZVLHdCQUFRbEksU0FBUixDQUFrQm9FLEtBQWxCLEdBQTBCLFlBQVc7QUFDakMsMkJBQU9BLE1BQU1qRSxJQUFOLENBQVcsS0FBS3NjLE9BQUwsRUFBWCxDQUFQO0FBQ0gsaUJBRkQ7O0FBSUF2VSx3QkFBUWxJLFNBQVIsQ0FBa0Jxa0IsTUFBbEIsR0FBMkIsWUFBVztBQUNsQyx3QkFBSW5JLFNBQVMsS0FBS08sT0FBTCxFQUFiO0FBQ0FQLDJCQUFPd0ksMEJBQVA7QUFDQSwyQkFBT0wsT0FBT2xrQixJQUFQLENBQVkrYixNQUFaLENBQVA7QUFDSCxpQkFKRDs7QUFNQWhVLHdCQUFRbEksU0FBUixDQUFrQnF1QixNQUFsQixHQUEyQixZQUFXO0FBQ2xDLDJCQUFPLEtBQUsvSixhQUFMLEVBQVA7QUFDSCxpQkFGRDs7QUFJQXBjLHdCQUFRbEksU0FBUixDQUFrQmt1QixPQUFsQixHQUE0QixZQUFXO0FBQ25DLHlCQUFLeEosMEJBQUw7QUFDQSwyQkFBTyxLQUFLSixhQUFMLEVBQVA7QUFDSCxpQkFIRDs7QUFLQXBjLHdCQUFRZ3dCLGlCQUFSLEdBQTRCQSxpQkFBNUI7QUFDQyxhQXJHRDtBQXVHQyxTQXpHaUMsRUF5R2hDLEVBekdnQyxDQXBsSjh0QixFQTZySjF2QixJQUFHLENBQUMsVUFBU2pnQixPQUFULEVBQWlCcGEsTUFBakIsRUFBd0JDLE9BQXhCLEVBQWdDO0FBQzFDOztBQUNBRCxtQkFBT0MsT0FBUCxHQUFpQixVQUFTb0ssT0FBVCxFQUFrQmlULFFBQWxCLEVBQTRCO0FBQzdDLG9CQUFJckMsT0FBT2IsUUFBUSxRQUFSLENBQVg7QUFDQSxvQkFBSXdHLFdBQVczRixLQUFLMkYsUUFBcEI7QUFDQSxvQkFBSTNmLFdBQVdnYSxLQUFLaGEsUUFBcEI7O0FBRUEseUJBQVNzYyxtQkFBVCxDQUE2Qm5jLEdBQTdCLEVBQWtDMGMsT0FBbEMsRUFBMkM7QUFDdkMsd0JBQUk3YyxTQUFTRyxHQUFULENBQUosRUFBbUI7QUFDZiw0QkFBSUEsZUFBZWlKLE9BQW5CLEVBQTRCLE9BQU9qSixHQUFQO0FBQzVCLDRCQUFJMFYsT0FBT3l3QixRQUFRbm1DLEdBQVIsQ0FBWDtBQUNBLDRCQUFJMFYsU0FBUzhKLFFBQWIsRUFBdUI7QUFDbkIsZ0NBQUk5QyxPQUFKLEVBQWFBLFFBQVFnRyxZQUFSO0FBQ2IsZ0NBQUlwSixNQUFNclEsUUFBUW1LLE1BQVIsQ0FBZXNDLEtBQUtoWCxDQUFwQixDQUFWO0FBQ0EsZ0NBQUlnZSxPQUFKLEVBQWFBLFFBQVFpRyxXQUFSO0FBQ2IsbUNBQU9ySixHQUFQO0FBQ0gseUJBTEQsTUFLTyxJQUFJLE9BQU81RCxJQUFQLEtBQWdCLFVBQXBCLEVBQWdDO0FBQ25DLGdDQUFJMHdCLHFCQUFxQnBtQyxHQUFyQixDQUFKLEVBQStCO0FBQzNCLG9DQUFJc1osTUFBTSxJQUFJclEsT0FBSixDQUFZaVQsUUFBWixDQUFWO0FBQ0FsYyxvQ0FBSTZjLEtBQUosQ0FDSXZELElBQUkrYSxRQURSLEVBRUkvYSxJQUFJa0QsT0FGUixFQUdJalcsU0FISixFQUlJK1MsR0FKSixFQUtJLElBTEo7QUFPQSx1Q0FBT0EsR0FBUDtBQUNIO0FBQ0QsbUNBQU8rc0IsV0FBV3JtQyxHQUFYLEVBQWdCMFYsSUFBaEIsRUFBc0JnSCxPQUF0QixDQUFQO0FBQ0g7QUFDSjtBQUNELDJCQUFPMWMsR0FBUDtBQUNIOztBQUVELHlCQUFTc21DLFNBQVQsQ0FBbUJ0bUMsR0FBbkIsRUFBd0I7QUFDcEIsMkJBQU9BLElBQUkwVixJQUFYO0FBQ0g7O0FBRUQseUJBQVN5d0IsT0FBVCxDQUFpQm5tQyxHQUFqQixFQUFzQjtBQUNsQix3QkFBSTtBQUNBLCtCQUFPc21DLFVBQVV0bUMsR0FBVixDQUFQO0FBQ0gscUJBRkQsQ0FFRSxPQUFPdEIsQ0FBUCxFQUFVO0FBQ1I4Z0IsaUNBQVM5Z0IsQ0FBVCxHQUFhQSxDQUFiO0FBQ0EsK0JBQU84Z0IsUUFBUDtBQUNIO0FBQ0o7O0FBRUQsb0JBQUkrbUIsVUFBVSxHQUFHNWtDLGNBQWpCO0FBQ0EseUJBQVN5a0Msb0JBQVQsQ0FBOEJwbUMsR0FBOUIsRUFBbUM7QUFDL0Isd0JBQUk7QUFDQSwrQkFBT3VtQyxRQUFRcmxDLElBQVIsQ0FBYWxCLEdBQWIsRUFBa0IsV0FBbEIsQ0FBUDtBQUNILHFCQUZELENBRUUsT0FBT3RCLENBQVAsRUFBVTtBQUNSLCtCQUFPLEtBQVA7QUFDSDtBQUNKOztBQUVELHlCQUFTMm5DLFVBQVQsQ0FBb0JoSyxDQUFwQixFQUF1QjNtQixJQUF2QixFQUE2QmdILE9BQTdCLEVBQXNDO0FBQ2xDLHdCQUFJakgsVUFBVSxJQUFJeE0sT0FBSixDQUFZaVQsUUFBWixDQUFkO0FBQ0Esd0JBQUk1QyxNQUFNN0QsT0FBVjtBQUNBLHdCQUFJaUgsT0FBSixFQUFhQSxRQUFRZ0csWUFBUjtBQUNiak4sNEJBQVEwUSxrQkFBUjtBQUNBLHdCQUFJekosT0FBSixFQUFhQSxRQUFRaUcsV0FBUjtBQUNiLHdCQUFJcVosY0FBYyxJQUFsQjtBQUNBLHdCQUFJNzFCLFNBQVMwVCxLQUFLMEYsUUFBTCxDQUFjN0osSUFBZCxFQUFvQnhVLElBQXBCLENBQXlCbTdCLENBQXpCLEVBQTRCdnFCLE9BQTVCLEVBQXFDc0IsTUFBckMsQ0FBYjtBQUNBNG9CLGtDQUFjLEtBQWQ7O0FBRUEsd0JBQUl2bUIsV0FBV3RQLFdBQVdxWixRQUExQixFQUFvQztBQUNoQy9KLGdDQUFRc2YsZUFBUixDQUF3QjV1QixPQUFPekgsQ0FBL0IsRUFBa0MsSUFBbEMsRUFBd0MsSUFBeEM7QUFDQStXLGtDQUFVLElBQVY7QUFDSDs7QUFFRCw2QkFBUzNELE9BQVQsQ0FBaUIzTSxLQUFqQixFQUF3QjtBQUNwQiw0QkFBSSxDQUFDc1EsT0FBTCxFQUFjO0FBQ2RBLGdDQUFRdUgsZ0JBQVIsQ0FBeUI3WCxLQUF6QjtBQUNBc1Esa0NBQVUsSUFBVjtBQUNIOztBQUVELDZCQUFTckMsTUFBVCxDQUFnQmdTLE1BQWhCLEVBQXdCO0FBQ3BCLDRCQUFJLENBQUMzUCxPQUFMLEVBQWM7QUFDZEEsZ0NBQVFzZixlQUFSLENBQXdCM1AsTUFBeEIsRUFBZ0M0VyxXQUFoQyxFQUE2QyxJQUE3QztBQUNBdm1CLGtDQUFVLElBQVY7QUFDSDtBQUNELDJCQUFPNkQsR0FBUDtBQUNIOztBQUVELHVCQUFPNkMsbUJBQVA7QUFDQyxhQXBGRDtBQXNGQyxTQXhGUSxFQXdGUCxFQUFDLFVBQVMsRUFBVixFQXhGTyxDQTdySnV2QixFQXF4Si91QixJQUFHLENBQUMsVUFBU25ELE9BQVQsRUFBaUJwYSxNQUFqQixFQUF3QkMsT0FBeEIsRUFBZ0M7QUFDckQ7O0FBQ0FELG1CQUFPQyxPQUFQLEdBQWlCLFVBQVNvSyxPQUFULEVBQWtCaVQsUUFBbEIsRUFBNEJFLEtBQTVCLEVBQW1DO0FBQ3BELG9CQUFJdkMsT0FBT2IsUUFBUSxRQUFSLENBQVg7QUFDQSxvQkFBSXNYLGVBQWVybkIsUUFBUXFuQixZQUEzQjs7QUFFQSx5QkFBU2tXLGFBQVQsQ0FBdUJDLE1BQXZCLEVBQWdDO0FBQzVCLHlCQUFLQSxNQUFMLEdBQWNBLE1BQWQ7QUFDSDs7QUFFREQsOEJBQWN6bEMsU0FBZCxDQUF3QjJnQixnQkFBeEIsR0FBMkMsWUFBVztBQUNsRHZMLGlDQUFhLEtBQUtzd0IsTUFBbEI7QUFDSCxpQkFGRDs7QUFJQSxvQkFBSUMsYUFBYSxTQUFiQSxVQUFhLENBQVN2aEMsS0FBVCxFQUFnQjtBQUFFLDJCQUFPd2hDLE1BQU0sQ0FBQyxJQUFQLEVBQWE3WCxVQUFiLENBQXdCM3BCLEtBQXhCLENBQVA7QUFBd0MsaUJBQTNFO0FBQ0Esb0JBQUl3aEMsUUFBUTE5QixRQUFRMDlCLEtBQVIsR0FBZ0IsVUFBVUMsRUFBVixFQUFjemhDLEtBQWQsRUFBcUI7QUFDN0Msd0JBQUltVSxHQUFKO0FBQ0Esd0JBQUltdEIsTUFBSjtBQUNBLHdCQUFJdGhDLFVBQVVvQixTQUFkLEVBQXlCO0FBQ3JCK1MsOEJBQU1yUSxRQUFRNkksT0FBUixDQUFnQjNNLEtBQWhCLEVBQ0cwWCxLQURILENBQ1M2cEIsVUFEVCxFQUNxQixJQURyQixFQUMyQixJQUQzQixFQUNpQ0UsRUFEakMsRUFDcUNyZ0MsU0FEckMsQ0FBTjtBQUVBLDRCQUFJNlYsTUFBTXdELFlBQU4sTUFBd0J6YSxpQkFBaUI4RCxPQUE3QyxFQUFzRDtBQUNsRHFRLGdDQUFJb0UsWUFBSixDQUFpQnZZLEtBQWpCO0FBQ0g7QUFDSixxQkFORCxNQU1PO0FBQ0htVSw4QkFBTSxJQUFJclEsT0FBSixDQUFZaVQsUUFBWixDQUFOO0FBQ0F1cUIsaUNBQVN2d0IsV0FBVyxZQUFXO0FBQUVvRCxnQ0FBSSthLFFBQUo7QUFBaUIseUJBQXpDLEVBQTJDLENBQUN1UyxFQUE1QyxDQUFUO0FBQ0EsNEJBQUl4cUIsTUFBTXdELFlBQU4sRUFBSixFQUEwQjtBQUN0QnRHLGdDQUFJb0UsWUFBSixDQUFpQixJQUFJOG9CLGFBQUosQ0FBa0JDLE1BQWxCLENBQWpCO0FBQ0g7QUFDRG50Qiw0QkFBSTZNLGtCQUFKO0FBQ0g7QUFDRDdNLHdCQUFJaWQsbUJBQUo7QUFDQSwyQkFBT2pkLEdBQVA7QUFDSCxpQkFuQkQ7O0FBcUJBclEsd0JBQVFsSSxTQUFSLENBQWtCNGxDLEtBQWxCLEdBQTBCLFVBQVVDLEVBQVYsRUFBYztBQUNwQywyQkFBT0QsTUFBTUMsRUFBTixFQUFVLElBQVYsQ0FBUDtBQUNILGlCQUZEOztBQUlBLG9CQUFJQyxlQUFlLFNBQWZBLFlBQWUsQ0FBVXB4QixPQUFWLEVBQW1CcEMsT0FBbkIsRUFBNEIrTSxNQUE1QixFQUFvQztBQUNuRCx3QkFBSW1PLEdBQUo7QUFDQSx3QkFBSSxPQUFPbGIsT0FBUCxLQUFtQixRQUF2QixFQUFpQztBQUM3Qiw0QkFBSUEsbUJBQW1CMkMsS0FBdkIsRUFBOEI7QUFDMUJ1WSxrQ0FBTWxiLE9BQU47QUFDSCx5QkFGRCxNQUVPO0FBQ0hrYixrQ0FBTSxJQUFJK0IsWUFBSixDQUFpQixxQkFBakIsQ0FBTjtBQUNIO0FBQ0oscUJBTkQsTUFNTztBQUNIL0IsOEJBQU0sSUFBSStCLFlBQUosQ0FBaUJqZCxPQUFqQixDQUFOO0FBQ0g7QUFDRHdHLHlCQUFLc2UsOEJBQUwsQ0FBb0M1SixHQUFwQztBQUNBOVksNEJBQVFnTSxpQkFBUixDQUEwQjhNLEdBQTFCO0FBQ0E5WSw0QkFBUStHLE9BQVIsQ0FBZ0IrUixHQUFoQjs7QUFFQSx3QkFBSW5PLFVBQVUsSUFBZCxFQUFvQjtBQUNoQkEsK0JBQU9ULE1BQVA7QUFDSDtBQUNKLGlCQWxCRDs7QUFvQkEseUJBQVNtbkIsWUFBVCxDQUFzQjNoQyxLQUF0QixFQUE2QjtBQUN6QmdSLGlDQUFhLEtBQUtzd0IsTUFBbEI7QUFDQSwyQkFBT3RoQyxLQUFQO0FBQ0g7O0FBRUQseUJBQVM0aEMsWUFBVCxDQUFzQjNoQixNQUF0QixFQUE4QjtBQUMxQmpQLGlDQUFhLEtBQUtzd0IsTUFBbEI7QUFDQSwwQkFBTXJoQixNQUFOO0FBQ0g7O0FBRURuYyx3QkFBUWxJLFNBQVIsQ0FBa0IrVixPQUFsQixHQUE0QixVQUFVOHZCLEVBQVYsRUFBY3Z6QixPQUFkLEVBQXVCO0FBQy9DdXpCLHlCQUFLLENBQUNBLEVBQU47QUFDQSx3QkFBSXR0QixHQUFKLEVBQVM4RyxNQUFUOztBQUVBLHdCQUFJNG1CLGdCQUFnQixJQUFJUixhQUFKLENBQWtCdHdCLFdBQVcsU0FBUyt3QixjQUFULEdBQTBCO0FBQ3ZFLDRCQUFJM3RCLElBQUk0SCxTQUFKLEVBQUosRUFBcUI7QUFDakIybEIseUNBQWF2dEIsR0FBYixFQUFrQmpHLE9BQWxCLEVBQTJCK00sTUFBM0I7QUFDSDtBQUNKLHFCQUpxQyxFQUluQ3dtQixFQUptQyxDQUFsQixDQUFwQjs7QUFNQSx3QkFBSXhxQixNQUFNd0QsWUFBTixFQUFKLEVBQTBCO0FBQ3RCUSxpQ0FBUyxLQUFLMUssSUFBTCxFQUFUO0FBQ0E0RCw4QkFBTThHLE9BQU92RCxLQUFQLENBQWFpcUIsWUFBYixFQUEyQkMsWUFBM0IsRUFDY3hnQyxTQURkLEVBQ3lCeWdDLGFBRHpCLEVBQ3dDemdDLFNBRHhDLENBQU47QUFFQStTLDRCQUFJb0UsWUFBSixDQUFpQnNwQixhQUFqQjtBQUNILHFCQUxELE1BS087QUFDSDF0Qiw4QkFBTSxLQUFLdUQsS0FBTCxDQUFXaXFCLFlBQVgsRUFBeUJDLFlBQXpCLEVBQ2N4Z0MsU0FEZCxFQUN5QnlnQyxhQUR6QixFQUN3Q3pnQyxTQUR4QyxDQUFOO0FBRUg7O0FBRUQsMkJBQU8rUyxHQUFQO0FBQ0gsaUJBckJEO0FBdUJDLGFBM0ZEO0FBNkZDLFNBL0ZtQixFQStGbEIsRUFBQyxVQUFTLEVBQVYsRUEvRmtCLENBcnhKNHVCLEVBbzNKL3VCLElBQUcsQ0FBQyxVQUFTTixPQUFULEVBQWlCcGEsTUFBakIsRUFBd0JDLE9BQXhCLEVBQWdDO0FBQ3JEOztBQUNBRCxtQkFBT0MsT0FBUCxHQUFpQixVQUFVb0ssT0FBVixFQUFtQnFXLFlBQW5CLEVBQWlDbkQsbUJBQWpDLEVBQ2IrRyxhQURhLEVBQ0VoSCxRQURGLEVBQ1lFLEtBRFosRUFDbUI7QUFDaEMsb0JBQUl2QyxPQUFPYixRQUFRLFFBQVIsQ0FBWDtBQUNBLG9CQUFJdEYsWUFBWXNGLFFBQVEsVUFBUixFQUFvQnRGLFNBQXBDO0FBQ0Esb0JBQUlpYSxXQUFXM1UsUUFBUSxRQUFSLEVBQWtCMlUsUUFBakM7QUFDQSxvQkFBSW5PLFdBQVczRixLQUFLMkYsUUFBcEI7QUFDQSxvQkFBSUQsV0FBVzFGLEtBQUswRixRQUFwQjtBQUNBLG9CQUFJMm5CLE9BQU8sRUFBWDs7QUFFQSx5QkFBU3JZLE9BQVQsQ0FBaUJud0IsQ0FBakIsRUFBb0I7QUFDaEJ3WCwrQkFBVyxZQUFVO0FBQUMsOEJBQU14WCxDQUFOO0FBQVMscUJBQS9CLEVBQWlDLENBQWpDO0FBQ0g7O0FBRUQseUJBQVN5b0Msd0JBQVQsQ0FBa0NDLFFBQWxDLEVBQTRDO0FBQ3hDLHdCQUFJN3BCLGVBQWVwQixvQkFBb0JpckIsUUFBcEIsQ0FBbkI7QUFDQSx3QkFBSTdwQixpQkFBaUI2cEIsUUFBakIsSUFDQSxPQUFPQSxTQUFTQyxhQUFoQixLQUFrQyxVQURsQyxJQUVBLE9BQU9ELFNBQVNFLFlBQWhCLEtBQWlDLFVBRmpDLElBR0FGLFNBQVNDLGFBQVQsRUFISixFQUc4QjtBQUMxQjlwQixxQ0FBYWdxQixjQUFiLENBQTRCSCxTQUFTRSxZQUFULEVBQTVCO0FBQ0g7QUFDRCwyQkFBTy9wQixZQUFQO0FBQ0g7QUFDRCx5QkFBU2lxQixPQUFULENBQWlCQyxTQUFqQixFQUE0QnhDLFVBQTVCLEVBQXdDO0FBQ3BDLHdCQUFJN2tDLElBQUksQ0FBUjtBQUNBLHdCQUFJMlcsTUFBTTB3QixVQUFVbm5DLE1BQXBCO0FBQ0Esd0JBQUlnWixNQUFNLElBQUlyUSxPQUFKLENBQVlpVCxRQUFaLENBQVY7QUFDQSw2QkFBU3dyQixRQUFULEdBQW9CO0FBQ2hCLDRCQUFJdG5DLEtBQUsyVyxHQUFULEVBQWMsT0FBT3VDLElBQUkrYSxRQUFKLEVBQVA7QUFDZCw0QkFBSTlXLGVBQWU0cEIseUJBQXlCTSxVQUFVcm5DLEdBQVYsQ0FBekIsQ0FBbkI7QUFDQSw0QkFBSW1kLHdCQUF3QnRVLE9BQXhCLElBQ0FzVSxhQUFhOHBCLGFBQWIsRUFESixFQUNrQztBQUM5QixnQ0FBSTtBQUNBOXBCLCtDQUFlcEIsb0JBQ1hvQixhQUFhK3BCLFlBQWIsR0FBNEJLLFVBQTVCLENBQXVDMUMsVUFBdkMsQ0FEVyxFQUVYd0MsVUFBVWh5QixPQUZDLENBQWY7QUFHSCw2QkFKRCxDQUlFLE9BQU8vVyxDQUFQLEVBQVU7QUFDUix1Q0FBT213QixRQUFRbndCLENBQVIsQ0FBUDtBQUNIO0FBQ0QsZ0NBQUk2ZSx3QkFBd0J0VSxPQUE1QixFQUFxQztBQUNqQyx1Q0FBT3NVLGFBQWFWLEtBQWIsQ0FBbUI2cUIsUUFBbkIsRUFBNkI3WSxPQUE3QixFQUNtQixJQURuQixFQUN5QixJQUR6QixFQUMrQixJQUQvQixDQUFQO0FBRUg7QUFDSjtBQUNENlk7QUFDSDtBQUNEQTtBQUNBLDJCQUFPcHVCLEdBQVA7QUFDSDs7QUFFRCx5QkFBU3N1QixRQUFULENBQWtCcjlCLElBQWxCLEVBQXdCa0wsT0FBeEIsRUFBaUNpSCxPQUFqQyxFQUEwQztBQUN0Qyx5QkFBS21yQixLQUFMLEdBQWF0OUIsSUFBYjtBQUNBLHlCQUFLb3BCLFFBQUwsR0FBZ0JsZSxPQUFoQjtBQUNBLHlCQUFLcXlCLFFBQUwsR0FBZ0JwckIsT0FBaEI7QUFDSDs7QUFFRGtyQix5QkFBUzdtQyxTQUFULENBQW1Cd0osSUFBbkIsR0FBMEIsWUFBWTtBQUNsQywyQkFBTyxLQUFLczlCLEtBQVo7QUFDSCxpQkFGRDs7QUFJQUQseUJBQVM3bUMsU0FBVCxDQUFtQjBVLE9BQW5CLEdBQTZCLFlBQVk7QUFDckMsMkJBQU8sS0FBS2tlLFFBQVo7QUFDSCxpQkFGRDs7QUFJQWlVLHlCQUFTN21DLFNBQVQsQ0FBbUJnbkMsUUFBbkIsR0FBOEIsWUFBWTtBQUN0Qyx3QkFBSSxLQUFLdHlCLE9BQUwsR0FBZWdVLFdBQWYsRUFBSixFQUFrQztBQUM5QiwrQkFBTyxLQUFLaFUsT0FBTCxHQUFldFEsS0FBZixFQUFQO0FBQ0g7QUFDRCwyQkFBTytoQyxJQUFQO0FBQ0gsaUJBTEQ7O0FBT0FVLHlCQUFTN21DLFNBQVQsQ0FBbUI0bUMsVUFBbkIsR0FBZ0MsVUFBUzFDLFVBQVQsRUFBcUI7QUFDakQsd0JBQUk4QyxXQUFXLEtBQUtBLFFBQUwsRUFBZjtBQUNBLHdCQUFJcnJCLFVBQVUsS0FBS29yQixRQUFuQjtBQUNBLHdCQUFJcHJCLFlBQVluVyxTQUFoQixFQUEyQm1XLFFBQVFnRyxZQUFSO0FBQzNCLHdCQUFJcEosTUFBTXl1QixhQUFhYixJQUFiLEdBQ0osS0FBS2MsU0FBTCxDQUFlRCxRQUFmLEVBQXlCOUMsVUFBekIsQ0FESSxHQUNtQyxJQUQ3QztBQUVBLHdCQUFJdm9CLFlBQVluVyxTQUFoQixFQUEyQm1XLFFBQVFpRyxXQUFSO0FBQzNCLHlCQUFLZ1IsUUFBTCxDQUFjc1UsZ0JBQWQ7QUFDQSx5QkFBS0osS0FBTCxHQUFhLElBQWI7QUFDQSwyQkFBT3Z1QixHQUFQO0FBQ0gsaUJBVkQ7O0FBWUFzdUIseUJBQVNNLFVBQVQsR0FBc0IsVUFBVW4wQixDQUFWLEVBQWE7QUFDL0IsMkJBQVFBLEtBQUssSUFBTCxJQUNBLE9BQU9BLEVBQUVnMEIsUUFBVCxLQUFzQixVQUR0QixJQUVBLE9BQU9oMEIsRUFBRTR6QixVQUFULEtBQXdCLFVBRmhDO0FBR0gsaUJBSkQ7O0FBTUEseUJBQVNRLGdCQUFULENBQTBCL21DLEVBQTFCLEVBQThCcVUsT0FBOUIsRUFBdUNpSCxPQUF2QyxFQUFnRDtBQUM1Qyx5QkFBS2thLFlBQUwsQ0FBa0J4MUIsRUFBbEIsRUFBc0JxVSxPQUF0QixFQUErQmlILE9BQS9CO0FBQ0g7QUFDRGlSLHlCQUFTd2EsZ0JBQVQsRUFBMkJQLFFBQTNCOztBQUVBTyxpQ0FBaUJwbkMsU0FBakIsQ0FBMkJpbkMsU0FBM0IsR0FBdUMsVUFBVUQsUUFBVixFQUFvQjlDLFVBQXBCLEVBQWdDO0FBQ25FLHdCQUFJN2pDLEtBQUssS0FBS21KLElBQUwsRUFBVDtBQUNBLDJCQUFPbkosR0FBR0YsSUFBSCxDQUFRNm1DLFFBQVIsRUFBa0JBLFFBQWxCLEVBQTRCOUMsVUFBNUIsQ0FBUDtBQUNILGlCQUhEOztBQUtBLHlCQUFTbUQsbUJBQVQsQ0FBNkJqakMsS0FBN0IsRUFBb0M7QUFDaEMsd0JBQUl5aUMsU0FBU00sVUFBVCxDQUFvQi9pQyxLQUFwQixDQUFKLEVBQWdDO0FBQzVCLDZCQUFLc2lDLFNBQUwsQ0FBZSxLQUFLbG1DLEtBQXBCLEVBQTJCZ21DLGNBQTNCLENBQTBDcGlDLEtBQTFDO0FBQ0EsK0JBQU9BLE1BQU1zUSxPQUFOLEVBQVA7QUFDSDtBQUNELDJCQUFPdFEsS0FBUDtBQUNIOztBQUVELHlCQUFTa2pDLFlBQVQsQ0FBc0IvbkMsTUFBdEIsRUFBOEI7QUFDMUIseUJBQUtBLE1BQUwsR0FBY0EsTUFBZDtBQUNBLHlCQUFLbVYsT0FBTCxHQUFlLElBQWY7QUFDQSx5QkFBS25WLFNBQU8sQ0FBWixJQUFpQixJQUFqQjtBQUNIOztBQUVEK25DLDZCQUFhdG5DLFNBQWIsQ0FBdUIyZ0IsZ0JBQXZCLEdBQTBDLFlBQVc7QUFDakQsd0JBQUkzSyxNQUFNLEtBQUt6VyxNQUFmO0FBQ0EseUJBQUssSUFBSUYsSUFBSSxDQUFiLEVBQWdCQSxJQUFJMlcsR0FBcEIsRUFBeUIsRUFBRTNXLENBQTNCLEVBQThCO0FBQzFCLDRCQUFJZ2lCLE9BQU8sS0FBS2hpQixDQUFMLENBQVg7QUFDQSw0QkFBSWdpQixnQkFBZ0JuWixPQUFwQixFQUE2QjtBQUN6Qm1aLGlDQUFLekMsTUFBTDtBQUNIO0FBQ0o7QUFDSixpQkFSRDs7QUFVQTFXLHdCQUFRcS9CLEtBQVIsR0FBZ0IsWUFBWTtBQUN4Qix3QkFBSXZ4QixNQUFNMVcsVUFBVUMsTUFBcEI7QUFDQSx3QkFBSXlXLE1BQU0sQ0FBVixFQUFhLE9BQU91SSxhQUNKLHFEQURJLENBQVA7QUFFYix3QkFBSWxlLEtBQUtmLFVBQVUwVyxNQUFNLENBQWhCLENBQVQ7QUFDQSx3QkFBSSxPQUFPM1YsRUFBUCxLQUFjLFVBQWxCLEVBQThCO0FBQzFCLCtCQUFPa2UsYUFBYSxrQ0FBa0N6RixLQUFLaUYsV0FBTCxDQUFpQjFkLEVBQWpCLENBQS9DLENBQVA7QUFDSDtBQUNELHdCQUFJNlEsS0FBSjtBQUNBLHdCQUFJczJCLGFBQWEsSUFBakI7QUFDQSx3QkFBSXh4QixRQUFRLENBQVIsSUFBYTFWLE1BQU1pTCxPQUFOLENBQWNqTSxVQUFVLENBQVYsQ0FBZCxDQUFqQixFQUE4QztBQUMxQzRSLGdDQUFRNVIsVUFBVSxDQUFWLENBQVI7QUFDQTBXLDhCQUFNOUUsTUFBTTNSLE1BQVo7QUFDQWlvQyxxQ0FBYSxLQUFiO0FBQ0gscUJBSkQsTUFJTztBQUNIdDJCLGdDQUFRNVIsU0FBUjtBQUNBMFc7QUFDSDtBQUNELHdCQUFJMHdCLFlBQVksSUFBSVksWUFBSixDQUFpQnR4QixHQUFqQixDQUFoQjtBQUNBLHlCQUFLLElBQUkzVyxJQUFJLENBQWIsRUFBZ0JBLElBQUkyVyxHQUFwQixFQUF5QixFQUFFM1csQ0FBM0IsRUFBOEI7QUFDMUIsNEJBQUkybkMsV0FBVzkxQixNQUFNN1IsQ0FBTixDQUFmO0FBQ0EsNEJBQUl3bkMsU0FBU00sVUFBVCxDQUFvQkgsUUFBcEIsQ0FBSixFQUFtQztBQUMvQixnQ0FBSVMsV0FBV1QsUUFBZjtBQUNBQSx1Q0FBV0EsU0FBU3R5QixPQUFULEVBQVg7QUFDQXN5QixxQ0FBU1IsY0FBVCxDQUF3QmlCLFFBQXhCO0FBQ0gseUJBSkQsTUFJTztBQUNILGdDQUFJanJCLGVBQWVwQixvQkFBb0I0ckIsUUFBcEIsQ0FBbkI7QUFDQSxnQ0FBSXhxQix3QkFBd0J0VSxPQUE1QixFQUFxQztBQUNqQzgrQiwyQ0FDSXhxQixhQUFhVixLQUFiLENBQW1CdXJCLG1CQUFuQixFQUF3QyxJQUF4QyxFQUE4QyxJQUE5QyxFQUFvRDtBQUNoRFgsK0NBQVdBLFNBRHFDO0FBRWhEbG1DLDJDQUFPbkI7QUFGeUMsaUNBQXBELEVBR0RtRyxTQUhDLENBREo7QUFLSDtBQUNKO0FBQ0RraEMsa0NBQVVybkMsQ0FBVixJQUFlMm5DLFFBQWY7QUFDSDs7QUFFRCx3QkFBSVUscUJBQXFCLElBQUlwbkMsS0FBSixDQUFVb21DLFVBQVVubkMsTUFBcEIsQ0FBekI7QUFDQSx5QkFBSyxJQUFJRixJQUFJLENBQWIsRUFBZ0JBLElBQUlxb0MsbUJBQW1Cbm9DLE1BQXZDLEVBQStDLEVBQUVGLENBQWpELEVBQW9EO0FBQ2hEcW9DLDJDQUFtQnJvQyxDQUFuQixJQUF3QjZJLFFBQVE2SSxPQUFSLENBQWdCMjFCLFVBQVVybkMsQ0FBVixDQUFoQixFQUE4QnM1QixPQUE5QixFQUF4QjtBQUNIOztBQUVELHdCQUFJZ1AsZ0JBQWdCei9CLFFBQVF1bUIsR0FBUixDQUFZaVosa0JBQVosRUFDZi95QixJQURlLENBQ1YsVUFBU2l6QixXQUFULEVBQXNCO0FBQ3hCLDZCQUFLLElBQUl2b0MsSUFBSSxDQUFiLEVBQWdCQSxJQUFJdW9DLFlBQVlyb0MsTUFBaEMsRUFBd0MsRUFBRUYsQ0FBMUMsRUFBNkM7QUFDekMsZ0NBQUk2a0MsYUFBYTBELFlBQVl2b0MsQ0FBWixDQUFqQjtBQUNBLGdDQUFJNmtDLFdBQVd2UyxVQUFYLEVBQUosRUFBNkI7QUFDekJsVCx5Q0FBUzlnQixDQUFULEdBQWF1bUMsV0FBVzN4QixLQUFYLEVBQWI7QUFDQSx1Q0FBT2tNLFFBQVA7QUFDSCw2QkFIRCxNQUdPLElBQUksQ0FBQ3lsQixXQUFXeGIsV0FBWCxFQUFMLEVBQStCO0FBQ2xDaWYsOENBQWMvb0IsTUFBZDtBQUNBO0FBQ0g7QUFDRGdwQix3Q0FBWXZvQyxDQUFaLElBQWlCNmtDLFdBQVc5L0IsS0FBWCxFQUFqQjtBQUNIO0FBQ0RzUSxnQ0FBUWlOLFlBQVI7O0FBRUF0aEIsNkJBQUttZSxTQUFTbmUsRUFBVCxDQUFMO0FBQ0EsNEJBQUlrWSxNQUFNaXZCLGFBQ0pubkMsR0FBR1IsS0FBSCxDQUFTMkYsU0FBVCxFQUFvQm9pQyxXQUFwQixDQURJLEdBQytCdm5DLEdBQUd1bkMsV0FBSCxDQUR6QztBQUVBLDRCQUFJbmhCLGlCQUFpQi9SLFFBQVFrTixXQUFSLEVBQXJCO0FBQ0F2Ryw4QkFBTThOLHFCQUFOLENBQ0k1USxHQURKLEVBQ1NrTyxjQURULEVBQ3lCLGVBRHpCLEVBQzBDL1IsT0FEMUM7QUFFQSwrQkFBTzZELEdBQVA7QUFDSCxxQkF0QmUsQ0FBcEI7O0FBd0JBLHdCQUFJN0QsVUFBVWl6QixjQUFjOVYsTUFBZCxDQUFxQixZQUFXO0FBQzFDLDRCQUFJcVMsYUFBYSxJQUFJaDhCLFFBQVFnd0IsaUJBQVosQ0FBOEJ5UCxhQUE5QixDQUFqQjtBQUNBLCtCQUFPbEIsUUFBUUMsU0FBUixFQUFtQnhDLFVBQW5CLENBQVA7QUFDSCxxQkFIYSxDQUFkO0FBSUF3Qyw4QkFBVWh5QixPQUFWLEdBQW9CQSxPQUFwQjtBQUNBQSw0QkFBUWlJLFlBQVIsQ0FBcUIrcEIsU0FBckI7QUFDQSwyQkFBT2h5QixPQUFQO0FBQ0gsaUJBMUVEOztBQTRFQXhNLHdCQUFRbEksU0FBUixDQUFrQndtQyxjQUFsQixHQUFtQyxVQUFVaUIsUUFBVixFQUFvQjtBQUNuRCx5QkFBS3pyQixTQUFMLEdBQWlCLEtBQUtBLFNBQUwsR0FBaUIsTUFBbEM7QUFDQSx5QkFBSzZyQixTQUFMLEdBQWlCSixRQUFqQjtBQUNILGlCQUhEOztBQUtBdi9CLHdCQUFRbEksU0FBUixDQUFrQnNtQyxhQUFsQixHQUFrQyxZQUFZO0FBQzFDLDJCQUFPLENBQUMsS0FBS3RxQixTQUFMLEdBQWlCLE1BQWxCLElBQTRCLENBQW5DO0FBQ0gsaUJBRkQ7O0FBSUE5VCx3QkFBUWxJLFNBQVIsQ0FBa0J1bUMsWUFBbEIsR0FBaUMsWUFBWTtBQUN6QywyQkFBTyxLQUFLc0IsU0FBWjtBQUNILGlCQUZEOztBQUlBMy9CLHdCQUFRbEksU0FBUixDQUFrQmtuQyxnQkFBbEIsR0FBcUMsWUFBWTtBQUM3Qyx5QkFBS2xyQixTQUFMLEdBQWlCLEtBQUtBLFNBQUwsR0FBa0IsQ0FBQyxNQUFwQztBQUNBLHlCQUFLNnJCLFNBQUwsR0FBaUJyaUMsU0FBakI7QUFDSCxpQkFIRDs7QUFLQTBDLHdCQUFRbEksU0FBUixDQUFrQnluQyxRQUFsQixHQUE2QixVQUFVcG5DLEVBQVYsRUFBYztBQUN2Qyx3QkFBSSxPQUFPQSxFQUFQLEtBQWMsVUFBbEIsRUFBOEI7QUFDMUIsK0JBQU8sSUFBSSttQyxnQkFBSixDQUFxQi9tQyxFQUFyQixFQUF5QixJQUF6QixFQUErQjhoQixlQUEvQixDQUFQO0FBQ0g7QUFDRCwwQkFBTSxJQUFJeFAsU0FBSixFQUFOO0FBQ0gsaUJBTEQ7QUFPSCxhQWhPRDtBQWtPQyxTQXBPbUIsRUFvT2xCLEVBQUMsWUFBVyxFQUFaLEVBQWUsVUFBUyxFQUF4QixFQXBPa0IsQ0FwM0o0dUIsRUF3bEtqdUIsSUFBRyxDQUFDLFVBQVNzRixPQUFULEVBQWlCcGEsTUFBakIsRUFBd0JDLE9BQXhCLEVBQWdDO0FBQ25FOztBQUNBLGdCQUFJK3dCLE1BQU01VyxRQUFRLE9BQVIsQ0FBVjtBQUNBLGdCQUFJbUYsY0FBYyxPQUFPK2xCLFNBQVAsSUFBb0IsV0FBdEM7O0FBRUEsZ0JBQUkxa0IsV0FBVyxFQUFDOWdCLEdBQUcsRUFBSixFQUFmO0FBQ0EsZ0JBQUltcUMsY0FBSjtBQUNBLGdCQUFJQyxlQUFlLE9BQU8za0MsSUFBUCxLQUFnQixXQUFoQixHQUE4QkEsSUFBOUIsR0FDZixPQUFPeEYsTUFBUCxLQUFrQixXQUFsQixHQUFnQ0EsTUFBaEMsR0FDQSxPQUFPVSxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDQSxNQUFoQyxHQUNBLFNBQVNrSCxTQUFULEdBQXFCLElBQXJCLEdBQTRCLElBSGhDOztBQUtBLHFCQUFTd2lDLFVBQVQsR0FBc0I7QUFDbEIsb0JBQUk7QUFDQSx3QkFBSTlyQixTQUFTNHJCLGNBQWI7QUFDQUEscUNBQWlCLElBQWpCO0FBQ0EsMkJBQU81ckIsT0FBT3JjLEtBQVAsQ0FBYSxJQUFiLEVBQW1CUCxTQUFuQixDQUFQO0FBQ0gsaUJBSkQsQ0FJRSxPQUFPM0IsQ0FBUCxFQUFVO0FBQ1I4Z0IsNkJBQVM5Z0IsQ0FBVCxHQUFhQSxDQUFiO0FBQ0EsMkJBQU84Z0IsUUFBUDtBQUNIO0FBQ0o7QUFDRCxxQkFBU0QsUUFBVCxDQUFrQm5lLEVBQWxCLEVBQXNCO0FBQ2xCeW5DLGlDQUFpQnpuQyxFQUFqQjtBQUNBLHVCQUFPMm5DLFVBQVA7QUFDSDs7QUFFRCxnQkFBSXBiLFdBQVcsU0FBWEEsUUFBVyxDQUFTcWIsS0FBVCxFQUFnQkMsTUFBaEIsRUFBd0I7QUFDbkMsb0JBQUkxQyxVQUFVLEdBQUc1a0MsY0FBakI7O0FBRUEseUJBQVN1bkMsQ0FBVCxHQUFhO0FBQ1QseUJBQUs5NEIsV0FBTCxHQUFtQjQ0QixLQUFuQjtBQUNBLHlCQUFLcFMsWUFBTCxHQUFvQnFTLE1BQXBCO0FBQ0EseUJBQUssSUFBSXRxQixZQUFULElBQXlCc3FCLE9BQU9sb0MsU0FBaEMsRUFBMkM7QUFDdkMsNEJBQUl3bEMsUUFBUXJsQyxJQUFSLENBQWErbkMsT0FBT2xvQyxTQUFwQixFQUErQjRkLFlBQS9CLEtBQ0FBLGFBQWFpTixNQUFiLENBQW9Cak4sYUFBYXJlLE1BQWIsR0FBb0IsQ0FBeEMsTUFBK0MsR0FEbkQsRUFFQztBQUNHLGlDQUFLcWUsZUFBZSxHQUFwQixJQUEyQnNxQixPQUFPbG9DLFNBQVAsQ0FBaUI0ZCxZQUFqQixDQUEzQjtBQUNIO0FBQ0o7QUFDSjtBQUNEdXFCLGtCQUFFbm9DLFNBQUYsR0FBY2tvQyxPQUFPbG9DLFNBQXJCO0FBQ0Fpb0Msc0JBQU1qb0MsU0FBTixHQUFrQixJQUFJbW9DLENBQUosRUFBbEI7QUFDQSx1QkFBT0YsTUFBTWpvQyxTQUFiO0FBQ0gsYUFqQkQ7O0FBb0JBLHFCQUFTb29DLFdBQVQsQ0FBcUI1b0MsR0FBckIsRUFBMEI7QUFDdEIsdUJBQU9BLE9BQU8sSUFBUCxJQUFlQSxRQUFRLElBQXZCLElBQStCQSxRQUFRLEtBQXZDLElBQ0gsT0FBT0EsR0FBUCxLQUFlLFFBRFosSUFDd0IsT0FBT0EsR0FBUCxLQUFlLFFBRDlDO0FBR0g7O0FBRUQscUJBQVNWLFFBQVQsQ0FBa0JzRixLQUFsQixFQUF5QjtBQUNyQix1QkFBTyxPQUFPQSxLQUFQLEtBQWlCLFVBQWpCLElBQ0EsUUFBT0EsS0FBUCx5Q0FBT0EsS0FBUCxPQUFpQixRQUFqQixJQUE2QkEsVUFBVSxJQUQ5QztBQUVIOztBQUVELHFCQUFTNHlCLGdCQUFULENBQTBCcVIsVUFBMUIsRUFBc0M7QUFDbEMsb0JBQUksQ0FBQ0QsWUFBWUMsVUFBWixDQUFMLEVBQThCLE9BQU9BLFVBQVA7O0FBRTlCLHVCQUFPLElBQUlwekIsS0FBSixDQUFVcXpCLGFBQWFELFVBQWIsQ0FBVixDQUFQO0FBQ0g7O0FBRUQscUJBQVNyTCxZQUFULENBQXNCOWdCLE1BQXRCLEVBQThCcXNCLFFBQTlCLEVBQXdDO0FBQ3BDLG9CQUFJdnlCLE1BQU1rRyxPQUFPM2MsTUFBakI7QUFDQSxvQkFBSWdaLE1BQU0sSUFBSWpZLEtBQUosQ0FBVTBWLE1BQU0sQ0FBaEIsQ0FBVjtBQUNBLG9CQUFJM1csQ0FBSjtBQUNBLHFCQUFLQSxJQUFJLENBQVQsRUFBWUEsSUFBSTJXLEdBQWhCLEVBQXFCLEVBQUUzVyxDQUF2QixFQUEwQjtBQUN0QmtaLHdCQUFJbFosQ0FBSixJQUFTNmMsT0FBTzdjLENBQVAsQ0FBVDtBQUNIO0FBQ0RrWixvQkFBSWxaLENBQUosSUFBU2twQyxRQUFUO0FBQ0EsdUJBQU9od0IsR0FBUDtBQUNIOztBQUVELHFCQUFTb2xCLHdCQUFULENBQWtDMStCLEdBQWxDLEVBQXVDUSxHQUF2QyxFQUE0QytvQyxZQUE1QyxFQUEwRDtBQUN0RCxvQkFBSTNaLElBQUlvQixLQUFSLEVBQWU7QUFDWCx3QkFBSVUsT0FBTzV4QixPQUFPb3hCLHdCQUFQLENBQWdDbHhCLEdBQWhDLEVBQXFDUSxHQUFyQyxDQUFYOztBQUVBLHdCQUFJa3hCLFFBQVEsSUFBWixFQUFrQjtBQUNkLCtCQUFPQSxLQUFLaG5CLEdBQUwsSUFBWSxJQUFaLElBQW9CZ25CLEtBQUt6c0IsR0FBTCxJQUFZLElBQWhDLEdBQ0d5c0IsS0FBS3ZzQixLQURSLEdBRUdva0MsWUFGVjtBQUdIO0FBQ0osaUJBUkQsTUFRTztBQUNILDJCQUFPLEdBQUc1bkMsY0FBSCxDQUFrQlQsSUFBbEIsQ0FBdUJsQixHQUF2QixFQUE0QlEsR0FBNUIsSUFBbUNSLElBQUlRLEdBQUosQ0FBbkMsR0FBOEMrRixTQUFyRDtBQUNIO0FBQ0o7O0FBRUQscUJBQVN5akIsaUJBQVQsQ0FBMkJocUIsR0FBM0IsRUFBZ0MrWCxJQUFoQyxFQUFzQzVTLEtBQXRDLEVBQTZDO0FBQ3pDLG9CQUFJZ2tDLFlBQVlucEMsR0FBWixDQUFKLEVBQXNCLE9BQU9BLEdBQVA7QUFDdEIsb0JBQUltVSxhQUFhO0FBQ2JoUCwyQkFBT0EsS0FETTtBQUViaVAsa0NBQWMsSUFGRDtBQUdiQyxnQ0FBWSxLQUhDO0FBSWJDLDhCQUFVO0FBSkcsaUJBQWpCO0FBTUFzYixvQkFBSTNiLGNBQUosQ0FBbUJqVSxHQUFuQixFQUF3QitYLElBQXhCLEVBQThCNUQsVUFBOUI7QUFDQSx1QkFBT25VLEdBQVA7QUFDSDs7QUFFRCxxQkFBUzZ1QixPQUFULENBQWlCalcsQ0FBakIsRUFBb0I7QUFDaEIsc0JBQU1BLENBQU47QUFDSDs7QUFFRCxnQkFBSW1tQixvQkFBcUIsWUFBVztBQUNoQyxvQkFBSXlLLHFCQUFxQixDQUNyQm5vQyxNQUFNTixTQURlLEVBRXJCakIsT0FBT2lCLFNBRmMsRUFHckJ2QyxTQUFTdUMsU0FIWSxDQUF6Qjs7QUFNQSxvQkFBSTBvQyxrQkFBa0IsU0FBbEJBLGVBQWtCLENBQVNscEMsR0FBVCxFQUFjO0FBQ2hDLHlCQUFLLElBQUlILElBQUksQ0FBYixFQUFnQkEsSUFBSW9wQyxtQkFBbUJscEMsTUFBdkMsRUFBK0MsRUFBRUYsQ0FBakQsRUFBb0Q7QUFDaEQsNEJBQUlvcEMsbUJBQW1CcHBDLENBQW5CLE1BQTBCRyxHQUE5QixFQUFtQztBQUMvQixtQ0FBTyxJQUFQO0FBQ0g7QUFDSjtBQUNELDJCQUFPLEtBQVA7QUFDSCxpQkFQRDs7QUFTQSxvQkFBSXF2QixJQUFJb0IsS0FBUixFQUFlO0FBQ1gsd0JBQUlsUCxVQUFVaGlCLE9BQU9zeEIsbUJBQXJCO0FBQ0EsMkJBQU8sVUFBU3B4QixHQUFULEVBQWM7QUFDakIsNEJBQUlzWixNQUFNLEVBQVY7QUFDQSw0QkFBSW93QixjQUFjNXBDLE9BQU9kLE1BQVAsQ0FBYyxJQUFkLENBQWxCO0FBQ0EsK0JBQU9nQixPQUFPLElBQVAsSUFBZSxDQUFDeXBDLGdCQUFnQnpwQyxHQUFoQixDQUF2QixFQUE2QztBQUN6QyxnQ0FBSXVILElBQUo7QUFDQSxnQ0FBSTtBQUNBQSx1Q0FBT3VhLFFBQVE5aEIsR0FBUixDQUFQO0FBQ0gsNkJBRkQsQ0FFRSxPQUFPdEIsQ0FBUCxFQUFVO0FBQ1IsdUNBQU80YSxHQUFQO0FBQ0g7QUFDRCxpQ0FBSyxJQUFJbFosSUFBSSxDQUFiLEVBQWdCQSxJQUFJbUgsS0FBS2pILE1BQXpCLEVBQWlDLEVBQUVGLENBQW5DLEVBQXNDO0FBQ2xDLG9DQUFJSSxNQUFNK0csS0FBS25ILENBQUwsQ0FBVjtBQUNBLG9DQUFJc3BDLFlBQVlscEMsR0FBWixDQUFKLEVBQXNCO0FBQ3RCa3BDLDRDQUFZbHBDLEdBQVosSUFBbUIsSUFBbkI7QUFDQSxvQ0FBSWt4QixPQUFPNXhCLE9BQU9veEIsd0JBQVAsQ0FBZ0NseEIsR0FBaEMsRUFBcUNRLEdBQXJDLENBQVg7QUFDQSxvQ0FBSWt4QixRQUFRLElBQVIsSUFBZ0JBLEtBQUtobkIsR0FBTCxJQUFZLElBQTVCLElBQW9DZ25CLEtBQUt6c0IsR0FBTCxJQUFZLElBQXBELEVBQTBEO0FBQ3REcVUsd0NBQUlsTyxJQUFKLENBQVM1SyxHQUFUO0FBQ0g7QUFDSjtBQUNEUixrQ0FBTTR2QixJQUFJMW5CLGNBQUosQ0FBbUJsSSxHQUFuQixDQUFOO0FBQ0g7QUFDRCwrQkFBT3NaLEdBQVA7QUFDSCxxQkF0QkQ7QUF1QkgsaUJBekJELE1BeUJPO0FBQ0gsd0JBQUlpdEIsVUFBVSxHQUFHNWtDLGNBQWpCO0FBQ0EsMkJBQU8sVUFBUzNCLEdBQVQsRUFBYztBQUNqQiw0QkFBSXlwQyxnQkFBZ0J6cEMsR0FBaEIsQ0FBSixFQUEwQixPQUFPLEVBQVA7QUFDMUIsNEJBQUlzWixNQUFNLEVBQVY7O0FBRUE7QUFDQXF3QixxQ0FBYSxLQUFLLElBQUlucEMsR0FBVCxJQUFnQlIsR0FBaEIsRUFBcUI7QUFDOUIsZ0NBQUl1bUMsUUFBUXJsQyxJQUFSLENBQWFsQixHQUFiLEVBQWtCUSxHQUFsQixDQUFKLEVBQTRCO0FBQ3hCOFksb0NBQUlsTyxJQUFKLENBQVM1SyxHQUFUO0FBQ0gsNkJBRkQsTUFFTztBQUNILHFDQUFLLElBQUlKLElBQUksQ0FBYixFQUFnQkEsSUFBSW9wQyxtQkFBbUJscEMsTUFBdkMsRUFBK0MsRUFBRUYsQ0FBakQsRUFBb0Q7QUFDaEQsd0NBQUltbUMsUUFBUXJsQyxJQUFSLENBQWFzb0MsbUJBQW1CcHBDLENBQW5CLENBQWIsRUFBb0NJLEdBQXBDLENBQUosRUFBOEM7QUFDMUMsaURBQVNtcEMsV0FBVDtBQUNIO0FBQ0o7QUFDRHJ3QixvQ0FBSWxPLElBQUosQ0FBUzVLLEdBQVQ7QUFDSDtBQUNKO0FBQ0QsK0JBQU84WSxHQUFQO0FBQ0gscUJBbEJEO0FBbUJIO0FBRUosYUFoRXVCLEVBQXhCOztBQWtFQSxnQkFBSXN3Qix3QkFBd0IscUJBQTVCO0FBQ0EscUJBQVM3SSxPQUFULENBQWlCMy9CLEVBQWpCLEVBQXFCO0FBQ2pCLG9CQUFJO0FBQ0Esd0JBQUksT0FBT0EsRUFBUCxLQUFjLFVBQWxCLEVBQThCO0FBQzFCLDRCQUFJbUcsT0FBT3FvQixJQUFJdUIsS0FBSixDQUFVL3ZCLEdBQUdMLFNBQWIsQ0FBWDs7QUFFQSw0QkFBSThvQyxhQUFhamEsSUFBSW9CLEtBQUosSUFBYXpwQixLQUFLakgsTUFBTCxHQUFjLENBQTVDO0FBQ0EsNEJBQUl3cEMsaUNBQWlDdmlDLEtBQUtqSCxNQUFMLEdBQWMsQ0FBZCxJQUNqQyxFQUFFaUgsS0FBS2pILE1BQUwsS0FBZ0IsQ0FBaEIsSUFBcUJpSCxLQUFLLENBQUwsTUFBWSxhQUFuQyxDQURKO0FBRUEsNEJBQUl3aUMsb0NBQ0FILHNCQUFzQi82QixJQUF0QixDQUEyQnpOLEtBQUssRUFBaEMsS0FBdUN3dUIsSUFBSXVCLEtBQUosQ0FBVS92QixFQUFWLEVBQWNkLE1BQWQsR0FBdUIsQ0FEbEU7O0FBR0EsNEJBQUl1cEMsY0FBY0MsOEJBQWQsSUFDQUMsaUNBREosRUFDdUM7QUFDbkMsbUNBQU8sSUFBUDtBQUNIO0FBQ0o7QUFDRCwyQkFBTyxLQUFQO0FBQ0gsaUJBaEJELENBZ0JFLE9BQU9yckMsQ0FBUCxFQUFVO0FBQ1IsMkJBQU8sS0FBUDtBQUNIO0FBQ0o7O0FBRUQscUJBQVN1K0IsZ0JBQVQsQ0FBMEJqOUIsR0FBMUIsRUFBK0I7QUFDM0I7QUFDQSx5QkFBU2dxQyxlQUFULEdBQTJCLENBQUU7QUFDN0JBLGdDQUFnQmpwQyxTQUFoQixHQUE0QmYsR0FBNUI7QUFDQSxvQkFBSW1WLElBQUksQ0FBUjtBQUNBLHVCQUFPQSxHQUFQO0FBQVksd0JBQUk2MEIsZUFBSjtBQUFaLGlCQUNBLE9BQU9ocUMsR0FBUDtBQUNBdkIscUJBQUt1QixHQUFMO0FBQ0g7O0FBRUQsZ0JBQUlpcUMsU0FBUyx1QkFBYjtBQUNBLHFCQUFTN3JCLFlBQVQsQ0FBc0JuZCxHQUF0QixFQUEyQjtBQUN2Qix1QkFBT2dwQyxPQUFPcDdCLElBQVAsQ0FBWTVOLEdBQVosQ0FBUDtBQUNIOztBQUVELHFCQUFTdStCLFdBQVQsQ0FBcUJRLEtBQXJCLEVBQTRCa0ssTUFBNUIsRUFBb0N6TCxNQUFwQyxFQUE0QztBQUN4QyxvQkFBSW5sQixNQUFNLElBQUlqWSxLQUFKLENBQVUyK0IsS0FBVixDQUFWO0FBQ0EscUJBQUksSUFBSTUvQixJQUFJLENBQVosRUFBZUEsSUFBSTQvQixLQUFuQixFQUEwQixFQUFFNS9CLENBQTVCLEVBQStCO0FBQzNCa1osd0JBQUlsWixDQUFKLElBQVM4cEMsU0FBUzlwQyxDQUFULEdBQWFxK0IsTUFBdEI7QUFDSDtBQUNELHVCQUFPbmxCLEdBQVA7QUFDSDs7QUFFRCxxQkFBUyt2QixZQUFULENBQXNCcnBDLEdBQXRCLEVBQTJCO0FBQ3ZCLG9CQUFJO0FBQ0EsMkJBQU9BLE1BQU0sRUFBYjtBQUNILGlCQUZELENBRUUsT0FBT3RCLENBQVAsRUFBVTtBQUNSLDJCQUFPLDRCQUFQO0FBQ0g7QUFDSjs7QUFFRCxxQkFBU3lyQyxPQUFULENBQWlCbnFDLEdBQWpCLEVBQXNCO0FBQ2xCLHVCQUFPQSxRQUFRLElBQVIsSUFDQSxRQUFPQSxHQUFQLHlDQUFPQSxHQUFQLE9BQWUsUUFEZixJQUVBLE9BQU9BLElBQUlxVCxPQUFYLEtBQXVCLFFBRnZCLElBR0EsT0FBT3JULElBQUkrWCxJQUFYLEtBQW9CLFFBSDNCO0FBSUg7O0FBRUQscUJBQVNvZ0IsOEJBQVQsQ0FBd0N6NUIsQ0FBeEMsRUFBMkM7QUFDdkMsb0JBQUk7QUFDQXNyQixzQ0FBa0J0ckIsQ0FBbEIsRUFBcUIsZUFBckIsRUFBc0MsSUFBdEM7QUFDSCxpQkFGRCxDQUdBLE9BQU0wckMsTUFBTixFQUFjLENBQUU7QUFDbkI7O0FBRUQscUJBQVNuUSx1QkFBVCxDQUFpQ3Y3QixDQUFqQyxFQUFvQztBQUNoQyxvQkFBSUEsS0FBSyxJQUFULEVBQWUsT0FBTyxLQUFQO0FBQ2YsdUJBQVNBLGFBQWFzWCxNQUFNLHdCQUFOLEVBQWdDNGEsZ0JBQTlDLElBQ0pseUIsRUFBRSxlQUFGLE1BQXVCLElBRDNCO0FBRUg7O0FBRUQscUJBQVNvbEIsY0FBVCxDQUF3QjlqQixHQUF4QixFQUE2QjtBQUN6Qix1QkFBT21xQyxRQUFRbnFDLEdBQVIsS0FBZ0I0dkIsSUFBSXlCLGtCQUFKLENBQXVCcnhCLEdBQXZCLEVBQTRCLE9BQTVCLENBQXZCO0FBQ0g7O0FBRUQsZ0JBQUlrOEIsb0JBQXFCLFlBQVc7QUFDaEMsb0JBQUksRUFBRSxXQUFXLElBQUlsbUIsS0FBSixFQUFiLENBQUosRUFBK0I7QUFDM0IsMkJBQU8sVUFBUzdRLEtBQVQsRUFBZ0I7QUFDbkIsNEJBQUkyZSxlQUFlM2UsS0FBZixDQUFKLEVBQTJCLE9BQU9BLEtBQVA7QUFDM0IsNEJBQUk7QUFBQyxrQ0FBTSxJQUFJNlEsS0FBSixDQUFVcXpCLGFBQWFsa0MsS0FBYixDQUFWLENBQU47QUFBc0MseUJBQTNDLENBQ0EsT0FBTW9wQixHQUFOLEVBQVc7QUFBQyxtQ0FBT0EsR0FBUDtBQUFZO0FBQzNCLHFCQUpEO0FBS0gsaUJBTkQsTUFNTztBQUNILDJCQUFPLFVBQVNwcEIsS0FBVCxFQUFnQjtBQUNuQiw0QkFBSTJlLGVBQWUzZSxLQUFmLENBQUosRUFBMkIsT0FBT0EsS0FBUDtBQUMzQiwrQkFBTyxJQUFJNlEsS0FBSixDQUFVcXpCLGFBQWFsa0MsS0FBYixDQUFWLENBQVA7QUFDSCxxQkFIRDtBQUlIO0FBQ0osYUFidUIsRUFBeEI7O0FBZUEscUJBQVMyWixXQUFULENBQXFCOWUsR0FBckIsRUFBMEI7QUFDdEIsdUJBQU8sR0FBRzRCLFFBQUgsQ0FBWVYsSUFBWixDQUFpQmxCLEdBQWpCLENBQVA7QUFDSDs7QUFFRCxxQkFBUzhnQyxlQUFULENBQXlCdUosSUFBekIsRUFBK0JDLEVBQS9CLEVBQW1DdlksTUFBbkMsRUFBMkM7QUFDdkMsb0JBQUl4cUIsT0FBT3FvQixJQUFJdUIsS0FBSixDQUFVa1osSUFBVixDQUFYO0FBQ0EscUJBQUssSUFBSWpxQyxJQUFJLENBQWIsRUFBZ0JBLElBQUltSCxLQUFLakgsTUFBekIsRUFBaUMsRUFBRUYsQ0FBbkMsRUFBc0M7QUFDbEMsd0JBQUlJLE1BQU0rRyxLQUFLbkgsQ0FBTCxDQUFWO0FBQ0Esd0JBQUkyeEIsT0FBT3Z4QixHQUFQLENBQUosRUFBaUI7QUFDYiw0QkFBSTtBQUNBb3ZCLGdDQUFJM2IsY0FBSixDQUFtQnEyQixFQUFuQixFQUF1QjlwQyxHQUF2QixFQUE0Qm92QixJQUFJcUIsYUFBSixDQUFrQm9aLElBQWxCLEVBQXdCN3BDLEdBQXhCLENBQTVCO0FBQ0gseUJBRkQsQ0FFRSxPQUFPNHBDLE1BQVAsRUFBZSxDQUFFO0FBQ3RCO0FBQ0o7QUFDSjs7QUFFRCxnQkFBSTVNLFVBQVUsaUJBQVMvN0IsQ0FBVCxFQUFZO0FBQ3RCLG9CQUFJbXVCLElBQUl0akIsT0FBSixDQUFZN0ssQ0FBWixDQUFKLEVBQW9CO0FBQ2hCLDJCQUFPQSxDQUFQO0FBQ0g7QUFDRCx1QkFBTyxJQUFQO0FBQ0gsYUFMRDs7QUFPQSxnQkFBSSxPQUFPc0csTUFBUCxLQUFrQixXQUFsQixJQUFpQ0EsT0FBTzIvQixRQUE1QyxFQUFzRDtBQUNsRCxvQkFBSTZDLFlBQVksT0FBT2xwQyxNQUFNZ3BDLElBQWIsS0FBc0IsVUFBdEIsR0FBbUMsVUFBUzVvQyxDQUFULEVBQVk7QUFDM0QsMkJBQU9KLE1BQU1ncEMsSUFBTixDQUFXNW9DLENBQVgsQ0FBUDtBQUNILGlCQUZlLEdBRVosVUFBU0EsQ0FBVCxFQUFZO0FBQ1osd0JBQUk2WCxNQUFNLEVBQVY7QUFDQSx3QkFBSWt4QixLQUFLL29DLEVBQUVzRyxPQUFPMi9CLFFBQVQsR0FBVDtBQUNBLHdCQUFJK0MsUUFBSjtBQUNBLDJCQUFPLENBQUUsQ0FBQ0EsV0FBV0QsR0FBRzVWLElBQUgsRUFBWixFQUF1QkksSUFBaEMsRUFBdUM7QUFDbkMxYiw0QkFBSWxPLElBQUosQ0FBU3EvQixTQUFTdGxDLEtBQWxCO0FBQ0g7QUFDRCwyQkFBT21VLEdBQVA7QUFDSCxpQkFWRDs7QUFZQWtrQiwwQkFBVSxpQkFBUy83QixDQUFULEVBQVk7QUFDbEIsd0JBQUltdUIsSUFBSXRqQixPQUFKLENBQVk3SyxDQUFaLENBQUosRUFBb0I7QUFDaEIsK0JBQU9BLENBQVA7QUFDSCxxQkFGRCxNQUVPLElBQUlBLEtBQUssSUFBTCxJQUFhLE9BQU9BLEVBQUVzRyxPQUFPMi9CLFFBQVQsQ0FBUCxLQUE4QixVQUEvQyxFQUEyRDtBQUM5RCwrQkFBTzZDLFVBQVU5b0MsQ0FBVixDQUFQO0FBQ0g7QUFDRCwyQkFBTyxJQUFQO0FBQ0gsaUJBUEQ7QUFRSDs7QUFFRCxnQkFBSXVaLFNBQVMsT0FBT3RXLE9BQVAsS0FBbUIsV0FBbkIsSUFDTG9hLFlBQVlwYSxPQUFaLEVBQXFCbWlCLFdBQXJCLE9BQXVDLGtCQUQvQzs7QUFHQSxnQkFBSTZqQixrQkFBa0IsT0FBT2htQyxPQUFQLEtBQW1CLFdBQW5CLElBQ2xCLE9BQU9BLFFBQVEyUyxHQUFmLEtBQXVCLFdBRDNCOztBQUdBLHFCQUFTQSxHQUFULENBQWE3VyxHQUFiLEVBQWtCO0FBQ2QsdUJBQU9rcUMsa0JBQWtCaG1DLFFBQVEyUyxHQUFSLENBQVk3VyxHQUFaLENBQWxCLEdBQXFDK0YsU0FBNUM7QUFDSDs7QUFFRCxxQkFBU285QixnQkFBVCxHQUE0QjtBQUN4QixvQkFBSSxPQUFPMTZCLE9BQVAsS0FBbUIsVUFBdkIsRUFBbUM7QUFDL0Isd0JBQUk7QUFDQSw0QkFBSXdNLFVBQVUsSUFBSXhNLE9BQUosQ0FBWSxZQUFVLENBQUUsQ0FBeEIsQ0FBZDtBQUNBLDRCQUFJLEdBQUdySCxRQUFILENBQVlWLElBQVosQ0FBaUJ1VSxPQUFqQixNQUE4QixrQkFBbEMsRUFBc0Q7QUFDbEQsbUNBQU94TSxPQUFQO0FBQ0g7QUFDSixxQkFMRCxDQUtFLE9BQU92SyxDQUFQLEVBQVUsQ0FBRTtBQUNqQjtBQUNKOztBQUVELHFCQUFTb25CLFVBQVQsQ0FBb0IzaEIsSUFBcEIsRUFBMEI4ZCxFQUExQixFQUE4QjtBQUMxQix1QkFBTzlkLEtBQUs3RSxJQUFMLENBQVUyaUIsRUFBVixDQUFQO0FBQ0g7O0FBRUQsZ0JBQUkzSSxNQUFNO0FBQ055bkIseUJBQVNBLE9BREg7QUFFTjNpQiw4QkFBY0EsWUFGUjtBQUdOMmdCLG1DQUFtQkEsaUJBSGI7QUFJTkwsMENBQTBCQSx3QkFKcEI7QUFLTjdQLHlCQUFTQSxPQUxIO0FBTU52aUIseUJBQVNzakIsSUFBSXRqQixPQU5QO0FBT05reEIseUJBQVNBLE9BUEg7QUFRTnhULG1DQUFtQkEsaUJBUmI7QUFTTm1mLDZCQUFhQSxXQVRQO0FBVU50cEMsMEJBQVVBLFFBVko7QUFXTnNxQyx5QkFBU0EsT0FYSDtBQVlOaHNCLDZCQUFhQSxXQVpQO0FBYU5xQiwwQkFBVUEsUUFiSjtBQWNORCwwQkFBVUEsUUFkSjtBQWVOb08sMEJBQVVBLFFBZko7QUFnQk5vUSw4QkFBY0EsWUFoQlI7QUFpQk5oRyxrQ0FBa0JBLGdCQWpCWjtBQWtCTmtGLGtDQUFrQkEsZ0JBbEJaO0FBbUJOdUMsNkJBQWFBLFdBbkJQO0FBb0JONTlCLDBCQUFVeW5DLFlBcEJKO0FBcUJOdmxCLGdDQUFnQkEsY0FyQlY7QUFzQk5vWSxtQ0FBbUJBLGlCQXRCYjtBQXVCTmpDLHlDQUF5QkEsdUJBdkJuQjtBQXdCTjlCLGdEQUFnQ0EsOEJBeEIxQjtBQXlCTnJaLDZCQUFhQSxXQXpCUDtBQTBCTmdpQixpQ0FBaUJBLGVBMUJYO0FBMkJOam1CLDZCQUFhLE9BQU84dkIsTUFBUCxLQUFrQixXQUFsQixJQUFpQ0EsTUFBakMsSUFDQSxPQUFPQSxPQUFPQyxTQUFkLEtBQTRCLFVBNUJuQztBQTZCTjV2Qix3QkFBUUEsTUE3QkY7QUE4Qk4wdkIsaUNBQWlCQSxlQTlCWDtBQStCTnJ6QixxQkFBS0EsR0EvQkM7QUFnQ05oWSx3QkFBUXlwQyxZQWhDRjtBQWlDTm5GLGtDQUFrQkEsZ0JBakNaO0FBa0NON2QsNEJBQVlBO0FBbENOLGFBQVY7QUFvQ0F4TSxnQkFBSTBxQixZQUFKLEdBQW1CMXFCLElBQUkwQixNQUFKLElBQWUsWUFBVztBQUN6QyxvQkFBSXpELFVBQVU3UyxRQUFROFMsUUFBUixDQUFpQnNXLElBQWpCLENBQXNCdkQsS0FBdEIsQ0FBNEIsR0FBNUIsRUFBaUM5cUIsR0FBakMsQ0FBcUNvckMsTUFBckMsQ0FBZDtBQUNBLHVCQUFRdHpCLFFBQVEsQ0FBUixNQUFlLENBQWYsSUFBb0JBLFFBQVEsQ0FBUixJQUFhLEVBQWxDLElBQTBDQSxRQUFRLENBQVIsSUFBYSxDQUE5RDtBQUNILGFBSGdDLEVBQWpDOztBQUtBLGdCQUFJK0IsSUFBSTBCLE1BQVIsRUFBZ0IxQixJQUFJMmpCLGdCQUFKLENBQXFCdjRCLE9BQXJCOztBQUVoQixnQkFBSTtBQUFDLHNCQUFNLElBQUlzUixLQUFKLEVBQU47QUFBb0IsYUFBekIsQ0FBMEIsT0FBT3RYLENBQVAsRUFBVTtBQUFDNGEsb0JBQUk0VCxhQUFKLEdBQW9CeHVCLENBQXBCO0FBQXVCO0FBQzVERSxtQkFBT0MsT0FBUCxHQUFpQnlhLEdBQWpCO0FBRUMsU0E3WGlDLEVBNlhoQyxFQUFDLFNBQVEsRUFBVCxFQTdYZ0MsQ0F4bEs4dEIsRUFBM2IsRUFxOUtwVCxFQXI5S29ULEVBcTlLalQsQ0FBQyxDQUFELENBcjlLaVQsRUFxOUs1UyxDQXI5SzRTLENBQVA7QUFzOUs3VCxDQXQ5S0EsQ0FBRCxDQXM5S3VCLENBQUMsSUFBSSxPQUFPM2EsTUFBUCxLQUFrQixXQUFsQixJQUFpQ0EsV0FBVyxJQUFoRCxFQUFzRDtBQUFnQ0EsV0FBT21zQyxDQUFQLEdBQVduc0MsT0FBT3NLLE9BQWxCO0FBQWdGLENBQXRLLE1BQTRLLElBQUksT0FBTzlFLElBQVAsS0FBZ0IsV0FBaEIsSUFBK0JBLFNBQVMsSUFBNUMsRUFBa0Q7QUFBOEJBLFNBQUsybUMsQ0FBTCxHQUFTM21DLEtBQUs4RSxPQUFkO0FBQWdGLEM7Ozs7Ozs7Ozs7OztBQ2wvS3BXO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0MsV0FBVTdFLElBQVYsRUFBZ0IybUMsT0FBaEIsRUFBeUI7QUFDdEIsTUFBSSxJQUFKLEVBQWdEO0FBQzVDO0FBQ0FyeUIsSUFBQSxpQ0FBTyxFQUFQLG9DQUFXcXlCLE9BQVg7QUFBQTtBQUFBO0FBQUE7QUFDSCxHQUhELE1BR08sSUFBSSxRQUFPbHNDLE9BQVAseUNBQU9BLE9BQVAsT0FBbUIsUUFBdkIsRUFBaUM7QUFDcEM7QUFDQTtBQUNBO0FBQ0FELFdBQU9DLE9BQVAsR0FBaUJrc0MsU0FBakI7QUFDSCxHQUxNLE1BS0E7QUFDSDtBQUNBM21DLFNBQUs0bUMsYUFBTCxHQUFxQkQsU0FBckI7QUFDTDtBQUNGLENBYkEsYUFhTyxZQUFZO0FBQ3BCOztBQUVBLE1BQUlFLE1BQU1DLGNBQVY7QUFDQSxNQUFJLENBQUNELEdBQUwsRUFBVSxNQUFNLElBQUlqMUIsS0FBSixDQUFVLHdCQUFWLENBQU47QUFDVm0xQixVQUFRbmYsR0FBUixHQUFjO0FBQ1osYUFBU3ZVLElBREcsRUFDRyxTQUFTQSxJQURaLEVBQ2tCLFFBQVFBLElBRDFCLEVBQ2dDLFFBQVFBLElBRHhDLEVBQzhDLFNBQVNBO0FBRHZELEdBQWQ7O0FBSUEsTUFBSTJ6QixrQkFBa0IsSUFBSSxFQUFKLEdBQVMsSUFBL0IsQ0FUb0IsQ0FTZ0I7O0FBRXBDO0FBQ0E7QUFDQTs7QUFFQSxXQUFTRCxPQUFULENBQWlCdDRCLE9BQWpCLEVBQTBCaUIsUUFBMUIsRUFBb0M7QUFDbEM7QUFDQSxRQUFHLE9BQU9BLFFBQVAsS0FBb0IsVUFBdkIsRUFDRSxNQUFNLElBQUlrQyxLQUFKLENBQVUseUJBQXlCbEMsUUFBbkMsQ0FBTjs7QUFFRixRQUFHLENBQUNqQixPQUFKLEVBQ0UsTUFBTSxJQUFJbUQsS0FBSixDQUFVLGtCQUFWLENBQU47O0FBRUYsUUFBSXExQixxQkFBcUJ4NEIsUUFBUXk0QixVQUFqQyxDQVJrQyxDQVFXOztBQUU3QyxRQUFHLE9BQU96NEIsT0FBUCxLQUFtQixRQUF0QixFQUNFQSxVQUFVLEVBQUMsT0FBTUEsT0FBUCxFQUFWLENBREYsS0FHRUEsVUFBVXlaLEtBQUtpZixLQUFMLENBQVdqZixLQUFLQyxTQUFMLENBQWUxWixPQUFmLENBQVgsQ0FBVixDQWJnQyxDQWFlOztBQUVqREEsWUFBUXk0QixVQUFSLEdBQXFCRCxrQkFBckIsQ0Fma0MsQ0FlTTs7QUFFeEMsUUFBSXg0QixRQUFRMjRCLE9BQVosRUFBcUJMLFFBQVFuZixHQUFSLEdBQWN5ZixXQUFkOztBQUVyQixRQUFHNTRCLFFBQVE2NEIsR0FBWCxFQUFnQjtBQUNkNzRCLGNBQVFnQixHQUFSLEdBQWNoQixRQUFRNjRCLEdBQXRCO0FBQ0EsYUFBTzc0QixRQUFRNjRCLEdBQWY7QUFDRDs7QUFFRCxRQUFHLENBQUM3NEIsUUFBUWdCLEdBQVQsSUFBZ0JoQixRQUFRZ0IsR0FBUixLQUFnQixFQUFuQyxFQUNFLE1BQU0sSUFBSW1DLEtBQUosQ0FBVSxvQ0FBVixDQUFOOztBQUVGLFFBQUcsT0FBT25ELFFBQVFnQixHQUFmLElBQXNCLFFBQXpCLEVBQ0UsTUFBTSxJQUFJbUMsS0FBSixDQUFVLDhCQUFWLENBQU47O0FBRUYsUUFBSTIxQixzQkFBc0IsQ0FBQyxPQUFELEVBQVUsb0JBQVYsRUFBZ0MsY0FBaEMsRUFBZ0QsZ0JBQWhELENBQTFCO0FBQ0EsU0FBSyxJQUFJdnJDLElBQUksQ0FBYixFQUFnQkEsSUFBSXVyQyxvQkFBb0JyckMsTUFBeEMsRUFBZ0RGLEdBQWhEO0FBQ0UsVUFBR3lTLFFBQVM4NEIsb0JBQW9CdnJDLENBQXBCLENBQVQsQ0FBSCxFQUNFLE1BQU0sSUFBSTRWLEtBQUosQ0FBVSxhQUFhMjFCLG9CQUFvQnZyQyxDQUFwQixDQUFiLEdBQXNDLG1CQUFoRCxDQUFOO0FBRkosS0FJQXlTLFFBQVFpQixRQUFSLEdBQW1CQSxRQUFuQjtBQUNBakIsWUFBUXdVLE1BQVIsR0FBaUJ4VSxRQUFRd1UsTUFBUixJQUFrQixLQUFuQztBQUNBeFUsWUFBUSs0QixPQUFSLEdBQWtCLzRCLFFBQVErNEIsT0FBUixJQUFtQixFQUFyQztBQUNBLzRCLFlBQVF1dEIsSUFBUixHQUFrQnZ0QixRQUFRdXRCLElBQVIsSUFBZ0IsSUFBbEM7QUFDQXZ0QixZQUFRaUUsT0FBUixHQUFrQmpFLFFBQVFpRSxPQUFSLElBQW1CcTBCLFFBQVFDLGVBQTdDOztBQUVBLFFBQUd2NEIsUUFBUSs0QixPQUFSLENBQWdCQyxJQUFuQixFQUNFLE1BQU0sSUFBSTcxQixLQUFKLENBQVUsdUNBQVYsQ0FBTjs7QUFFRixRQUFHbkQsUUFBUWk1QixJQUFYLEVBQWlCO0FBQ2ZqNUIsY0FBUSs0QixPQUFSLENBQWdCRyxNQUFoQixHQUF5Qmw1QixRQUFRKzRCLE9BQVIsQ0FBZ0JHLE1BQWhCLElBQTBCLGtCQUFuRDtBQUNBLFVBQUdsNUIsUUFBUXdVLE1BQVIsS0FBbUIsS0FBdEIsRUFDRXhVLFFBQVErNEIsT0FBUixDQUFnQixjQUFoQixJQUFrQyxrQkFBbEM7O0FBRUYsVUFBRyxPQUFPLzRCLFFBQVFpNUIsSUFBZixLQUF3QixTQUEzQixFQUNFajVCLFFBQVF1dEIsSUFBUixHQUFlOVQsS0FBS0MsU0FBTCxDQUFlMVosUUFBUWk1QixJQUF2QixDQUFmLENBREYsS0FFSyxJQUFHLE9BQU9qNUIsUUFBUXV0QixJQUFmLEtBQXdCLFFBQTNCLEVBQ0h2dEIsUUFBUXV0QixJQUFSLEdBQWU5VCxLQUFLQyxTQUFMLENBQWUxWixRQUFRdXRCLElBQXZCLENBQWY7QUFDSDs7QUFFRDtBQUNBLFFBQUk0TCxZQUFZLFNBQVpBLFNBQVksQ0FBU2hzQyxHQUFULEVBQWM7QUFDNUIsVUFBSWlCLE1BQU0sRUFBVjtBQUNBLFdBQUksSUFBSWs4QixDQUFSLElBQWFuOUIsR0FBYjtBQUNFLFlBQUlBLElBQUkyQixjQUFKLENBQW1CdzdCLENBQW5CLENBQUosRUFBMkI7QUFDekJsOEIsY0FBSW1LLElBQUosQ0FBUzZnQyxtQkFBbUI5TyxDQUFuQixJQUF3QixHQUF4QixHQUE4QjhPLG1CQUFtQmpzQyxJQUFJbTlCLENBQUosQ0FBbkIsQ0FBdkM7QUFDRDtBQUhILE9BSUEsT0FBT2w4QixJQUFJZ3BCLElBQUosQ0FBUyxHQUFULENBQVA7QUFDRCxLQVBEOztBQVNBLFFBQUdwWCxRQUFRcTVCLEVBQVgsRUFBYztBQUNaLFVBQUlBLEtBQU0sT0FBT3I1QixRQUFRcTVCLEVBQWYsSUFBcUIsUUFBdEIsR0FBaUNyNUIsUUFBUXE1QixFQUF6QyxHQUE4Q0YsVUFBVW41QixRQUFRcTVCLEVBQWxCLENBQXZEO0FBQ0EsVUFBR3I1QixRQUFRZ0IsR0FBUixDQUFZMmEsT0FBWixDQUFvQixHQUFwQixNQUE2QixDQUFDLENBQWpDLEVBQW1DO0FBQUU7QUFDakMzYixnQkFBUWdCLEdBQVIsR0FBY2hCLFFBQVFnQixHQUFSLEdBQVksR0FBWixHQUFnQnE0QixFQUE5QjtBQUNILE9BRkQsTUFFSztBQUFFO0FBQ0hyNUIsZ0JBQVFnQixHQUFSLEdBQWNoQixRQUFRZ0IsR0FBUixHQUFZLEdBQVosR0FBZ0JxNEIsRUFBOUI7QUFDSDtBQUNGO0FBQ0Q7O0FBRUE7QUFDQSxRQUFJQyxZQUFZLFNBQVpBLFNBQVksQ0FBU25zQyxHQUFULEVBQWM7QUFDNUI7QUFDQSxVQUFJbUcsU0FBUyxFQUFiO0FBQ0FBLGFBQU9pbUMsT0FBUCxHQUFpQixvQ0FBa0N4akMsS0FBS3lqQyxLQUFMLENBQVd6akMsS0FBSzBqQyxNQUFMLEtBQWMsVUFBekIsQ0FBbkQ7QUFDQSxVQUFJM2IsUUFBUSxFQUFaO0FBQ0EsV0FBSSxJQUFJd00sQ0FBUixJQUFhbjlCLEdBQWIsRUFBaUI7QUFDYixZQUFJQSxJQUFJMkIsY0FBSixDQUFtQnc3QixDQUFuQixDQUFKLEVBQTJCO0FBQ3ZCeE0sZ0JBQU12bEIsSUFBTixDQUNJLE9BQUtqRixPQUFPaW1DLE9BQVosR0FBb0IsSUFBcEIsR0FDQSx3Q0FEQSxHQUN5Q2pQLENBRHpDLEdBQzJDLEdBRDNDLEdBQytDLElBRC9DLEdBRUEsSUFGQSxHQUdBbjlCLElBQUltOUIsQ0FBSixDQUhBLEdBR08sSUFKWDtBQU1IO0FBQ0o7QUFDRHhNLFlBQU12bEIsSUFBTixDQUFZLE9BQUtqRixPQUFPaW1DLE9BQVosR0FBb0IsSUFBaEM7QUFDQWptQyxhQUFPaTZCLElBQVAsR0FBY3pQLE1BQU0xRyxJQUFOLENBQVcsRUFBWCxDQUFkO0FBQ0E5akIsYUFBTzdGLE1BQVAsR0FBZ0I2RixPQUFPaTZCLElBQVAsQ0FBWTkvQixNQUE1QjtBQUNBNkYsYUFBTytMLElBQVAsR0FBYyxtQ0FBaUMvTCxPQUFPaW1DLE9BQXREO0FBQ0EsYUFBT2ptQyxNQUFQO0FBQ0QsS0FwQkQ7O0FBc0JBLFFBQUcwTSxRQUFRMDVCLElBQVgsRUFBZ0I7QUFDZCxVQUFHLE9BQU8xNUIsUUFBUTA1QixJQUFmLElBQXVCLFFBQTFCLEVBQW9DLE1BQU0sdUJBQU47QUFDcEMsVUFBRzE1QixRQUFRd1UsTUFBUixLQUFtQixNQUF0QixFQUE2QjtBQUN6QixZQUFJbWxCLFdBQVcsQ0FBQzM1QixRQUFRMjVCLFFBQVIsSUFBb0IsbUNBQXJCLEVBQTBEM2xCLFdBQTFELEVBQWY7QUFDQWhVLGdCQUFRKzRCLE9BQVIsQ0FBZ0IsY0FBaEIsSUFBa0NZLFFBQWxDO0FBQ0EsZ0JBQU9BLFFBQVA7QUFDSSxlQUFLLG1DQUFMO0FBQ0kzNUIsb0JBQVF1dEIsSUFBUixHQUFlNEwsVUFBVW41QixRQUFRMDVCLElBQWxCLEVBQXdCcHJDLE9BQXhCLENBQWdDLE1BQWhDLEVBQXdDLEdBQXhDLENBQWY7QUFDQTtBQUNKLGVBQUsscUJBQUw7QUFDSSxnQkFBSXNyQyxRQUFRTixVQUFVdDVCLFFBQVEwNUIsSUFBbEIsQ0FBWjtBQUNBO0FBQ0ExNUIsb0JBQVF1dEIsSUFBUixHQUFlcU0sTUFBTXJNLElBQXJCO0FBQ0F2dEIsb0JBQVErNEIsT0FBUixDQUFnQixjQUFoQixJQUFrQ2EsTUFBTXY2QixJQUF4QztBQUNBO0FBQ0o7QUFBVSxrQkFBTSxJQUFJOEQsS0FBSixDQUFVLDBCQUF3QncyQixRQUFsQyxDQUFOO0FBVmQ7QUFZSDtBQUNGO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBMzVCLFlBQVF5NEIsVUFBUixHQUFxQno0QixRQUFReTRCLFVBQVIsSUFBc0I3ekIsSUFBM0M7QUFDQSxRQUFHNUUsUUFBUXk0QixVQUFSLEtBQXVCLElBQTFCLEVBQWdDO0FBQzlCejRCLGNBQVF5NEIsVUFBUixHQUFxQngzQixRQUFyQjtBQUNBakIsY0FBUWlCLFFBQVIsR0FBbUIyRCxJQUFuQjtBQUNEOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQUcsQ0FBQzVFLFFBQVErNEIsT0FBUixDQUFnQmMsYUFBakIsSUFBa0M3NUIsUUFBUTg1QixJQUE3QyxFQUNFOTVCLFFBQVErNEIsT0FBUixDQUFnQmMsYUFBaEIsR0FBZ0MsV0FBV0UsUUFBUS81QixRQUFRODVCLElBQVIsQ0FBYUUsUUFBYixHQUF3QixHQUF4QixHQUE4Qmg2QixRQUFRODVCLElBQVIsQ0FBYUcsUUFBbkQsQ0FBM0M7O0FBRUYsV0FBT0MsUUFBUWw2QixPQUFSLENBQVA7QUFDRDs7QUFFRCxNQUFJbTZCLFVBQVUsQ0FBZDtBQUNBLFdBQVNELE9BQVQsQ0FBaUJsNkIsT0FBakIsRUFBMEI7QUFDeEIsUUFBSW82QixNQUFNLElBQUloQyxHQUFKLEVBQVY7QUFBQSxRQUNJaUMsWUFBWSxLQURoQjtBQUFBLFFBRUlDLFVBQVVDLGVBQWV2NkIsUUFBUWdCLEdBQXZCLENBRmQ7QUFBQSxRQUdJdzVCLGdCQUFpQixxQkFBcUJKLEdBSDFDOztBQUtBRCxlQUFXLENBQVg7QUFDQUMsUUFBSUssTUFBSixHQUFhTixPQUFiO0FBQ0FDLFFBQUlNLEVBQUosR0FBU1AsVUFBVSxJQUFWLEdBQWlCbjZCLFFBQVF3VSxNQUF6QixHQUFrQyxHQUFsQyxHQUF3Q3hVLFFBQVFnQixHQUF6RDtBQUNBbzVCLFFBQUlPLEdBQUosR0FBVVAsSUFBSU0sRUFBZCxDQVR3QixDQVNQOztBQUVqQixRQUFHSixXQUFXLENBQUNFLGFBQWYsRUFBOEI7QUFDNUIsVUFBSUksV0FBVyxJQUFJejNCLEtBQUosQ0FBVSxvREFBb0RuRCxRQUFRZ0IsR0FBdEUsQ0FBZjtBQUNBNDVCLGVBQVNDLElBQVQsR0FBZ0IsYUFBaEI7QUFDQSxhQUFPNzZCLFFBQVFpQixRQUFSLENBQWlCMjVCLFFBQWpCLEVBQTJCUixHQUEzQixDQUFQO0FBQ0Q7O0FBRURBLFFBQUlVLFlBQUosR0FBbUJ6M0IsV0FBVzAzQixRQUFYLEVBQXFCLzZCLFFBQVFpRSxPQUE3QixDQUFuQjtBQUNBLGFBQVM4MkIsUUFBVCxHQUFvQjtBQUNsQlYsa0JBQVksSUFBWjtBQUNBLFVBQUlXLEtBQUssSUFBSTczQixLQUFKLENBQVUsV0FBVixDQUFUO0FBQ0E2M0IsU0FBRzUwQixJQUFILEdBQVUsV0FBVjtBQUNBNDBCLFNBQUdDLFFBQUgsR0FBY2o3QixRQUFRaUUsT0FBdEI7O0FBRUFxMEIsY0FBUW5mLEdBQVIsQ0FBWTFZLEtBQVosQ0FBa0IsU0FBbEIsRUFBNkIsRUFBRSxNQUFLMjVCLElBQUlPLEdBQVgsRUFBZ0IsZ0JBQWUzNkIsUUFBUWlFLE9BQXZDLEVBQTdCO0FBQ0EsYUFBT2pFLFFBQVFpQixRQUFSLENBQWlCKzVCLEVBQWpCLEVBQXFCWixHQUFyQixDQUFQO0FBQ0Q7O0FBRUQ7QUFDQSxRQUFJYyxNQUFNLEVBQUMsWUFBVyxLQUFaLEVBQW1CLFdBQVUsS0FBN0IsRUFBb0MsT0FBTSxLQUExQyxFQUFWOztBQUVBZCxRQUFJZSxrQkFBSixHQUF5QkMsZUFBekI7QUFDQWhCLFFBQUlpQixJQUFKLENBQVNyN0IsUUFBUXdVLE1BQWpCLEVBQXlCeFUsUUFBUWdCLEdBQWpDLEVBQXNDLElBQXRDLEVBaEN3QixDQWdDb0I7QUFDNUMsUUFBR3M1QixPQUFILEVBQ0VGLElBQUlrQixlQUFKLEdBQXNCLENBQUMsQ0FBRXQ3QixRQUFRczdCLGVBQWpDO0FBQ0ZsQixRQUFJbUIsSUFBSixDQUFTdjdCLFFBQVF1dEIsSUFBakI7QUFDQSxXQUFPNk0sR0FBUDs7QUFFQSxhQUFTZ0IsZUFBVCxDQUF5QnZuQixLQUF6QixFQUFnQztBQUM5QixVQUFHd21CLFNBQUgsRUFDRSxPQUFPL0IsUUFBUW5mLEdBQVIsQ0FBWTVQLEtBQVosQ0FBa0IsaUNBQWxCLEVBQXFELEVBQUMsU0FBUTZ3QixJQUFJb0IsVUFBYixFQUF5QixNQUFLcEIsSUFBSU0sRUFBbEMsRUFBckQsQ0FBUDs7QUFFRnBDLGNBQVFuZixHQUFSLENBQVk1UCxLQUFaLENBQWtCLGNBQWxCLEVBQWtDLEVBQUMsU0FBUTZ3QixJQUFJb0IsVUFBYixFQUF5QixNQUFLcEIsSUFBSU0sRUFBbEMsRUFBc0MsYUFBWUwsU0FBbEQsRUFBbEM7O0FBRUEsVUFBR0QsSUFBSW9CLFVBQUosS0FBbUJwRCxJQUFJcUQsTUFBMUIsRUFBa0M7QUFDaENuRCxnQkFBUW5mLEdBQVIsQ0FBWTVQLEtBQVosQ0FBa0IsaUJBQWxCLEVBQXFDLEVBQUMsTUFBSzZ3QixJQUFJTSxFQUFWLEVBQXJDO0FBQ0EsYUFBSyxJQUFJL3NDLEdBQVQsSUFBZ0JxUyxRQUFRKzRCLE9BQXhCO0FBQ0VxQixjQUFJc0IsZ0JBQUosQ0FBcUIvdEMsR0FBckIsRUFBMEJxUyxRQUFRKzRCLE9BQVIsQ0FBZ0JwckMsR0FBaEIsQ0FBMUI7QUFERjtBQUVELE9BSkQsTUFNSyxJQUFHeXNDLElBQUlvQixVQUFKLEtBQW1CcEQsSUFBSXVELGdCQUExQixFQUNIQyxjQURHLEtBR0EsSUFBR3hCLElBQUlvQixVQUFKLEtBQW1CcEQsSUFBSXlELE9BQTFCLEVBQW1DO0FBQ3RDRDtBQUNBRTtBQUNELE9BSEksTUFLQSxJQUFHMUIsSUFBSW9CLFVBQUosS0FBbUJwRCxJQUFJMkQsSUFBMUIsRUFBZ0M7QUFDbkNIO0FBQ0FFO0FBQ0FFO0FBQ0Q7QUFDRjs7QUFFRCxhQUFTSixXQUFULEdBQXVCO0FBQ3JCLFVBQUdWLElBQUl4NEIsUUFBUCxFQUNFOztBQUVGdzRCLFVBQUl4NEIsUUFBSixHQUFlLElBQWY7QUFDQTQxQixjQUFRbmYsR0FBUixDQUFZNVAsS0FBWixDQUFrQixjQUFsQixFQUFrQyxFQUFDLE1BQUs2d0IsSUFBSU0sRUFBVixFQUFjLFVBQVNOLElBQUk2QixNQUEzQixFQUFsQztBQUNBMzRCLG1CQUFhODJCLElBQUlVLFlBQWpCO0FBQ0FWLFVBQUk4QixVQUFKLEdBQWlCOUIsSUFBSTZCLE1BQXJCLENBUHFCLENBT087O0FBRTVCO0FBQ0EsVUFBRzNCLFdBQVdGLElBQUk4QixVQUFKLElBQWtCLENBQWhDLEVBQW1DO0FBQ2pDLFlBQUl0QixXQUFXLElBQUl6M0IsS0FBSixDQUFVLDRCQUE0Qm5ELFFBQVFnQixHQUE5QyxDQUFmO0FBQ0E0NUIsaUJBQVNDLElBQVQsR0FBZ0IsVUFBaEI7O0FBRUE7QUFDQUssWUFBSWlCLE9BQUosR0FBYyxJQUFkO0FBQ0FqQixZQUFJa0IsR0FBSixHQUFVLElBQVY7O0FBRUEsZUFBT3A4QixRQUFRaUIsUUFBUixDQUFpQjI1QixRQUFqQixFQUEyQlIsR0FBM0IsQ0FBUDtBQUNEOztBQUVEcDZCLGNBQVF5NEIsVUFBUixDQUFtQixJQUFuQixFQUF5QjJCLEdBQXpCO0FBQ0Q7O0FBRUQsYUFBUzBCLFVBQVQsR0FBc0I7QUFDcEIsVUFBR1osSUFBSWlCLE9BQVAsRUFDRTs7QUFFRmpCLFVBQUlpQixPQUFKLEdBQWMsSUFBZDtBQUNBN0QsY0FBUW5mLEdBQVIsQ0FBWTVQLEtBQVosQ0FBa0IsdUJBQWxCLEVBQTJDLEVBQUMsTUFBSzZ3QixJQUFJTSxFQUFWLEVBQTNDO0FBQ0E7QUFDRDs7QUFFRCxhQUFTc0IsTUFBVCxHQUFrQjtBQUNoQixVQUFHZCxJQUFJa0IsR0FBUCxFQUNFOztBQUVGbEIsVUFBSWtCLEdBQUosR0FBVSxJQUFWO0FBQ0E5RCxjQUFRbmYsR0FBUixDQUFZNVAsS0FBWixDQUFrQixjQUFsQixFQUFrQyxFQUFDLE1BQUs2d0IsSUFBSU0sRUFBVixFQUFsQzs7QUFFQU4sVUFBSTdNLElBQUosR0FBVzZNLElBQUlpQyxZQUFmO0FBQ0EsVUFBR3I4QixRQUFRaTVCLElBQVgsRUFBaUI7QUFDZixZQUFXO0FBQUVtQixjQUFJN00sSUFBSixHQUFXOVQsS0FBS2lmLEtBQUwsQ0FBVzBCLElBQUlpQyxZQUFmLENBQVg7QUFBeUMsU0FBdEQsQ0FDQSxPQUFPckIsRUFBUCxFQUFXO0FBQUUsaUJBQU9oN0IsUUFBUWlCLFFBQVIsQ0FBaUIrNUIsRUFBakIsRUFBcUJaLEdBQXJCLENBQVA7QUFBeUM7QUFDdkQ7O0FBRURwNkIsY0FBUWlCLFFBQVIsQ0FBaUIsSUFBakIsRUFBdUJtNUIsR0FBdkIsRUFBNEJBLElBQUk3TSxJQUFoQztBQUNEO0FBRUYsR0E1UW1CLENBNFFsQjs7QUFFRitLLFVBQVFnRCxlQUFSLEdBQTBCLEtBQTFCO0FBQ0FoRCxVQUFRQyxlQUFSLEdBQTBCQSxlQUExQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUFELFVBQVFnRSxRQUFSLEdBQW1CLFVBQVN0OEIsT0FBVCxFQUFrQnU4QixTQUFsQixFQUE2QjtBQUM5QyxRQUFJQyxNQUFNLFNBQU5BLEdBQU0sQ0FBVWhvQixNQUFWLEVBQWtCO0FBQzFCLFVBQUl0VCxJQUFJLFNBQUpBLENBQUksQ0FBVXU3QixNQUFWLEVBQWtCeDdCLFFBQWxCLEVBQTRCO0FBQ2xDLFlBQUcsT0FBT3c3QixNQUFQLEtBQWtCLFFBQXJCLEVBQ0VBLFNBQVMsRUFBQyxPQUFPQSxNQUFSLEVBQVQsQ0FERixLQUVLO0FBQ0hBLG1CQUFTaGpCLEtBQUtpZixLQUFMLENBQVdqZixLQUFLQyxTQUFMLENBQWUraUIsTUFBZixDQUFYLENBQVQ7QUFDRDtBQUNELGFBQUssSUFBSWx2QyxDQUFULElBQWN5UyxPQUFkLEVBQXVCO0FBQ3JCLGNBQUl5OEIsT0FBT2x2QyxDQUFQLE1BQWNtRyxTQUFsQixFQUE2QitvQyxPQUFPbHZDLENBQVAsSUFBWXlTLFFBQVF6UyxDQUFSLENBQVo7QUFDOUI7QUFDRCxlQUFPaW5CLE9BQU9pb0IsTUFBUCxFQUFleDdCLFFBQWYsQ0FBUDtBQUNELE9BVkQ7QUFXQSxhQUFPQyxDQUFQO0FBQ0QsS0FiRDtBQWNBLFFBQUl3N0IsS0FBS0YsSUFBSWxFLE9BQUosQ0FBVDtBQUNBb0UsT0FBRzdrQyxHQUFILEdBQVMya0MsSUFBSWxFLFFBQVF6Z0MsR0FBWixDQUFUO0FBQ0E2a0MsT0FBR0MsSUFBSCxHQUFVSCxJQUFJbEUsUUFBUXFFLElBQVosQ0FBVjtBQUNBRCxPQUFHRSxHQUFILEdBQVNKLElBQUlsRSxRQUFRc0UsR0FBWixDQUFUO0FBQ0FGLE9BQUdHLElBQUgsR0FBVUwsSUFBSWxFLFFBQVF1RSxJQUFaLENBQVY7QUFDQSxXQUFPSCxFQUFQO0FBQ0QsR0FyQkQ7O0FBdUJBO0FBQ0E7QUFDQTs7QUFFQSxNQUFJSSxZQUFZLENBQUUsS0FBRixFQUFTLEtBQVQsRUFBZ0IsTUFBaEIsRUFBd0IsTUFBeEIsQ0FBaEI7QUFDQUEsWUFBVWhwQyxPQUFWLENBQWtCLFVBQVNpcEMsUUFBVCxFQUFtQjtBQUNuQyxRQUFJdm9CLFNBQVN1b0IsU0FBU0MsV0FBVCxFQUFiO0FBQ0EsUUFBSXhxQyxPQUFTdXFDLFNBQVMvb0IsV0FBVCxFQUFiOztBQUVBc2tCLFlBQVE5bEMsSUFBUixJQUFnQixVQUFTK2lCLElBQVQsRUFBZTtBQUM3QixVQUFHLE9BQU9BLElBQVAsS0FBZ0IsUUFBbkIsRUFDRUEsT0FBTyxFQUFDLFVBQVNmLE1BQVYsRUFBa0IsT0FBTWUsSUFBeEIsRUFBUCxDQURGLEtBRUs7QUFDSEEsZUFBT2tFLEtBQUtpZixLQUFMLENBQVdqZixLQUFLQyxTQUFMLENBQWVuRSxJQUFmLENBQVgsQ0FBUDtBQUNBQSxhQUFLZixNQUFMLEdBQWNBLE1BQWQ7QUFDRDs7QUFFRCxVQUFJOWhCLE9BQU8sQ0FBQzZpQixJQUFELEVBQU92bkIsTUFBUCxDQUFjUSxNQUFNTixTQUFOLENBQWdCeEIsS0FBaEIsQ0FBc0JxQixLQUF0QixDQUE0QlAsU0FBNUIsRUFBdUMsQ0FBQyxDQUFELENBQXZDLENBQWQsQ0FBWDtBQUNBLGFBQU84cUMsUUFBUXZxQyxLQUFSLENBQWMsSUFBZCxFQUFvQjJFLElBQXBCLENBQVA7QUFDRCxLQVZEO0FBV0QsR0FmRDs7QUFpQkE7QUFDQTtBQUNBOztBQUVBNGxDLFVBQVEyRSxLQUFSLEdBQWdCLFVBQVNqOUIsT0FBVCxFQUFrQmlCLFFBQWxCLEVBQTRCO0FBQzFDLFFBQUcsT0FBT2pCLE9BQVAsS0FBbUIsUUFBdEIsRUFDRUEsVUFBVSxFQUFDLE9BQU1BOztBQUVuQjtBQUZZLEtBQVYsQ0FHRkEsUUFBUWk1QixJQUFSLEdBQWUsSUFBZjtBQUNBLFFBQUdqNUIsUUFBUXV0QixJQUFYLEVBQ0V2dEIsUUFBUWk1QixJQUFSLEdBQWVqNUIsUUFBUXV0QixJQUF2QjtBQUNGLFdBQU92dEIsUUFBUXV0QixJQUFmOztBQUVBdHNCLGVBQVdBLFlBQVkyRCxJQUF2Qjs7QUFFQSxRQUFJdzFCLE1BQU05QixRQUFRdDRCLE9BQVIsRUFBaUJrOUIsYUFBakIsQ0FBVjtBQUNBLFdBQU85QyxHQUFQOztBQUVBLGFBQVM4QyxhQUFULENBQXVCbEMsRUFBdkIsRUFBMkJtQyxJQUEzQixFQUFpQzVQLElBQWpDLEVBQXVDO0FBQ3JDLFVBQUd5TixFQUFILEVBQ0UsT0FBTy81QixTQUFTKzVCLEVBQVQsRUFBYW1DLElBQWIsRUFBbUI1UCxJQUFuQixDQUFQOztBQUVGLFVBQUcsQ0FBQzRQLEtBQUtqQixVQUFMLEdBQWtCLEdBQWxCLElBQXlCaUIsS0FBS2pCLFVBQUwsR0FBa0IsR0FBNUMsS0FBb0QzTyxLQUFLOXNCLEtBQTVELEVBQW1FO0FBQ2pFO0FBQ0F1NkIsYUFBSyxJQUFJNzNCLEtBQUosQ0FBVSxxQkFBcUJvcUIsS0FBSzlzQixLQUFMLENBQVc4UixNQUFYLElBQXFCZ2IsS0FBSzlzQixLQUFMLENBQVdBLEtBQXJELENBQVYsQ0FBTDtBQUNBLGFBQUssSUFBSTlTLEdBQVQsSUFBZ0I0L0IsSUFBaEI7QUFDRXlOLGFBQUdydEMsR0FBSCxJQUFVNC9CLEtBQUs1L0IsR0FBTCxDQUFWO0FBREYsU0FFQSxPQUFPc1QsU0FBUys1QixFQUFULEVBQWFtQyxJQUFiLEVBQW1CNVAsSUFBbkIsQ0FBUDtBQUNEOztBQUVELGFBQU90c0IsU0FBUys1QixFQUFULEVBQWFtQyxJQUFiLEVBQW1CNVAsSUFBbkIsQ0FBUDtBQUNEO0FBQ0YsR0E3QkQ7O0FBK0JBO0FBQ0E7QUFDQTs7QUFFQSxXQUFTM29CLElBQVQsR0FBZ0IsQ0FBRTs7QUFFbEIsV0FBU2cwQixTQUFULEdBQXFCO0FBQ25CLFFBQUl3RSxTQUFTLEVBQWI7QUFBQSxRQUNJQyxTQUFTLENBQUMsT0FBRCxFQUFVLE9BQVYsRUFBbUIsTUFBbkIsRUFBMkIsTUFBM0IsRUFBbUMsT0FBbkMsQ0FEYjtBQUFBLFFBRUl6ZixLQUZKO0FBQUEsUUFFV3J3QixDQUZYOztBQUlBLFNBQUlBLElBQUksQ0FBUixFQUFXQSxJQUFJOHZDLE9BQU81dkMsTUFBdEIsRUFBOEJGLEdBQTlCLEVBQW1DO0FBQ2pDcXdCLGNBQVF5ZixPQUFPOXZDLENBQVAsQ0FBUjs7QUFFQTZ2QyxhQUFPeGYsS0FBUCxJQUFnQmhaLElBQWhCO0FBQ0EsVUFBRyxPQUFPc1UsT0FBUCxLQUFtQixXQUFuQixJQUFrQ0EsT0FBbEMsSUFBNkNBLFFBQVEwRSxLQUFSLENBQWhELEVBQ0V3ZixPQUFPeGYsS0FBUCxJQUFnQjBmLFVBQVVwa0IsT0FBVixFQUFtQjBFLEtBQW5CLENBQWhCO0FBQ0g7O0FBRUQsV0FBT3dmLE1BQVA7QUFDRDs7QUFFRCxXQUFTRSxTQUFULENBQW1CbndDLEdBQW5CLEVBQXdCcW5CLE1BQXhCLEVBQWdDO0FBQzlCLFdBQU8rb0IsZ0JBQVA7O0FBRUEsYUFBU0EsZ0JBQVQsQ0FBMEJudkMsR0FBMUIsRUFBK0J5YixPQUEvQixFQUF3QztBQUN0QyxVQUFHLFFBQU9BLE9BQVAseUNBQU9BLE9BQVAsT0FBbUIsUUFBdEIsRUFDRXpiLE9BQU8sTUFBTXFyQixLQUFLQyxTQUFMLENBQWU3UCxPQUFmLENBQWI7O0FBRUYsYUFBTzFjLElBQUlxbkIsTUFBSixFQUFZbm1CLElBQVosQ0FBaUJsQixHQUFqQixFQUFzQmlCLEdBQXRCLENBQVA7QUFDRDtBQUNGOztBQUVEO0FBQ0EsV0FBU21zQyxjQUFULENBQXdCMUIsR0FBeEIsRUFBNkI7QUFDM0IsUUFBSTJFLE9BQU8sZ0RBQVg7O0FBRUE7QUFDQTtBQUNBLFFBQUlDLFlBQUo7QUFDQSxRQUFJO0FBQUVBLHFCQUFlQyxTQUFTQyxJQUF4QjtBQUE4QixLQUFwQyxDQUNBLE9BQU85eEMsQ0FBUCxFQUFVO0FBQ1I7QUFDQTR4QyxxQkFBZXJwQixTQUFTcWQsYUFBVCxDQUF3QixHQUF4QixDQUFmO0FBQ0FnTSxtQkFBYUUsSUFBYixHQUFvQixFQUFwQjtBQUNBRixxQkFBZUEsYUFBYUUsSUFBNUI7QUFDRDs7QUFFRCxRQUFJQyxlQUFlSixLQUFLL29DLElBQUwsQ0FBVWdwQyxhQUFhenBCLFdBQWIsRUFBVixLQUF5QyxFQUE1RDtBQUFBLFFBQ0k2cEIsUUFBUUwsS0FBSy9vQyxJQUFMLENBQVVva0MsSUFBSTdrQixXQUFKLEVBQVYsQ0FEWjs7QUFHQSxRQUFJMWdCLFNBQVMsQ0FBQyxFQUNadXFDLFVBQ0dBLE1BQU0sQ0FBTixLQUFZRCxhQUFhLENBQWIsQ0FBWixJQUNBQyxNQUFNLENBQU4sS0FBWUQsYUFBYSxDQUFiLENBRFosSUFFQSxDQUFDQyxNQUFNLENBQU4sTUFBYUEsTUFBTSxDQUFOLE1BQWEsT0FBYixHQUF1QixFQUF2QixHQUE0QixHQUF6QyxDQUFELE1BQW9ERCxhQUFhLENBQWIsTUFBb0JBLGFBQWEsQ0FBYixNQUFvQixPQUFwQixHQUE4QixFQUE5QixHQUFtQyxHQUF2RCxDQUFwRCxDQUhILENBRFksQ0FBZDs7QUFRQTtBQUNBLFdBQU90cUMsTUFBUDtBQUNEOztBQUVEO0FBQ0EsV0FBU3ltQyxPQUFULENBQWtCcmlDLElBQWxCLEVBQXdCO0FBQ3BCO0FBQ0EsUUFBSW9tQyxNQUFNLG1FQUFWO0FBQ0EsUUFBSUMsRUFBSjtBQUFBLFFBQVFuTSxFQUFSO0FBQUEsUUFBWW9NLEVBQVo7QUFBQSxRQUFnQkMsRUFBaEI7QUFBQSxRQUFvQkMsRUFBcEI7QUFBQSxRQUF3QkMsRUFBeEI7QUFBQSxRQUE0QkMsRUFBNUI7QUFBQSxRQUFnQ0MsSUFBaEM7QUFBQSxRQUFzQzl3QyxJQUFJLENBQTFDO0FBQUEsUUFBNkMrd0MsS0FBSyxDQUFsRDtBQUFBLFFBQXFEQyxNQUFJLEVBQXpEO0FBQUEsUUFBNkRDLFVBQVUsRUFBdkU7O0FBRUEsUUFBSSxDQUFDOW1DLElBQUwsRUFBVztBQUNQLGFBQU9BLElBQVA7QUFDSDs7QUFFRDtBQUNBOztBQUVBLE9BQUc7QUFBRTtBQUNEcW1DLFdBQUtybUMsS0FBSyttQyxVQUFMLENBQWdCbHhDLEdBQWhCLENBQUw7QUFDQXFrQyxXQUFLbDZCLEtBQUsrbUMsVUFBTCxDQUFnQmx4QyxHQUFoQixDQUFMO0FBQ0F5d0MsV0FBS3RtQyxLQUFLK21DLFVBQUwsQ0FBZ0JseEMsR0FBaEIsQ0FBTDs7QUFFQTh3QyxhQUFPTixNQUFJLEVBQUosR0FBU25NLE1BQUksQ0FBYixHQUFpQm9NLEVBQXhCOztBQUVBQyxXQUFLSSxRQUFNLEVBQU4sR0FBVyxJQUFoQjtBQUNBSCxXQUFLRyxRQUFNLEVBQU4sR0FBVyxJQUFoQjtBQUNBRixXQUFLRSxRQUFNLENBQU4sR0FBVSxJQUFmO0FBQ0FELFdBQUtDLE9BQU8sSUFBWjs7QUFFQTtBQUNBRyxjQUFRRixJQUFSLElBQWdCUixJQUFJL2tCLE1BQUosQ0FBV2tsQixFQUFYLElBQWlCSCxJQUFJL2tCLE1BQUosQ0FBV21sQixFQUFYLENBQWpCLEdBQWtDSixJQUFJL2tCLE1BQUosQ0FBV29sQixFQUFYLENBQWxDLEdBQW1ETCxJQUFJL2tCLE1BQUosQ0FBV3FsQixFQUFYLENBQW5FO0FBQ0gsS0FkRCxRQWNTN3dDLElBQUltSyxLQUFLakssTUFkbEI7O0FBZ0JBOHdDLFVBQU1DLFFBQVFwbkIsSUFBUixDQUFhLEVBQWIsQ0FBTjs7QUFFQSxZQUFRMWYsS0FBS2pLLE1BQUwsR0FBYyxDQUF0QjtBQUNJLFdBQUssQ0FBTDtBQUNJOHdDLGNBQU1BLElBQUk3eEMsS0FBSixDQUFVLENBQVYsRUFBYSxDQUFDLENBQWQsSUFBbUIsSUFBekI7QUFDSjtBQUNBLFdBQUssQ0FBTDtBQUNJNnhDLGNBQU1BLElBQUk3eEMsS0FBSixDQUFVLENBQVYsRUFBYSxDQUFDLENBQWQsSUFBbUIsR0FBekI7QUFDSjtBQU5KOztBQVNBLFdBQU82eEMsR0FBUDtBQUNIO0FBQ0csU0FBT2pHLE9BQVA7QUFDSjtBQUNDLENBN2RBLENBQUQ7QUE4ZEEsZ0I7Ozs7Ozs7Ozs7O0FDN2VBO0FBQ0E7O0FBRUEsS0FBTSxVQUFTL21DLElBQVQsRUFBZTJtQyxPQUFmLEVBQXdCO0FBQzVCLE1BQUksSUFBSixFQUFnRDtBQUM5Q3J5QixJQUFBLG9DQUFPcXlCLE9BQVA7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNELEdBRkQsTUFFTyxJQUFJLFFBQU9sc0MsT0FBUCx5Q0FBT0EsT0FBUCxPQUFtQixRQUF2QixFQUFpQztBQUN0Q0QsV0FBT0MsT0FBUCxHQUFpQmtzQyxTQUFqQjtBQUNELEdBRk0sTUFFQTtBQUNMM21DLFNBQUttdEMsVUFBTCxHQUFrQnhHLFNBQWxCO0FBQ0Q7QUFDRixDQVJLLFlBUUUsWUFBVzs7QUFFakIsV0FBU3dHLFVBQVQsR0FBb0IsYUFBZTtBQUNqQyxRQUFJQyxVQUFVbnhDLFVBQVVDLE1BQXhCOztBQUVBLFFBQUlreEMsWUFBWSxDQUFoQixFQUFtQjtBQUNqQixZQUFNLElBQUl4N0IsS0FBSixDQUFVLHNEQUFWLENBQU47QUFDRDs7QUFFRCxRQUFJbkIsT0FBT29TLFNBQVNxZCxhQUFULENBQXVCLE1BQXZCLENBQVg7QUFDQXp2QixTQUFLMjdCLElBQUwsR0FBWW53QyxVQUFVLENBQVYsQ0FBWjs7QUFFQSxRQUFJbXhDLFlBQVksQ0FBaEIsRUFBbUI7QUFDakIsYUFBTzM4QixLQUFLMjdCLElBQVo7QUFDRDs7QUFFRCxRQUFJZCxPQUFPem9CLFNBQVN3cUIsb0JBQVQsQ0FBOEIsTUFBOUIsRUFBc0MsQ0FBdEMsQ0FBWDtBQUNBL0IsU0FBS2dDLFlBQUwsQ0FBa0I3OEIsSUFBbEIsRUFBd0I2NkIsS0FBS2lDLFVBQTdCOztBQUVBLFFBQUk1NEIsSUFBSWtPLFNBQVNxZCxhQUFULENBQXVCLEdBQXZCLENBQVI7QUFDQSxRQUFJc04sUUFBSjs7QUFFQSxTQUFLLElBQUlyd0MsUUFBUSxDQUFqQixFQUFvQkEsUUFBUWl3QyxPQUE1QixFQUFxQ2p3QyxPQUFyQyxFQUE4QztBQUM1Q3dYLFFBQUV5M0IsSUFBRixHQUFTbndDLFVBQVVrQixLQUFWLENBQVQ7QUFDQXF3QyxpQkFBVzc0QixFQUFFeTNCLElBQWI7QUFDQTM3QixXQUFLMjdCLElBQUwsR0FBWW9CLFFBQVo7QUFDRDs7QUFFRGxDLFNBQUttQyxXQUFMLENBQWlCaDlCLElBQWpCOztBQUVBLFdBQU8rOEIsUUFBUDtBQUNEOztBQUVELFNBQU9MLFVBQVA7QUFFRCxDQTNDSyxDQUFOLEM7Ozs7Ozs7OztBQ0hBLElBQUlPLFNBQVMsbUJBQUFyL0IsQ0FBUSxFQUFSLENBQWI7O0FBRUEsSUFBSXMvQixXQUFXLG1CQUFBdC9CLENBQVEsRUFBUixDQUFmO0FBQ0EsSUFBSXUvQixVQUFVLENBQUMsbUJBQUF2L0IsQ0FBUSxFQUFSLENBQUQsQ0FBZDs7QUFFQTdULE9BQU9DLE9BQVAsR0FBaUJpekMsT0FBT0csV0FBUCxDQUFtQkYsUUFBbkIsRUFBNkJDLE9BQTdCLENBQWpCLEM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTEEsSUFBTXovQixRQUFRLG1CQUFBRSxDQUFTLENBQVQsQ0FBZDs7QUFFQSxJQUFNTyxZQUFXLG1CQUFBUCxDQUFTLENBQVQsQ0FBakI7QUFDQSxJQUFNTSxrQkFBa0IsbUJBQUFOLENBQVMsRUFBVCxDQUF4QjtBQUNBLElBQU1rQixxQkFBcUIsbUJBQUFsQixDQUFTLENBQVQsQ0FBM0I7QUFDQSxJQUFNeS9CLFNBQVMsbUJBQUF6L0IsQ0FBUyxFQUFULENBQWY7O0FBRUEsU0FBUzAvQixVQUFULENBQXFCQyxRQUFyQixFQUFnQztBQUFBLFFBQ3RCQyxNQURzQjtBQUFBOztBQUd4Qix3QkFBYTUrQixNQUFiLEVBQXNCO0FBQUE7O0FBQUEsd0hBQ1gyK0IsUUFEVyxFQUNELEVBREMsRUFDRzMrQixNQURIOztBQUVsQixrQkFBSzYrQixJQUFMLEdBQVksQ0FBRSxLQUFGLEVBQVMsYUFBVCxFQUF3QixPQUF4QixFQUFpQyxVQUFqQyxDQUFaO0FBQ0Esa0JBQUtwM0IsS0FBTCxHQUFhLENBQUUsT0FBRixFQUFXLFVBQVgsRUFBdUIsVUFBdkIsQ0FBYjtBQUNBLGdCQUFLekgsTUFBTCxFQUFjO0FBQ1ZULDBCQUFTNUMsV0FBVCxDQUFzQnFELE1BQXRCLEVBQThCO0FBQzFCbzVCLDhCQUFVO0FBQ05sNkIsa0NBQVU7QUFESixxQkFEZ0I7QUFJMUI0L0IsMkJBQU87QUFDSDUvQixrQ0FBVTtBQURQLHFCQUptQjtBQU8xQm02Qiw4QkFBVTtBQUNObjZCLGtDQUFVO0FBREo7QUFQZ0IsaUJBQTlCO0FBV0Esc0JBQUtwSSxJQUFMLEdBQVlrSixNQUFaO0FBQ0g7QUFDRCxrQkFBSysrQixVQUFMLENBQWdCQyxJQUFoQixHQUF1QixNQUFLQyxjQUFMLENBQW9CcHpDLElBQXBCLE9BQXZCO0FBbEJrQjtBQW1CckI7O0FBdEJ1QjtBQUFBO0FBQUEsb0NBd0JQO0FBQUE7O0FBQ2Isb0JBQU11VCxVQUFVYyw4Q0FBaEI7QUFDQWQsd0JBQVFpNkIsUUFBUixHQUFtQmo2QixRQUFRZ0IsR0FBM0I7QUFDQWhCLHdCQUFRZ0IsR0FBUixHQUFjdE4sU0FBZDtBQUNBLHVCQUFPLEtBQUs2ckMsUUFBTCxDQUFjTyxLQUFkLENBQXFCcGdDLE1BQU0sRUFBTixFQUFVLEtBQUtoSSxJQUFmLEVBQXFCc0ksT0FBckIsQ0FBckIsRUFDTjZDLElBRE0sQ0FDRCxVQUFFazlCLElBQUYsRUFBWTtBQUNkLDJCQUFLaC9CLEtBQUwsR0FBYWcvQixLQUFLaC9CLEtBQWxCO0FBQ0E7QUFDSCxpQkFKTSxDQUFQO0FBS0g7QUFqQ3VCO0FBQUE7QUFBQSxxQ0FtQ2Y7QUFDTCxxQkFBS0EsS0FBTCxHQUFhck4sU0FBYjtBQUNBLG9CQUFLLEtBQUtzc0MsU0FBVixFQUFzQjtBQUNsQix5QkFBS1QsUUFBTCxDQUFjVSxNQUFkO0FBQ0g7QUFDSjtBQXhDdUI7QUFBQTtBQUFBLHNDQTBDZDtBQUNOLHFCQUFLVixRQUFMLENBQWNXLGFBQWQsQ0FBNkIsSUFBN0I7QUFDSDtBQTVDdUI7QUFBQTtBQUFBLDJDQThDUmxnQyxPQTlDUSxFQThDRTtBQUN0QixvQkFBSyxDQUFDLEtBQUswNkIsRUFBWCxFQUFnQjE2QixRQUFRbWdDLFNBQVIsR0FBb0IsS0FBcEIsQ0FBaEIsS0FDSztBQUNEbmdDLDRCQUFRdXRCLElBQVIsQ0FBYXlNLFFBQWIsR0FBd0J0bUMsU0FBeEI7QUFDQXNNLDRCQUFRdXRCLElBQVIsQ0FBYTBNLFFBQWIsR0FBd0J2bUMsU0FBeEI7QUFDSDtBQUNELHVCQUFPc00sT0FBUDtBQUNIO0FBckR1QjtBQUFBO0FBQUEsbUNBdURoQndVLE1BdkRnQixFQXVEUDtBQUNiLHdCQUFTQSxNQUFUO0FBQ0kseUJBQUssTUFBTDtBQUNJLCtCQUFPLFlBQVA7QUFDSjtBQUNJLDhDQUFvQixLQUFLa21CLEVBQXpCO0FBSlI7QUFNSDtBQTlEdUI7QUFBQTtBQUFBLHFDQWdFZGxtQixNQWhFYyxFQWdFTjljLElBaEVNLEVBZ0VDO0FBQ3JCLHdCQUFTOGMsTUFBVDtBQUNJLHlCQUFLLFFBQUw7QUFDSSwrQkFBTyxPQUFPLEtBQUtrbUIsRUFBWixLQUFtQixRQUFuQixHQUNIdGtDLFFBQVE2SSxPQUFSLEVBREcsR0FFSDdJLFFBQVFtSyxNQUFSLENBQWdCLElBQUlMLGVBQUosQ0FBcUIsK0JBQXJCLENBQWhCLENBRko7QUFHSix5QkFBSyxNQUFMO0FBQ0ksK0JBQU9DLFVBQVV6SSxJQUFWLEVBQWdCO0FBQ25Cc2lDLHNDQUFVO0FBQ05sNkIsMENBQVUsUUFESjtBQUVOc2dDLDBDQUFVO0FBRkosNkJBRFM7QUFLbkJWLG1DQUFPO0FBQ0g1L0IsMENBQVUsUUFEUDtBQUVIc2dDLDBDQUFVO0FBRlAsNkJBTFk7QUFTbkJuRyxzQ0FBVTtBQUNObjZCLDBDQUFVLFFBREo7QUFFTnNnQywwQ0FBVTtBQUZKO0FBVFMseUJBQWhCLENBQVA7QUFjSix5QkFBSyxLQUFMO0FBQ0ksK0JBQU9qZ0MsVUFBVXpJLElBQVYsRUFBZ0I7QUFDbkJzaUMsc0NBQVU7QUFDTmw2QiwwQ0FBVSxRQURKO0FBRU5zZ0MsMENBQVU7QUFGSiw2QkFEUztBQUtuQlYsbUNBQU87QUFDSDUvQiwwQ0FBVTtBQURQLDZCQUxZO0FBUW5CbTZCLHNDQUFVO0FBQ05uNkIsMENBQVUsUUFESjtBQUVOc2dDLDBDQUFVO0FBRko7QUFSUyx5QkFBaEIsQ0FBUDtBQWFKO0FBQ0ksK0JBQU8sT0FBTyxLQUFLMUYsRUFBWixLQUFtQixRQUFuQixHQUNIdGtDLFFBQVE2SSxPQUFSLEVBREcsR0FFSDdJLFFBQVFtSyxNQUFSLENBQWdCLElBQUlMLGVBQUosQ0FBcUIsOEJBQXJCLENBQWhCLENBRko7QUFuQ1I7QUF1Q0g7QUF4R3VCOztBQUFBO0FBQUEsTUFDUG0vQixNQURPOztBQTRHNUIsV0FBT0csTUFBUDtBQUNIOztBQUVEenpDLE9BQU9DLE9BQVAsR0FBaUI7QUFDYmtaLFVBQU0sUUFETztBQUVibzZCO0FBRmEsQ0FBakIsQzs7Ozs7OztBQ3RIQTs7OztBQUVBdnpDLE9BQU9DLE9BQVAsR0FBaUJxMEMsV0FBakI7QUFDQUEsWUFBWW5JLE9BQVosR0FBc0IsbUJBQUF0NEIsQ0FBUSxFQUFSLENBQXRCOztBQUVBLElBQUkwZ0MsTUFBTUQsWUFBWSxhQUFaLENBQVY7QUFDQUMsSUFBSUMsS0FBSixHQUFZRixZQUFZQyxHQUFaLEVBQWlCLEVBQUU5L0IsU0FBUyx5QkFBWCxFQUFzQzRGLE1BQU0sT0FBNUMsRUFBakIsQ0FBWjs7QUFFQTs7Ozs7Ozs7QUFRQSxTQUFTaTZCLFdBQVQsQ0FBcUJuN0IsSUFBckIsRUFBMkJxSSxNQUEzQixFQUFtQ2l6QixVQUFuQyxFQUErQ3RJLE9BQS9DLEVBQXdEO0FBQ3BELFFBQUl1SSxVQUFKO0FBQ0EsUUFBSUMsTUFBSjs7QUFFQTtBQUNBbnpCLGFBQVNvekIsUUFBUW56QyxTQUFSLEVBQW1CLENBQW5CLEVBQXNCMlYsS0FBdEIsRUFBNkJ5OUIsV0FBN0IsRUFBMEMsQ0FBQ0MsZUFBRCxFQUFrQkMsWUFBbEIsQ0FBMUMsQ0FBVDtBQUNBTixpQkFBYUcsUUFBUW56QyxTQUFSLEVBQW1CLENBQW5CLEVBQXNCLEVBQXRCLEVBQTBCcXpDLGVBQTFCLEVBQTJDLENBQUNDLFlBQUQsQ0FBM0MsQ0FBYjtBQUNBNUksY0FBVXlJLFFBQVFuekMsU0FBUixFQUFtQixDQUFuQixFQUFzQm9YLElBQXRCLEVBQTRCazhCLFlBQTVCLEVBQTBDLEVBQTFDLENBQVY7QUFDQTU3QixXQUFPeTdCLFFBQVFuekMsU0FBUixFQUFtQixDQUFuQixFQUFzQitmLFdBQVdwSyxLQUFYLEdBQW1CLE9BQW5CLEdBQTZCb0ssT0FBT3JmLFNBQVAsQ0FBaUJteUMsV0FBakIsQ0FBNkJuN0IsSUFBaEYsRUFBc0Y2N0IsU0FBdEYsRUFBaUcsQ0FBQ0gsV0FBRCxFQUFjQyxlQUFkLEVBQStCQyxZQUEvQixDQUFqRyxDQUFQOztBQUVBO0FBQ0FKLGFBQVNuekIsV0FBV3BLLEtBQXBCO0FBQ0EsUUFBSXU5QixVQUFVeEksWUFBWXR6QixJQUExQixFQUFnQ3N6QixVQUFVbUksWUFBWW5JLE9BQVosQ0FBb0IzbUMsSUFBOUI7O0FBRWhDO0FBQ0FrdkMsaUJBQVksbUJBQVNqZ0MsT0FBVCxFQUFrQndnQyxhQUFsQixFQUFpQztBQUN6QyxZQUFJQyxLQUFKO0FBQ0EsWUFBSUMsRUFBSjtBQUNBLFlBQUlDLFNBQUo7QUFDQSxZQUFJNXpDLENBQUo7QUFDQSxZQUFJZ2lCLElBQUo7QUFDQSxZQUFJblUsS0FBSjs7QUFFQTtBQUNBLFlBQUksRUFBRSxnQkFBZ0JxbEMsVUFBbEIsQ0FBSixFQUFrQyxPQUFPLElBQUlBLFVBQUosQ0FBY2pnQyxPQUFkLEVBQXVCd2dDLGFBQXZCLENBQVA7O0FBRWxDO0FBQ0EsZUFBTyxLQUFLempDLFdBQUwsQ0FBaUIySCxJQUF4QjtBQUNBalksZUFBT21VLGNBQVAsQ0FBc0IsS0FBSzdELFdBQTNCLEVBQXdDLE1BQXhDLEVBQWdEO0FBQzVDaUUsd0JBQVksS0FEZ0M7QUFFNUNELDBCQUFjLElBRjhCO0FBRzVDalAsbUJBQU80UyxJQUhxQztBQUk1Q3pELHNCQUFVO0FBSmtDLFNBQWhEOztBQU9BO0FBQ0EsWUFBSSxPQUFPakIsT0FBUCxLQUFtQixRQUF2QixFQUFpQ0EsVUFBVSxFQUFFQSxTQUFTQSxPQUFYLEVBQVY7QUFDakMsWUFBSSxDQUFDQSxPQUFMLEVBQWNBLFVBQVUsRUFBVjs7QUFFZDtBQUNBMGdDLGFBQUssS0FBS2IsV0FBTCxDQUFpQmUsS0FBakIsQ0FBdUIxMEMsS0FBdkIsQ0FBNkIsQ0FBN0IsRUFBZ0MyMEMsT0FBaEMsR0FBMEN6MEMsR0FBMUMsQ0FBOEMsVUFBUzBGLEtBQVQsRUFBZ0I7QUFBRSxtQkFBT0EsTUFBTWt1QyxVQUFiO0FBQXlCLFNBQXpGLENBQUw7QUFDQVUsV0FBRzNvQyxJQUFILENBQVFpSSxPQUFSO0FBQ0EwZ0MsV0FBR0ksT0FBSCxDQUFXLEVBQVg7QUFDQWxtQyxnQkFBUW5PLE9BQU9oQixNQUFQLENBQWM4QixLQUFkLENBQW9CZCxNQUFwQixFQUE0QmkwQyxFQUE1QixDQUFSOztBQUVBO0FBQ0FELGdCQUFRLElBQVI7QUFDQUUsb0JBQVksRUFBWjtBQUNBbDBDLGVBQU95SCxJQUFQLENBQVkyckMsWUFBWW5JLE9BQXhCLEVBQWlDcGtDLE9BQWpDLENBQXlDLFVBQVNuRyxHQUFULEVBQWM7QUFDbkR3ekMsc0JBQVV4ekMsR0FBVixJQUFpQixVQUFTeU4sS0FBVCxFQUFnQndGLE1BQWhCLEVBQXdCO0FBQ3JDeS9CLDRCQUFZbkksT0FBWixDQUFvQnZxQyxHQUFwQixFQUF5QlUsSUFBekIsQ0FBOEI0eUMsS0FBOUIsRUFBcUM3bEMsS0FBckMsRUFBNEN3RixNQUE1QyxFQUFvRHVnQyxTQUFwRDtBQUNILGFBRkQ7QUFHSCxTQUpEOztBQU1BO0FBQ0EsYUFBSzV6QyxJQUFJLEtBQUs4eUMsV0FBTCxDQUFpQmUsS0FBakIsQ0FBdUIzekMsTUFBdkIsR0FBZ0MsQ0FBekMsRUFBNENGLEtBQUssQ0FBakQsRUFBb0RBLEdBQXBELEVBQXlEO0FBQ3JEZ2lCLG1CQUFPLEtBQUs4d0IsV0FBTCxDQUFpQmUsS0FBakIsQ0FBdUI3ekMsQ0FBdkIsQ0FBUDtBQUNBLGdCQUFJZ2lCLEtBQUsyb0IsT0FBTCxLQUFpQnR6QixJQUFyQixFQUEyQjtBQUN2QjJLLHFCQUFLMm9CLE9BQUwsQ0FBYTdwQyxJQUFiLENBQWtCLElBQWxCLEVBQXdCK00sS0FBeEIsRUFBK0I0bEMsYUFBL0IsRUFBOENHLFNBQTlDO0FBQ0g7QUFDSjtBQUNKLEtBOUNEOztBQWdEQTtBQUNBVixlQUFVdnlDLFNBQVYsR0FBc0JqQixPQUFPZCxNQUFQLENBQWNvaEIsT0FBT3JmLFNBQXJCLENBQXRCO0FBQ0F1eUMsZUFBVXZ5QyxTQUFWLENBQW9CcVAsV0FBcEIsR0FBa0NrakMsVUFBbEM7O0FBRUE7QUFDQUEsZUFBVXZ5QyxTQUFWLENBQW9CZ1gsSUFBcEIsR0FBMkJBLElBQTNCOztBQUVBO0FBQ0F1N0IsZUFBVXZ5QyxTQUFWLENBQW9CbXlDLFdBQXBCLEdBQWtDO0FBQzlCZSxlQUFPVixTQUFTLEVBQVQsR0FBY256QixPQUFPcmYsU0FBUCxDQUFpQm15QyxXQUFqQixDQUE2QmUsS0FBN0IsQ0FBbUMxMEMsS0FBbkMsQ0FBeUMsQ0FBekMsQ0FEUztBQUU5QndyQyxpQkFBU0EsT0FGcUI7QUFHOUJoekIsY0FBTUEsSUFId0I7QUFJOUJxSSxnQkFBUUEsTUFKc0I7QUFLOUJpekIsb0JBQVlBO0FBTGtCLEtBQWxDO0FBT0FDLGVBQVV2eUMsU0FBVixDQUFvQm15QyxXQUFwQixDQUFnQ2UsS0FBaEMsQ0FBc0NFLE9BQXRDLENBQThDYixXQUFVdnlDLFNBQVYsQ0FBb0JteUMsV0FBbEU7O0FBRUE7QUFDQUksZUFBVXZ5QyxTQUFWLENBQW9CYSxRQUFwQixHQUErQixZQUFXO0FBQ3RDLFlBQUl1RSxTQUFTLEtBQUsrc0MsV0FBTCxDQUFpQmUsS0FBakIsQ0FBdUIsS0FBS2YsV0FBTCxDQUFpQmUsS0FBakIsQ0FBdUIzekMsTUFBdkIsR0FBZ0MsQ0FBdkQsRUFBMER5WCxJQUF2RTtBQUNBLFlBQUksS0FBS2tCLElBQVQsRUFBZTlTLFVBQVcsTUFBTSxLQUFLOFMsSUFBdEI7QUFDZixZQUFJLEtBQUs1RixPQUFULEVBQWtCbE4sVUFBVSxPQUFPLEtBQUtrTixPQUF0QjtBQUNsQixlQUFPbE4sTUFBUDtBQUNILEtBTEQ7O0FBT0EsV0FBT210QyxVQUFQO0FBQ0g7O0FBS0QsU0FBU0UsT0FBVCxDQUFpQmp1QyxJQUFqQixFQUF1QmhFLEtBQXZCLEVBQThCZ29DLFlBQTlCLEVBQTRDeFgsTUFBNUMsRUFBb0RxaUIsV0FBcEQsRUFBaUU7QUFDN0QsUUFBSUMsT0FBTyxDQUFDLENBQVo7QUFDQSxRQUFJQyxRQUFRLENBQUMsQ0FBYjtBQUNBLFFBQUlsMEMsQ0FBSjtBQUNBLFFBQUlraUIsQ0FBSjtBQUNBLFFBQUl2TCxNQUFNeFYsUUFBUWdFLEtBQUtqRixNQUFiLEdBQXNCaUIsS0FBdEIsR0FBOEJnRSxLQUFLakYsTUFBN0M7QUFDQSxRQUFJQyxHQUFKOztBQUVBLFNBQUtILElBQUksQ0FBVCxFQUFZQSxLQUFLMlcsR0FBakIsRUFBc0IzVyxHQUF0QixFQUEyQjtBQUN2QkcsY0FBTWdGLEtBQUtuRixDQUFMLENBQU47QUFDQSxZQUFJaTBDLFNBQVMsQ0FBQyxDQUFkLEVBQWlCO0FBQ2IsaUJBQUsveEIsSUFBSSxDQUFULEVBQVlBLElBQUk4eEIsWUFBWTl6QyxNQUE1QixFQUFvQ2dpQixHQUFwQyxFQUF5QztBQUNyQyxvQkFBSTh4QixZQUFZOXhCLENBQVosRUFBZS9oQixHQUFmLENBQUosRUFBeUI4ekMsT0FBT2owQyxDQUFQO0FBQzVCO0FBQ0o7QUFDRCxZQUFJazBDLFVBQVUsQ0FBQyxDQUFYLElBQWdCdmlCLE9BQU94eEIsR0FBUCxDQUFwQixFQUFpQztBQUM3Qit6QyxvQkFBUWwwQyxDQUFSO0FBQ0g7QUFDSjs7QUFFRCxRQUFJazBDLFVBQVUsQ0FBQyxDQUFYLElBQWdCRCxTQUFTLENBQUMsQ0FBMUIsSUFBK0JBLE9BQU9DLEtBQTFDLEVBQWlELE1BQU0sSUFBSW5CLElBQUlDLEtBQVIsRUFBTjtBQUNqRCxXQUFPa0IsVUFBVSxDQUFDLENBQVgsR0FBYy91QyxLQUFLK3VDLEtBQUwsQ0FBZCxHQUE0Qi9LLFlBQW5DO0FBQ0g7O0FBRUQsU0FBU29LLFlBQVQsQ0FBc0J4dUMsS0FBdEIsRUFBNkI7QUFDekIsV0FBTyxPQUFPQSxLQUFQLEtBQWlCLFVBQWpCLElBQStCQSxVQUFVNlEsS0FBekMsSUFBa0QsQ0FBQzdRLE1BQU1wRSxTQUFOLENBQWdCbXlDLFdBQTFFO0FBQ0g7O0FBRUQsU0FBU1UsU0FBVCxDQUFtQnp1QyxLQUFuQixFQUEwQjtBQUN0QixXQUFPLE9BQU9BLEtBQVAsS0FBaUIsUUFBeEI7QUFDSDs7QUFFRCxTQUFTc3VDLFdBQVQsQ0FBcUJ0dUMsS0FBckIsRUFBNEI7QUFDeEIsV0FBTyxPQUFPQSxLQUFQLEtBQWlCLFVBQWpCLEtBQWdDQSxVQUFVNlEsS0FBVixJQUFtQjdRLE1BQU1wRSxTQUFOLENBQWdCbXlDLFdBQW5FLENBQVA7QUFDSDs7QUFFRCxTQUFTUSxlQUFULENBQXlCdnVDLEtBQXpCLEVBQWdDO0FBQzVCLFdBQU9BLFNBQVMsUUFBT0EsS0FBUCx5Q0FBT0EsS0FBUCxPQUFpQixRQUFqQztBQUNIOztBQUVELFNBQVNzUyxJQUFULEdBQWdCLENBQUUsQzs7Ozs7OztBQ3RKbEI7Ozs7QUFFQTVZLFFBQVEwMUMsYUFBUixHQUF3QixVQUFTbEIsVUFBVCxFQUFxQlEsYUFBckIsRUFBb0M5SSxPQUFwQyxFQUE2QztBQUNqRSxRQUFJMTNCLE9BQUo7QUFDQTAzQixZQUFRM21DLElBQVIsQ0FBYWl2QyxVQUFiLEVBQXlCUSxhQUF6QixFQUF3QzlJLE9BQXhDOztBQUVBMTNCLGNBQVUsS0FBS0EsT0FBZjtBQUNBLFFBQUlnZ0MsV0FBVzF4QyxjQUFYLENBQTBCLFVBQTFCLENBQUosRUFBMkMwUixXQUFXLGVBQWVnZ0MsV0FBV21CLFFBQTFCLEdBQXFDLEdBQWhEO0FBQzNDLFFBQUluQixXQUFXMXhDLGNBQVgsQ0FBMEIsVUFBMUIsQ0FBSixFQUEyQzBSLFdBQVcsZ0JBQWdCZ2dDLFdBQVdvQixRQUEzQixHQUFzQyxHQUFqRDtBQUMzQyxTQUFLcGhDLE9BQUwsR0FBZUEsT0FBZjtBQUNILENBUkQ7O0FBVUF4VSxRQUFRdUYsSUFBUixHQUFlLFVBQVNpdkMsVUFBVCxFQUFxQlEsYUFBckIsRUFBb0NHLFNBQXBDLEVBQStDO0FBQzFELFFBQUlGLFFBQVEsSUFBWjtBQUNBLFFBQUk3NkIsSUFBSjtBQUNBLFFBQUl4RixTQUFTLEVBQUVpaEMsYUFBYTErQixNQUFNcVksZUFBckIsRUFBc0NzbUIsVUFBVSxJQUFoRCxFQUFiO0FBQ0EsUUFBSUMsYUFBYSxFQUFqQjtBQUNBLFFBQUlDLHNCQUFzQjcrQixNQUFNcVksZUFBaEM7QUFDQSxRQUFJaGhCLEtBQUo7O0FBRUEsYUFBU3luQyxXQUFULEdBQXVCO0FBQ25Cem5DLGNBQU0sQ0FBTixJQUFXeW1DLE1BQU1seUMsUUFBTixFQUFYO0FBQ0FreUMsY0FBTXptQyxLQUFOLEdBQWNBLE1BQU00YyxJQUFOLENBQVcsSUFBWCxDQUFkO0FBQ0g7O0FBRUQ7QUFDQSxRQUFJLENBQUM0cEIsYUFBRCxJQUFrQixRQUFPQSxhQUFQLHlDQUFPQSxhQUFQLE9BQXlCLFFBQS9DLEVBQXlEQSxnQkFBZ0IsRUFBaEI7QUFDekQsUUFBSUEsY0FBY2x5QyxjQUFkLENBQTZCLGFBQTdCLEtBQ0EsT0FBT2t5QyxjQUFjYSxXQUFyQixLQUFxQyxRQURyQyxJQUVBLENBQUNLLE1BQU1sQixjQUFjYSxXQUFwQixDQUZELElBR0FiLGNBQWNhLFdBQWQsSUFBNkIsQ0FIakMsRUFHb0NqaEMsT0FBT2loQyxXQUFQLEdBQXFCYixjQUFjYSxXQUFuQztBQUNwQyxRQUFJLENBQUNiLGNBQWNseUMsY0FBZCxDQUE2QixVQUE3QixDQUFMLEVBQStDOFIsT0FBT2toQyxRQUFQLEdBQWtCZCxjQUFjYyxRQUFoQzs7QUFFL0M7QUFDQSxRQUFJLENBQUNsaEMsT0FBT2toQyxRQUFSLElBQW9CLEtBQUt6QixXQUFMLENBQWlCOXlCLE1BQWpCLEtBQTRCcEssS0FBcEQsRUFBMkQ7O0FBRXZEO0FBQ0FsVyxlQUFPeUgsSUFBUCxDQUFZOHJDLFVBQVosRUFBd0Ixc0MsT0FBeEIsQ0FBZ0MsVUFBU25HLEdBQVQsRUFBYztBQUMxQyxvQkFBT0EsR0FBUDtBQUNJLHFCQUFLLE1BQUw7QUFDSXlZLDJCQUFPbzZCLFdBQVdwNkIsSUFBWCxJQUFtQixLQUFLLENBQS9CO0FBQ0E7QUFDSixxQkFBSyxTQUFMO0FBQ0kyN0IsaUNBQWF2QixXQUFXaGdDLE9BQVgsSUFBc0IsRUFBbkM7QUFDQTtBQUNKO0FBQ0l5Z0MsMEJBQU10ekMsR0FBTixJQUFhNnlDLFdBQVc3eUMsR0FBWCxDQUFiO0FBUlI7QUFVSCxTQVhEOztBQWFBO0FBQ0F3VixjQUFNcVksZUFBTixHQUF3QjVhLE9BQU9paEMsV0FBUCxHQUFxQixDQUE3QztBQUNBcm5DLGdCQUFTLElBQUkySSxLQUFKLEVBQUQsQ0FBYzNJLEtBQWQsQ0FBb0JrZCxLQUFwQixDQUEwQixJQUExQixDQUFSO0FBQ0FsZCxjQUFNaEYsTUFBTixDQUFhLENBQWIsRUFBZ0IsQ0FBaEI7QUFDQWdGLGNBQU04bUMsT0FBTixDQUFjLEVBQWQ7QUFDQW4rQixjQUFNcVksZUFBTixHQUF3QndtQixtQkFBeEI7QUFDQSxhQUFLeG5DLEtBQUwsR0FBYUEsTUFBTTRjLElBQU4sQ0FBVyxJQUFYLENBQWI7O0FBRUFucUIsZUFBT21VLGNBQVAsQ0FBc0IsSUFBdEIsRUFBNEIsTUFBNUIsRUFBb0M7QUFDaENHLDBCQUFjLElBRGtCO0FBRWhDQyx3QkFBWSxJQUZvQjtBQUdoQzNKLGlCQUFLLGVBQVc7QUFDWix1QkFBT3VPLElBQVA7QUFDSCxhQUwrQjtBQU1oQ2hVLGlCQUFLLGFBQVNFLEtBQVQsRUFBZ0I7QUFDakI4VCx1QkFBTzlULEtBQVA7QUFDQTJ2QztBQUNIO0FBVCtCLFNBQXBDOztBQVlBaDFDLGVBQU9tVSxjQUFQLENBQXNCLElBQXRCLEVBQTRCLFNBQTVCLEVBQXVDO0FBQ25DRywwQkFBYyxJQURxQjtBQUVuQ0Msd0JBQVksSUFGdUI7QUFHbkMzSixpQkFBSyxlQUFXO0FBQ1osdUJBQU9rcUMsVUFBUDtBQUNILGFBTGtDO0FBTW5DM3ZDLGlCQUFLLGFBQVNFLEtBQVQsRUFBZ0I7QUFDakJ5dkMsNkJBQWF6dkMsS0FBYjtBQUNBMnZDO0FBQ0g7QUFUa0MsU0FBdkM7O0FBYUFBO0FBRUg7QUFDSixDQTFFRCxDOzs7Ozs7Ozs7QUNYQWwyQyxPQUFPQyxPQUFQLEdBQWlCLG1CQUFBNFQsQ0FBUSxFQUFSLENBQWpCLEM7Ozs7Ozs7QUNEQTs7QUFFQSxJQUFJM1QsU0FBZ0IsbUJBQUEyVCxDQUFRLEVBQVIsQ0FBcEI7QUFBQSxJQUNJdWlDLGdCQUFnQixtQkFBQXZpQyxDQUFRLEVBQVIsQ0FEcEI7QUFBQSxJQUVJd2lDLGFBQWdCLG1CQUFBeGlDLENBQVEsRUFBUixDQUZwQjtBQUFBLElBR0l5aUMsV0FBZ0IsbUJBQUF6aUMsQ0FBUSxFQUFSLENBSHBCO0FBQUEsSUFLSXNCLENBTEo7O0FBT0FBLElBQUluVixPQUFPQyxPQUFQLEdBQWlCLFVBQVVzMkMsSUFBVixFQUFnQmh3QyxLQUFoQixDQUFxQixhQUFyQixFQUFvQztBQUN4RCxLQUFJazRCLENBQUosRUFBTzMrQixDQUFQLEVBQVUwMkMsQ0FBVixFQUFhdmlDLE9BQWIsRUFBc0I2ZSxJQUF0QjtBQUNBLEtBQUtyeEIsVUFBVUMsTUFBVixHQUFtQixDQUFwQixJQUEyQixPQUFPNjBDLElBQVAsS0FBZ0IsUUFBL0MsRUFBMEQ7QUFDekR0aUMsWUFBVTFOLEtBQVY7QUFDQUEsVUFBUWd3QyxJQUFSO0FBQ0FBLFNBQU8sSUFBUDtBQUNBLEVBSkQsTUFJTztBQUNOdGlDLFlBQVV4UyxVQUFVLENBQVYsQ0FBVjtBQUNBO0FBQ0QsS0FBSTgwQyxRQUFRLElBQVosRUFBa0I7QUFDakI5WCxNQUFJK1gsSUFBSSxJQUFSO0FBQ0ExMkMsTUFBSSxLQUFKO0FBQ0EsRUFIRCxNQUdPO0FBQ04yK0IsTUFBSTZYLFNBQVNoMEMsSUFBVCxDQUFjaTBDLElBQWQsRUFBb0IsR0FBcEIsQ0FBSjtBQUNBejJDLE1BQUl3MkMsU0FBU2gwQyxJQUFULENBQWNpMEMsSUFBZCxFQUFvQixHQUFwQixDQUFKO0FBQ0FDLE1BQUlGLFNBQVNoMEMsSUFBVCxDQUFjaTBDLElBQWQsRUFBb0IsR0FBcEIsQ0FBSjtBQUNBOztBQUVEempCLFFBQU8sRUFBRXZzQixPQUFPQSxLQUFULEVBQWdCaVAsY0FBY2lwQixDQUE5QixFQUFpQ2hwQixZQUFZM1YsQ0FBN0MsRUFBZ0Q0VixVQUFVOGdDLENBQTFELEVBQVA7QUFDQSxRQUFPLENBQUN2aUMsT0FBRCxHQUFXNmUsSUFBWCxHQUFrQjV5QixPQUFPazJDLGNBQWNuaUMsT0FBZCxDQUFQLEVBQStCNmUsSUFBL0IsQ0FBekI7QUFDQSxDQXBCRDs7QUFzQkEzZCxFQUFFc2hDLEVBQUYsR0FBTyxVQUFVRixJQUFWLEVBQWdCenFDLEdBQWhCLEVBQXFCekYsR0FBckIsQ0FBd0IsYUFBeEIsRUFBdUM7QUFDN0MsS0FBSW80QixDQUFKLEVBQU8zK0IsQ0FBUCxFQUFVbVUsT0FBVixFQUFtQjZlLElBQW5CO0FBQ0EsS0FBSSxPQUFPeWpCLElBQVAsS0FBZ0IsUUFBcEIsRUFBOEI7QUFDN0J0aUMsWUFBVTVOLEdBQVY7QUFDQUEsUUFBTXlGLEdBQU47QUFDQUEsUUFBTXlxQyxJQUFOO0FBQ0FBLFNBQU8sSUFBUDtBQUNBLEVBTEQsTUFLTztBQUNOdGlDLFlBQVV4UyxVQUFVLENBQVYsQ0FBVjtBQUNBO0FBQ0QsS0FBSXFLLE9BQU8sSUFBWCxFQUFpQjtBQUNoQkEsUUFBTW5FLFNBQU47QUFDQSxFQUZELE1BRU8sSUFBSSxDQUFDMHVDLFdBQVd2cUMsR0FBWCxDQUFMLEVBQXNCO0FBQzVCbUksWUFBVW5JLEdBQVY7QUFDQUEsUUFBTXpGLE1BQU1zQixTQUFaO0FBQ0EsRUFITSxNQUdBLElBQUl0QixPQUFPLElBQVgsRUFBaUI7QUFDdkJBLFFBQU1zQixTQUFOO0FBQ0EsRUFGTSxNQUVBLElBQUksQ0FBQzB1QyxXQUFXaHdDLEdBQVgsQ0FBTCxFQUFzQjtBQUM1QjROLFlBQVU1TixHQUFWO0FBQ0FBLFFBQU1zQixTQUFOO0FBQ0E7QUFDRCxLQUFJNHVDLFFBQVEsSUFBWixFQUFrQjtBQUNqQjlYLE1BQUksSUFBSjtBQUNBMytCLE1BQUksS0FBSjtBQUNBLEVBSEQsTUFHTztBQUNOMitCLE1BQUk2WCxTQUFTaDBDLElBQVQsQ0FBY2kwQyxJQUFkLEVBQW9CLEdBQXBCLENBQUo7QUFDQXoyQyxNQUFJdzJDLFNBQVNoMEMsSUFBVCxDQUFjaTBDLElBQWQsRUFBb0IsR0FBcEIsQ0FBSjtBQUNBOztBQUVEempCLFFBQU8sRUFBRWhuQixLQUFLQSxHQUFQLEVBQVl6RixLQUFLQSxHQUFqQixFQUFzQm1QLGNBQWNpcEIsQ0FBcEMsRUFBdUNocEIsWUFBWTNWLENBQW5ELEVBQVA7QUFDQSxRQUFPLENBQUNtVSxPQUFELEdBQVc2ZSxJQUFYLEdBQWtCNXlCLE9BQU9rMkMsY0FBY25pQyxPQUFkLENBQVAsRUFBK0I2ZSxJQUEvQixDQUF6QjtBQUNBLENBL0JELEM7Ozs7Ozs7QUMvQkE7O0FBRUE5eUIsT0FBT0MsT0FBUCxHQUFpQixtQkFBQTRULENBQVEsRUFBUixNQUNkM1MsT0FBT2hCLE1BRE8sR0FFZCxtQkFBQTJULENBQVEsRUFBUixDQUZILEM7Ozs7Ozs7QUNGQTs7QUFFQTdULE9BQU9DLE9BQVAsR0FBaUIsWUFBWTtBQUM1QixLQUFJQyxTQUFTZ0IsT0FBT2hCLE1BQXBCO0FBQUEsS0FBNEJrQixHQUE1QjtBQUNBLEtBQUksT0FBT2xCLE1BQVAsS0FBa0IsVUFBdEIsRUFBa0MsT0FBTyxLQUFQO0FBQ2xDa0IsT0FBTSxFQUFFczFDLEtBQUssS0FBUCxFQUFOO0FBQ0F4MkMsUUFBT2tCLEdBQVAsRUFBWSxFQUFFdTFDLEtBQUssS0FBUCxFQUFaLEVBQTRCLEVBQUVDLE1BQU0sTUFBUixFQUE1QjtBQUNBLFFBQVF4MUMsSUFBSXMxQyxHQUFKLEdBQVV0MUMsSUFBSXUxQyxHQUFkLEdBQW9CdjFDLElBQUl3MUMsSUFBekIsS0FBbUMsWUFBMUM7QUFDQSxDQU5ELEM7Ozs7Ozs7QUNGQTs7QUFFQSxJQUFJanVDLE9BQVEsbUJBQUFrTCxDQUFRLEVBQVIsQ0FBWjtBQUFBLElBQ0l0TixRQUFRLG1CQUFBc04sQ0FBUSxFQUFSLENBRFo7QUFBQSxJQUdJNUosTUFBTUQsS0FBS0MsR0FIZjs7QUFLQWpLLE9BQU9DLE9BQVAsR0FBaUIsVUFBVTQyQyxJQUFWLEVBQWdCL1QsR0FBaEIsQ0FBbUIsV0FBbkIsRUFBZ0M7QUFDaEQsS0FBSXB1QixLQUFKO0FBQUEsS0FBV2xULENBQVg7QUFBQSxLQUFjK1UsSUFBSXRNLElBQUl4SSxVQUFVQyxNQUFkLEVBQXNCLENBQXRCLENBQWxCO0FBQUEsS0FBNEN4QixNQUE1QztBQUNBMjJDLFFBQU8zMUMsT0FBT3FGLE1BQU1zd0MsSUFBTixDQUFQLENBQVA7QUFDQTMyQyxVQUFTLGdCQUFVMEIsR0FBVixFQUFlO0FBQ3ZCLE1BQUk7QUFBRWkxQyxRQUFLajFDLEdBQUwsSUFBWWtoQyxJQUFJbGhDLEdBQUosQ0FBWjtBQUF1QixHQUE3QixDQUE4QixPQUFPOUIsQ0FBUCxFQUFVO0FBQ3ZDLE9BQUksQ0FBQzRVLEtBQUwsRUFBWUEsUUFBUTVVLENBQVI7QUFDWjtBQUNELEVBSkQ7QUFLQSxNQUFLMEIsSUFBSSxDQUFULEVBQVlBLElBQUkrVSxDQUFoQixFQUFtQixFQUFFL1UsQ0FBckIsRUFBd0I7QUFDdkJzaEMsUUFBTXJoQyxVQUFVRCxDQUFWLENBQU47QUFDQW1ILE9BQUttNkIsR0FBTCxFQUFVLzZCLE9BQVYsQ0FBa0I3SCxNQUFsQjtBQUNBO0FBQ0QsS0FBSXdVLFVBQVUvTSxTQUFkLEVBQXlCLE1BQU0rTSxLQUFOO0FBQ3pCLFFBQU9taUMsSUFBUDtBQUNBLENBZEQsQzs7Ozs7OztBQ1BBOztBQUVBOztBQUVBNzJDLE9BQU9DLE9BQVAsR0FBaUIsVUFBVW1CLEdBQVYsRUFBZTtBQUFFLFNBQU8sT0FBT0EsR0FBUCxLQUFlLFVBQXRCO0FBQW1DLENBQXJFLEM7Ozs7Ozs7QUNKQTs7QUFFQXBCLE9BQU9DLE9BQVAsR0FBaUIsbUJBQUE0VCxDQUFRLEVBQVIsTUFDZDNTLE9BQU95SCxJQURPLEdBRWQsbUJBQUFrTCxDQUFRLEVBQVIsQ0FGSCxDOzs7Ozs7O0FDRkE7O0FBRUE3VCxPQUFPQyxPQUFQLEdBQWlCLFlBQVk7QUFDNUIsS0FBSTtBQUNIaUIsU0FBT3lILElBQVAsQ0FBWSxXQUFaO0FBQ0EsU0FBTyxJQUFQO0FBQ0EsRUFIRCxDQUdFLE9BQU83SSxDQUFQLEVBQVU7QUFBRSxTQUFPLEtBQVA7QUFBZTtBQUM3QixDQUxELEM7Ozs7Ozs7QUNGQTs7QUFFQSxJQUFJNkksT0FBT3pILE9BQU95SCxJQUFsQjs7QUFFQTNJLE9BQU9DLE9BQVAsR0FBaUIsVUFBVXlILE1BQVYsRUFBa0I7QUFDbEMsUUFBT2lCLEtBQUtqQixVQUFVLElBQVYsR0FBaUJBLE1BQWpCLEdBQTBCeEcsT0FBT3dHLE1BQVAsQ0FBL0IsQ0FBUDtBQUNBLENBRkQsQzs7Ozs7OztBQ0pBOztBQUVBLElBQUlLLFVBQVV0RixNQUFNTixTQUFOLENBQWdCNEYsT0FBOUI7QUFBQSxJQUF1QzNILFNBQVNjLE9BQU9kLE1BQXZEOztBQUVBLElBQUkwRixVQUFVLFNBQVZBLE9BQVUsQ0FBVWc5QixHQUFWLEVBQWUxaEMsR0FBZixFQUFvQjtBQUNqQyxLQUFJUSxHQUFKO0FBQ0EsTUFBS0EsR0FBTCxJQUFZa2hDLEdBQVo7QUFBaUIxaEMsTUFBSVEsR0FBSixJQUFXa2hDLElBQUlsaEMsR0FBSixDQUFYO0FBQWpCO0FBQ0EsQ0FIRDs7QUFLQTVCLE9BQU9DLE9BQVAsR0FBaUIsVUFBVWdVLE9BQVYsQ0FBaUIsY0FBakIsRUFBaUM7QUFDakQsS0FBSTFNLFNBQVNuSCxPQUFPLElBQVAsQ0FBYjtBQUNBMkgsU0FBUXpGLElBQVIsQ0FBYWIsU0FBYixFQUF3QixVQUFVd1MsT0FBVixFQUFtQjtBQUMxQyxNQUFJQSxXQUFXLElBQWYsRUFBcUI7QUFDckJuTyxVQUFRNUUsT0FBTytTLE9BQVAsQ0FBUixFQUF5QjFNLE1BQXpCO0FBQ0EsRUFIRDtBQUlBLFFBQU9BLE1BQVA7QUFDQSxDQVBELEM7Ozs7Ozs7QUNUQTs7QUFFQXZILE9BQU9DLE9BQVAsR0FBaUIsVUFBVXVDLEVBQVYsRUFBYztBQUM5QixLQUFJLE9BQU9BLEVBQVAsS0FBYyxVQUFsQixFQUE4QixNQUFNLElBQUlzUyxTQUFKLENBQWN0UyxLQUFLLG9CQUFuQixDQUFOO0FBQzlCLFFBQU9BLEVBQVA7QUFDQSxDQUhELEM7Ozs7Ozs7QUNGQTs7QUFFQXhDLE9BQU9DLE9BQVAsR0FBaUIsVUFBVXNHLEtBQVYsRUFBaUI7QUFDakMsS0FBSUEsU0FBUyxJQUFiLEVBQW1CLE1BQU0sSUFBSXVPLFNBQUosQ0FBYyw4QkFBZCxDQUFOO0FBQ25CLFFBQU92TyxLQUFQO0FBQ0EsQ0FIRCxDOzs7Ozs7O0FDRkE7O0FBRUF2RyxPQUFPQyxPQUFQLEdBQWlCLG1CQUFBNFQsQ0FBUSxFQUFSLE1BQ2R6UixPQUFPRCxTQUFQLENBQWlCbTBDLFFBREgsR0FFZCxtQkFBQXppQyxDQUFRLEVBQVIsQ0FGSCxDOzs7Ozs7O0FDRkE7O0FBRUEsSUFBSXhSLE1BQU0sWUFBVjs7QUFFQXJDLE9BQU9DLE9BQVAsR0FBaUIsWUFBWTtBQUM1QixLQUFJLE9BQU9vQyxJQUFJaTBDLFFBQVgsS0FBd0IsVUFBNUIsRUFBd0MsT0FBTyxLQUFQO0FBQ3hDLFFBQVNqMEMsSUFBSWkwQyxRQUFKLENBQWEsS0FBYixNQUF3QixJQUF6QixJQUFtQ2owQyxJQUFJaTBDLFFBQUosQ0FBYSxLQUFiLE1BQXdCLEtBQW5FO0FBQ0EsQ0FIRCxDOzs7Ozs7O0FDSkE7O0FBRUEsSUFBSTFtQixVQUFVeHRCLE9BQU9ELFNBQVAsQ0FBaUJ5dEIsT0FBL0I7O0FBRUE1dkIsT0FBT0MsT0FBUCxHQUFpQixVQUFVNjJDLFlBQVYsQ0FBc0IsY0FBdEIsRUFBc0M7QUFDdEQsUUFBT2xuQixRQUFRdHRCLElBQVIsQ0FBYSxJQUFiLEVBQW1CdzBDLFlBQW5CLEVBQWlDcjFDLFVBQVUsQ0FBVixDQUFqQyxJQUFpRCxDQUFDLENBQXpEO0FBQ0EsQ0FGRCxDOzs7Ozs7Ozs7OztBQ0pBOzs7Ozs7Ozs7QUFTQTtBQUNBLElBQUlzMUMsV0FBVyxJQUFJLENBQW5CO0FBQUEsSUFDSTV6QyxtQkFBbUIsZ0JBRHZCOztBQUdBO0FBQ0EsSUFBSUMsVUFBVSxvQkFBZDtBQUFBLElBQ0lLLFVBQVUsbUJBRGQ7QUFBQSxJQUVJQyxTQUFTLDRCQUZiO0FBQUEsSUFHSVEsWUFBWSxpQkFIaEI7O0FBS0E7QUFDQSxJQUFJbUIsYUFBYSxRQUFPNUUsTUFBUCx5Q0FBT0EsTUFBUCxNQUFpQixRQUFqQixJQUE2QkEsTUFBN0IsSUFBdUNBLE9BQU9TLE1BQVAsS0FBa0JBLE1BQXpELElBQW1FVCxNQUFwRjs7QUFFQTtBQUNBLElBQUk2RSxXQUFXLFFBQU9DLElBQVAseUNBQU9BLElBQVAsTUFBZSxRQUFmLElBQTJCQSxJQUEzQixJQUFtQ0EsS0FBS3JFLE1BQUwsS0FBZ0JBLE1BQW5ELElBQTZEcUUsSUFBNUU7O0FBRUE7QUFDQSxJQUFJQyxPQUFPSCxjQUFjQyxRQUFkLElBQTBCMUYsU0FBUyxhQUFULEdBQXJDOztBQUVBOzs7Ozs7Ozs7O0FBVUEsU0FBU29DLEtBQVQsQ0FBZXlFLElBQWYsRUFBcUJDLE9BQXJCLEVBQThCQyxJQUE5QixFQUFvQztBQUNsQyxVQUFRQSxLQUFLakYsTUFBYjtBQUNFLFNBQUssQ0FBTDtBQUFRLGFBQU8rRSxLQUFLbkUsSUFBTCxDQUFVb0UsT0FBVixDQUFQO0FBQ1IsU0FBSyxDQUFMO0FBQVEsYUFBT0QsS0FBS25FLElBQUwsQ0FBVW9FLE9BQVYsRUFBbUJDLEtBQUssQ0FBTCxDQUFuQixDQUFQO0FBQ1IsU0FBSyxDQUFMO0FBQVEsYUFBT0YsS0FBS25FLElBQUwsQ0FBVW9FLE9BQVYsRUFBbUJDLEtBQUssQ0FBTCxDQUFuQixFQUE0QkEsS0FBSyxDQUFMLENBQTVCLENBQVA7QUFDUixTQUFLLENBQUw7QUFBUSxhQUFPRixLQUFLbkUsSUFBTCxDQUFVb0UsT0FBVixFQUFtQkMsS0FBSyxDQUFMLENBQW5CLEVBQTRCQSxLQUFLLENBQUwsQ0FBNUIsRUFBcUNBLEtBQUssQ0FBTCxDQUFyQyxDQUFQO0FBSlY7QUFNQSxTQUFPRixLQUFLekUsS0FBTCxDQUFXMEUsT0FBWCxFQUFvQkMsSUFBcEIsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7QUFTQSxTQUFTcXdDLFFBQVQsQ0FBa0Jud0MsS0FBbEIsRUFBeUJDLFFBQXpCLEVBQW1DO0FBQ2pDLE1BQUluRSxRQUFRLENBQUMsQ0FBYjtBQUFBLE1BQ0lqQixTQUFTbUYsUUFBUUEsTUFBTW5GLE1BQWQsR0FBdUIsQ0FEcEM7QUFBQSxNQUVJNkYsU0FBUzlFLE1BQU1mLE1BQU4sQ0FGYjs7QUFJQSxTQUFPLEVBQUVpQixLQUFGLEdBQVVqQixNQUFqQixFQUF5QjtBQUN2QjZGLFdBQU81RSxLQUFQLElBQWdCbUUsU0FBU0QsTUFBTWxFLEtBQU4sQ0FBVCxFQUF1QkEsS0FBdkIsRUFBOEJrRSxLQUE5QixDQUFoQjtBQUNEO0FBQ0QsU0FBT1UsTUFBUDtBQUNEOztBQUVEOzs7Ozs7OztBQVFBLFNBQVNSLFNBQVQsQ0FBbUJGLEtBQW5CLEVBQTBCRyxNQUExQixFQUFrQztBQUNoQyxNQUFJckUsUUFBUSxDQUFDLENBQWI7QUFBQSxNQUNJakIsU0FBU3NGLE9BQU90RixNQURwQjtBQUFBLE1BRUl1RixTQUFTSixNQUFNbkYsTUFGbkI7O0FBSUEsU0FBTyxFQUFFaUIsS0FBRixHQUFVakIsTUFBakIsRUFBeUI7QUFDdkJtRixVQUFNSSxTQUFTdEUsS0FBZixJQUF3QnFFLE9BQU9yRSxLQUFQLENBQXhCO0FBQ0Q7QUFDRCxTQUFPa0UsS0FBUDtBQUNEOztBQUVEO0FBQ0EsSUFBSXlCLGNBQWNwSCxPQUFPaUIsU0FBekI7O0FBRUE7QUFDQSxJQUFJWSxpQkFBaUJ1RixZQUFZdkYsY0FBakM7O0FBRUE7Ozs7O0FBS0EsSUFBSWdHLGlCQUFpQlQsWUFBWXRGLFFBQWpDOztBQUVBO0FBQ0EsSUFBSW1HLFVBQVMzRCxLQUFLMkQsTUFBbEI7QUFBQSxJQUNJSyx1QkFBdUJsQixZQUFZa0Isb0JBRHZDO0FBQUEsSUFFSXl0QyxtQkFBbUI5dEMsVUFBU0EsUUFBTyt0QyxrQkFBaEIsR0FBcUN2dkMsU0FGNUQ7O0FBSUE7QUFDQSxJQUFJb0MsWUFBWUMsS0FBS0MsR0FBckI7O0FBRUE7Ozs7Ozs7Ozs7O0FBV0EsU0FBU2t0QyxXQUFULENBQXFCdHdDLEtBQXJCLEVBQTRCdXdDLEtBQTVCLEVBQW1DQyxTQUFuQyxFQUE4Q0MsUUFBOUMsRUFBd0QvdkMsTUFBeEQsRUFBZ0U7QUFDOUQsTUFBSTVFLFFBQVEsQ0FBQyxDQUFiO0FBQUEsTUFDSWpCLFNBQVNtRixNQUFNbkYsTUFEbkI7O0FBR0EyMUMsZ0JBQWNBLFlBQVlFLGFBQTFCO0FBQ0Fod0MsYUFBV0EsU0FBUyxFQUFwQjs7QUFFQSxTQUFPLEVBQUU1RSxLQUFGLEdBQVVqQixNQUFqQixFQUF5QjtBQUN2QixRQUFJNkUsUUFBUU0sTUFBTWxFLEtBQU4sQ0FBWjtBQUNBLFFBQUl5MEMsUUFBUSxDQUFSLElBQWFDLFVBQVU5d0MsS0FBVixDQUFqQixFQUFtQztBQUNqQyxVQUFJNndDLFFBQVEsQ0FBWixFQUFlO0FBQ2I7QUFDQUQsb0JBQVk1d0MsS0FBWixFQUFtQjZ3QyxRQUFRLENBQTNCLEVBQThCQyxTQUE5QixFQUF5Q0MsUUFBekMsRUFBbUQvdkMsTUFBbkQ7QUFDRCxPQUhELE1BR087QUFDTFIsa0JBQVVRLE1BQVYsRUFBa0JoQixLQUFsQjtBQUNEO0FBQ0YsS0FQRCxNQU9PLElBQUksQ0FBQyt3QyxRQUFMLEVBQWU7QUFDcEIvdkMsYUFBT0EsT0FBTzdGLE1BQWQsSUFBd0I2RSxLQUF4QjtBQUNEO0FBQ0Y7QUFDRCxTQUFPZ0IsTUFBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7QUFTQSxTQUFTaXdDLFFBQVQsQ0FBa0I5dkMsTUFBbEIsRUFBMEIySCxLQUExQixFQUFpQztBQUMvQjNILFdBQVN4RyxPQUFPd0csTUFBUCxDQUFUO0FBQ0EsU0FBTyt2QyxXQUFXL3ZDLE1BQVgsRUFBbUIySCxLQUFuQixFQUEwQixVQUFTOUksS0FBVCxFQUFnQjNFLEdBQWhCLEVBQXFCO0FBQ3BELFdBQU9BLE9BQU84RixNQUFkO0FBQ0QsR0FGTSxDQUFQO0FBR0Q7O0FBRUQ7Ozs7Ozs7OztBQVNBLFNBQVMrdkMsVUFBVCxDQUFvQi92QyxNQUFwQixFQUE0QjJILEtBQTVCLEVBQW1DZ29DLFNBQW5DLEVBQThDO0FBQzVDLE1BQUkxMEMsUUFBUSxDQUFDLENBQWI7QUFBQSxNQUNJakIsU0FBUzJOLE1BQU0zTixNQURuQjtBQUFBLE1BRUk2RixTQUFTLEVBRmI7O0FBSUEsU0FBTyxFQUFFNUUsS0FBRixHQUFVakIsTUFBakIsRUFBeUI7QUFDdkIsUUFBSUUsTUFBTXlOLE1BQU0xTSxLQUFOLENBQVY7QUFBQSxRQUNJNEQsUUFBUW1CLE9BQU85RixHQUFQLENBRFo7O0FBR0EsUUFBSXkxQyxVQUFVOXdDLEtBQVYsRUFBaUIzRSxHQUFqQixDQUFKLEVBQTJCO0FBQ3pCMkYsYUFBTzNGLEdBQVAsSUFBYzJFLEtBQWQ7QUFDRDtBQUNGO0FBQ0QsU0FBT2dCLE1BQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7QUFRQSxTQUFTNkosUUFBVCxDQUFrQjNLLElBQWxCLEVBQXdCNEssS0FBeEIsRUFBK0I7QUFDN0JBLFVBQVF0SCxVQUFVc0gsVUFBVTFKLFNBQVYsR0FBdUJsQixLQUFLL0UsTUFBTCxHQUFjLENBQXJDLEdBQTBDMlAsS0FBcEQsRUFBMkQsQ0FBM0QsQ0FBUjtBQUNBLFNBQU8sWUFBVztBQUNoQixRQUFJMUssT0FBT2xGLFNBQVg7QUFBQSxRQUNJa0IsUUFBUSxDQUFDLENBRGI7QUFBQSxRQUVJakIsU0FBU3FJLFVBQVVwRCxLQUFLakYsTUFBTCxHQUFjMlAsS0FBeEIsRUFBK0IsQ0FBL0IsQ0FGYjtBQUFBLFFBR0l4SyxRQUFRcEUsTUFBTWYsTUFBTixDQUhaOztBQUtBLFdBQU8sRUFBRWlCLEtBQUYsR0FBVWpCLE1BQWpCLEVBQXlCO0FBQ3ZCbUYsWUFBTWxFLEtBQU4sSUFBZWdFLEtBQUswSyxRQUFRMU8sS0FBYixDQUFmO0FBQ0Q7QUFDREEsWUFBUSxDQUFDLENBQVQ7QUFDQSxRQUFJMk8sWUFBWTdPLE1BQU00TyxRQUFRLENBQWQsQ0FBaEI7QUFDQSxXQUFPLEVBQUUxTyxLQUFGLEdBQVUwTyxLQUFqQixFQUF3QjtBQUN0QkMsZ0JBQVUzTyxLQUFWLElBQW1CZ0UsS0FBS2hFLEtBQUwsQ0FBbkI7QUFDRDtBQUNEMk8sY0FBVUQsS0FBVixJQUFtQnhLLEtBQW5CO0FBQ0EsV0FBTzdFLE1BQU15RSxJQUFOLEVBQVksSUFBWixFQUFrQjZLLFNBQWxCLENBQVA7QUFDRCxHQWhCRDtBQWlCRDs7QUFFRDs7Ozs7OztBQU9BLFNBQVNpbUMsYUFBVCxDQUF1Qmh4QyxLQUF2QixFQUE4QjtBQUM1QixTQUFPbUgsUUFBUW5ILEtBQVIsS0FBa0JvSCxZQUFZcEgsS0FBWixDQUFsQixJQUNMLENBQUMsRUFBRTB3QyxvQkFBb0Ixd0MsS0FBcEIsSUFBNkJBLE1BQU0wd0MsZ0JBQU4sQ0FBL0IsQ0FESDtBQUVEOztBQUVEOzs7Ozs7O0FBT0EsU0FBU1MsS0FBVCxDQUFlbnhDLEtBQWYsRUFBc0I7QUFDcEIsTUFBSSxPQUFPQSxLQUFQLElBQWdCLFFBQWhCLElBQTRCb3hDLFNBQVNweEMsS0FBVCxDQUFoQyxFQUFpRDtBQUMvQyxXQUFPQSxLQUFQO0FBQ0Q7QUFDRCxNQUFJZ0IsU0FBVWhCLFFBQVEsRUFBdEI7QUFDQSxTQUFRZ0IsVUFBVSxHQUFWLElBQWtCLElBQUloQixLQUFMLElBQWUsQ0FBQ3d3QyxRQUFsQyxHQUE4QyxJQUE5QyxHQUFxRHh2QyxNQUE1RDtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkEsU0FBU29HLFdBQVQsQ0FBcUJwSCxLQUFyQixFQUE0QjtBQUMxQjtBQUNBLFNBQU8wSyxrQkFBa0IxSyxLQUFsQixLQUE0QnhELGVBQWVULElBQWYsQ0FBb0JpRSxLQUFwQixFQUEyQixRQUEzQixDQUE1QixLQUNKLENBQUNpRCxxQkFBcUJsSCxJQUFyQixDQUEwQmlFLEtBQTFCLEVBQWlDLFFBQWpDLENBQUQsSUFBK0N3QyxlQUFlekcsSUFBZixDQUFvQmlFLEtBQXBCLEtBQThCbkQsT0FEekUsQ0FBUDtBQUVEOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVCQSxJQUFJc0ssVUFBVWpMLE1BQU1pTCxPQUFwQjs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQSxTQUFTNkYsV0FBVCxDQUFxQmhOLEtBQXJCLEVBQTRCO0FBQzFCLFNBQU9BLFNBQVMsSUFBVCxJQUFpQjZKLFNBQVM3SixNQUFNN0UsTUFBZixDQUFqQixJQUEyQyxDQUFDVixXQUFXdUYsS0FBWCxDQUFuRDtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBLFNBQVMwSyxpQkFBVCxDQUEyQjFLLEtBQTNCLEVBQWtDO0FBQ2hDLFNBQU80SixhQUFhNUosS0FBYixLQUF1QmdOLFlBQVloTixLQUFaLENBQTlCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLFNBQVN2RixVQUFULENBQW9CdUYsS0FBcEIsRUFBMkI7QUFDekI7QUFDQTtBQUNBLE1BQUlzSSxNQUFNNU4sU0FBU3NGLEtBQVQsSUFBa0J3QyxlQUFlekcsSUFBZixDQUFvQmlFLEtBQXBCLENBQWxCLEdBQStDLEVBQXpEO0FBQ0EsU0FBT3NJLE9BQU9wTCxPQUFQLElBQWtCb0wsT0FBT25MLE1BQWhDO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMEJBLFNBQVMwTSxRQUFULENBQWtCN0osS0FBbEIsRUFBeUI7QUFDdkIsU0FBTyxPQUFPQSxLQUFQLElBQWdCLFFBQWhCLElBQ0xBLFFBQVEsQ0FBQyxDQURKLElBQ1NBLFFBQVEsQ0FBUixJQUFhLENBRHRCLElBQzJCQSxTQUFTcEQsZ0JBRDNDO0FBRUQ7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5QkEsU0FBU2xDLFFBQVQsQ0FBa0JzRixLQUFsQixFQUF5QjtBQUN2QixNQUFJK00sY0FBYy9NLEtBQWQseUNBQWNBLEtBQWQsQ0FBSjtBQUNBLFNBQU8sQ0FBQyxDQUFDQSxLQUFGLEtBQVkrTSxRQUFRLFFBQVIsSUFBb0JBLFFBQVEsVUFBeEMsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkEsU0FBU25ELFlBQVQsQ0FBc0I1SixLQUF0QixFQUE2QjtBQUMzQixTQUFPLENBQUMsQ0FBQ0EsS0FBRixJQUFXLFFBQU9BLEtBQVAseUNBQU9BLEtBQVAsTUFBZ0IsUUFBbEM7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsU0FBU294QyxRQUFULENBQWtCcHhDLEtBQWxCLEVBQXlCO0FBQ3ZCLFNBQU8sUUFBT0EsS0FBUCx5Q0FBT0EsS0FBUCxNQUFnQixRQUFoQixJQUNKNEosYUFBYTVKLEtBQWIsS0FBdUJ3QyxlQUFlekcsSUFBZixDQUFvQmlFLEtBQXBCLEtBQThCckMsU0FEeEQ7QUFFRDs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsSUFBSTB6QyxPQUFPeG1DLFNBQVMsVUFBUzFKLE1BQVQsRUFBaUIySCxLQUFqQixFQUF3QjtBQUMxQyxTQUFPM0gsVUFBVSxJQUFWLEdBQWlCLEVBQWpCLEdBQXNCOHZDLFNBQVM5dkMsTUFBVCxFQUFpQnN2QyxTQUFTRyxZQUFZOW5DLEtBQVosRUFBbUIsQ0FBbkIsQ0FBVCxFQUFnQ3FvQyxLQUFoQyxDQUFqQixDQUE3QjtBQUNELENBRlUsQ0FBWDs7QUFJQTEzQyxPQUFPQyxPQUFQLEdBQWlCMjNDLElBQWpCLEM7Ozs7Ozs7Ozs7QUN0ZkMsV0FBVW4zQyxNQUFWLEVBQWtCa0gsU0FBbEIsRUFBNkI7QUFDMUI7O0FBRUEsUUFBSWxILE9BQU95a0MsWUFBWCxFQUF5QjtBQUNyQjtBQUNIOztBQUVELFFBQUkyUyxhQUFhLENBQWpCLENBUDBCLENBT047QUFDcEIsUUFBSUMsZ0JBQWdCLEVBQXBCO0FBQ0EsUUFBSUMsd0JBQXdCLEtBQTVCO0FBQ0EsUUFBSUMsTUFBTXYzQyxPQUFPNG5CLFFBQWpCO0FBQ0EsUUFBSTR2QixpQkFBSjs7QUFFQSxhQUFTL1MsWUFBVCxDQUFzQmh3QixRQUF0QixFQUFnQztBQUM5QjtBQUNBLFlBQUksT0FBT0EsUUFBUCxLQUFvQixVQUF4QixFQUFvQztBQUNsQ0EsdUJBQVcsSUFBSXRWLFFBQUosQ0FBYSxLQUFLc1YsUUFBbEIsQ0FBWDtBQUNEO0FBQ0Q7QUFDQSxZQUFJdk8sT0FBTyxJQUFJbEUsS0FBSixDQUFVaEIsVUFBVUMsTUFBVixHQUFtQixDQUE3QixDQUFYO0FBQ0EsYUFBSyxJQUFJRixJQUFJLENBQWIsRUFBZ0JBLElBQUltRixLQUFLakYsTUFBekIsRUFBaUNGLEdBQWpDLEVBQXNDO0FBQ2xDbUYsaUJBQUtuRixDQUFMLElBQVVDLFVBQVVELElBQUksQ0FBZCxDQUFWO0FBQ0g7QUFDRDtBQUNBLFlBQUkwMkMsT0FBTyxFQUFFaGpDLFVBQVVBLFFBQVosRUFBc0J2TyxNQUFNQSxJQUE1QixFQUFYO0FBQ0FteEMsc0JBQWNELFVBQWQsSUFBNEJLLElBQTVCO0FBQ0FELDBCQUFrQkosVUFBbEI7QUFDQSxlQUFPQSxZQUFQO0FBQ0Q7O0FBRUQsYUFBU00sY0FBVCxDQUF3QnRRLE1BQXhCLEVBQWdDO0FBQzVCLGVBQU9pUSxjQUFjalEsTUFBZCxDQUFQO0FBQ0g7O0FBRUQsYUFBU3p2QixHQUFULENBQWE4L0IsSUFBYixFQUFtQjtBQUNmLFlBQUloakMsV0FBV2dqQyxLQUFLaGpDLFFBQXBCO0FBQ0EsWUFBSXZPLE9BQU91eEMsS0FBS3Z4QyxJQUFoQjtBQUNBLGdCQUFRQSxLQUFLakYsTUFBYjtBQUNBLGlCQUFLLENBQUw7QUFDSXdUO0FBQ0E7QUFDSixpQkFBSyxDQUFMO0FBQ0lBLHlCQUFTdk8sS0FBSyxDQUFMLENBQVQ7QUFDQTtBQUNKLGlCQUFLLENBQUw7QUFDSXVPLHlCQUFTdk8sS0FBSyxDQUFMLENBQVQsRUFBa0JBLEtBQUssQ0FBTCxDQUFsQjtBQUNBO0FBQ0osaUJBQUssQ0FBTDtBQUNJdU8seUJBQVN2TyxLQUFLLENBQUwsQ0FBVCxFQUFrQkEsS0FBSyxDQUFMLENBQWxCLEVBQTJCQSxLQUFLLENBQUwsQ0FBM0I7QUFDQTtBQUNKO0FBQ0l1Tyx5QkFBU2xULEtBQVQsQ0FBZTJGLFNBQWYsRUFBMEJoQixJQUExQjtBQUNBO0FBZko7QUFpQkg7O0FBRUQsYUFBU3l4QyxZQUFULENBQXNCdlEsTUFBdEIsRUFBOEI7QUFDMUI7QUFDQTtBQUNBLFlBQUlrUSxxQkFBSixFQUEyQjtBQUN2QjtBQUNBO0FBQ0F6Z0MsdUJBQVc4Z0MsWUFBWCxFQUF5QixDQUF6QixFQUE0QnZRLE1BQTVCO0FBQ0gsU0FKRCxNQUlPO0FBQ0gsZ0JBQUlxUSxPQUFPSixjQUFjalEsTUFBZCxDQUFYO0FBQ0EsZ0JBQUlxUSxJQUFKLEVBQVU7QUFDTkgsd0NBQXdCLElBQXhCO0FBQ0Esb0JBQUk7QUFDQTMvQix3QkFBSTgvQixJQUFKO0FBQ0gsaUJBRkQsU0FFVTtBQUNOQyxtQ0FBZXRRLE1BQWY7QUFDQWtRLDRDQUF3QixLQUF4QjtBQUNIO0FBQ0o7QUFDSjtBQUNKOztBQUVELGFBQVNNLDZCQUFULEdBQXlDO0FBQ3JDSiw0QkFBb0IsMkJBQVNwUSxNQUFULEVBQWlCO0FBQ2pDL2hDLG9CQUFRdVMsUUFBUixDQUFpQixZQUFZO0FBQUUrL0IsNkJBQWF2USxNQUFiO0FBQXVCLGFBQXREO0FBQ0gsU0FGRDtBQUdIOztBQUVELGFBQVN5USxpQkFBVCxHQUE2QjtBQUN6QjtBQUNBO0FBQ0EsWUFBSTczQyxPQUFPODNDLFdBQVAsSUFBc0IsQ0FBQzkzQyxPQUFPKzNDLGFBQWxDLEVBQWlEO0FBQzdDLGdCQUFJQyw0QkFBNEIsSUFBaEM7QUFDQSxnQkFBSUMsZUFBZWo0QyxPQUFPazRDLFNBQTFCO0FBQ0FsNEMsbUJBQU9rNEMsU0FBUCxHQUFtQixZQUFXO0FBQzFCRiw0Q0FBNEIsS0FBNUI7QUFDSCxhQUZEO0FBR0FoNEMsbUJBQU84M0MsV0FBUCxDQUFtQixFQUFuQixFQUF1QixHQUF2QjtBQUNBOTNDLG1CQUFPazRDLFNBQVAsR0FBbUJELFlBQW5CO0FBQ0EsbUJBQU9ELHlCQUFQO0FBQ0g7QUFDSjs7QUFFRCxhQUFTRyxnQ0FBVCxHQUE0QztBQUN4QztBQUNBO0FBQ0E7O0FBRUEsWUFBSUMsZ0JBQWdCLGtCQUFrQjd1QyxLQUFLMGpDLE1BQUwsRUFBbEIsR0FBa0MsR0FBdEQ7QUFDQSxZQUFJb0wsa0JBQWtCLFNBQWxCQSxlQUFrQixDQUFTaHhCLEtBQVQsRUFBZ0I7QUFDbEMsZ0JBQUlBLE1BQU0zWixNQUFOLEtBQWlCMU4sTUFBakIsSUFDQSxPQUFPcW5CLE1BQU1uYyxJQUFiLEtBQXNCLFFBRHRCLElBRUFtYyxNQUFNbmMsSUFBTixDQUFXaWtCLE9BQVgsQ0FBbUJpcEIsYUFBbkIsTUFBc0MsQ0FGMUMsRUFFNkM7QUFDekNULDZCQUFhLENBQUN0d0IsTUFBTW5jLElBQU4sQ0FBV2hMLEtBQVgsQ0FBaUJrNEMsY0FBY24zQyxNQUEvQixDQUFkO0FBQ0g7QUFDSixTQU5EOztBQVFBLFlBQUlqQixPQUFPczRDLGdCQUFYLEVBQTZCO0FBQ3pCdDRDLG1CQUFPczRDLGdCQUFQLENBQXdCLFNBQXhCLEVBQW1DRCxlQUFuQyxFQUFvRCxLQUFwRDtBQUNILFNBRkQsTUFFTztBQUNIcjRDLG1CQUFPdTRDLFdBQVAsQ0FBbUIsV0FBbkIsRUFBZ0NGLGVBQWhDO0FBQ0g7O0FBRURiLDRCQUFvQiwyQkFBU3BRLE1BQVQsRUFBaUI7QUFDakNwbkMsbUJBQU84M0MsV0FBUCxDQUFtQk0sZ0JBQWdCaFIsTUFBbkMsRUFBMkMsR0FBM0M7QUFDSCxTQUZEO0FBR0g7O0FBRUQsYUFBU29SLG1DQUFULEdBQStDO0FBQzNDLFlBQUlDLFVBQVUsSUFBSUMsY0FBSixFQUFkO0FBQ0FELGdCQUFRRSxLQUFSLENBQWNULFNBQWQsR0FBMEIsVUFBUzd3QixLQUFULEVBQWdCO0FBQ3RDLGdCQUFJK2YsU0FBUy9mLE1BQU1uYyxJQUFuQjtBQUNBeXNDLHlCQUFhdlEsTUFBYjtBQUNILFNBSEQ7O0FBS0FvUSw0QkFBb0IsMkJBQVNwUSxNQUFULEVBQWlCO0FBQ2pDcVIsb0JBQVFHLEtBQVIsQ0FBY2QsV0FBZCxDQUEwQjFRLE1BQTFCO0FBQ0gsU0FGRDtBQUdIOztBQUVELGFBQVN5UixxQ0FBVCxHQUFpRDtBQUM3QyxZQUFJQyxPQUFPdkIsSUFBSXdCLGVBQWY7QUFDQXZCLDRCQUFvQiwyQkFBU3BRLE1BQVQsRUFBaUI7QUFDakM7QUFDQTtBQUNBLGdCQUFJNFIsU0FBU3pCLElBQUl0UyxhQUFKLENBQWtCLFFBQWxCLENBQWI7QUFDQStULG1CQUFPckssa0JBQVAsR0FBNEIsWUFBWTtBQUNwQ2dKLDZCQUFhdlEsTUFBYjtBQUNBNFIsdUJBQU9ySyxrQkFBUCxHQUE0QixJQUE1QjtBQUNBbUsscUJBQUt0RyxXQUFMLENBQWlCd0csTUFBakI7QUFDQUEseUJBQVMsSUFBVDtBQUNILGFBTEQ7QUFNQUYsaUJBQUtHLFdBQUwsQ0FBaUJELE1BQWpCO0FBQ0gsU0FYRDtBQVlIOztBQUVELGFBQVNFLCtCQUFULEdBQTJDO0FBQ3ZDMUIsNEJBQW9CLDJCQUFTcFEsTUFBVCxFQUFpQjtBQUNqQ3Z3Qix1QkFBVzhnQyxZQUFYLEVBQXlCLENBQXpCLEVBQTRCdlEsTUFBNUI7QUFDSCxTQUZEO0FBR0g7O0FBRUQ7QUFDQSxRQUFJK1IsV0FBVzE0QyxPQUFPb0ksY0FBUCxJQUF5QnBJLE9BQU9vSSxjQUFQLENBQXNCN0ksTUFBdEIsQ0FBeEM7QUFDQW01QyxlQUFXQSxZQUFZQSxTQUFTdGlDLFVBQXJCLEdBQWtDc2lDLFFBQWxDLEdBQTZDbjVDLE1BQXhEOztBQUVBO0FBQ0EsUUFBSSxHQUFHdUMsUUFBSCxDQUFZVixJQUFaLENBQWlCN0IsT0FBT3FGLE9BQXhCLE1BQXFDLGtCQUF6QyxFQUE2RDtBQUN6RDtBQUNBdXlDO0FBRUgsS0FKRCxNQUlPLElBQUlDLG1CQUFKLEVBQXlCO0FBQzVCO0FBQ0FNO0FBRUgsS0FKTSxNQUlBLElBQUluNEMsT0FBTzA0QyxjQUFYLEVBQTJCO0FBQzlCO0FBQ0FGO0FBRUgsS0FKTSxNQUlBLElBQUlqQixPQUFPLHdCQUF3QkEsSUFBSXRTLGFBQUosQ0FBa0IsUUFBbEIsQ0FBbkMsRUFBZ0U7QUFDbkU7QUFDQTRUO0FBRUgsS0FKTSxNQUlBO0FBQ0g7QUFDQUs7QUFDSDs7QUFFREMsYUFBUzFVLFlBQVQsR0FBd0JBLFlBQXhCO0FBQ0EwVSxhQUFTekIsY0FBVCxHQUEwQkEsY0FBMUI7QUFDSCxDQXpMQSxFQXlMQyxPQUFPNXlDLElBQVAsS0FBZ0IsV0FBaEIsR0FBOEIsT0FBTzlFLE1BQVAsS0FBa0IsV0FBbEIsZUFBdUNBLE1BQXJFLEdBQThFOEUsSUF6TC9FLENBQUQsQzs7Ozs7Ozs7OztBQ0FBdkYsT0FBT0MsT0FBUCxHQUFpQjQ1QyxXQUFqQjs7QUFFQSxTQUFTQSxXQUFULEdBQXVCO0FBQ3RCaG1DLENBQUEsbUJBQUFBLENBQVEsRUFBUjtBQUNBLFFBQU8sRUFBUDtBQUNBLEM7Ozs7Ozs7Ozs7O0FDTEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7O0FBSUE7Ozs7Ozs7QUFRQTtBQUNBOztBQUVBLElBQUksUUFBTzZaLElBQVAseUNBQU9BLElBQVAsT0FBZ0IsUUFBcEIsRUFBOEI7QUFDMUJBLFdBQU8sRUFBUDtBQUNIOztBQUVBLGFBQVk7QUFDVDs7QUFFQSxRQUFJb3NCLFNBQVMsZUFBYjtBQUNBLFFBQUlDLFNBQVMscUNBQWI7QUFDQSxRQUFJQyxXQUFXLGtFQUFmO0FBQ0EsUUFBSUMsVUFBVSxzQkFBZDtBQUNBLFFBQUlDLGVBQWUsaUlBQW5CO0FBQ0EsUUFBSUMsZUFBZSwwR0FBbkI7O0FBRUEsYUFBU3RnQyxDQUFULENBQVd2UyxDQUFYLEVBQWM7QUFDVjtBQUNBLGVBQU9BLElBQUksRUFBSixHQUNELE1BQU1BLENBREwsR0FFREEsQ0FGTjtBQUdIOztBQUVELGFBQVM4eUMsVUFBVCxHQUFzQjtBQUNsQixlQUFPLEtBQUtudkMsT0FBTCxFQUFQO0FBQ0g7O0FBRUQsUUFBSSxPQUFPb3ZDLEtBQUtsNEMsU0FBTCxDQUFlKzRCLE1BQXRCLEtBQWlDLFVBQXJDLEVBQWlEOztBQUU3Q21mLGFBQUtsNEMsU0FBTCxDQUFlKzRCLE1BQWYsR0FBd0IsWUFBWTs7QUFFaEMsbUJBQU9sQyxTQUFTLEtBQUsvdEIsT0FBTCxFQUFULElBQ0QsS0FBS3F2QyxjQUFMLEtBQXdCLEdBQXhCLEdBQ016Z0MsRUFBRSxLQUFLMGdDLFdBQUwsS0FBcUIsQ0FBdkIsQ0FETixHQUNrQyxHQURsQyxHQUVNMWdDLEVBQUUsS0FBSzJnQyxVQUFMLEVBQUYsQ0FGTixHQUU2QixHQUY3QixHQUdNM2dDLEVBQUUsS0FBSzRnQyxXQUFMLEVBQUYsQ0FITixHQUc4QixHQUg5QixHQUlNNWdDLEVBQUUsS0FBSzZnQyxhQUFMLEVBQUYsQ0FKTixHQUlnQyxHQUpoQyxHQUtNN2dDLEVBQUUsS0FBSzhnQyxhQUFMLEVBQUYsQ0FMTixHQUtnQyxHQU4vQixHQU9ELElBUE47QUFRSCxTQVZEOztBQVlBQyxnQkFBUXo0QyxTQUFSLENBQWtCKzRCLE1BQWxCLEdBQTJCa2YsVUFBM0I7QUFDQW5PLGVBQU85cEMsU0FBUCxDQUFpQis0QixNQUFqQixHQUEwQmtmLFVBQTFCO0FBQ0FoNEMsZUFBT0QsU0FBUCxDQUFpQis0QixNQUFqQixHQUEwQmtmLFVBQTFCO0FBQ0g7O0FBRUQsUUFBSVMsR0FBSjtBQUNBLFFBQUkvb0IsTUFBSjtBQUNBLFFBQUlncEIsSUFBSjtBQUNBLFFBQUlDLEdBQUo7O0FBR0EsYUFBU0MsS0FBVCxDQUFlQyxNQUFmLEVBQXVCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFUWYscUJBQWEvdEMsU0FBYixHQUF5QixDQUF6QjtBQUNBLGVBQU8rdEMsYUFBYWpxQyxJQUFiLENBQWtCZ3JDLE1BQWxCLElBQ0QsT0FBT0EsT0FBTzE0QyxPQUFQLENBQWUyM0MsWUFBZixFQUE2QixVQUFVLy9CLENBQVYsRUFBYTtBQUMvQyxnQkFBSXNrQixJQUFJcWMsS0FBSzNnQyxDQUFMLENBQVI7QUFDQSxtQkFBTyxPQUFPc2tCLENBQVAsS0FBYSxRQUFiLEdBQ0RBLENBREMsR0FFRCxRQUFRLENBQUMsU0FBU3RrQixFQUFFdTRCLFVBQUYsQ0FBYSxDQUFiLEVBQWdCMXZDLFFBQWhCLENBQXlCLEVBQXpCLENBQVYsRUFBd0NyQyxLQUF4QyxDQUE4QyxDQUFDLENBQS9DLENBRmQ7QUFHSCxTQUxRLENBQVAsR0FLRyxJQU5GLEdBT0QsT0FBT3M2QyxNQUFQLEdBQWdCLElBUHRCO0FBUUg7O0FBR0QsYUFBUzU0QyxHQUFULENBQWFULEdBQWIsRUFBa0IyMUIsTUFBbEIsRUFBMEI7O0FBRTlCOztBQUVRLFlBQUkvMUIsQ0FBSixDQUpzQixDQUlOO0FBQ2hCLFlBQUlzQixDQUFKLENBTHNCLENBS047QUFDaEIsWUFBSUQsQ0FBSixDQU5zQixDQU1OO0FBQ2hCLFlBQUluQixNQUFKO0FBQ0EsWUFBSXc1QyxPQUFPTCxHQUFYO0FBQ0EsWUFBSU0sT0FBSjtBQUNBLFlBQUk1MEMsUUFBUWd4QixPQUFPMzFCLEdBQVAsQ0FBWjs7QUFFUjs7QUFFUSxZQUFJMkUsU0FBUyxRQUFPQSxLQUFQLHlDQUFPQSxLQUFQLE9BQWlCLFFBQTFCLElBQ0ksT0FBT0EsTUFBTTIwQixNQUFiLEtBQXdCLFVBRGhDLEVBQzRDO0FBQ3hDMzBCLG9CQUFRQSxNQUFNMjBCLE1BQU4sQ0FBYXQ1QixHQUFiLENBQVI7QUFDSDs7QUFFVDtBQUNBOztBQUVRLFlBQUksT0FBT201QyxHQUFQLEtBQWUsVUFBbkIsRUFBK0I7QUFDM0J4MEMsb0JBQVF3MEMsSUFBSXo0QyxJQUFKLENBQVNpMUIsTUFBVCxFQUFpQjMxQixHQUFqQixFQUFzQjJFLEtBQXRCLENBQVI7QUFDSDs7QUFFVDs7QUFFUSx1QkFBZUEsS0FBZix5Q0FBZUEsS0FBZjtBQUNBLGlCQUFLLFFBQUw7QUFDSSx1QkFBT3kwQyxNQUFNejBDLEtBQU4sQ0FBUDs7QUFFSixpQkFBSyxRQUFMOztBQUVSOztBQUVZLHVCQUFPeXlCLFNBQVN6eUIsS0FBVCxJQUNEbkUsT0FBT21FLEtBQVAsQ0FEQyxHQUVELE1BRk47O0FBSUosaUJBQUssU0FBTDtBQUNBLGlCQUFLLE1BQUw7O0FBRVI7QUFDQTtBQUNBOztBQUVZLHVCQUFPbkUsT0FBT21FLEtBQVAsQ0FBUDs7QUFFWjtBQUNBOztBQUVRLGlCQUFLLFFBQUw7O0FBRVI7QUFDQTs7QUFFWSxvQkFBSSxDQUFDQSxLQUFMLEVBQVk7QUFDUiwyQkFBTyxNQUFQO0FBQ0g7O0FBRWI7O0FBRVlzMEMsdUJBQU8vb0IsTUFBUDtBQUNBcXBCLDBCQUFVLEVBQVY7O0FBRVo7O0FBRVksb0JBQUlqNkMsT0FBT2lCLFNBQVAsQ0FBaUJhLFFBQWpCLENBQTBCaEIsS0FBMUIsQ0FBZ0N1RSxLQUFoQyxNQUEyQyxnQkFBL0MsRUFBaUU7O0FBRTdFO0FBQ0E7O0FBRWdCN0UsNkJBQVM2RSxNQUFNN0UsTUFBZjtBQUNBLHlCQUFLRixJQUFJLENBQVQsRUFBWUEsSUFBSUUsTUFBaEIsRUFBd0JGLEtBQUssQ0FBN0IsRUFBZ0M7QUFDNUIyNUMsZ0NBQVEzNUMsQ0FBUixJQUFhYSxJQUFJYixDQUFKLEVBQU8rRSxLQUFQLEtBQWlCLE1BQTlCO0FBQ0g7O0FBRWpCO0FBQ0E7O0FBRWdCMUQsd0JBQUlzNEMsUUFBUXo1QyxNQUFSLEtBQW1CLENBQW5CLEdBQ0UsSUFERixHQUVFbTVDLE1BQ0ksUUFBUUEsR0FBUixHQUFjTSxRQUFROXZCLElBQVIsQ0FBYSxRQUFRd3ZCLEdBQXJCLENBQWQsR0FBMEMsSUFBMUMsR0FBaURLLElBQWpELEdBQXdELEdBRDVELEdBRUksTUFBTUMsUUFBUTl2QixJQUFSLENBQWEsR0FBYixDQUFOLEdBQTBCLEdBSnBDO0FBS0F3dkIsMEJBQU1LLElBQU47QUFDQSwyQkFBT3I0QyxDQUFQO0FBQ0g7O0FBRWI7O0FBRVksb0JBQUlrNEMsT0FBTyxRQUFPQSxHQUFQLHlDQUFPQSxHQUFQLE9BQWUsUUFBMUIsRUFBb0M7QUFDaENyNUMsNkJBQVNxNUMsSUFBSXI1QyxNQUFiO0FBQ0EseUJBQUtGLElBQUksQ0FBVCxFQUFZQSxJQUFJRSxNQUFoQixFQUF3QkYsS0FBSyxDQUE3QixFQUFnQztBQUM1Qiw0QkFBSSxPQUFPdTVDLElBQUl2NUMsQ0FBSixDQUFQLEtBQWtCLFFBQXRCLEVBQWdDO0FBQzVCc0IsZ0NBQUlpNEMsSUFBSXY1QyxDQUFKLENBQUo7QUFDQXFCLGdDQUFJUixJQUFJUyxDQUFKLEVBQU95RCxLQUFQLENBQUo7QUFDQSxnQ0FBSTFELENBQUosRUFBTztBQUNIczRDLHdDQUFRM3VDLElBQVIsQ0FBYXd1QyxNQUFNbDRDLENBQU4sS0FDVCszQyxNQUNNLElBRE4sR0FFTSxHQUhHLElBSVRoNEMsQ0FKSjtBQUtIO0FBQ0o7QUFDSjtBQUNKLGlCQWZELE1BZU87O0FBRW5COztBQUVnQix5QkFBS0MsQ0FBTCxJQUFVeUQsS0FBVixFQUFpQjtBQUNiLDRCQUFJckYsT0FBT2lCLFNBQVAsQ0FBaUJZLGNBQWpCLENBQWdDVCxJQUFoQyxDQUFxQ2lFLEtBQXJDLEVBQTRDekQsQ0FBNUMsQ0FBSixFQUFvRDtBQUNoREQsZ0NBQUlSLElBQUlTLENBQUosRUFBT3lELEtBQVAsQ0FBSjtBQUNBLGdDQUFJMUQsQ0FBSixFQUFPO0FBQ0hzNEMsd0NBQVEzdUMsSUFBUixDQUFhd3VDLE1BQU1sNEMsQ0FBTixLQUNUKzNDLE1BQ00sSUFETixHQUVNLEdBSEcsSUFJVGg0QyxDQUpKO0FBS0g7QUFDSjtBQUNKO0FBQ0o7O0FBRWI7QUFDQTs7QUFFWUEsb0JBQUlzNEMsUUFBUXo1QyxNQUFSLEtBQW1CLENBQW5CLEdBQ0UsSUFERixHQUVFbTVDLE1BQ0ksUUFBUUEsR0FBUixHQUFjTSxRQUFROXZCLElBQVIsQ0FBYSxRQUFRd3ZCLEdBQXJCLENBQWQsR0FBMEMsSUFBMUMsR0FBaURLLElBQWpELEdBQXdELEdBRDVELEdBRUksTUFBTUMsUUFBUTl2QixJQUFSLENBQWEsR0FBYixDQUFOLEdBQTBCLEdBSnBDO0FBS0F3dkIsc0JBQU1LLElBQU47QUFDQSx1QkFBT3I0QyxDQUFQO0FBMUdKO0FBNEdIOztBQUVMOztBQUVJLFFBQUksT0FBTzZxQixLQUFLQyxTQUFaLEtBQTBCLFVBQTlCLEVBQTBDO0FBQ3RDbXRCLGVBQU8sRUFBSztBQUNSLGtCQUFNLEtBREg7QUFFSCxrQkFBTSxLQUZIO0FBR0gsa0JBQU0sS0FISDtBQUlILGtCQUFNLEtBSkg7QUFLSCxrQkFBTSxLQUxIO0FBTUgsa0JBQU0sTUFOSDtBQU9ILGtCQUFNO0FBUEgsU0FBUDtBQVNBcHRCLGFBQUtDLFNBQUwsR0FBaUIsVUFBVXBuQixLQUFWLEVBQWlCNjBDLFFBQWpCLEVBQTJCQyxLQUEzQixFQUFrQzs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFWSxnQkFBSTc1QyxDQUFKO0FBQ0FxNUMsa0JBQU0sRUFBTjtBQUNBL29CLHFCQUFTLEVBQVQ7O0FBRVo7QUFDQTs7QUFFWSxnQkFBSSxPQUFPdXBCLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDM0IscUJBQUs3NUMsSUFBSSxDQUFULEVBQVlBLElBQUk2NUMsS0FBaEIsRUFBdUI3NUMsS0FBSyxDQUE1QixFQUErQjtBQUMzQnN3Qiw4QkFBVSxHQUFWO0FBQ0g7O0FBRWpCO0FBRWEsYUFQRCxNQU9PLElBQUksT0FBT3VwQixLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQ2xDdnBCLHlCQUFTdXBCLEtBQVQ7QUFDSDs7QUFFYjtBQUNBOztBQUVZTixrQkFBTUssUUFBTjtBQUNBLGdCQUFJQSxZQUFZLE9BQU9BLFFBQVAsS0FBb0IsVUFBaEMsS0FDSyxRQUFPQSxRQUFQLHlDQUFPQSxRQUFQLE9BQW9CLFFBQXBCLElBQ0QsT0FBT0EsU0FBUzE1QyxNQUFoQixLQUEyQixRQUYvQixDQUFKLEVBRThDO0FBQzFDLHNCQUFNLElBQUkwVixLQUFKLENBQVUsZ0JBQVYsQ0FBTjtBQUNIOztBQUViO0FBQ0E7O0FBRVksbUJBQU8vVSxJQUFJLEVBQUosRUFBUSxFQUFDLElBQUlrRSxLQUFMLEVBQVIsQ0FBUDtBQUNILFNBeENEO0FBeUNIOztBQUdMOztBQUVJLFFBQUksT0FBT21uQixLQUFLaWYsS0FBWixLQUFzQixVQUExQixFQUFzQztBQUNsQ2pmLGFBQUtpZixLQUFMLEdBQWEsVUFBVTJPLElBQVYsRUFBZ0JDLE9BQWhCLEVBQXlCOztBQUU5QztBQUNBOztBQUVZLGdCQUFJNzNCLENBQUo7O0FBRUEscUJBQVM4M0IsSUFBVCxDQUFjamtCLE1BQWQsRUFBc0IzMUIsR0FBdEIsRUFBMkI7O0FBRXZDO0FBQ0E7O0FBRWdCLG9CQUFJa0IsQ0FBSjtBQUNBLG9CQUFJRCxDQUFKO0FBQ0Esb0JBQUkwRCxRQUFRZ3hCLE9BQU8zMUIsR0FBUCxDQUFaO0FBQ0Esb0JBQUkyRSxTQUFTLFFBQU9BLEtBQVAseUNBQU9BLEtBQVAsT0FBaUIsUUFBOUIsRUFBd0M7QUFDcEMseUJBQUt6RCxDQUFMLElBQVV5RCxLQUFWLEVBQWlCO0FBQ2IsNEJBQUlyRixPQUFPaUIsU0FBUCxDQUFpQlksY0FBakIsQ0FBZ0NULElBQWhDLENBQXFDaUUsS0FBckMsRUFBNEN6RCxDQUE1QyxDQUFKLEVBQW9EO0FBQ2hERCxnQ0FBSTI0QyxLQUFLajFDLEtBQUwsRUFBWXpELENBQVosQ0FBSjtBQUNBLGdDQUFJRCxNQUFNOEUsU0FBVixFQUFxQjtBQUNqQnBCLHNDQUFNekQsQ0FBTixJQUFXRCxDQUFYO0FBQ0gsNkJBRkQsTUFFTztBQUNILHVDQUFPMEQsTUFBTXpELENBQU4sQ0FBUDtBQUNIO0FBQ0o7QUFDSjtBQUNKO0FBQ0QsdUJBQU95NEMsUUFBUWo1QyxJQUFSLENBQWFpMUIsTUFBYixFQUFxQjMxQixHQUFyQixFQUEwQjJFLEtBQTFCLENBQVA7QUFDSDs7QUFHYjtBQUNBO0FBQ0E7O0FBRVkrMEMsbUJBQU9sNUMsT0FBT2s1QyxJQUFQLENBQVA7QUFDQW5CLHlCQUFhaHVDLFNBQWIsR0FBeUIsQ0FBekI7QUFDQSxnQkFBSWd1QyxhQUFhbHFDLElBQWIsQ0FBa0JxckMsSUFBbEIsQ0FBSixFQUE2QjtBQUN6QkEsdUJBQU9BLEtBQUsvNEMsT0FBTCxDQUFhNDNDLFlBQWIsRUFBMkIsVUFBVWhnQyxDQUFWLEVBQWE7QUFDM0MsMkJBQU8sUUFDQyxDQUFDLFNBQVNBLEVBQUV1NEIsVUFBRixDQUFhLENBQWIsRUFBZ0IxdkMsUUFBaEIsQ0FBeUIsRUFBekIsQ0FBVixFQUF3Q3JDLEtBQXhDLENBQThDLENBQUMsQ0FBL0MsQ0FEUjtBQUVILGlCQUhNLENBQVA7QUFJSDs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFWSxnQkFDSW01QyxPQUFPN3BDLElBQVAsQ0FDSXFyQyxLQUNLLzRDLE9BREwsQ0FDYXczQyxNQURiLEVBQ3FCLEdBRHJCLEVBRUt4M0MsT0FGTCxDQUVheTNDLFFBRmIsRUFFdUIsR0FGdkIsRUFHS3ozQyxPQUhMLENBR2EwM0MsT0FIYixFQUdzQixFQUh0QixDQURKLENBREosRUFPRTs7QUFFZDtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0J2MkIsb0JBQUk3akIsS0FBSyxNQUFNeTdDLElBQU4sR0FBYSxHQUFsQixDQUFKOztBQUVoQjtBQUNBOztBQUVnQix1QkFBUSxPQUFPQyxPQUFQLEtBQW1CLFVBQXBCLEdBQ0RDLEtBQUssRUFBQyxJQUFJOTNCLENBQUwsRUFBTCxFQUFjLEVBQWQsQ0FEQyxHQUVEQSxDQUZOO0FBR0g7O0FBRWI7O0FBRVksa0JBQU0sSUFBSSszQixXQUFKLENBQWdCLFlBQWhCLENBQU47QUFDSCxTQXBGRDtBQXFGSDtBQUNKLENBNVZBLEdBQUQsQzs7Ozs7Ozs7O0FDL0pBLElBQUl4Z0MsT0FBTyxtQkFBQXBILENBQVEsQ0FBUixDQUFYO0FBQ0EsSUFBSWxULFFBQVFzYSxLQUFLdGEsS0FBakI7QUFDQSxJQUFJRyxRQUFRbWEsS0FBS25hLEtBQWpCO0FBQ0EsSUFBSUYsT0FBT3FhLEtBQUtyYSxJQUFoQjtBQUNBLElBQUlGLE9BQU91YSxLQUFLdmEsSUFBaEI7QUFDQSxJQUFJTixTQUFTNmEsS0FBSzdhLE1BQWxCO0FBQ0EsSUFBSVcsU0FBU2thLEtBQUtsYSxNQUFsQjtBQUNBLElBQUlDLGFBQWFpYSxLQUFLamEsVUFBdEI7QUFDQSxJQUFJQyxXQUFXZ2EsS0FBS2hhLFFBQXBCOztBQUVBakIsT0FBT0MsT0FBUCxHQUFpQjtBQUNoQm96QyxjQUFhQTtBQURHLENBQWpCOztBQUlBLElBQUlxSSxXQUFXO0FBQ2QvaUMsVUFBUyxRQURLO0FBRWRnakMsVUFBUyxLQUZLOztBQUlkO0FBQ0E7QUFDQTd2QyxNQUFLLGFBQVNsSyxHQUFULEVBQWNnNkMsb0JBQWQsRUFBb0M7QUFDeEMsTUFBSWp3QyxPQUFPLEtBQUtrd0MsT0FBTCxDQUFhbkksSUFBYixDQUFrQixLQUFLb0ksZ0JBQUwsR0FBd0JsNkMsR0FBMUMsQ0FBWDtBQUNBLFNBQU8sS0FBS202QyxZQUFMLENBQWtCcHdDLElBQWxCLEVBQXdCaXdDLG9CQUF4QixDQUFQO0FBQ0EsRUFUYTs7QUFXZDtBQUNBO0FBQ0F2MUMsTUFBSyxhQUFTekUsR0FBVCxFQUFjMkUsS0FBZCxFQUFxQjtBQUN6QixNQUFJQSxVQUFVb0IsU0FBZCxFQUF5QjtBQUN4QixVQUFPLEtBQUtxMEMsTUFBTCxDQUFZcDZDLEdBQVosQ0FBUDtBQUNBO0FBQ0QsT0FBS2k2QyxPQUFMLENBQWF2L0IsS0FBYixDQUFtQixLQUFLdy9CLGdCQUFMLEdBQXdCbDZDLEdBQTNDLEVBQWdELEtBQUtxNkMsVUFBTCxDQUFnQjExQyxLQUFoQixDQUFoRDtBQUNBLFNBQU9BLEtBQVA7QUFDQSxFQW5CYTs7QUFxQmQ7QUFDQXkxQyxTQUFRLGdCQUFTcDZDLEdBQVQsRUFBYztBQUNyQixPQUFLaTZDLE9BQUwsQ0FBYUcsTUFBYixDQUFvQixLQUFLRixnQkFBTCxHQUF3Qmw2QyxHQUE1QztBQUNBLEVBeEJhOztBQTBCZDtBQUNBO0FBQ0FoQixPQUFNLGNBQVNzVSxRQUFULEVBQW1CO0FBQ3hCLE1BQUkzUCxPQUFPLElBQVg7QUFDQSxPQUFLczJDLE9BQUwsQ0FBYWo3QyxJQUFiLENBQWtCLFVBQVNlLEdBQVQsRUFBY3U2QyxhQUFkLEVBQTZCO0FBQzlDaG5DLFlBQVM1UyxJQUFULENBQWNpRCxJQUFkLEVBQW9CQSxLQUFLdzJDLFlBQUwsQ0FBa0JwNkMsR0FBbEIsQ0FBcEIsRUFBNEMsQ0FBQ3U2QyxpQkFBaUIsRUFBbEIsRUFBc0IzNUMsT0FBdEIsQ0FBOEJnRCxLQUFLNDJDLGdCQUFuQyxFQUFxRCxFQUFyRCxDQUE1QztBQUNBLEdBRkQ7QUFHQSxFQWpDYTs7QUFtQ2Q7QUFDQUMsV0FBVSxvQkFBVztBQUNwQixPQUFLUCxPQUFMLENBQWFPLFFBQWI7QUFDQSxFQXRDYTs7QUF3Q2Q7QUFDQTs7QUFFQTtBQUNBQyxlQUFjLHNCQUFTQyxTQUFULEVBQW9CO0FBQ2pDLFNBQVEsS0FBS1IsZ0JBQUwsSUFBeUIsZUFBYVEsU0FBYixHQUF1QixHQUF4RDtBQUNBLEVBOUNhOztBQWdEZDtBQUNBO0FBQ0E7QUFDQWpKLGNBQWEsdUJBQVc7QUFDdkIsU0FBT0EsYUFBWXJ4QyxLQUFaLENBQWtCLElBQWxCLEVBQXdCUCxTQUF4QixDQUFQO0FBQ0EsRUFyRGE7O0FBdURkODZDLFlBQVcsbUJBQVNDLE1BQVQsRUFBaUI7QUFDM0IsT0FBS0MsVUFBTCxDQUFnQkQsTUFBaEI7QUFDQSxFQXpEYTs7QUEyRGRGLFlBQVcsbUJBQVNBLFVBQVQsRUFBb0I7QUFDOUIsU0FBT2pKLGFBQVksS0FBS3dJLE9BQWpCLEVBQTBCLEtBQUt6SSxPQUEvQixFQUF3Q2tKLFVBQXhDLENBQVA7QUFDQTtBQTdEYSxDQUFmOztBQWdFQSxTQUFTcjdCLEtBQVQsR0FBaUI7QUFDaEIsS0FBSXk3QixXQUFZLE9BQU92dkIsT0FBUCxJQUFrQixXQUFsQixHQUFnQyxJQUFoQyxHQUF1Q0EsT0FBdkQ7QUFDQSxLQUFJLENBQUN1dkIsUUFBTCxFQUFlO0FBQUU7QUFBUTtBQUN6QixLQUFJbDZDLEtBQU1rNkMsU0FBUzMxQixJQUFULEdBQWdCMjFCLFNBQVMzMUIsSUFBekIsR0FBZ0MyMUIsU0FBU3R2QixHQUFuRDtBQUNBNXFCLElBQUdSLEtBQUgsQ0FBUzA2QyxRQUFULEVBQW1CajdDLFNBQW5CO0FBQ0E7O0FBRUQsU0FBUzR4QyxZQUFULENBQXFCRixRQUFyQixFQUErQkMsT0FBL0IsRUFBd0NrSixTQUF4QyxFQUFtRDtBQUNsRCxLQUFJLENBQUNBLFNBQUwsRUFBZ0I7QUFDZkEsY0FBWSxFQUFaO0FBQ0E7QUFDRCxLQUFJbkosWUFBWSxDQUFDcHlDLE9BQU9veUMsUUFBUCxDQUFqQixFQUFtQztBQUNsQ0EsYUFBVyxDQUFDQSxRQUFELENBQVg7QUFDQTtBQUNELEtBQUlDLFdBQVcsQ0FBQ3J5QyxPQUFPcXlDLE9BQVAsQ0FBaEIsRUFBaUM7QUFDaENBLFlBQVUsQ0FBQ0EsT0FBRCxDQUFWO0FBQ0E7O0FBRUQsS0FBSXVKLGtCQUFtQkwsWUFBWSxlQUFhQSxTQUFiLEdBQXVCLEdBQW5DLEdBQXlDLEVBQWhFO0FBQ0EsS0FBSU0sa0JBQW1CTixZQUFZLElBQUlyekMsTUFBSixDQUFXLE1BQUkwekMsZUFBZixDQUFaLEdBQThDLElBQXJFO0FBQ0EsS0FBSUUsa0JBQWtCLG1CQUF0QixDQWJrRCxDQWFSO0FBQzFDLEtBQUksQ0FBQ0EsZ0JBQWdCNXNDLElBQWhCLENBQXFCcXNDLFNBQXJCLENBQUwsRUFBc0M7QUFDckMsUUFBTSxJQUFJbGxDLEtBQUosQ0FBVSwwRUFBVixDQUFOO0FBQ0E7O0FBRUQsS0FBSTBsQyxxQkFBcUI7QUFDeEJoQixvQkFBa0JhLGVBRE07QUFFeEJSLG9CQUFrQlMsZUFGTTs7QUFJeEJHLGdCQUFjLHNCQUFTbEIsT0FBVCxFQUFrQjtBQUMvQixPQUFJO0FBQ0gsUUFBSW1CLFVBQVUsbUJBQWQ7QUFDQW5CLFlBQVF2L0IsS0FBUixDQUFjMGdDLE9BQWQsRUFBdUJBLE9BQXZCO0FBQ0EsUUFBSUMsS0FBTXBCLFFBQVFuSSxJQUFSLENBQWFzSixPQUFiLE1BQTBCQSxPQUFwQztBQUNBbkIsWUFBUUcsTUFBUixDQUFlZ0IsT0FBZjtBQUNBLFdBQU9DLEVBQVA7QUFDQSxJQU5ELENBTUUsT0FBTW45QyxDQUFOLEVBQVM7QUFDVixXQUFPLEtBQVA7QUFDQTtBQUNELEdBZHVCOztBQWdCeEJvOUMsdUJBQXFCLDZCQUFTQyxZQUFULEVBQXVCQyxRQUF2QixFQUFpQztBQUNyRCxPQUFJQyxRQUFRLEtBQUtELFFBQUwsQ0FBWjtBQUNBLFFBQUtBLFFBQUwsSUFBaUIsU0FBU0UsUUFBVCxHQUFvQjtBQUNwQyxRQUFJMzJDLE9BQU9oRyxNQUFNYyxTQUFOLEVBQWlCLENBQWpCLENBQVg7QUFDQSxRQUFJOEQsT0FBTyxJQUFYOztBQUVBO0FBQ0E7QUFDQSxhQUFTZzRDLFFBQVQsR0FBb0I7QUFDbkIsU0FBSSxDQUFDRixLQUFMLEVBQVk7QUFBRTtBQUFRO0FBQ3RCejhDLFVBQUthLFNBQUwsRUFBZ0IsVUFBU3lHLEdBQVQsRUFBYzFHLENBQWQsRUFBaUI7QUFDaENtRixXQUFLbkYsQ0FBTCxJQUFVMEcsR0FBVjtBQUNBLE1BRkQ7QUFHQSxZQUFPbTFDLE1BQU1yN0MsS0FBTixDQUFZdUQsSUFBWixFQUFrQm9CLElBQWxCLENBQVA7QUFDQTs7QUFFRDtBQUNBO0FBQ0EsUUFBSTYyQyxZQUFZLENBQUNELFFBQUQsRUFBV3Q3QyxNQUFYLENBQWtCMEUsSUFBbEIsQ0FBaEI7O0FBRUEsV0FBT3cyQyxhQUFhbjdDLEtBQWIsQ0FBbUJ1RCxJQUFuQixFQUF5Qmk0QyxTQUF6QixDQUFQO0FBQ0EsSUFuQkQ7QUFvQkEsR0F0Q3VCOztBQXdDeEJ2QixjQUFZLG9CQUFTNzZDLEdBQVQsRUFBYztBQUN6QixVQUFPc3NCLEtBQUtDLFNBQUwsQ0FBZXZzQixHQUFmLENBQVA7QUFDQSxHQTFDdUI7O0FBNEN4QjI2QyxnQkFBYyxzQkFBUzBCLE1BQVQsRUFBaUJDLFVBQWpCLEVBQTZCO0FBQzFDLE9BQUksQ0FBQ0QsTUFBTCxFQUFhO0FBQUUsV0FBT0MsVUFBUDtBQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBSS83QyxNQUFNLEVBQVY7QUFDQSxPQUFJO0FBQUVBLFVBQU0rckIsS0FBS2lmLEtBQUwsQ0FBVzhRLE1BQVgsQ0FBTjtBQUEwQixJQUFoQyxDQUNBLE9BQU0zOUMsQ0FBTixFQUFTO0FBQUU2QixVQUFNODdDLE1BQU47QUFBYzs7QUFFekIsVUFBUTk3QyxRQUFRZ0csU0FBUixHQUFvQmhHLEdBQXBCLEdBQTBCKzdDLFVBQWxDO0FBQ0EsR0F4RHVCOztBQTBEeEJDLGVBQWEscUJBQVM5QixPQUFULEVBQWtCO0FBQzlCLE9BQUksS0FBS0YsT0FBVCxFQUFrQjtBQUFFO0FBQVE7QUFDNUIsT0FBSSxLQUFLb0IsWUFBTCxDQUFrQmxCLE9BQWxCLENBQUosRUFBZ0M7QUFDL0IsU0FBS0EsT0FBTCxHQUFlQSxPQUFmO0FBQ0EsU0FBS0YsT0FBTCxHQUFlLElBQWY7QUFDQTtBQUNELEdBaEV1Qjs7QUFrRXhCYyxjQUFZLG9CQUFTRCxNQUFULEVBQWlCO0FBQzVCLE9BQUlqM0MsT0FBTyxJQUFYOztBQUVBO0FBQ0E7QUFDQSxPQUFJeEUsT0FBT3k3QyxNQUFQLENBQUosRUFBb0I7QUFDbkI1N0MsU0FBSzQ3QyxNQUFMLEVBQWEsVUFBU0EsTUFBVCxFQUFpQjtBQUM3QmozQyxVQUFLazNDLFVBQUwsQ0FBZ0JELE1BQWhCO0FBQ0EsS0FGRDtBQUdBO0FBQ0E7O0FBRUQ7QUFDQTtBQUNBLE9BQUlvQixhQUFhOThDLE1BQU0sS0FBS3N5QyxPQUFYLEVBQW9CLFVBQVN3SyxVQUFULEVBQXFCO0FBQ3pELFdBQVFwQixXQUFXb0IsVUFBbkI7QUFDQSxJQUZnQixDQUFqQjtBQUdBLE9BQUlBLFVBQUosRUFBZ0I7QUFDZjtBQUNBO0FBQ0QsUUFBS3hLLE9BQUwsQ0FBYTVtQyxJQUFiLENBQWtCZ3dDLE1BQWxCOztBQUVBO0FBQ0EsT0FBSSxDQUFDeDdDLFdBQVd3N0MsTUFBWCxDQUFMLEVBQXlCO0FBQ3hCLFVBQU0sSUFBSXBsQyxLQUFKLENBQVUscURBQVYsQ0FBTjtBQUNBOztBQUVELE9BQUl5bUMsbUJBQW1CckIsT0FBT2w2QyxJQUFQLENBQVksSUFBWixDQUF2QjtBQUNBLE9BQUksQ0FBQ3JCLFNBQVM0OEMsZ0JBQVQsQ0FBTCxFQUFpQztBQUNoQyxVQUFNLElBQUl6bUMsS0FBSixDQUFVLHNEQUFWLENBQU47QUFDQTs7QUFFRDtBQUNBeFcsUUFBS2k5QyxnQkFBTCxFQUF1QixVQUFTVixZQUFULEVBQXVCQyxRQUF2QixFQUFpQztBQUN2RCxRQUFJLENBQUNwOEMsV0FBV204QyxZQUFYLENBQUwsRUFBK0I7QUFDOUIsV0FBTSxJQUFJL2xDLEtBQUosQ0FBVSwwQkFBd0JnbUMsUUFBeEIsR0FBaUMsZUFBakMsR0FBaURaLE9BQU9yakMsSUFBeEQsR0FBNkQseUNBQXZFLENBQU47QUFDQTtBQUNENVQsU0FBSzIzQyxtQkFBTCxDQUF5QkMsWUFBekIsRUFBdUNDLFFBQXZDO0FBQ0EsSUFMRDtBQU1BLEdBekd1Qjs7QUEyR3hCO0FBQ0E7O0FBRUE7QUFDQVUsY0FBWSxvQkFBU2pDLE9BQVQsRUFBa0I7QUFDN0I1NkIsU0FBTSxzRUFBTjtBQUNBLFFBQUswOEIsV0FBTCxDQUFpQjlCLE9BQWpCO0FBQ0E7QUFsSHVCLEVBQXpCOztBQXFIQSxLQUFJa0MsUUFBUTM5QyxPQUFPMDhDLGtCQUFQLEVBQTJCcEIsUUFBM0IsRUFBcUM7QUFDaER0SSxXQUFTO0FBRHVDLEVBQXJDLENBQVo7QUFHQTJLLE9BQU1DLEdBQU4sR0FBWSxFQUFaO0FBQ0FwOUMsTUFBS205QyxLQUFMLEVBQVksVUFBU3JyQixJQUFULEVBQWUwcUIsUUFBZixFQUF5QjtBQUNwQyxNQUFJcDhDLFdBQVcweEIsSUFBWCxDQUFKLEVBQXNCO0FBQ3JCcXJCLFNBQU1DLEdBQU4sQ0FBVVosUUFBVixJQUFzQjE4QyxLQUFLcTlDLEtBQUwsRUFBWXJyQixJQUFaLENBQXRCO0FBQ0E7QUFDRCxFQUpEO0FBS0E5eEIsTUFBS3V5QyxRQUFMLEVBQWUsVUFBUzBJLE9BQVQsRUFBa0I7QUFDaENrQyxRQUFNSixXQUFOLENBQWtCOUIsT0FBbEI7QUFDQSxFQUZEO0FBR0FqN0MsTUFBS3d5QyxPQUFMLEVBQWMsVUFBU29KLE1BQVQsRUFBaUI7QUFDOUJ1QixRQUFNdEIsVUFBTixDQUFpQkQsTUFBakI7QUFDQSxFQUZEO0FBR0EsUUFBT3VCLEtBQVA7QUFDQSxDOzs7Ozs7Ozs7QUM1T0QvOUMsT0FBT0MsT0FBUCxHQUFpQjtBQUNoQjtBQUNBLG1CQUFBNFQsQ0FBUSxFQUFSLENBRmdCLEVBR2hCLG1CQUFBQSxDQUFRLEVBQVIsQ0FIZ0IsRUFJaEIsbUJBQUFBLENBQVEsRUFBUixDQUpnQixFQUtoQixtQkFBQUEsQ0FBUSxFQUFSLENBTGdCLEVBTWhCLG1CQUFBQSxDQUFRLEVBQVIsQ0FOZ0IsRUFPaEIsbUJBQUFBLENBQVEsRUFBUixDQVBnQixDQUFqQixDOzs7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSW9ILE9BQU8sbUJBQUFwSCxDQUFRLENBQVIsQ0FBWDtBQUNBLElBQUlyVCxTQUFTeWEsS0FBS3phLE1BQWxCO0FBQ0EsSUFBSUYsT0FBTzJhLEtBQUszYSxJQUFoQjs7QUFFQU4sT0FBT0MsT0FBUCxHQUFpQjtBQUNoQmtaLE9BQU0sZUFEVTtBQUVoQnU2QixPQUFNQSxJQUZVO0FBR2hCcDNCLFFBQU9BLEtBSFM7QUFJaEIxYixPQUFNQSxJQUpVO0FBS2hCbzdDLFNBQVFBLE1BTFE7QUFNaEJJLFdBQVVBO0FBTk0sQ0FBakI7O0FBU0EsSUFBSXBFLE1BQU14M0MsT0FBTzZuQixRQUFqQjs7QUFFQSxTQUFTcXJCLElBQVQsQ0FBYzl4QyxHQUFkLEVBQW1CO0FBQ2xCLEtBQUksQ0FBQ0EsR0FBRCxJQUFRLENBQUNxOEMsS0FBS3I4QyxHQUFMLENBQWIsRUFBd0I7QUFBRSxTQUFPLElBQVA7QUFBYTtBQUN2QyxLQUFJczhDLFlBQVksa0JBQ2ZDLE9BQU92OEMsR0FBUCxFQUFZVyxPQUFaLENBQW9CLGFBQXBCLEVBQW1DLE1BQW5DLENBRGUsR0FFZixvQ0FGRDtBQUdBLFFBQU82N0MsU0FBU3BHLElBQUlxRyxNQUFKLENBQVc5N0MsT0FBWCxDQUFtQixJQUFJMEcsTUFBSixDQUFXaTFDLFNBQVgsQ0FBbkIsRUFBMEMsSUFBMUMsQ0FBVCxDQUFQO0FBQ0E7O0FBRUQsU0FBU3Q5QyxJQUFULENBQWNzVSxRQUFkLEVBQXdCO0FBQ3ZCLEtBQUlvcEMsVUFBVXRHLElBQUlxRyxNQUFKLENBQVcxeUIsS0FBWCxDQUFpQixNQUFqQixDQUFkO0FBQ0EsTUFBSyxJQUFJbnFCLElBQUk4OEMsUUFBUTU4QyxNQUFSLEdBQWlCLENBQTlCLEVBQWlDRixLQUFLLENBQXRDLEVBQXlDQSxHQUF6QyxFQUE4QztBQUM3QyxNQUFJLENBQUNsQixLQUFLZytDLFFBQVE5OEMsQ0FBUixDQUFMLENBQUwsRUFBdUI7QUFDdEI7QUFDQTtBQUNELE1BQUkrOEMsTUFBTUQsUUFBUTk4QyxDQUFSLEVBQVdtcUIsS0FBWCxDQUFpQixHQUFqQixDQUFWO0FBQ0EsTUFBSS9wQixNQUFNdzhDLFNBQVNHLElBQUksQ0FBSixDQUFULENBQVY7QUFDQSxNQUFJNThDLE1BQU15OEMsU0FBU0csSUFBSSxDQUFKLENBQVQsQ0FBVjtBQUNBcnBDLFdBQVN2VCxHQUFULEVBQWNDLEdBQWQ7QUFDQTtBQUNEOztBQUVELFNBQVMwYSxLQUFULENBQWUxYSxHQUFmLEVBQW9CK0osSUFBcEIsRUFBMEI7QUFDekIsS0FBRyxDQUFDL0osR0FBSixFQUFTO0FBQUU7QUFBUTtBQUNuQm8yQyxLQUFJcUcsTUFBSixHQUFhRixPQUFPdjhDLEdBQVAsSUFBYyxHQUFkLEdBQW9CdThDLE9BQU94eUMsSUFBUCxDQUFwQixHQUFtQyxpREFBaEQ7QUFDQTs7QUFFRCxTQUFTcXdDLE1BQVQsQ0FBZ0JwNkMsR0FBaEIsRUFBcUI7QUFDcEIsS0FBSSxDQUFDQSxHQUFELElBQVEsQ0FBQ3E4QyxLQUFLcjhDLEdBQUwsQ0FBYixFQUF3QjtBQUN2QjtBQUNBO0FBQ0RvMkMsS0FBSXFHLE1BQUosR0FBYUYsT0FBT3Y4QyxHQUFQLElBQWMsa0RBQTNCO0FBQ0E7O0FBRUQsU0FBU3c2QyxRQUFULEdBQW9CO0FBQ25CeDdDLE1BQUssVUFBUytjLENBQVQsRUFBWS9iLEdBQVosRUFBaUI7QUFDckJvNkMsU0FBT3A2QyxHQUFQO0FBQ0EsRUFGRDtBQUdBOztBQUVELFNBQVNxOEMsSUFBVCxDQUFjcjhDLEdBQWQsRUFBbUI7QUFDbEIsUUFBUSxJQUFJcUgsTUFBSixDQUFXLGdCQUFnQmsxQyxPQUFPdjhDLEdBQVAsRUFBWVcsT0FBWixDQUFvQixhQUFwQixFQUFtQyxNQUFuQyxDQUFoQixHQUE2RCxTQUF4RSxDQUFELENBQXFGME4sSUFBckYsQ0FBMEYrbkMsSUFBSXFHLE1BQTlGLENBQVA7QUFDQSxDOzs7Ozs7Ozs7QUM1REQsSUFBSXBqQyxPQUFPLG1CQUFBcEgsQ0FBUSxDQUFSLENBQVg7QUFDQSxJQUFJclQsU0FBU3lhLEtBQUt6YSxNQUFsQjs7QUFFQVIsT0FBT0MsT0FBUCxHQUFpQjtBQUNoQmtaLE9BQU0sY0FEVTtBQUVoQnU2QixPQUFNQSxJQUZVO0FBR2hCcDNCLFFBQU9BLEtBSFM7QUFJaEIxYixPQUFNQSxJQUpVO0FBS2hCbzdDLFNBQVFBLE1BTFE7QUFNaEJJLFdBQVVBO0FBTk0sQ0FBakI7O0FBU0EsU0FBU29DLFlBQVQsR0FBd0I7QUFDdkIsUUFBT2grQyxPQUFPZytDLFlBQWQ7QUFDQTs7QUFFRCxTQUFTOUssSUFBVCxDQUFjOXhDLEdBQWQsRUFBbUI7QUFDbEIsUUFBTzQ4QyxlQUFlQyxPQUFmLENBQXVCNzhDLEdBQXZCLENBQVA7QUFDQTs7QUFFRCxTQUFTMGEsS0FBVCxDQUFlMWEsR0FBZixFQUFvQitKLElBQXBCLEVBQTBCO0FBQ3pCLFFBQU82eUMsZUFBZUUsT0FBZixDQUF1Qjk4QyxHQUF2QixFQUE0QitKLElBQTVCLENBQVA7QUFDQTs7QUFFRCxTQUFTL0ssSUFBVCxDQUFjNEIsRUFBZCxFQUFrQjtBQUNqQixNQUFLLElBQUloQixJQUFJZzlDLGVBQWU5OEMsTUFBZixHQUF3QixDQUFyQyxFQUF3Q0YsS0FBSyxDQUE3QyxFQUFnREEsR0FBaEQsRUFBcUQ7QUFDcEQsTUFBSUksTUFBTTQ4QyxlQUFlNThDLEdBQWYsQ0FBbUJKLENBQW5CLENBQVY7QUFDQWdCLEtBQUdreEMsS0FBSzl4QyxHQUFMLENBQUgsRUFBY0EsR0FBZDtBQUNBO0FBQ0Q7O0FBRUQsU0FBU282QyxNQUFULENBQWdCcDZDLEdBQWhCLEVBQXFCO0FBQ3BCLFFBQU80OEMsZUFBZUcsVUFBZixDQUEwQi84QyxHQUExQixDQUFQO0FBQ0E7O0FBRUQsU0FBU3c2QyxRQUFULEdBQW9CO0FBQ25CLFFBQU9vQyxlQUFlcHpDLEtBQWYsRUFBUDtBQUNBLEM7Ozs7Ozs7OztBQ3JDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQXBMLE9BQU9DLE9BQVAsR0FBaUI7QUFDaEJrWixPQUFNLGVBRFU7QUFFaEJ1NkIsT0FBTUEsSUFGVTtBQUdoQnAzQixRQUFPQSxLQUhTO0FBSWhCMWIsT0FBTUEsSUFKVTtBQUtoQm83QyxTQUFRQSxNQUxRO0FBTWhCSSxXQUFVQTtBQU5NLENBQWpCOztBQVNBLElBQUl3QyxnQkFBZ0IsRUFBcEI7O0FBRUEsU0FBU2xMLElBQVQsQ0FBYzl4QyxHQUFkLEVBQW1CO0FBQ2xCLFFBQU9nOUMsY0FBY2g5QyxHQUFkLENBQVA7QUFDQTs7QUFFRCxTQUFTMGEsS0FBVCxDQUFlMWEsR0FBZixFQUFvQitKLElBQXBCLEVBQTBCO0FBQ3pCaXpDLGVBQWNoOUMsR0FBZCxJQUFxQitKLElBQXJCO0FBQ0E7O0FBRUQsU0FBUy9LLElBQVQsQ0FBY3NVLFFBQWQsRUFBd0I7QUFDdkIsTUFBSyxJQUFJdFQsR0FBVCxJQUFnQmc5QyxhQUFoQixFQUErQjtBQUM5QixNQUFJQSxjQUFjNzdDLGNBQWQsQ0FBNkJuQixHQUE3QixDQUFKLEVBQXVDO0FBQ3RDc1QsWUFBUzBwQyxjQUFjaDlDLEdBQWQsQ0FBVCxFQUE2QkEsR0FBN0I7QUFDQTtBQUNEO0FBQ0Q7O0FBRUQsU0FBU282QyxNQUFULENBQWdCcDZDLEdBQWhCLEVBQXFCO0FBQ3BCLFFBQU9nOUMsY0FBY2g5QyxHQUFkLENBQVA7QUFDQTs7QUFFRCxTQUFTdzZDLFFBQVQsQ0FBa0J4NkMsR0FBbEIsRUFBdUI7QUFDdEJnOUMsaUJBQWdCLEVBQWhCO0FBQ0EsQzs7Ozs7Ozs7O0FDdENEO0FBQ0E7QUFDQTs7QUFFQSxJQUFJM2pDLE9BQU8sbUJBQUFwSCxDQUFRLENBQVIsQ0FBWDtBQUNBLElBQUlyVCxTQUFTeWEsS0FBS3phLE1BQWxCOztBQUVBUixPQUFPQyxPQUFQLEdBQWlCO0FBQ2hCa1osT0FBTSxxQkFEVTtBQUVoQnU2QixPQUFNQSxJQUZVO0FBR2hCcDNCLFFBQU9BLEtBSFM7QUFJaEIxYixPQUFNQSxJQUpVO0FBS2hCbzdDLFNBQVFBLE1BTFE7QUFNaEJJLFdBQVVBO0FBTk0sQ0FBakI7O0FBU0EsSUFBSXlDLGdCQUFnQnIrQyxPQUFPcStDLGFBQTNCOztBQUVBLFNBQVNuTCxJQUFULENBQWM5eEMsR0FBZCxFQUFtQjtBQUNsQixRQUFPaTlDLGNBQWNqOUMsR0FBZCxDQUFQO0FBQ0E7O0FBRUQsU0FBUzBhLEtBQVQsQ0FBZTFhLEdBQWYsRUFBb0IrSixJQUFwQixFQUEwQjtBQUN6Qmt6QyxlQUFjajlDLEdBQWQsSUFBcUIrSixJQUFyQjtBQUNBOztBQUVELFNBQVMvSyxJQUFULENBQWM0QixFQUFkLEVBQWtCO0FBQ2pCLE1BQUssSUFBSWhCLElBQUlxOUMsY0FBY245QyxNQUFkLEdBQXVCLENBQXBDLEVBQXVDRixLQUFLLENBQTVDLEVBQStDQSxHQUEvQyxFQUFvRDtBQUNuRCxNQUFJSSxNQUFNaTlDLGNBQWNqOUMsR0FBZCxDQUFrQkosQ0FBbEIsQ0FBVjtBQUNBZ0IsS0FBR3E4QyxjQUFjajlDLEdBQWQsQ0FBSCxFQUF1QkEsR0FBdkI7QUFDQTtBQUNEOztBQUVELFNBQVNvNkMsTUFBVCxDQUFnQnA2QyxHQUFoQixFQUFxQjtBQUNwQixRQUFPaTlDLGNBQWNGLFVBQWQsQ0FBeUIvOEMsR0FBekIsQ0FBUDtBQUNBOztBQUVELFNBQVN3NkMsUUFBVCxHQUFvQjtBQUNuQng3QyxNQUFLLFVBQVNnQixHQUFULEVBQWMrYixDQUFkLEVBQWlCO0FBQ3JCLFNBQU9raEMsY0FBY2o5QyxHQUFkLENBQVA7QUFDQSxFQUZEO0FBR0EsQzs7Ozs7Ozs7O0FDekNEO0FBQ0E7QUFDQTs7QUFFQSxJQUFJcVosT0FBTyxtQkFBQXBILENBQVEsQ0FBUixDQUFYO0FBQ0EsSUFBSXJULFNBQVN5YSxLQUFLemEsTUFBbEI7O0FBRUFSLE9BQU9DLE9BQVAsR0FBaUI7QUFDaEJrWixPQUFNLHVCQURVO0FBRWhCbUQsUUFBT0EsS0FGUztBQUdoQm8zQixPQUFNQSxJQUhVO0FBSWhCOXlDLE9BQU1BLElBSlU7QUFLaEJvN0MsU0FBUUEsTUFMUTtBQU1oQkksV0FBVUE7QUFOTSxDQUFqQjs7QUFTQSxJQUFJMEMsY0FBYyxTQUFsQjtBQUNBLElBQUk5RyxNQUFNeDNDLE9BQU82bkIsUUFBakI7QUFDQSxJQUFJMDJCLGlCQUFpQkMsMEJBQXJCO0FBQ0EsSUFBSUMsVUFBVSxDQUFDeitDLE9BQU84a0MsU0FBUCxHQUFtQjlrQyxPQUFPOGtDLFNBQVAsQ0FBaUI0WixTQUFwQyxHQUFnRCxFQUFqRCxFQUFxRG56QixLQUFyRCxDQUEyRCw0QkFBM0QsQ0FBZCxDLENBQXVHOztBQUV2RyxTQUFTelAsS0FBVCxDQUFlNmlDLFVBQWYsRUFBMkJ4ekMsSUFBM0IsRUFBaUM7QUFDaEMsS0FBSXN6QyxPQUFKLEVBQWE7QUFBRTtBQUFRO0FBQ3ZCLEtBQUlHLFdBQVdDLE9BQU9GLFVBQVAsQ0FBZjtBQUNBSixnQkFBZSxVQUFTTyxTQUFULEVBQW9CO0FBQ2xDQSxZQUFVQyxZQUFWLENBQXVCSCxRQUF2QixFQUFpQ3p6QyxJQUFqQztBQUNBMnpDLFlBQVV6TCxJQUFWLENBQWVpTCxXQUFmO0FBQ0EsRUFIRDtBQUlBOztBQUVELFNBQVNwTCxJQUFULENBQWN5TCxVQUFkLEVBQTBCO0FBQ3pCLEtBQUlGLE9BQUosRUFBYTtBQUFFO0FBQVE7QUFDdkIsS0FBSUcsV0FBV0MsT0FBT0YsVUFBUCxDQUFmO0FBQ0EsS0FBSXY4QyxNQUFNLElBQVY7QUFDQW04QyxnQkFBZSxVQUFTTyxTQUFULEVBQW9CO0FBQ2xDMThDLFFBQU0wOEMsVUFBVUUsWUFBVixDQUF1QkosUUFBdkIsQ0FBTjtBQUNBLEVBRkQ7QUFHQSxRQUFPeDhDLEdBQVA7QUFDQTs7QUFFRCxTQUFTaEMsSUFBVCxDQUFjc1UsUUFBZCxFQUF3QjtBQUN2QjZwQyxnQkFBZSxVQUFTTyxTQUFULEVBQW9CO0FBQ2xDLE1BQUlqckMsYUFBYWlyQyxVQUFVRyxXQUFWLENBQXNCakcsZUFBdEIsQ0FBc0NubEMsVUFBdkQ7QUFDQSxPQUFLLElBQUk3UyxJQUFFNlMsV0FBVzNTLE1BQVgsR0FBa0IsQ0FBN0IsRUFBZ0NGLEtBQUcsQ0FBbkMsRUFBc0NBLEdBQXRDLEVBQTJDO0FBQzFDLE9BQUlrK0MsT0FBT3JyQyxXQUFXN1MsQ0FBWCxDQUFYO0FBQ0EwVCxZQUFTb3FDLFVBQVVFLFlBQVYsQ0FBdUJFLEtBQUt2bUMsSUFBNUIsQ0FBVCxFQUE0Q3VtQyxLQUFLdm1DLElBQWpEO0FBQ0E7QUFDRCxFQU5EO0FBT0E7O0FBRUQsU0FBUzZpQyxNQUFULENBQWdCbUQsVUFBaEIsRUFBNEI7QUFDM0IsS0FBSUMsV0FBV0MsT0FBT0YsVUFBUCxDQUFmO0FBQ0FKLGdCQUFlLFVBQVNPLFNBQVQsRUFBb0I7QUFDbENBLFlBQVVLLGVBQVYsQ0FBMEJQLFFBQTFCO0FBQ0FFLFlBQVV6TCxJQUFWLENBQWVpTCxXQUFmO0FBQ0EsRUFIRDtBQUlBOztBQUVELFNBQVMxQyxRQUFULEdBQW9CO0FBQ25CMkMsZ0JBQWUsVUFBU08sU0FBVCxFQUFvQjtBQUNsQyxNQUFJanJDLGFBQWFpckMsVUFBVUcsV0FBVixDQUFzQmpHLGVBQXRCLENBQXNDbmxDLFVBQXZEO0FBQ0FpckMsWUFBVU0sSUFBVixDQUFlZCxXQUFmO0FBQ0EsT0FBSyxJQUFJdDlDLElBQUU2UyxXQUFXM1MsTUFBWCxHQUFrQixDQUE3QixFQUFnQ0YsS0FBRyxDQUFuQyxFQUFzQ0EsR0FBdEMsRUFBMkM7QUFDMUM4OUMsYUFBVUssZUFBVixDQUEwQnRyQyxXQUFXN1MsQ0FBWCxFQUFjMlgsSUFBeEM7QUFDQTtBQUNEbW1DLFlBQVV6TCxJQUFWLENBQWVpTCxXQUFmO0FBQ0EsRUFQRDtBQVFBOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSWUsc0JBQXNCLElBQUk1MkMsTUFBSixDQUFXLHVDQUFYLEVBQW9ELEdBQXBELENBQTFCO0FBQ0EsU0FBU28yQyxNQUFULENBQWdCejlDLEdBQWhCLEVBQXFCO0FBQ3BCLFFBQU9BLElBQUlXLE9BQUosQ0FBWSxLQUFaLEVBQW1CLE9BQW5CLEVBQTRCQSxPQUE1QixDQUFvQ3M5QyxtQkFBcEMsRUFBeUQsS0FBekQsQ0FBUDtBQUNBOztBQUVELFNBQVNiLHdCQUFULEdBQW9DO0FBQ25DLEtBQUksQ0FBQ2hILEdBQUQsSUFBUSxDQUFDQSxJQUFJd0IsZUFBYixJQUFnQyxDQUFDeEIsSUFBSXdCLGVBQUosQ0FBb0JzRyxXQUF6RCxFQUFzRTtBQUNyRSxTQUFPLElBQVA7QUFDQTtBQUNELEtBQUlDLFlBQVksUUFBaEI7QUFBQSxLQUNDQyxZQUREO0FBQUEsS0FFQ0MsZ0JBRkQ7QUFBQSxLQUdDWCxTQUhEOztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNIO0FBQ0FXLHFCQUFtQixJQUFJQyxhQUFKLENBQWtCLFVBQWxCLENBQW5CO0FBQ0FELG1CQUFpQjNRLElBQWpCO0FBQ0EyUSxtQkFBaUIzakMsS0FBakIsQ0FBdUIsTUFBSXlqQyxTQUFKLEdBQWMsc0JBQWQsR0FBcUNBLFNBQXJDLEdBQStDLHVDQUF0RTtBQUNBRSxtQkFBaUJFLEtBQWpCO0FBQ0FILGlCQUFlQyxpQkFBaUJ6SixDQUFqQixDQUFtQjRKLE1BQW5CLENBQTBCLENBQTFCLEVBQTZCLzNCLFFBQTVDO0FBQ0FpM0IsY0FBWVUsYUFBYXRhLGFBQWIsQ0FBMkIsS0FBM0IsQ0FBWjtBQUNBLEVBUkQsQ0FRRSxPQUFNNWxDLENBQU4sRUFBUztBQUNWO0FBQ0E7QUFDQXcvQyxjQUFZdEgsSUFBSXRTLGFBQUosQ0FBa0IsS0FBbEIsQ0FBWjtBQUNBc2EsaUJBQWVoSSxJQUFJeFcsSUFBbkI7QUFDQTs7QUFFRCxRQUFPLFVBQVM2ZSxhQUFULEVBQXdCO0FBQzlCLE1BQUkxNUMsT0FBTyxHQUFHaEcsS0FBSCxDQUFTMkIsSUFBVCxDQUFjYixTQUFkLEVBQXlCLENBQXpCLENBQVg7QUFDQWtGLE9BQUs0dUMsT0FBTCxDQUFhK0osU0FBYjtBQUNBO0FBQ0E7QUFDQVUsZUFBYXRHLFdBQWIsQ0FBeUI0RixTQUF6QjtBQUNBQSxZQUFVUSxXQUFWLENBQXNCLG1CQUF0QjtBQUNBUixZQUFVTSxJQUFWLENBQWVkLFdBQWY7QUFDQXVCLGdCQUFjcitDLEtBQWQsQ0FBb0IsSUFBcEIsRUFBMEIyRSxJQUExQjtBQUNBcTVDLGVBQWEvTSxXQUFiLENBQXlCcU0sU0FBekI7QUFDQTtBQUNBLEVBWEQ7QUFZQSxDOzs7Ozs7Ozs7QUM5SEQsSUFBSXJrQyxPQUFPLG1CQUFBcEgsQ0FBUSxDQUFSLENBQVg7QUFDQSxJQUFJclQsU0FBU3lhLEtBQUt6YSxNQUFsQjs7QUFFQVIsT0FBT0MsT0FBUCxHQUFpQjtBQUNoQmtaLE9BQU0sZ0JBRFU7QUFFaEJ1NkIsT0FBTUEsSUFGVTtBQUdoQnAzQixRQUFPQSxLQUhTO0FBSWhCMWIsT0FBTUEsSUFKVTtBQUtoQm83QyxTQUFRQSxNQUxRO0FBTWhCSSxXQUFVQTtBQU5NLENBQWpCOztBQVNBLFNBQVNrRSxjQUFULEdBQTBCO0FBQ3pCLFFBQU85L0MsT0FBTzgvQyxjQUFkO0FBQ0E7O0FBRUQsU0FBUzVNLElBQVQsQ0FBYzl4QyxHQUFkLEVBQW1CO0FBQ2xCLFFBQU8wK0MsaUJBQWlCN0IsT0FBakIsQ0FBeUI3OEMsR0FBekIsQ0FBUDtBQUNBOztBQUVELFNBQVMwYSxLQUFULENBQWUxYSxHQUFmLEVBQW9CK0osSUFBcEIsRUFBMEI7QUFDekIsUUFBTzIwQyxpQkFBaUI1QixPQUFqQixDQUF5Qjk4QyxHQUF6QixFQUE4QitKLElBQTlCLENBQVA7QUFDQTs7QUFFRCxTQUFTL0ssSUFBVCxDQUFjNEIsRUFBZCxFQUFrQjtBQUNqQixNQUFLLElBQUloQixJQUFJOCtDLGlCQUFpQjUrQyxNQUFqQixHQUEwQixDQUF2QyxFQUEwQ0YsS0FBSyxDQUEvQyxFQUFrREEsR0FBbEQsRUFBdUQ7QUFDdEQsTUFBSUksTUFBTTArQyxpQkFBaUIxK0MsR0FBakIsQ0FBcUJKLENBQXJCLENBQVY7QUFDQWdCLEtBQUdreEMsS0FBSzl4QyxHQUFMLENBQUgsRUFBY0EsR0FBZDtBQUNBO0FBQ0Q7O0FBRUQsU0FBU282QyxNQUFULENBQWdCcDZDLEdBQWhCLEVBQXFCO0FBQ3BCLFFBQU8wK0MsaUJBQWlCM0IsVUFBakIsQ0FBNEIvOEMsR0FBNUIsQ0FBUDtBQUNBOztBQUVELFNBQVN3NkMsUUFBVCxHQUFvQjtBQUNuQixRQUFPa0UsaUJBQWlCbDFDLEtBQWpCLEVBQVA7QUFDQSxDOzs7Ozs7Ozs7QUNyQ0QsSUFBSXBKLFFBQVFwQyxTQUFTdUMsU0FBVCxDQUFtQkgsS0FBL0I7O0FBRUE7O0FBRUEvQixRQUFRcVgsVUFBUixHQUFxQixZQUFXO0FBQzlCLFNBQU8sSUFBSWlwQyxPQUFKLENBQVl2K0MsTUFBTU0sSUFBTixDQUFXZ1YsVUFBWCxFQUF1QnZYLE1BQXZCLEVBQStCMEIsU0FBL0IsQ0FBWixFQUF1RDhWLFlBQXZELENBQVA7QUFDRCxDQUZEO0FBR0F0WCxRQUFRdWdELFdBQVIsR0FBc0IsWUFBVztBQUMvQixTQUFPLElBQUlELE9BQUosQ0FBWXYrQyxNQUFNTSxJQUFOLENBQVdrK0MsV0FBWCxFQUF3QnpnRCxNQUF4QixFQUFnQzBCLFNBQWhDLENBQVosRUFBd0RnL0MsYUFBeEQsQ0FBUDtBQUNELENBRkQ7QUFHQXhnRCxRQUFRc1gsWUFBUixHQUNBdFgsUUFBUXdnRCxhQUFSLEdBQXdCLFVBQVN2b0MsT0FBVCxFQUFrQjtBQUN4QyxNQUFJQSxPQUFKLEVBQWE7QUFDWEEsWUFBUWlvQyxLQUFSO0FBQ0Q7QUFDRixDQUxEOztBQU9BLFNBQVNJLE9BQVQsQ0FBaUI1UixFQUFqQixFQUFxQitSLE9BQXJCLEVBQThCO0FBQzVCLE9BQUs5UixHQUFMLEdBQVdELEVBQVg7QUFDQSxPQUFLZ1MsUUFBTCxHQUFnQkQsT0FBaEI7QUFDRDtBQUNESCxRQUFRcCtDLFNBQVIsQ0FBa0J5K0MsS0FBbEIsR0FBMEJMLFFBQVFwK0MsU0FBUixDQUFrQjArQyxHQUFsQixHQUF3QixZQUFXLENBQUUsQ0FBL0Q7QUFDQU4sUUFBUXArQyxTQUFSLENBQWtCZytDLEtBQWxCLEdBQTBCLFlBQVc7QUFDbkMsT0FBS1EsUUFBTCxDQUFjcitDLElBQWQsQ0FBbUJ2QyxNQUFuQixFQUEyQixLQUFLNnVDLEdBQWhDO0FBQ0QsQ0FGRDs7QUFJQTtBQUNBM3VDLFFBQVE2Z0QsTUFBUixHQUFpQixVQUFTdDlCLElBQVQsRUFBZXU5QixLQUFmLEVBQXNCO0FBQ3JDeHBDLGVBQWFpTSxLQUFLdzlCLGNBQWxCO0FBQ0F4OUIsT0FBS3k5QixZQUFMLEdBQW9CRixLQUFwQjtBQUNELENBSEQ7O0FBS0E5Z0QsUUFBUWloRCxRQUFSLEdBQW1CLFVBQVMxOUIsSUFBVCxFQUFlO0FBQ2hDak0sZUFBYWlNLEtBQUt3OUIsY0FBbEI7QUFDQXg5QixPQUFLeTlCLFlBQUwsR0FBb0IsQ0FBQyxDQUFyQjtBQUNELENBSEQ7O0FBS0FoaEQsUUFBUWtoRCxZQUFSLEdBQXVCbGhELFFBQVFtaEQsTUFBUixHQUFpQixVQUFTNTlCLElBQVQsRUFBZTtBQUNyRGpNLGVBQWFpTSxLQUFLdzlCLGNBQWxCOztBQUVBLE1BQUlELFFBQVF2OUIsS0FBS3k5QixZQUFqQjtBQUNBLE1BQUlGLFNBQVMsQ0FBYixFQUFnQjtBQUNkdjlCLFNBQUt3OUIsY0FBTCxHQUFzQjFwQyxXQUFXLFNBQVMrcEMsU0FBVCxHQUFxQjtBQUNwRCxVQUFJNzlCLEtBQUs4OUIsVUFBVCxFQUNFOTlCLEtBQUs4OUIsVUFBTDtBQUNILEtBSHFCLEVBR25CUCxLQUhtQixDQUF0QjtBQUlEO0FBQ0YsQ0FWRDs7QUFZQTtBQUNBLG1CQUFBbHRDLENBQVEsRUFBUjtBQUNBNVQsUUFBUWlsQyxZQUFSLEdBQXVCQSxZQUF2QjtBQUNBamxDLFFBQVFrNEMsY0FBUixHQUF5QkEsY0FBekIsQzs7Ozs7Ozs7Ozs7QUNwREE7Ozs7Ozs7OztBQVNBLENBQUMsVUFBU2w0QyxPQUFULEVBQWtCRCxNQUFsQixFQUEwQjhaLE1BQTFCLEVBQWtDO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxNQUFJMUYsV0FBVyxTQUFYQSxRQUFXLENBQVNDLFVBQVQsRUFBcUJDLFdBQXJCLEVBQWtDTCxPQUFsQyxFQUEyQztBQUN4REEsY0FBVXBSLEVBQUUwK0MsTUFBRixDQUFTLEVBQVQsRUFBYTErQyxFQUFFb1IsT0FBZixFQUF3QkEsT0FBeEIsQ0FBVjs7QUFFQSxRQUFJdXRDLFVBQVUzK0MsRUFBRTQrQyxjQUFGLENBQWlCcHRDLFVBQWpCLEVBQTZCQyxXQUE3QixFQUEwQ0wsT0FBMUMsQ0FBZDtBQUFBLFFBQ0l5ckMsSUFESjtBQUFBLFFBRUlnQyxTQUZKOztBQUlBLFNBQUtoQyxJQUFMLElBQWE4QixPQUFiLEVBQXNCO0FBQ3BCLFdBQUtFLFNBQUwsSUFBa0JGLFFBQVE5QixJQUFSLENBQWxCLEVBQWlDO0FBQy9CLFlBQUk3OEMsRUFBRTg2QixTQUFGLENBQVk2akIsUUFBUTlCLElBQVIsRUFBY2dDLFNBQWQsQ0FBWixDQUFKLEVBQTJDO0FBQ3pDLGdCQUFNLElBQUl0cUMsS0FBSixDQUFVLHFEQUFWLENBQU47QUFDRDtBQUNGO0FBQ0Y7QUFDRCxXQUFPaEQsU0FBU3V0Qyx3QkFBVCxDQUFrQ0gsT0FBbEMsRUFBMkN2dEMsT0FBM0MsQ0FBUDtBQUNELEdBZkQ7O0FBaUJBLE1BQUlwUixJQUFJdVIsUUFBUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBdlIsSUFBRTArQyxNQUFGLEdBQVcsVUFBU25nRCxHQUFULEVBQWM7QUFDdkIsT0FBR1QsS0FBSCxDQUFTMkIsSUFBVCxDQUFjYixTQUFkLEVBQXlCLENBQXpCLEVBQTRCc0csT0FBNUIsQ0FBb0MsVUFBU29HLE1BQVQsRUFBaUI7QUFDbkQsV0FBSyxJQUFJdXhDLElBQVQsSUFBaUJ2eEMsTUFBakIsRUFBeUI7QUFDdkIvTSxZQUFJcytDLElBQUosSUFBWXZ4QyxPQUFPdXhDLElBQVAsQ0FBWjtBQUNEO0FBQ0YsS0FKRDtBQUtBLFdBQU90K0MsR0FBUDtBQUNELEdBUEQ7O0FBU0F5QixJQUFFMCtDLE1BQUYsQ0FBU250QyxRQUFULEVBQW1CO0FBQ2pCO0FBQ0E7QUFDQXVFLGFBQVM7QUFDUGlwQyxhQUFPLENBREE7QUFFUEMsYUFBTyxFQUZBO0FBR1BDLGFBQU8sQ0FIQTtBQUlQQyxnQkFBVSxJQUpIO0FBS1AvK0MsZ0JBQVUsb0JBQVc7QUFDbkIsWUFBSTJWLFVBQVU5VixFQUFFbS9DLE1BQUYsQ0FBUyw0QkFBVCxFQUF1Q24vQyxFQUFFOFYsT0FBekMsQ0FBZDtBQUNBLFlBQUksQ0FBQzlWLEVBQUVvL0MsT0FBRixDQUFVcC9DLEVBQUU4VixPQUFGLENBQVVvcEMsUUFBcEIsQ0FBTCxFQUFvQztBQUNsQ3BwQyxxQkFBVyxNQUFNOVYsRUFBRThWLE9BQUYsQ0FBVW9wQyxRQUEzQjtBQUNEO0FBQ0QsZUFBT3BwQyxPQUFQO0FBQ0Q7QUFYTSxLQUhROztBQWlCakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQXRPLGFBQVMsT0FBT0EsT0FBUCxLQUFtQixXQUFuQixHQUFpQ0EsT0FBakMsR0FBMkMsMEJBQTJCLElBdkI5RDs7QUF5QmpCNjNDLHlCQUFxQixPQXpCSjs7QUEyQmpCO0FBQ0E7QUFDQTtBQUNBVCxvQkFBZ0Isd0JBQVNwdEMsVUFBVCxFQUFxQkMsV0FBckIsRUFBa0NMLE9BQWxDLEVBQTJDO0FBQ3pELFVBQUl1dEMsVUFBVSxFQUFkO0FBQUEsVUFDSTlCLElBREo7QUFBQSxVQUVJeUMsYUFGSjtBQUFBLFVBR0k1N0MsS0FISjtBQUFBLFVBSUl1TixVQUpKO0FBQUEsVUFLSTR0QyxTQUxKO0FBQUEsVUFNSVUsZ0JBTko7QUFBQSxVQU9JMXRDLEtBUEo7O0FBU0EsVUFBSTdSLEVBQUV3L0MsWUFBRixDQUFlaHVDLFVBQWYsS0FBOEJ4UixFQUFFeS9DLGVBQUYsQ0FBa0JqdUMsVUFBbEIsQ0FBbEMsRUFBaUU7QUFDL0RBLHFCQUFheFIsRUFBRTAvQyxpQkFBRixDQUFvQmx1QyxVQUFwQixDQUFiO0FBQ0Q7O0FBRUQ7QUFDQSxXQUFLcXJDLElBQUwsSUFBYXByQyxXQUFiLEVBQTBCO0FBQ3hCL04sZ0JBQVExRCxFQUFFMi9DLGtCQUFGLENBQXFCbnVDLFVBQXJCLEVBQWlDcXJDLElBQWpDLENBQVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E1ckMscUJBQWFqUixFQUFFMEUsTUFBRixDQUFTK00sWUFBWW9yQyxJQUFaLENBQVQsRUFBNEJuNUMsS0FBNUIsRUFBbUM4TixVQUFuQyxFQUErQ3FyQyxJQUEvQyxFQUFxRHpyQyxPQUFyRCxFQUE4REssV0FBOUQsQ0FBYjs7QUFFQSxhQUFLNnRDLGFBQUwsSUFBc0JydUMsVUFBdEIsRUFBa0M7QUFDaEM0dEMsc0JBQVk3K0MsRUFBRWlSLFVBQUYsQ0FBYXF1QyxhQUFiLENBQVo7O0FBRUEsY0FBSSxDQUFDVCxTQUFMLEVBQWdCO0FBQ2RodEMsb0JBQVE3UixFQUFFbS9DLE1BQUYsQ0FBUywyQkFBVCxFQUFzQyxFQUFDN29DLE1BQU1ncEMsYUFBUCxFQUF0QyxDQUFSO0FBQ0Esa0JBQU0sSUFBSS9xQyxLQUFKLENBQVUxQyxLQUFWLENBQU47QUFDRDs7QUFFRDB0Qyw2QkFBbUJ0dUMsV0FBV3F1QyxhQUFYLENBQW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBQyw2QkFBbUJ2L0MsRUFBRTBFLE1BQUYsQ0FBUzY2QyxnQkFBVCxFQUEyQjc3QyxLQUEzQixFQUFrQzhOLFVBQWxDLEVBQThDcXJDLElBQTlDLEVBQW9EenJDLE9BQXBELEVBQTZESyxXQUE3RCxDQUFuQjtBQUNBLGNBQUksQ0FBQzh0QyxnQkFBTCxFQUF1QjtBQUNyQjtBQUNEO0FBQ0RaLGtCQUFRaDFDLElBQVIsQ0FBYTtBQUNYaTJDLHVCQUFXL0MsSUFEQTtBQUVYbjVDLG1CQUFPQSxLQUZJO0FBR1htN0MsdUJBQVdTLGFBSEE7QUFJWE8sMkJBQWV6dUMsT0FKSjtBQUtYSSx3QkFBWUEsVUFMRDtBQU1YSixxQkFBU211QyxnQkFORTtBQU9YMXRDLG1CQUFPZ3RDLFVBQVVwL0MsSUFBVixDQUFlby9DLFNBQWYsRUFDSG43QyxLQURHLEVBRUg2N0MsZ0JBRkcsRUFHSDFDLElBSEcsRUFJSHJyQyxVQUpHLEVBS0hKLE9BTEc7QUFQSSxXQUFiO0FBY0Q7QUFDRjs7QUFFRCxhQUFPdXRDLE9BQVA7QUFDRCxLQTFGZ0I7O0FBNEZqQjtBQUNBO0FBQ0FHLDhCQUEwQixrQ0FBU3J0QixNQUFULEVBQWlCcmdCLE9BQWpCLEVBQTBCO0FBQ2xEcWdCLGVBQVN6eEIsRUFBRTgvQyxnQkFBRixDQUFtQnJ1QixNQUFuQixFQUEyQnJnQixPQUEzQixDQUFUO0FBQ0FxZ0IsZUFBU3p4QixFQUFFKy9DLG9CQUFGLENBQXVCdHVCLE1BQXZCLEVBQStCcmdCLE9BQS9CLENBQVQ7QUFDQXFnQixlQUFTenhCLEVBQUVnZ0Qsb0JBQUYsQ0FBdUJ2dUIsTUFBdkIsRUFBK0JyZ0IsT0FBL0IsQ0FBVDs7QUFFQSxVQUFJK3RDLFNBQVMvdEMsUUFBUSt0QyxNQUFSLElBQWtCLFNBQS9COztBQUVBLFVBQUksT0FBT24vQyxFQUFFaWdELFVBQUYsQ0FBYWQsTUFBYixDQUFQLEtBQWdDLFVBQXBDLEVBQWdEO0FBQzlDMXRCLGlCQUFTenhCLEVBQUVpZ0QsVUFBRixDQUFhZCxNQUFiLEVBQXFCMXRCLE1BQXJCLENBQVQ7QUFDRCxPQUZELE1BRU87QUFDTCxjQUFNLElBQUlsZCxLQUFKLENBQVV2VSxFQUFFbS9DLE1BQUYsQ0FBUywwQkFBVCxFQUFxQy90QyxPQUFyQyxDQUFWLENBQU47QUFDRDs7QUFFRCxhQUFPcFIsRUFBRW8vQyxPQUFGLENBQVUzdEIsTUFBVixJQUFvQjNzQixTQUFwQixHQUFnQzJzQixNQUF2QztBQUNELEtBNUdnQjs7QUE4R2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0F6VCxXQUFPLGVBQVN4TSxVQUFULEVBQXFCQyxXQUFyQixFQUFrQ0wsT0FBbEMsRUFBMkM7QUFDaERBLGdCQUFVcFIsRUFBRTArQyxNQUFGLENBQVMsRUFBVCxFQUFhMStDLEVBQUVnZSxLQUFGLENBQVE1TSxPQUFyQixFQUE4QkEsT0FBOUIsQ0FBVjs7QUFFQSxVQUFJOHVDLGFBQWE5dUMsUUFBUSt1QyxVQUFSLElBQXNCLFVBQVMxdUIsTUFBVCxFQUFpQjtBQUN0RCxlQUFPQSxNQUFQO0FBQ0QsT0FGRDs7QUFJQTtBQUNBLFVBQUlyZ0IsUUFBUWd2QyxlQUFSLEtBQTRCLEtBQWhDLEVBQXVDO0FBQ3JDNXVDLHFCQUFheFIsRUFBRW9nRCxlQUFGLENBQWtCNXVDLFVBQWxCLEVBQThCQyxXQUE5QixDQUFiO0FBQ0Q7O0FBRUQsVUFBSWt0QyxVQUFVMytDLEVBQUU0K0MsY0FBRixDQUFpQnB0QyxVQUFqQixFQUE2QkMsV0FBN0IsRUFBMENMLE9BQTFDLENBQWQ7O0FBRUEsYUFBTyxJQUFJcFIsRUFBRXdILE9BQU4sQ0FBYyxVQUFTNkksT0FBVCxFQUFrQnNCLE1BQWxCLEVBQTBCO0FBQzdDM1IsVUFBRXFnRCxjQUFGLENBQWlCMUIsT0FBakIsRUFBMEIxcUMsSUFBMUIsQ0FBK0IsWUFBVztBQUN4QyxjQUFJd2QsU0FBU3p4QixFQUFFOCtDLHdCQUFGLENBQTJCSCxPQUEzQixFQUFvQ3Z0QyxPQUFwQyxDQUFiO0FBQ0EsY0FBSXFnQixNQUFKLEVBQVk7QUFDVjlmLG1CQUFPLElBQUl1dUMsVUFBSixDQUFlenVCLE1BQWYsRUFBdUJyZ0IsT0FBdkIsRUFBZ0NJLFVBQWhDLEVBQTRDQyxXQUE1QyxDQUFQO0FBQ0QsV0FGRCxNQUVPO0FBQ0xwQixvQkFBUW1CLFVBQVI7QUFDRDtBQUNGLFNBUEQsRUFPRyxVQUFTc2IsR0FBVCxFQUFjO0FBQ2ZuYixpQkFBT21iLEdBQVA7QUFDRCxTQVREO0FBVUQsT0FYTSxDQUFQO0FBWUQsS0E1SWdCOztBQThJakJ3ekIsWUFBUSxnQkFBUzU4QyxLQUFULEVBQWdCK04sV0FBaEIsRUFBNkJMLE9BQTdCLEVBQXNDO0FBQzVDQSxnQkFBVXBSLEVBQUUwK0MsTUFBRixDQUFTLEVBQVQsRUFBYTErQyxFQUFFc2dELE1BQUYsQ0FBU2x2QyxPQUF0QixFQUErQkEsT0FBL0IsRUFBd0M7QUFDaEQrdEMsZ0JBQVEsTUFEd0M7QUFFaERvQixzQkFBYztBQUZrQyxPQUF4QyxDQUFWO0FBSUEsYUFBT3ZnRCxFQUFFLEVBQUNzZ0QsUUFBUTU4QyxLQUFULEVBQUYsRUFBbUIsRUFBQzQ4QyxRQUFRN3VDLFdBQVQsRUFBbkIsRUFBMENMLE9BQTFDLENBQVA7QUFDRCxLQXBKZ0I7O0FBc0pqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0FpdkMsb0JBQWdCLHdCQUFTMUIsT0FBVCxFQUFrQjtBQUNoQztBQUNBLGFBQU9BLFFBQVE5d0IsTUFBUixDQUFlLFVBQVMyeUIsSUFBVCxFQUFlOTdDLE1BQWYsRUFBdUI7QUFDM0M7QUFDQSxZQUFJLENBQUMxRSxFQUFFODZCLFNBQUYsQ0FBWXAyQixPQUFPbU4sS0FBbkIsQ0FBTCxFQUFnQztBQUM5QixpQkFBTzJ1QyxJQUFQO0FBQ0Q7O0FBRUQsZUFBT0EsS0FBS3ZzQyxJQUFMLENBQVUsWUFBVztBQUMxQixpQkFBT3ZQLE9BQU9tTixLQUFQLENBQWFvQyxJQUFiLENBQWtCLFVBQVNwQyxLQUFULEVBQWdCO0FBQ3ZDbk4sbUJBQU9tTixLQUFQLEdBQWVBLFNBQVMsSUFBeEI7QUFDRCxXQUZNLENBQVA7QUFHRCxTQUpNLENBQVA7QUFLRCxPQVhNLEVBV0osSUFBSTdSLEVBQUV3SCxPQUFOLENBQWMsVUFBUzJQLENBQVQsRUFBWTtBQUFFQTtBQUFNLE9BQWxDLENBWEksQ0FBUCxDQUZnQyxDQWFTO0FBQzFDLEtBektnQjs7QUEyS2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQXpTLFlBQVEsZ0JBQVNoQixLQUFULEVBQWdCO0FBQ3RCLFVBQUlJLE9BQU8sR0FBR2hHLEtBQUgsQ0FBUzJCLElBQVQsQ0FBY2IsU0FBZCxFQUF5QixDQUF6QixDQUFYO0FBQ0EsVUFBSSxPQUFPOEUsS0FBUCxLQUFpQixVQUFyQixFQUFpQztBQUMvQkEsZ0JBQVFBLE1BQU12RSxLQUFOLENBQVksSUFBWixFQUFrQjJFLElBQWxCLENBQVI7QUFDRDtBQUNELGFBQU9KLEtBQVA7QUFDRCxLQXpMZ0I7O0FBMkxqQjtBQUNBO0FBQ0ErOEMsY0FBVSxrQkFBUy84QyxLQUFULEVBQWdCO0FBQ3hCLGFBQU8sT0FBT0EsS0FBUCxLQUFpQixRQUFqQixJQUE2QixDQUFDNHZDLE1BQU01dkMsS0FBTixDQUFyQztBQUNELEtBL0xnQjs7QUFpTWpCO0FBQ0F2RixnQkFBWSxvQkFBU3VGLEtBQVQsRUFBZ0I7QUFDMUIsYUFBTyxPQUFPQSxLQUFQLEtBQWlCLFVBQXhCO0FBQ0QsS0FwTWdCOztBQXNNakI7QUFDQTtBQUNBZzlDLGVBQVcsbUJBQVNoOUMsS0FBVCxFQUFnQjtBQUN6QixhQUFPMUQsRUFBRXlnRCxRQUFGLENBQVcvOEMsS0FBWCxLQUFxQkEsUUFBUSxDQUFSLEtBQWMsQ0FBMUM7QUFDRCxLQTFNZ0I7O0FBNE1qQjtBQUNBaTlDLGVBQVcsbUJBQVNqOUMsS0FBVCxFQUFnQjtBQUN6QixhQUFPLE9BQU9BLEtBQVAsS0FBaUIsU0FBeEI7QUFDRCxLQS9NZ0I7O0FBaU5qQjtBQUNBdEYsY0FBVSxrQkFBU0csR0FBVCxFQUFjO0FBQ3RCLGFBQU9BLFFBQVFGLE9BQU9FLEdBQVAsQ0FBZjtBQUNELEtBcE5nQjs7QUFzTmpCO0FBQ0FxaUQsWUFBUSxnQkFBU3JpRCxHQUFULEVBQWM7QUFDcEIsYUFBT0EsZUFBZWk1QyxJQUF0QjtBQUNELEtBek5nQjs7QUEyTmpCO0FBQ0FxSixlQUFXLG1CQUFTdGlELEdBQVQsRUFBYztBQUN2QixhQUFPQSxRQUFRLElBQVIsSUFBZ0JBLFFBQVF1RyxTQUEvQjtBQUNELEtBOU5nQjs7QUFnT2pCO0FBQ0E7QUFDQWcyQixlQUFXLG1CQUFTWSxDQUFULEVBQVk7QUFDckIsYUFBTyxDQUFDLENBQUNBLENBQUYsSUFBTzE3QixFQUFFN0IsVUFBRixDQUFhdTlCLEVBQUV6bkIsSUFBZixDQUFkO0FBQ0QsS0FwT2dCOztBQXNPakJ3ckMscUJBQWlCLHlCQUFTOXJDLENBQVQsRUFBWTtBQUMzQixhQUFPQSxLQUFLM1QsRUFBRThnRCxRQUFGLENBQVdudEMsRUFBRW90QyxNQUFiLENBQVo7QUFDRCxLQXhPZ0I7O0FBME9qQnZCLGtCQUFjLHNCQUFTN3JDLENBQVQsRUFBWTtBQUN4QixVQUFJLENBQUNBLENBQUwsRUFBUTtBQUNOLGVBQU8sS0FBUDtBQUNEOztBQUVELFVBQUksQ0FBQ0EsRUFBRXF0QyxnQkFBSCxJQUF1QixDQUFDcnRDLEVBQUVzdEMsYUFBOUIsRUFBNkM7QUFDM0MsZUFBTyxLQUFQO0FBQ0Q7O0FBRUQsVUFBSWpoRCxFQUFFNUIsUUFBRixDQUFXb25CLFFBQVgsS0FBd0I3UixNQUFNNlIsUUFBbEMsRUFBNEM7QUFDMUMsZUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLFVBQUksUUFBTzA3QixXQUFQLHlDQUFPQSxXQUFQLE9BQXVCLFFBQTNCLEVBQXFDO0FBQ25DLGVBQU92dEMsYUFBYXV0QyxXQUFwQjtBQUNELE9BRkQsTUFFTztBQUNMLGVBQU92dEMsS0FDTCxRQUFPQSxDQUFQLHlDQUFPQSxDQUFQLE9BQWEsUUFEUixJQUVMQSxNQUFNLElBRkQsSUFHTEEsRUFBRTlRLFFBQUYsS0FBZSxDQUhWLElBSUwsT0FBTzhRLEVBQUV3dEMsUUFBVCxLQUFzQixRQUp4QjtBQUtEO0FBQ0YsS0FsUWdCOztBQW9RakIvQixhQUFTLGlCQUFTMTdDLEtBQVQsRUFBZ0I7QUFDdkIsVUFBSW01QyxJQUFKOztBQUVBO0FBQ0EsVUFBSSxDQUFDNzhDLEVBQUU2Z0QsU0FBRixDQUFZbjlDLEtBQVosQ0FBTCxFQUF5QjtBQUN2QixlQUFPLElBQVA7QUFDRDs7QUFFRDtBQUNBLFVBQUkxRCxFQUFFN0IsVUFBRixDQUFhdUYsS0FBYixDQUFKLEVBQXlCO0FBQ3ZCLGVBQU8sS0FBUDtBQUNEOztBQUVEO0FBQ0EsVUFBSTFELEVBQUU4Z0QsUUFBRixDQUFXcDlDLEtBQVgsQ0FBSixFQUF1QjtBQUNyQixlQUFPMUQsRUFBRXEvQyxtQkFBRixDQUFzQmp5QyxJQUF0QixDQUEyQjFKLEtBQTNCLENBQVA7QUFDRDs7QUFFRDtBQUNBLFVBQUkxRCxFQUFFNkssT0FBRixDQUFVbkgsS0FBVixDQUFKLEVBQXNCO0FBQ3BCLGVBQU9BLE1BQU03RSxNQUFOLEtBQWlCLENBQXhCO0FBQ0Q7O0FBRUQ7QUFDQSxVQUFJbUIsRUFBRTRnRCxNQUFGLENBQVNsOUMsS0FBVCxDQUFKLEVBQXFCO0FBQ25CLGVBQU8sS0FBUDtBQUNEOztBQUVEO0FBQ0EsVUFBSTFELEVBQUU1QixRQUFGLENBQVdzRixLQUFYLENBQUosRUFBdUI7QUFDckIsYUFBS201QyxJQUFMLElBQWFuNUMsS0FBYixFQUFvQjtBQUNsQixpQkFBTyxLQUFQO0FBQ0Q7QUFDRCxlQUFPLElBQVA7QUFDRDs7QUFFRCxhQUFPLEtBQVA7QUFDRCxLQXpTZ0I7O0FBMlNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBeTdDLFlBQVFuL0MsRUFBRTArQyxNQUFGLENBQVMsVUFBU2wvQyxHQUFULEVBQWM0aEQsSUFBZCxFQUFvQjtBQUNuQyxVQUFJLENBQUNwaEQsRUFBRThnRCxRQUFGLENBQVd0aEQsR0FBWCxDQUFMLEVBQXNCO0FBQ3BCLGVBQU9BLEdBQVA7QUFDRDtBQUNELGFBQU9BLElBQUlFLE9BQUosQ0FBWU0sRUFBRW0vQyxNQUFGLENBQVNrQyxhQUFyQixFQUFvQyxVQUFTQyxFQUFULEVBQWFDLEVBQWIsRUFBaUJDLEVBQWpCLEVBQXFCO0FBQzlELFlBQUlELE9BQU8sR0FBWCxFQUFnQjtBQUNkLGlCQUFPLE9BQU9DLEVBQVAsR0FBWSxHQUFuQjtBQUNELFNBRkQsTUFFTztBQUNMLGlCQUFPamlELE9BQU82aEQsS0FBS0ksRUFBTCxDQUFQLENBQVA7QUFDRDtBQUNGLE9BTk0sQ0FBUDtBQU9ELEtBWE8sRUFXTDtBQUNEO0FBQ0FILHFCQUFlO0FBRmQsS0FYSyxDQWxUUzs7QUFrVWpCO0FBQ0E7QUFDQTtBQUNBSSxjQUFVLGtCQUFTamlELEdBQVQsRUFBYztBQUN0QixVQUFJUSxFQUFFeWdELFFBQUYsQ0FBV2poRCxHQUFYLENBQUosRUFBcUI7QUFDbkI7QUFDQSxZQUFLQSxNQUFNLEdBQVAsR0FBYyxDQUFkLEtBQW9CLENBQXhCLEVBQTJCO0FBQ3pCLGlCQUFPLEtBQUtBLEdBQVo7QUFDRCxTQUZELE1BRU87QUFDTCxpQkFBT2tpRCxXQUFXdjZDLEtBQUt3NkMsS0FBTCxDQUFXbmlELE1BQU0sR0FBakIsSUFBd0IsR0FBbkMsRUFBd0NvaUQsT0FBeEMsQ0FBZ0QsQ0FBaEQsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsVUFBSTVoRCxFQUFFNkssT0FBRixDQUFVckwsR0FBVixDQUFKLEVBQW9CO0FBQ2xCLGVBQU9BLElBQUl4QixHQUFKLENBQVEsVUFBU29aLENBQVQsRUFBWTtBQUFFLGlCQUFPcFgsRUFBRXloRCxRQUFGLENBQVdycUMsQ0FBWCxDQUFQO0FBQXVCLFNBQTdDLEVBQStDb1IsSUFBL0MsQ0FBb0QsSUFBcEQsQ0FBUDtBQUNEOztBQUVELFVBQUl4b0IsRUFBRTVCLFFBQUYsQ0FBV29CLEdBQVgsQ0FBSixFQUFxQjtBQUNuQixlQUFPQSxJQUFJVyxRQUFKLEVBQVA7QUFDRDs7QUFFRDtBQUNBWCxZQUFNLEtBQUtBLEdBQVg7O0FBRUEsYUFBT0E7QUFDTDtBQURLLE9BRUpFLE9BRkksQ0FFSSxtQkFGSixFQUV5QixPQUZ6QjtBQUdMO0FBSEssT0FJSkEsT0FKSSxDQUlJLE1BSkosRUFJWSxFQUpaO0FBS0w7QUFMSyxPQU1KQSxPQU5JLENBTUksT0FOSixFQU1hLEdBTmI7QUFPTDtBQVBLLE9BUUpBLE9BUkksQ0FRSSxpQkFSSixFQVF1QixVQUFTNGhELEVBQVQsRUFBYUMsRUFBYixFQUFpQkMsRUFBakIsRUFBcUI7QUFDL0MsZUFBTyxLQUFLRCxFQUFMLEdBQVUsR0FBVixHQUFnQkMsR0FBR3A4QixXQUFILEVBQXZCO0FBQ0QsT0FWSSxFQVdKQSxXQVhJLEVBQVA7QUFZRCxLQXRXZ0I7O0FBd1dqQnk4QixvQkFBZ0Isd0JBQVNuK0MsS0FBVCxFQUFnQjtBQUM5QixhQUFPMUQsRUFBRXloRCxRQUFGLENBQVcvOUMsS0FBWCxDQUFQO0FBQ0QsS0ExV2dCOztBQTRXakJvOUMsY0FBVSxrQkFBU3A5QyxLQUFULEVBQWdCO0FBQ3hCLGFBQU8sT0FBT0EsS0FBUCxLQUFpQixRQUF4QjtBQUNELEtBOVdnQjs7QUFnWGpCbUgsYUFBUyxpQkFBU25ILEtBQVQsRUFBZ0I7QUFDdkIsYUFBTyxHQUFHdkQsUUFBSCxDQUFZVixJQUFaLENBQWlCaUUsS0FBakIsTUFBNEIsZ0JBQW5DO0FBQ0QsS0FsWGdCOztBQW9YakI7QUFDQTtBQUNBbytDLFlBQVEsZ0JBQVNwK0MsS0FBVCxFQUFnQjtBQUN0QixhQUFPMUQsRUFBRTVCLFFBQUYsQ0FBV3NGLEtBQVgsS0FBcUIsQ0FBQzFELEVBQUU2SyxPQUFGLENBQVVuSCxLQUFWLENBQXRCLElBQTBDLENBQUMxRCxFQUFFN0IsVUFBRixDQUFhdUYsS0FBYixDQUFsRDtBQUNELEtBeFhnQjs7QUEwWGpCK3ZDLGNBQVUsa0JBQVNsMUMsR0FBVCxFQUFjbUYsS0FBZCxFQUFxQjtBQUM3QixVQUFJLENBQUMxRCxFQUFFNmdELFNBQUYsQ0FBWXRpRCxHQUFaLENBQUwsRUFBdUI7QUFDckIsZUFBTyxLQUFQO0FBQ0Q7QUFDRCxVQUFJeUIsRUFBRTZLLE9BQUYsQ0FBVXRNLEdBQVYsQ0FBSixFQUFvQjtBQUNsQixlQUFPQSxJQUFJd3VCLE9BQUosQ0FBWXJwQixLQUFaLE1BQXVCLENBQUMsQ0FBL0I7QUFDRDtBQUNELGFBQU9BLFNBQVNuRixHQUFoQjtBQUNELEtBbFlnQjs7QUFvWWpCd2pELFlBQVEsZ0JBQVMvOUMsS0FBVCxFQUFnQjtBQUN0QixVQUFJLENBQUNoRSxFQUFFNkssT0FBRixDQUFVN0csS0FBVixDQUFMLEVBQXVCO0FBQ3JCLGVBQU9BLEtBQVA7QUFDRDtBQUNELGFBQU9BLE1BQU1zc0IsTUFBTixDQUFhLFVBQVMweEIsRUFBVCxFQUFhbGlELEtBQWIsRUFBb0JrRSxLQUFwQixFQUEyQjtBQUM3QyxlQUFPQSxNQUFNK29CLE9BQU4sQ0FBY2kxQixFQUFkLEtBQXFCbGlELEtBQTVCO0FBQ0QsT0FGTSxDQUFQO0FBR0QsS0EzWWdCOztBQTZZakJtaUQseUJBQXFCLDZCQUFTcDlDLE1BQVQsRUFBaUJxOUMsT0FBakIsRUFBMEI3dkMsUUFBMUIsRUFBb0M7QUFDdkQsVUFBSSxDQUFDclMsRUFBRThnRCxRQUFGLENBQVdvQixPQUFYLENBQUwsRUFBMEI7QUFDeEIsZUFBT3A5QyxTQUFQO0FBQ0Q7O0FBRUQsVUFBSS9GLE1BQU0sRUFBVjtBQUFBLFVBQ0lKLENBREo7QUFBQSxVQUVJMjhDLFNBQVMsS0FGYjs7QUFJQSxXQUFLMzhDLElBQUksQ0FBVCxFQUFZQSxJQUFJdWpELFFBQVFyakQsTUFBeEIsRUFBZ0MsRUFBRUYsQ0FBbEMsRUFBcUM7QUFDbkMsZ0JBQVF1akQsUUFBUXZqRCxDQUFSLENBQVI7QUFDRSxlQUFLLEdBQUw7QUFDRSxnQkFBSTI4QyxNQUFKLEVBQVk7QUFDVkEsdUJBQVMsS0FBVDtBQUNBdjhDLHFCQUFPLEdBQVA7QUFDRCxhQUhELE1BR087QUFDTDhGLHVCQUFTd04sU0FBU3hOLE1BQVQsRUFBaUI5RixHQUFqQixFQUFzQixLQUF0QixDQUFUO0FBQ0FBLG9CQUFNLEVBQU47QUFDRDtBQUNEOztBQUVGLGVBQUssSUFBTDtBQUNFLGdCQUFJdThDLE1BQUosRUFBWTtBQUNWQSx1QkFBUyxLQUFUO0FBQ0F2OEMscUJBQU8sSUFBUDtBQUNELGFBSEQsTUFHTztBQUNMdThDLHVCQUFTLElBQVQ7QUFDRDtBQUNEOztBQUVGO0FBQ0VBLHFCQUFTLEtBQVQ7QUFDQXY4QyxtQkFBT21qRCxRQUFRdmpELENBQVIsQ0FBUDtBQUNBO0FBdkJKO0FBeUJEOztBQUVELGFBQU8wVCxTQUFTeE4sTUFBVCxFQUFpQjlGLEdBQWpCLEVBQXNCLElBQXRCLENBQVA7QUFDRCxLQW5iZ0I7O0FBcWJqQjRnRCx3QkFBb0IsNEJBQVNwaEQsR0FBVCxFQUFjMmpELE9BQWQsRUFBdUI7QUFDekMsVUFBSSxDQUFDbGlELEVBQUU1QixRQUFGLENBQVdHLEdBQVgsQ0FBTCxFQUFzQjtBQUNwQixlQUFPdUcsU0FBUDtBQUNEOztBQUVELGFBQU85RSxFQUFFaWlELG1CQUFGLENBQXNCMWpELEdBQXRCLEVBQTJCMmpELE9BQTNCLEVBQW9DLFVBQVMzakQsR0FBVCxFQUFjUSxHQUFkLEVBQW1CO0FBQzVELFlBQUlpQixFQUFFNUIsUUFBRixDQUFXRyxHQUFYLENBQUosRUFBcUI7QUFDbkIsaUJBQU9BLElBQUlRLEdBQUosQ0FBUDtBQUNEO0FBQ0YsT0FKTSxDQUFQO0FBS0QsS0EvYmdCOztBQWljakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EyZ0QsdUJBQW1CLDJCQUFTNVUsSUFBVCxFQUFlMTVCLE9BQWYsRUFBd0I7QUFDekMsVUFBSWpOLFNBQVMsRUFBYjtBQUFBLFVBQ0l4RixDQURKO0FBQUEsVUFFSWtpQixDQUZKO0FBQUEsVUFHSXJRLEtBSEo7QUFBQSxVQUlJMnhDLE1BSko7QUFBQSxVQUtJQyxNQUxKO0FBQUEsVUFNSTErQyxLQU5KOztBQVFBLFVBQUkxRCxFQUFFeS9DLGVBQUYsQ0FBa0IzVSxJQUFsQixDQUFKLEVBQTZCO0FBQzNCQSxlQUFPQSxLQUFLLENBQUwsQ0FBUDtBQUNEOztBQUVELFVBQUksQ0FBQ0EsSUFBTCxFQUFXO0FBQ1QsZUFBTzNtQyxNQUFQO0FBQ0Q7O0FBRURpTixnQkFBVUEsV0FBVyxFQUFyQjs7QUFFQSt3QyxlQUFTclgsS0FBS2tXLGdCQUFMLENBQXNCLDZCQUF0QixDQUFUO0FBQ0EsV0FBS3JpRCxJQUFJLENBQVQsRUFBWUEsSUFBSXdqRCxPQUFPdGpELE1BQXZCLEVBQStCLEVBQUVGLENBQWpDLEVBQW9DO0FBQ2xDNlIsZ0JBQVEyeEMsT0FBT3hoQyxJQUFQLENBQVloaUIsQ0FBWixDQUFSOztBQUVBLFlBQUlxQixFQUFFNmdELFNBQUYsQ0FBWXJ3QyxNQUFNbXNDLFlBQU4sQ0FBbUIsY0FBbkIsQ0FBWixDQUFKLEVBQXFEO0FBQ25EO0FBQ0Q7O0FBRURqNUMsZ0JBQVExRCxFQUFFcWlELGlCQUFGLENBQW9CN3hDLE1BQU05TSxLQUExQixFQUFpQzBOLE9BQWpDLENBQVI7QUFDQSxZQUFJWixNQUFNQyxJQUFOLEtBQWUsUUFBbkIsRUFBNkI7QUFDM0IvTSxrQkFBUUEsUUFBUSxDQUFDQSxLQUFULEdBQWlCLElBQXpCO0FBQ0QsU0FGRCxNQUVPLElBQUk4TSxNQUFNQyxJQUFOLEtBQWUsVUFBbkIsRUFBK0I7QUFDcEMsY0FBSUQsTUFBTWdCLFVBQU4sQ0FBaUI5TixLQUFyQixFQUE0QjtBQUMxQixnQkFBSSxDQUFDOE0sTUFBTTh4QyxPQUFYLEVBQW9CO0FBQ2xCNStDLHNCQUFRUyxPQUFPcU0sTUFBTThGLElBQWIsS0FBc0IsSUFBOUI7QUFDRDtBQUNGLFdBSkQsTUFJTztBQUNMNVMsb0JBQVE4TSxNQUFNOHhDLE9BQWQ7QUFDRDtBQUNGLFNBUk0sTUFRQSxJQUFJOXhDLE1BQU1DLElBQU4sS0FBZSxPQUFuQixFQUE0QjtBQUNqQyxjQUFJLENBQUNELE1BQU04eEMsT0FBWCxFQUFvQjtBQUNsQjUrQyxvQkFBUVMsT0FBT3FNLE1BQU04RixJQUFiLEtBQXNCLElBQTlCO0FBQ0Q7QUFDRjtBQUNEblMsZUFBT3FNLE1BQU04RixJQUFiLElBQXFCNVMsS0FBckI7QUFDRDs7QUFFRHkrQyxlQUFTclgsS0FBS2tXLGdCQUFMLENBQXNCLGNBQXRCLENBQVQ7QUFDQSxXQUFLcmlELElBQUksQ0FBVCxFQUFZQSxJQUFJd2pELE9BQU90akQsTUFBdkIsRUFBK0IsRUFBRUYsQ0FBakMsRUFBb0M7QUFDbEM2UixnQkFBUTJ4QyxPQUFPeGhDLElBQVAsQ0FBWWhpQixDQUFaLENBQVI7QUFDQSxZQUFJNlIsTUFBTSt4QyxRQUFWLEVBQW9CO0FBQ2xCNytDLGtCQUFRLEVBQVI7QUFDQSxlQUFLbWQsQ0FBTCxJQUFVclEsTUFBTVksT0FBaEIsRUFBeUI7QUFDdkJneEMscUJBQVM1eEMsTUFBTVksT0FBTixDQUFjeVAsQ0FBZCxDQUFUO0FBQ0EsZ0JBQUl1aEMsT0FBT0ksUUFBWCxFQUFxQjtBQUNuQjkrQyxvQkFBTWlHLElBQU4sQ0FBVzNKLEVBQUVxaUQsaUJBQUYsQ0FBb0JELE9BQU8xK0MsS0FBM0IsRUFBa0MwTixPQUFsQyxDQUFYO0FBQ0Q7QUFDRjtBQUNGLFNBUkQsTUFRTztBQUNMMU4sa0JBQVExRCxFQUFFcWlELGlCQUFGLENBQW9CN3hDLE1BQU1ZLE9BQU4sQ0FBY1osTUFBTWl5QyxhQUFwQixFQUFtQy8rQyxLQUF2RCxFQUE4RDBOLE9BQTlELENBQVI7QUFDRDtBQUNEak4sZUFBT3FNLE1BQU04RixJQUFiLElBQXFCNVMsS0FBckI7QUFDRDs7QUFFRCxhQUFPUyxNQUFQO0FBQ0QsS0F2Z0JnQjs7QUF5Z0JqQmsrQyx1QkFBbUIsMkJBQVMzK0MsS0FBVCxFQUFnQjBOLE9BQWhCLEVBQXlCO0FBQzFDLFVBQUlBLFFBQVEzVCxJQUFSLElBQWdCdUMsRUFBRThnRCxRQUFGLENBQVdwOUMsS0FBWCxDQUFwQixFQUF1QztBQUNyQ0EsZ0JBQVFBLE1BQU1qRyxJQUFOLEVBQVI7QUFDRDs7QUFFRCxVQUFJMlQsUUFBUXN4QyxPQUFSLEtBQW9CLEtBQXBCLElBQTZCaC9DLFVBQVUsRUFBM0MsRUFBK0M7QUFDN0MsZUFBTyxJQUFQO0FBQ0Q7QUFDRCxhQUFPQSxLQUFQO0FBQ0QsS0FsaEJnQjs7QUFvaEJqQjJOLGdCQUFZLG9CQUFTN1IsR0FBVCxFQUFjO0FBQ3hCLFVBQUksQ0FBQ1EsRUFBRThnRCxRQUFGLENBQVd0aEQsR0FBWCxDQUFMLEVBQXNCO0FBQ3BCLGVBQU9BLEdBQVA7QUFDRDtBQUNELGFBQU9BLElBQUksQ0FBSixFQUFPNHVDLFdBQVAsS0FBdUI1dUMsSUFBSTFCLEtBQUosQ0FBVSxDQUFWLENBQTlCO0FBQ0QsS0F6aEJnQjs7QUEyaEJqQjtBQUNBZ2lELHNCQUFrQiwwQkFBU3J1QixNQUFULEVBQWlCO0FBQ2pDLGFBQU9BLE9BQU9uQixNQUFQLENBQWMsVUFBU3plLEtBQVQsRUFBZ0I7QUFDbkMsZUFBTyxDQUFDN1IsRUFBRW8vQyxPQUFGLENBQVV2dEMsTUFBTUEsS0FBaEIsQ0FBUjtBQUNELE9BRk0sQ0FBUDtBQUdELEtBaGlCZ0I7O0FBa2lCakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQWt1QywwQkFBc0IsOEJBQVN0dUIsTUFBVCxFQUFpQjtBQUNyQyxVQUFJNVosTUFBTSxFQUFWO0FBQ0E0WixhQUFPdnNCLE9BQVAsQ0FBZSxVQUFTMk0sS0FBVCxFQUFnQjtBQUM3QjtBQUNBLFlBQUk3UixFQUFFNkssT0FBRixDQUFVZ0gsTUFBTUEsS0FBaEIsQ0FBSixFQUE0QjtBQUMxQkEsZ0JBQU1BLEtBQU4sQ0FBWTNNLE9BQVosQ0FBb0IsVUFBU2trQixHQUFULEVBQWM7QUFDaEN2UixnQkFBSWxPLElBQUosQ0FBUzNKLEVBQUUwK0MsTUFBRixDQUFTLEVBQVQsRUFBYTdzQyxLQUFiLEVBQW9CLEVBQUNBLE9BQU91WCxHQUFSLEVBQXBCLENBQVQ7QUFDRCxXQUZEO0FBR0QsU0FKRCxNQUlPO0FBQ0x2UixjQUFJbE8sSUFBSixDQUFTa0ksS0FBVDtBQUNEO0FBQ0YsT0FURDtBQVVBLGFBQU9nRyxHQUFQO0FBQ0QsS0F0akJnQjs7QUF3akJqQjtBQUNBO0FBQ0Ftb0MsMEJBQXNCLDhCQUFTdnVCLE1BQVQsRUFBaUJyZ0IsT0FBakIsRUFBMEI7QUFDOUNBLGdCQUFVQSxXQUFXLEVBQXJCOztBQUVBLFVBQUl5RyxNQUFNLEVBQVY7QUFDQTRaLGFBQU92c0IsT0FBUCxDQUFlLFVBQVN5OUMsU0FBVCxFQUFvQjtBQUNqQyxZQUFJOXdDLFFBQVE3UixFQUFFMEUsTUFBRixDQUFTaStDLFVBQVU5d0MsS0FBbkIsRUFDUjh3QyxVQUFVai9DLEtBREYsRUFFUmkvQyxVQUFVL0MsU0FGRixFQUdSK0MsVUFBVXZ4QyxPQUhGLEVBSVJ1eEMsVUFBVW54QyxVQUpGLEVBS1JteEMsVUFBVTlDLGFBTEYsQ0FBWjs7QUFPQSxZQUFJLENBQUM3L0MsRUFBRThnRCxRQUFGLENBQVdqdkMsS0FBWCxDQUFMLEVBQXdCO0FBQ3RCZ0csY0FBSWxPLElBQUosQ0FBU2c1QyxTQUFUO0FBQ0E7QUFDRDs7QUFFRCxZQUFJOXdDLE1BQU0sQ0FBTixNQUFhLEdBQWpCLEVBQXNCO0FBQ3BCQSxrQkFBUUEsTUFBTS9ULEtBQU4sQ0FBWSxDQUFaLENBQVI7QUFDRCxTQUZELE1BRU8sSUFBSXNULFFBQVFtdkMsWUFBUixLQUF5QixLQUE3QixFQUFvQztBQUN6QzF1QyxrQkFBUTdSLEVBQUVxUixVQUFGLENBQWFyUixFQUFFeWhELFFBQUYsQ0FBV2tCLFVBQVUvQyxTQUFyQixDQUFiLElBQWdELEdBQWhELEdBQXNEL3RDLEtBQTlEO0FBQ0Q7QUFDREEsZ0JBQVFBLE1BQU1uUyxPQUFOLENBQWMsT0FBZCxFQUF1QixHQUF2QixDQUFSO0FBQ0FtUyxnQkFBUTdSLEVBQUVtL0MsTUFBRixDQUFTdHRDLEtBQVQsRUFBZ0IsRUFBQ25PLE9BQU8xRCxFQUFFNmhELGNBQUYsQ0FBaUJjLFVBQVVqL0MsS0FBM0IsQ0FBUixFQUFoQixDQUFSO0FBQ0FtVSxZQUFJbE8sSUFBSixDQUFTM0osRUFBRTArQyxNQUFGLENBQVMsRUFBVCxFQUFhaUUsU0FBYixFQUF3QixFQUFDOXdDLE9BQU9BLEtBQVIsRUFBeEIsQ0FBVDtBQUNELE9BckJEO0FBc0JBLGFBQU9nRyxHQUFQO0FBQ0QsS0FybEJnQjs7QUF1bEJqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBK3FDLDRCQUF3QixnQ0FBU254QixNQUFULEVBQWlCO0FBQ3ZDLFVBQUk1WixNQUFNLEVBQVY7QUFDQTRaLGFBQU92c0IsT0FBUCxDQUFlLFVBQVMyTSxLQUFULEVBQWdCO0FBQzdCLFlBQUlneEMsT0FBT2hyQyxJQUFJaEcsTUFBTSt0QyxTQUFWLENBQVg7QUFDQSxZQUFJaUQsSUFBSixFQUFVO0FBQ1JBLGVBQUtsNUMsSUFBTCxDQUFVa0ksS0FBVjtBQUNELFNBRkQsTUFFTztBQUNMZ0csY0FBSWhHLE1BQU0rdEMsU0FBVixJQUF1QixDQUFDL3RDLEtBQUQsQ0FBdkI7QUFDRDtBQUNGLE9BUEQ7QUFRQSxhQUFPZ0csR0FBUDtBQUNELEtBdG1CZ0I7O0FBd21CakI7QUFDQTtBQUNBO0FBQ0E7QUFDQWlyQywwQkFBc0IsOEJBQVNyeEIsTUFBVCxFQUFpQjtBQUNyQyxhQUFPQSxPQUNKenpCLEdBREksQ0FDQSxVQUFTNlQsS0FBVCxFQUFnQjtBQUFFLGVBQU9BLE1BQU1BLEtBQWI7QUFBcUIsT0FEdkMsRUFFSnllLE1BRkksQ0FFRyxVQUFTNXNCLEtBQVQsRUFBZ0I1RCxLQUFoQixFQUF1QjRDLElBQXZCLEVBQTZCO0FBQ25DLGVBQU9BLEtBQUtxcUIsT0FBTCxDQUFhcnBCLEtBQWIsTUFBd0I1RCxLQUEvQjtBQUNELE9BSkksQ0FBUDtBQUtELEtBbG5CZ0I7O0FBb25CakJzZ0QscUJBQWlCLHlCQUFTNXVDLFVBQVQsRUFBcUJ1eEMsU0FBckIsRUFBZ0M7QUFDL0MsZUFBU0MsZ0JBQVQsQ0FBMEJ6a0QsR0FBMUIsRUFBK0JRLEdBQS9CLEVBQW9DeTFCLElBQXBDLEVBQTBDO0FBQ3hDLFlBQUl4MEIsRUFBRTVCLFFBQUYsQ0FBV0csSUFBSVEsR0FBSixDQUFYLENBQUosRUFBMEI7QUFDeEIsaUJBQU9SLElBQUlRLEdBQUosQ0FBUDtBQUNEO0FBQ0QsZUFBUVIsSUFBSVEsR0FBSixJQUFXeTFCLE9BQU8sSUFBUCxHQUFjLEVBQWpDO0FBQ0Q7O0FBRUQsZUFBU3l1QixvQkFBVCxDQUE4QkYsU0FBOUIsRUFBeUM7QUFDdkMsWUFBSUcsS0FBSyxFQUFUO0FBQUEsWUFDSUMsVUFESjtBQUFBLFlBRUl0RyxJQUZKO0FBR0EsYUFBS0EsSUFBTCxJQUFha0csU0FBYixFQUF3QjtBQUN0QixjQUFJLENBQUNBLFVBQVVsRyxJQUFWLENBQUwsRUFBc0I7QUFDcEI7QUFDRDtBQUNENzhDLFlBQUVpaUQsbUJBQUYsQ0FBc0JpQixFQUF0QixFQUEwQnJHLElBQTFCLEVBQWdDbUcsZ0JBQWhDO0FBQ0Q7QUFDRCxlQUFPRSxFQUFQO0FBQ0Q7O0FBRUQsZUFBU0UsY0FBVCxDQUF3QjV4QyxVQUF4QixFQUFvQ3V4QyxTQUFwQyxFQUErQztBQUM3QyxZQUFJLENBQUMvaUQsRUFBRTVCLFFBQUYsQ0FBV29ULFVBQVgsQ0FBTCxFQUE2QjtBQUMzQixpQkFBT0EsVUFBUDtBQUNEOztBQUVELFlBQUlxRyxNQUFNN1gsRUFBRTArQyxNQUFGLENBQVMsRUFBVCxFQUFhbHRDLFVBQWIsQ0FBVjtBQUFBLFlBQ0ltaUMsQ0FESjtBQUFBLFlBRUlpTSxTQUZKOztBQUlBLGFBQUtBLFNBQUwsSUFBa0JwdUMsVUFBbEIsRUFBOEI7QUFDNUJtaUMsY0FBSW9QLFVBQVVuRCxTQUFWLENBQUo7O0FBRUEsY0FBSTUvQyxFQUFFNUIsUUFBRixDQUFXdTFDLENBQVgsQ0FBSixFQUFtQjtBQUNqQjk3QixnQkFBSStuQyxTQUFKLElBQWlCd0QsZUFBZXZyQyxJQUFJK25DLFNBQUosQ0FBZixFQUErQmpNLENBQS9CLENBQWpCO0FBQ0QsV0FGRCxNQUVPLElBQUksQ0FBQ0EsQ0FBTCxFQUFRO0FBQ2IsbUJBQU85N0IsSUFBSStuQyxTQUFKLENBQVA7QUFDRDtBQUNGO0FBQ0QsZUFBTy9uQyxHQUFQO0FBQ0Q7O0FBRUQsVUFBSSxDQUFDN1gsRUFBRTVCLFFBQUYsQ0FBVzJrRCxTQUFYLENBQUQsSUFBMEIsQ0FBQy9pRCxFQUFFNUIsUUFBRixDQUFXb1QsVUFBWCxDQUEvQixFQUF1RDtBQUNyRCxlQUFPLEVBQVA7QUFDRDs7QUFFRHV4QyxrQkFBWUUscUJBQXFCRixTQUFyQixDQUFaO0FBQ0EsYUFBT0ssZUFBZTV4QyxVQUFmLEVBQTJCdXhDLFNBQTNCLENBQVA7QUFDRCxLQXBxQmdCOztBQXNxQmpCTSxrQkFBYyxzQkFBUzl4QyxRQUFULEVBQW1CNU8sSUFBbkIsRUFBeUJ2RixPQUF6QixFQUFrQ0QsTUFBbEMsRUFBMEM4WixNQUExQyxFQUFrRDtBQUM5RCxVQUFJN1osT0FBSixFQUFhO0FBQ1gsWUFBSUQsVUFBVUEsT0FBT0MsT0FBckIsRUFBOEI7QUFDNUJBLG9CQUFVRCxPQUFPQyxPQUFQLEdBQWlCbVUsUUFBM0I7QUFDRDtBQUNEblUsZ0JBQVFtVSxRQUFSLEdBQW1CQSxRQUFuQjtBQUNELE9BTEQsTUFLTztBQUNMNU8sYUFBSzRPLFFBQUwsR0FBZ0JBLFFBQWhCO0FBQ0EsWUFBSUEsU0FBU3BULFVBQVQsQ0FBb0I4WSxNQUFwQixLQUErQkEsT0FBT3FzQyxHQUExQyxFQUErQztBQUM3Q3JzQyxpQkFBTyxFQUFQLEVBQVcsWUFBWTtBQUFFLG1CQUFPMUYsUUFBUDtBQUFrQixXQUEzQztBQUNEO0FBQ0Y7QUFDRixLQWxyQmdCOztBQW9yQmpCMlMsVUFBTSxjQUFTa0YsR0FBVCxFQUFjO0FBQ2xCLFVBQUksT0FBT2tCLE9BQVAsS0FBbUIsV0FBbkIsSUFBa0NBLFFBQVFwRyxJQUE5QyxFQUFvRDtBQUNsRG9HLGdCQUFRcEcsSUFBUixDQUFhLG1CQUFtQmtGLEdBQWhDO0FBQ0Q7QUFDRixLQXhyQmdCOztBQTByQmpCdlgsV0FBTyxlQUFTdVgsR0FBVCxFQUFjO0FBQ25CLFVBQUksT0FBT2tCLE9BQVAsS0FBbUIsV0FBbkIsSUFBa0NBLFFBQVF6WSxLQUE5QyxFQUFxRDtBQUNuRHlZLGdCQUFRelksS0FBUixDQUFjLG1CQUFtQnVYLEdBQWpDO0FBQ0Q7QUFDRjtBQTlyQmdCLEdBQW5COztBQWlzQkE3WCxXQUFTTixVQUFULEdBQXNCO0FBQ3BCO0FBQ0F1Z0MsY0FBVSxrQkFBUzl0QyxLQUFULEVBQWdCME4sT0FBaEIsRUFBeUI7QUFDakNBLGdCQUFVcFIsRUFBRTArQyxNQUFGLENBQVMsRUFBVCxFQUFhLEtBQUt0dEMsT0FBbEIsRUFBMkJBLE9BQTNCLENBQVY7QUFDQSxVQUFJQSxRQUFRbXlDLFVBQVIsR0FBcUIsQ0FBQ3ZqRCxFQUFFNmdELFNBQUYsQ0FBWW45QyxLQUFaLENBQXRCLEdBQTJDMUQsRUFBRW8vQyxPQUFGLENBQVUxN0MsS0FBVixDQUEvQyxFQUFpRTtBQUMvRCxlQUFPME4sUUFBUVEsT0FBUixJQUFtQixLQUFLQSxPQUF4QixJQUFtQyxnQkFBMUM7QUFDRDtBQUNGLEtBUG1CO0FBUXBCL1MsWUFBUSxnQkFBUzZFLEtBQVQsRUFBZ0IwTixPQUFoQixFQUF5Qnd1QyxTQUF6QixFQUFvQztBQUMxQztBQUNBLFVBQUksQ0FBQzUvQyxFQUFFNmdELFNBQUYsQ0FBWW45QyxLQUFaLENBQUwsRUFBeUI7QUFDdkI7QUFDRDs7QUFFRDBOLGdCQUFVcFIsRUFBRTArQyxNQUFGLENBQVMsRUFBVCxFQUFhLEtBQUt0dEMsT0FBbEIsRUFBMkJBLE9BQTNCLENBQVY7O0FBRUEsVUFBSXNuQixLQUFLdG5CLFFBQVFzbkIsRUFBakI7QUFBQSxVQUNJOHFCLFVBQVVweUMsUUFBUW95QyxPQUR0QjtBQUFBLFVBRUlDLFVBQVVyeUMsUUFBUXF5QyxPQUZ0QjtBQUFBLFVBR0lDLFlBQVl0eUMsUUFBUXN5QyxTQUFSLElBQXFCLFVBQVM1a0QsR0FBVCxFQUFjO0FBQUUsZUFBT0EsR0FBUDtBQUFhLE9BSGxFO0FBQUEsVUFJSWd1QixHQUpKO0FBQUEsVUFLSTJFLFNBQVMsRUFMYjs7QUFPQS90QixjQUFRZ2dELFVBQVVoZ0QsS0FBVixDQUFSO0FBQ0EsVUFBSTdFLFNBQVM2RSxNQUFNN0UsTUFBbkI7QUFDQSxVQUFHLENBQUNtQixFQUFFeWdELFFBQUYsQ0FBVzVoRCxNQUFYLENBQUosRUFBd0I7QUFDdEJtQixVQUFFNlIsS0FBRixDQUFRN1IsRUFBRW0vQyxNQUFGLENBQVMsd0RBQVQsRUFBbUUsRUFBQ3RDLE1BQU0rQyxTQUFQLEVBQW5FLENBQVI7QUFDQSxlQUFPeHVDLFFBQVFRLE9BQVIsSUFBbUIsS0FBSyt4QyxRQUF4QixJQUFvQyx5QkFBM0M7QUFDRDs7QUFFRDtBQUNBLFVBQUkzakQsRUFBRXlnRCxRQUFGLENBQVcvbkIsRUFBWCxLQUFrQjc1QixXQUFXNjVCLEVBQWpDLEVBQXFDO0FBQ25DNUwsY0FBTTFiLFFBQVF3eUMsV0FBUixJQUNKLEtBQUtBLFdBREQsSUFFSixxREFGRjtBQUdBbnlCLGVBQU85bkIsSUFBUCxDQUFZM0osRUFBRW0vQyxNQUFGLENBQVNyeUIsR0FBVCxFQUFjLEVBQUN5UixPQUFPN0YsRUFBUixFQUFkLENBQVo7QUFDRDs7QUFFRCxVQUFJMTRCLEVBQUV5Z0QsUUFBRixDQUFXZ0QsT0FBWCxLQUF1QjVrRCxTQUFTNGtELE9BQXBDLEVBQTZDO0FBQzNDMzJCLGNBQU0xYixRQUFReXlDLFFBQVIsSUFDSixLQUFLQSxRQURELElBRUosK0NBRkY7QUFHQXB5QixlQUFPOW5CLElBQVAsQ0FBWTNKLEVBQUVtL0MsTUFBRixDQUFTcnlCLEdBQVQsRUFBYyxFQUFDeVIsT0FBT2tsQixPQUFSLEVBQWQsQ0FBWjtBQUNEOztBQUVELFVBQUl6akQsRUFBRXlnRCxRQUFGLENBQVcrQyxPQUFYLEtBQXVCM2tELFNBQVMya0QsT0FBcEMsRUFBNkM7QUFDM0MxMkIsY0FBTTFiLFFBQVEweUMsT0FBUixJQUNKLEtBQUtBLE9BREQsSUFFSiw4Q0FGRjtBQUdBcnlCLGVBQU85bkIsSUFBUCxDQUFZM0osRUFBRW0vQyxNQUFGLENBQVNyeUIsR0FBVCxFQUFjLEVBQUN5UixPQUFPaWxCLE9BQVIsRUFBZCxDQUFaO0FBQ0Q7O0FBRUQsVUFBSS94QixPQUFPNXlCLE1BQVAsR0FBZ0IsQ0FBcEIsRUFBdUI7QUFDckIsZUFBT3VTLFFBQVFRLE9BQVIsSUFBbUI2ZixNQUExQjtBQUNEO0FBQ0YsS0F2RG1CO0FBd0RwQnN5QixrQkFBYyxzQkFBU3JnRCxLQUFULEVBQWdCME4sT0FBaEIsRUFBeUI7QUFDckM7QUFDQSxVQUFJLENBQUNwUixFQUFFNmdELFNBQUYsQ0FBWW45QyxLQUFaLENBQUwsRUFBeUI7QUFDdkI7QUFDRDs7QUFFRDBOLGdCQUFVcFIsRUFBRTArQyxNQUFGLENBQVMsRUFBVCxFQUFhLEtBQUt0dEMsT0FBbEIsRUFBMkJBLE9BQTNCLENBQVY7O0FBRUEsVUFBSXFnQixTQUFTLEVBQWI7QUFBQSxVQUNJbmIsSUFESjtBQUFBLFVBRUlpb0IsS0FGSjtBQUFBLFVBR0l5bEIsU0FBUztBQUNQQyxxQkFBc0IscUJBQVNqa0QsQ0FBVCxFQUFZNDdCLENBQVosRUFBZTtBQUFFLGlCQUFPNTdCLElBQUk0N0IsQ0FBWDtBQUFlLFNBRC9DO0FBRVBzb0IsOEJBQXNCLDhCQUFTbGtELENBQVQsRUFBWTQ3QixDQUFaLEVBQWU7QUFBRSxpQkFBTzU3QixLQUFLNDdCLENBQVo7QUFBZ0IsU0FGaEQ7QUFHUHVvQixpQkFBc0IsaUJBQVNua0QsQ0FBVCxFQUFZNDdCLENBQVosRUFBZTtBQUFFLGlCQUFPNTdCLE1BQU00N0IsQ0FBYjtBQUFpQixTQUhqRDtBQUlQd29CLGtCQUFzQixrQkFBU3BrRCxDQUFULEVBQVk0N0IsQ0FBWixFQUFlO0FBQUUsaUJBQU81N0IsSUFBSTQ3QixDQUFYO0FBQWUsU0FKL0M7QUFLUHlvQiwyQkFBc0IsMkJBQVNya0QsQ0FBVCxFQUFZNDdCLENBQVosRUFBZTtBQUFFLGlCQUFPNTdCLEtBQUs0N0IsQ0FBWjtBQUFnQixTQUxoRDtBQU1QMG9CLHFCQUFzQixxQkFBU3RrRCxDQUFULEVBQVk0N0IsQ0FBWixFQUFlO0FBQUUsaUJBQU81N0IsSUFBSTQ3QixDQUFKLEtBQVUsQ0FBakI7QUFBcUI7QUFOckQsT0FIYjs7QUFZQTtBQUNBLFVBQUk1N0IsRUFBRThnRCxRQUFGLENBQVdwOUMsS0FBWCxLQUFxQjBOLFFBQVFtekMsTUFBakMsRUFBeUM7QUFDdkMsWUFBSXAzQyxVQUFVLGdCQUFkO0FBQ0EsWUFBSSxDQUFDaUUsUUFBUW96QyxXQUFiLEVBQTBCO0FBQ3hCcjNDLHFCQUFXLFlBQVg7QUFDRDtBQUNEQSxtQkFBVyxHQUFYOztBQUVBLFlBQUksQ0FBRSxJQUFJL0csTUFBSixDQUFXK0csT0FBWCxFQUFvQkMsSUFBcEIsQ0FBeUIxSixLQUF6QixDQUFOLEVBQXdDO0FBQ3RDLGlCQUFPME4sUUFBUVEsT0FBUixJQUNMUixRQUFRdXlDLFFBREgsSUFFTCxLQUFLQSxRQUZBLElBR0wsS0FBSy94QyxPQUhBLElBSUwsd0JBSkY7QUFLRDtBQUNGOztBQUVEO0FBQ0EsVUFBSVIsUUFBUXF6QyxTQUFSLEtBQXNCLElBQXRCLElBQThCemtELEVBQUU4Z0QsUUFBRixDQUFXcDlDLEtBQVgsQ0FBOUIsSUFBbUQsQ0FBQzFELEVBQUVvL0MsT0FBRixDQUFVMTdDLEtBQVYsQ0FBeEQsRUFBMEU7QUFDeEVBLGdCQUFRLENBQUNBLEtBQVQ7QUFDRDs7QUFFRDtBQUNBLFVBQUksQ0FBQzFELEVBQUV5Z0QsUUFBRixDQUFXLzhDLEtBQVgsQ0FBTCxFQUF3QjtBQUN0QixlQUFPME4sUUFBUVEsT0FBUixJQUNMUixRQUFRdXlDLFFBREgsSUFFTCxLQUFLQSxRQUZBLElBR0wsS0FBSy94QyxPQUhBLElBSUwsaUJBSkY7QUFLRDs7QUFFRDtBQUNBO0FBQ0EsVUFBSVIsUUFBUW96QyxXQUFSLElBQXVCLENBQUN4a0QsRUFBRTBnRCxTQUFGLENBQVloOUMsS0FBWixDQUE1QixFQUFnRDtBQUM5QyxlQUFPME4sUUFBUVEsT0FBUixJQUNMUixRQUFRc3pDLFVBREgsSUFFTCxLQUFLQSxVQUZBLElBR0wsS0FBSzl5QyxPQUhBLElBSUwsb0JBSkY7QUFLRDs7QUFFRCxXQUFLMEUsSUFBTCxJQUFhMHRDLE1BQWIsRUFBcUI7QUFDbkJ6bEIsZ0JBQVFudEIsUUFBUWtGLElBQVIsQ0FBUjtBQUNBLFlBQUl0VyxFQUFFeWdELFFBQUYsQ0FBV2xpQixLQUFYLEtBQXFCLENBQUN5bEIsT0FBTzF0QyxJQUFQLEVBQWE1UyxLQUFiLEVBQW9CNjZCLEtBQXBCLENBQTFCLEVBQXNEO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLGNBQUl4L0IsTUFBTSxRQUFRaUIsRUFBRXFSLFVBQUYsQ0FBYWlGLElBQWIsQ0FBbEI7QUFDQSxjQUFJOFMsTUFBTWhZLFFBQVFyUyxHQUFSLEtBQ1IsS0FBS0EsR0FBTCxDQURRLElBRVIsS0FBSzZTLE9BRkcsSUFHUiwwQkFIRjs7QUFLQTZmLGlCQUFPOW5CLElBQVAsQ0FBWTNKLEVBQUVtL0MsTUFBRixDQUFTLzFCLEdBQVQsRUFBYztBQUN4Qm1WLG1CQUFPQSxLQURpQjtBQUV4Qjl0QixrQkFBTXpRLEVBQUV5aEQsUUFBRixDQUFXbnJDLElBQVg7QUFGa0IsV0FBZCxDQUFaO0FBSUQ7QUFDRjs7QUFFRCxVQUFJbEYsUUFBUXV6QyxHQUFSLElBQWVqaEQsUUFBUSxDQUFSLEtBQWMsQ0FBakMsRUFBb0M7QUFDbEMrdEIsZUFBTzluQixJQUFQLENBQVl5SCxRQUFRd3pDLE1BQVIsSUFDUixLQUFLQSxNQURHLElBRVIsS0FBS2h6QyxPQUZHLElBR1IsYUFISjtBQUlEO0FBQ0QsVUFBSVIsUUFBUXl6QyxJQUFSLElBQWdCbmhELFFBQVEsQ0FBUixLQUFjLENBQWxDLEVBQXFDO0FBQ25DK3RCLGVBQU85bkIsSUFBUCxDQUFZeUgsUUFBUTB6QyxPQUFSLElBQ1IsS0FBS0EsT0FERyxJQUVSLEtBQUtsekMsT0FGRyxJQUdSLGNBSEo7QUFJRDs7QUFFRCxVQUFJNmYsT0FBTzV5QixNQUFYLEVBQW1CO0FBQ2pCLGVBQU91UyxRQUFRUSxPQUFSLElBQW1CNmYsTUFBMUI7QUFDRDtBQUNGLEtBeEptQjtBQXlKcEJzekIsY0FBVS9rRCxFQUFFMCtDLE1BQUYsQ0FBUyxVQUFTaDdDLEtBQVQsRUFBZ0IwTixPQUFoQixFQUF5QjtBQUMxQyxVQUFJLENBQUNwUixFQUFFN0IsVUFBRixDQUFhLEtBQUsyckMsS0FBbEIsQ0FBRCxJQUE2QixDQUFDOXBDLEVBQUU3QixVQUFGLENBQWEsS0FBS2doRCxNQUFsQixDQUFsQyxFQUE2RDtBQUMzRCxjQUFNLElBQUk1cUMsS0FBSixDQUFVLHdGQUFWLENBQU47QUFDRDs7QUFFRDtBQUNBLFVBQUksQ0FBQ3ZVLEVBQUU2Z0QsU0FBRixDQUFZbjlDLEtBQVosQ0FBTCxFQUF5QjtBQUN2QjtBQUNEOztBQUVEME4sZ0JBQVVwUixFQUFFMCtDLE1BQUYsQ0FBUyxFQUFULEVBQWEsS0FBS3R0QyxPQUFsQixFQUEyQkEsT0FBM0IsQ0FBVjs7QUFFQSxVQUFJMGIsR0FBSjtBQUFBLFVBQ0kyRSxTQUFTLEVBRGI7QUFBQSxVQUVJdXpCLFdBQVc1ekMsUUFBUTR6QyxRQUFSLEdBQW1CLEtBQUtsYixLQUFMLENBQVcxNEIsUUFBUTR6QyxRQUFuQixFQUE2QjV6QyxPQUE3QixDQUFuQixHQUEyRDZ6QyxHQUYxRTtBQUFBLFVBR0lDLFNBQVM5ekMsUUFBUTh6QyxNQUFSLEdBQWlCLEtBQUtwYixLQUFMLENBQVcxNEIsUUFBUTh6QyxNQUFuQixFQUEyQjl6QyxPQUEzQixDQUFqQixHQUF1RDZ6QyxHQUhwRTs7QUFLQXZoRCxjQUFRLEtBQUtvbUMsS0FBTCxDQUFXcG1DLEtBQVgsRUFBa0IwTixPQUFsQixDQUFSOztBQUVBO0FBQ0E7QUFDQSxVQUFJa2lDLE1BQU01dkMsS0FBTixLQUFnQjBOLFFBQVErekMsUUFBUixJQUFvQnpoRCxRQUFRLFFBQVIsS0FBcUIsQ0FBN0QsRUFBZ0U7QUFDOURvcEIsY0FBTTFiLFFBQVF1eUMsUUFBUixJQUNKdnlDLFFBQVFRLE9BREosSUFFSixLQUFLK3hDLFFBRkQsSUFHSixzQkFIRjtBQUlBLGVBQU8zakQsRUFBRW0vQyxNQUFGLENBQVNyeUIsR0FBVCxFQUFjLEVBQUNwcEIsT0FBTzlFLFVBQVUsQ0FBVixDQUFSLEVBQWQsQ0FBUDtBQUNEOztBQUVELFVBQUksQ0FBQzAwQyxNQUFNMFIsUUFBTixDQUFELElBQW9CdGhELFFBQVFzaEQsUUFBaEMsRUFBMEM7QUFDeENsNEIsY0FBTTFiLFFBQVFnMEMsUUFBUixJQUNKaDBDLFFBQVFRLE9BREosSUFFSixLQUFLd3pDLFFBRkQsSUFHSixpQ0FIRjtBQUlBdDRCLGNBQU05c0IsRUFBRW0vQyxNQUFGLENBQVNyeUIsR0FBVCxFQUFjO0FBQ2xCcHBCLGlCQUFPLEtBQUt5N0MsTUFBTCxDQUFZejdDLEtBQVosRUFBbUIwTixPQUFuQixDQURXO0FBRWxCaTBDLGdCQUFNLEtBQUtsRyxNQUFMLENBQVk2RixRQUFaLEVBQXNCNXpDLE9BQXRCO0FBRlksU0FBZCxDQUFOO0FBSUFxZ0IsZUFBTzluQixJQUFQLENBQVltakIsR0FBWjtBQUNEOztBQUVELFVBQUksQ0FBQ3dtQixNQUFNNFIsTUFBTixDQUFELElBQWtCeGhELFFBQVF3aEQsTUFBOUIsRUFBc0M7QUFDcENwNEIsY0FBTTFiLFFBQVFrMEMsT0FBUixJQUNKbDBDLFFBQVFRLE9BREosSUFFSixLQUFLMHpDLE9BRkQsSUFHSiwrQkFIRjtBQUlBeDRCLGNBQU05c0IsRUFBRW0vQyxNQUFGLENBQVNyeUIsR0FBVCxFQUFjO0FBQ2xCdTRCLGdCQUFNLEtBQUtsRyxNQUFMLENBQVkrRixNQUFaLEVBQW9COXpDLE9BQXBCLENBRFk7QUFFbEIxTixpQkFBTyxLQUFLeTdDLE1BQUwsQ0FBWXo3QyxLQUFaLEVBQW1CME4sT0FBbkI7QUFGVyxTQUFkLENBQU47QUFJQXFnQixlQUFPOW5CLElBQVAsQ0FBWW1qQixHQUFaO0FBQ0Q7O0FBRUQsVUFBSTJFLE9BQU81eUIsTUFBWCxFQUFtQjtBQUNqQixlQUFPbUIsRUFBRStoRCxNQUFGLENBQVN0d0IsTUFBVCxDQUFQO0FBQ0Q7QUFDRixLQXhEUyxFQXdEUDtBQUNEcVksYUFBTyxJQUROO0FBRURxVixjQUFRO0FBRlAsS0F4RE8sQ0F6SlU7QUFxTnBCa0csVUFBTSxjQUFTM2hELEtBQVQsRUFBZ0IwTixPQUFoQixFQUF5QjtBQUM3QkEsZ0JBQVVwUixFQUFFMCtDLE1BQUYsQ0FBUyxFQUFULEVBQWF0dEMsT0FBYixFQUFzQixFQUFDK3pDLFVBQVUsSUFBWCxFQUF0QixDQUFWO0FBQ0EsYUFBT25sRCxFQUFFaVIsVUFBRixDQUFhOHpDLFFBQWIsQ0FBc0J0bEQsSUFBdEIsQ0FBMkJPLEVBQUVpUixVQUFGLENBQWE4ekMsUUFBeEMsRUFBa0RyaEQsS0FBbEQsRUFBeUQwTixPQUF6RCxDQUFQO0FBQ0QsS0F4Tm1CO0FBeU5wQit0QyxZQUFRLGdCQUFTejdDLEtBQVQsRUFBZ0IwTixPQUFoQixFQUF5QjtBQUMvQixVQUFJcFIsRUFBRThnRCxRQUFGLENBQVcxdkMsT0FBWCxLQUF3QkEsbUJBQW1CaEwsTUFBL0MsRUFBd0Q7QUFDdERnTCxrQkFBVSxFQUFDakUsU0FBU2lFLE9BQVYsRUFBVjtBQUNEOztBQUVEQSxnQkFBVXBSLEVBQUUwK0MsTUFBRixDQUFTLEVBQVQsRUFBYSxLQUFLdHRDLE9BQWxCLEVBQTJCQSxPQUEzQixDQUFWOztBQUVBLFVBQUlRLFVBQVVSLFFBQVFRLE9BQVIsSUFBbUIsS0FBS0EsT0FBeEIsSUFBbUMsWUFBakQ7QUFBQSxVQUNJekUsVUFBVWlFLFFBQVFqRSxPQUR0QjtBQUFBLFVBRUkrYixLQUZKOztBQUlBO0FBQ0EsVUFBSSxDQUFDbHBCLEVBQUU2Z0QsU0FBRixDQUFZbjlDLEtBQVosQ0FBTCxFQUF5QjtBQUN2QjtBQUNEO0FBQ0QsVUFBSSxDQUFDMUQsRUFBRThnRCxRQUFGLENBQVdwOUMsS0FBWCxDQUFMLEVBQXdCO0FBQ3RCLGVBQU9rTyxPQUFQO0FBQ0Q7O0FBRUQsVUFBSTVSLEVBQUU4Z0QsUUFBRixDQUFXM3pDLE9BQVgsQ0FBSixFQUF5QjtBQUN2QkEsa0JBQVUsSUFBSS9HLE1BQUosQ0FBV2dMLFFBQVFqRSxPQUFuQixFQUE0QmlFLFFBQVF3VyxLQUFwQyxDQUFWO0FBQ0Q7QUFDRHNCLGNBQVEvYixRQUFRdEgsSUFBUixDQUFhbkMsS0FBYixDQUFSO0FBQ0EsVUFBSSxDQUFDd2xCLEtBQUQsSUFBVUEsTUFBTSxDQUFOLEVBQVNycUIsTUFBVCxJQUFtQjZFLE1BQU03RSxNQUF2QyxFQUErQztBQUM3QyxlQUFPK1MsT0FBUDtBQUNEO0FBQ0YsS0FuUG1CO0FBb1BwQjJ6QyxlQUFXLG1CQUFTN2hELEtBQVQsRUFBZ0IwTixPQUFoQixFQUF5QjtBQUNsQztBQUNBLFVBQUksQ0FBQ3BSLEVBQUU2Z0QsU0FBRixDQUFZbjlDLEtBQVosQ0FBTCxFQUF5QjtBQUN2QjtBQUNEO0FBQ0QsVUFBSTFELEVBQUU2SyxPQUFGLENBQVV1RyxPQUFWLENBQUosRUFBd0I7QUFDdEJBLGtCQUFVLEVBQUNvMEMsUUFBUXAwQyxPQUFULEVBQVY7QUFDRDtBQUNEQSxnQkFBVXBSLEVBQUUwK0MsTUFBRixDQUFTLEVBQVQsRUFBYSxLQUFLdHRDLE9BQWxCLEVBQTJCQSxPQUEzQixDQUFWO0FBQ0EsVUFBSXBSLEVBQUV5ekMsUUFBRixDQUFXcmlDLFFBQVFvMEMsTUFBbkIsRUFBMkI5aEQsS0FBM0IsQ0FBSixFQUF1QztBQUNyQztBQUNEO0FBQ0QsVUFBSWtPLFVBQVVSLFFBQVFRLE9BQVIsSUFDWixLQUFLQSxPQURPLElBRVosdUNBRkY7QUFHQSxhQUFPNVIsRUFBRW0vQyxNQUFGLENBQVN2dEMsT0FBVCxFQUFrQixFQUFDbE8sT0FBT0EsS0FBUixFQUFsQixDQUFQO0FBQ0QsS0FwUW1CO0FBcVFwQitoRCxlQUFXLG1CQUFTL2hELEtBQVQsRUFBZ0IwTixPQUFoQixFQUF5QjtBQUNsQztBQUNBLFVBQUksQ0FBQ3BSLEVBQUU2Z0QsU0FBRixDQUFZbjlDLEtBQVosQ0FBTCxFQUF5QjtBQUN2QjtBQUNEO0FBQ0QsVUFBSTFELEVBQUU2SyxPQUFGLENBQVV1RyxPQUFWLENBQUosRUFBd0I7QUFDdEJBLGtCQUFVLEVBQUNvMEMsUUFBUXAwQyxPQUFULEVBQVY7QUFDRDtBQUNEQSxnQkFBVXBSLEVBQUUwK0MsTUFBRixDQUFTLEVBQVQsRUFBYSxLQUFLdHRDLE9BQWxCLEVBQTJCQSxPQUEzQixDQUFWO0FBQ0EsVUFBSSxDQUFDcFIsRUFBRXl6QyxRQUFGLENBQVdyaUMsUUFBUW8wQyxNQUFuQixFQUEyQjloRCxLQUEzQixDQUFMLEVBQXdDO0FBQ3RDO0FBQ0Q7QUFDRCxVQUFJa08sVUFBVVIsUUFBUVEsT0FBUixJQUFtQixLQUFLQSxPQUF4QixJQUFtQyx5QkFBakQ7QUFDQSxhQUFPNVIsRUFBRW0vQyxNQUFGLENBQVN2dEMsT0FBVCxFQUFrQixFQUFDbE8sT0FBT0EsS0FBUixFQUFsQixDQUFQO0FBQ0QsS0FuUm1CO0FBb1JwQm90QyxXQUFPOXdDLEVBQUUwK0MsTUFBRixDQUFTLFVBQVNoN0MsS0FBVCxFQUFnQjBOLE9BQWhCLEVBQXlCO0FBQ3ZDQSxnQkFBVXBSLEVBQUUwK0MsTUFBRixDQUFTLEVBQVQsRUFBYSxLQUFLdHRDLE9BQWxCLEVBQTJCQSxPQUEzQixDQUFWO0FBQ0EsVUFBSVEsVUFBVVIsUUFBUVEsT0FBUixJQUFtQixLQUFLQSxPQUF4QixJQUFtQyxzQkFBakQ7QUFDQTtBQUNBLFVBQUksQ0FBQzVSLEVBQUU2Z0QsU0FBRixDQUFZbjlDLEtBQVosQ0FBTCxFQUF5QjtBQUN2QjtBQUNEO0FBQ0QsVUFBSSxDQUFDMUQsRUFBRThnRCxRQUFGLENBQVdwOUMsS0FBWCxDQUFMLEVBQXdCO0FBQ3RCLGVBQU9rTyxPQUFQO0FBQ0Q7QUFDRCxVQUFJLENBQUMsS0FBSzh6QyxPQUFMLENBQWE3L0MsSUFBYixDQUFrQm5DLEtBQWxCLENBQUwsRUFBK0I7QUFDN0IsZUFBT2tPLE9BQVA7QUFDRDtBQUNGLEtBYk0sRUFhSjtBQUNEOHpDLGVBQVM7QUFEUixLQWJJLENBcFJhO0FBb1NwQkMsY0FBVSxrQkFBU2ppRCxLQUFULEVBQWdCME4sT0FBaEIsRUFBeUJ3dUMsU0FBekIsRUFBb0NwdUMsVUFBcEMsRUFBZ0Q7QUFDeEQsVUFBSSxDQUFDeFIsRUFBRTZnRCxTQUFGLENBQVluOUMsS0FBWixDQUFMLEVBQXlCO0FBQ3ZCO0FBQ0Q7O0FBRUQsVUFBSTFELEVBQUU4Z0QsUUFBRixDQUFXMXZDLE9BQVgsQ0FBSixFQUF5QjtBQUN2QkEsa0JBQVUsRUFBQ3d1QyxXQUFXeHVDLE9BQVosRUFBVjtBQUNEO0FBQ0RBLGdCQUFVcFIsRUFBRTArQyxNQUFGLENBQVMsRUFBVCxFQUFhLEtBQUt0dEMsT0FBbEIsRUFBMkJBLE9BQTNCLENBQVY7QUFDQSxVQUFJUSxVQUFVUixRQUFRUSxPQUFSLElBQ1osS0FBS0EsT0FETyxJQUVaLDhCQUZGOztBQUlBLFVBQUk1UixFQUFFby9DLE9BQUYsQ0FBVWh1QyxRQUFRd3VDLFNBQWxCLEtBQWdDLENBQUM1L0MsRUFBRThnRCxRQUFGLENBQVcxdkMsUUFBUXd1QyxTQUFuQixDQUFyQyxFQUFvRTtBQUNsRSxjQUFNLElBQUlyckMsS0FBSixDQUFVLDBDQUFWLENBQU47QUFDRDs7QUFFRCxVQUFJcXhDLGFBQWE1bEQsRUFBRTIvQyxrQkFBRixDQUFxQm51QyxVQUFyQixFQUFpQ0osUUFBUXd1QyxTQUF6QyxDQUFqQjtBQUFBLFVBQ0lpRyxhQUFhejBDLFFBQVF5MEMsVUFBUixJQUFzQixVQUFTQyxFQUFULEVBQWFDLEVBQWIsRUFBaUI7QUFDcEQsZUFBT0QsT0FBT0MsRUFBZDtBQUNELE9BSEg7O0FBS0EsVUFBSSxDQUFDRixXQUFXbmlELEtBQVgsRUFBa0JraUQsVUFBbEIsRUFBOEJ4MEMsT0FBOUIsRUFBdUN3dUMsU0FBdkMsRUFBa0RwdUMsVUFBbEQsQ0FBTCxFQUFvRTtBQUNsRSxlQUFPeFIsRUFBRW0vQyxNQUFGLENBQVN2dEMsT0FBVCxFQUFrQixFQUFDZ3VDLFdBQVc1L0MsRUFBRXloRCxRQUFGLENBQVdyd0MsUUFBUXd1QyxTQUFuQixDQUFaLEVBQWxCLENBQVA7QUFDRDtBQUNGLEtBN1RtQjs7QUErVHBCO0FBQ0E7QUFDQTNWLFNBQUssYUFBU3ZtQyxLQUFULEVBQWdCME4sT0FBaEIsRUFBeUI7QUFDNUIsVUFBSSxDQUFDcFIsRUFBRTZnRCxTQUFGLENBQVluOUMsS0FBWixDQUFMLEVBQXlCO0FBQ3ZCO0FBQ0Q7O0FBRUQwTixnQkFBVXBSLEVBQUUwK0MsTUFBRixDQUFTLEVBQVQsRUFBYSxLQUFLdHRDLE9BQWxCLEVBQTJCQSxPQUEzQixDQUFWOztBQUVBLFVBQUlRLFVBQVVSLFFBQVFRLE9BQVIsSUFBbUIsS0FBS0EsT0FBeEIsSUFBbUMsb0JBQWpEO0FBQUEsVUFDSW8wQyxVQUFVNTBDLFFBQVE0MEMsT0FBUixJQUFtQixLQUFLQSxPQUF4QixJQUFtQyxDQUFDLE1BQUQsRUFBUyxPQUFULENBRGpEO0FBQUEsVUFFSUMsYUFBYTcwQyxRQUFRNjBDLFVBQVIsSUFBc0IsS0FBS0EsVUFBM0IsSUFBeUMsS0FGMUQ7O0FBSUEsVUFBSSxDQUFDam1ELEVBQUU4Z0QsUUFBRixDQUFXcDlDLEtBQVgsQ0FBTCxFQUF3QjtBQUN0QixlQUFPa08sT0FBUDtBQUNEOztBQUVEO0FBQ0EsVUFBSXMwQyxRQUNGO0FBQ0E7QUFDQSxjQUZBLEdBRVdGLFFBQVF4OUIsSUFBUixDQUFhLEdBQWIsQ0FGWCxHQUUrQixPQUYvQjtBQUdBO0FBQ0EsNEJBSkEsR0FLQSxLQU5GOztBQVFBLFVBQUkyOUIsTUFBTSxxQ0FBVjs7QUFFQSxVQUFJRixVQUFKLEVBQWdCO0FBQ2RFLGVBQU8sR0FBUDtBQUNELE9BRkQsTUFFTztBQUNMRDtBQUNFO0FBQ0E7QUFDQSw2Q0FDQSwrQ0FEQSxHQUVBLG9EQUxGO0FBTUQ7O0FBRURBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUNBLDRDQURBLEdBRUEsZ0RBRkEsR0FHRixHQUhFO0FBSUE7QUFDQSxrRUFMQTtBQU1BO0FBQ0Esc0VBUEEsR0FRQUMsR0FSQSxHQVNGLEdBVEU7QUFVRjtBQUNBLHNCQVhFO0FBWUY7QUFDQSxzQkFiRSxHQWNKLEdBcEJBOztBQXNCQSxVQUFJVCxVQUFVLElBQUl0L0MsTUFBSixDQUFXOC9DLEtBQVgsRUFBa0IsR0FBbEIsQ0FBZDtBQUNBLFVBQUksQ0FBQ1IsUUFBUTcvQyxJQUFSLENBQWFuQyxLQUFiLENBQUwsRUFBMEI7QUFDeEIsZUFBT2tPLE9BQVA7QUFDRDtBQUNGO0FBaFltQixHQUF0Qjs7QUFtWUFMLFdBQVMwdUMsVUFBVCxHQUFzQjtBQUNwQm1HLGNBQVUsa0JBQVMzMEIsTUFBVCxFQUFpQjtBQUFDLGFBQU9BLE1BQVA7QUFBZSxLQUR2QjtBQUVwQjQwQixVQUFNcm1ELEVBQUU4aUQsb0JBRlk7QUFHcEJ3RCxhQUFTLGlCQUFTNzBCLE1BQVQsRUFBaUI7QUFDeEIsVUFBSW9yQixJQUFKOztBQUVBcHJCLGVBQVN6eEIsRUFBRTRpRCxzQkFBRixDQUF5Qm54QixNQUF6QixDQUFUO0FBQ0EsV0FBS29yQixJQUFMLElBQWFwckIsTUFBYixFQUFxQjtBQUNuQkEsZUFBT29yQixJQUFQLElBQWU3OEMsRUFBRThpRCxvQkFBRixDQUF1QnJ4QixPQUFPb3JCLElBQVAsQ0FBdkIsQ0FBZjtBQUNEO0FBQ0QsYUFBT3ByQixNQUFQO0FBQ0QsS0FYbUI7QUFZcEI4MEIsZ0JBQVksb0JBQVM5MEIsTUFBVCxFQUFpQjtBQUMzQixVQUFJb3JCLElBQUo7QUFDQXByQixlQUFTenhCLEVBQUU0aUQsc0JBQUYsQ0FBeUJueEIsTUFBekIsQ0FBVDtBQUNBLFdBQUtvckIsSUFBTCxJQUFhcHJCLE1BQWIsRUFBcUI7QUFDbkJBLGVBQU9vckIsSUFBUCxJQUFlcHJCLE9BQU9vckIsSUFBUCxFQUFhNytDLEdBQWIsQ0FBaUIsVUFBUzBHLE1BQVQsRUFBaUI7QUFDL0MsaUJBQU9BLE9BQU9tNkMsU0FBZDtBQUNELFNBRmMsRUFFWjJILElBRlksRUFBZjtBQUdEO0FBQ0QsYUFBTy8wQixNQUFQO0FBQ0Q7QUFyQm1CLEdBQXRCOztBQXdCQWxnQixXQUFTOHhDLFlBQVQsQ0FBc0I5eEMsUUFBdEIsRUFBZ0MsSUFBaEMsRUFBc0NuVSxPQUF0QyxFQUErQ0QsTUFBL0MsRUFBdUQsdUJBQXZEO0FBQ0QsQ0F6b0NELEVBeW9DR3NDLElBem9DSCxZQTBvQ1EsUUFBaUMsMEJBQTJCckMsT0FBNUQsR0FBc0UsSUExb0M5RSxFQTJvQ1EsUUFBZ0MsMEJBQTJCRCxNQUEzRCxHQUFvRSxJQTNvQzVFLEVBNG9DUSx1QkE1b0NSLEU7Ozs7Ozs7Ozs7Ozs7Ozs7QUNUQVMsT0FBTzRKLE9BQVAsR0FBaUIsbUJBQUF3SixDQUFTLEVBQVQsQ0FBakI7QUFDQSxJQUFNeTFDLGVBQWUsbUJBQUF6MUMsQ0FBUyxDQUFULENBQXJCO0FBQ0EsSUFBTTA0QixVQUFVbGlDLFFBQVE0M0IsU0FBUixDQUFtQixtQkFBQXB1QixDQUFTLEVBQVQsQ0FBbkIsQ0FBaEI7QUFDQSxJQUFNRixRQUFRLG1CQUFBRSxDQUFTLENBQVQsQ0FBZDtBQUNBLElBQU04K0IsY0FBYSxtQkFBQTkrQixDQUFTLEVBQVQsQ0FBbkI7QUFDQSxJQUFNa3FDLFNBQVEsbUJBQUFscUMsQ0FBUyxFQUFULENBQWQ7O0FBRUEsSUFBTWtCLHFCQUFxQixtQkFBQWxCLENBQVMsQ0FBVCxDQUEzQjtBQUNBLElBQU0rQyxvQkFBb0IsbUJBQUEvQyxDQUFTLENBQVQsQ0FBMUI7QUFDQSxJQUFNTyxXQUFXLG1CQUFBUCxDQUFTLENBQVQsQ0FBakI7QUFDQSxJQUFNNEMsZ0JBQWdCLG1CQUFBNUMsQ0FBUyxDQUFULENBQXRCOztBQUVBLElBQU00L0IsU0FBUyxtQkFBQTUvQixDQUFTLEVBQVQsQ0FBZjs7SUFFTTAxQyxRO0FBQ0Ysc0JBQWExMEMsTUFBYixFQUFzQjtBQUFBOztBQUNsQlQsaUJBQVM1QyxXQUFULENBQXNCcUQsTUFBdEIsRUFBOEI7QUFDMUJvQixrQkFBTTtBQUNGbEMsMEJBQVU7QUFEUixhQURvQjtBQUkxQnkxQyxvQkFBUTtBQUNKejFDLDBCQUFVLFFBRE47QUFFSnNnQywwQkFBVTtBQUZOLGFBSmtCO0FBUTFCMUgsbUJBQU87QUFDSDU0QiwwQkFBVTtBQURQLGFBUm1CO0FBVzFCMDFDLDBCQUFjO0FBQ1YxMUMsMEJBQVU7QUFEQTtBQVhZLFNBQTlCO0FBZUEsYUFBS3kxQyxNQUFMLEdBQWMzMEMsT0FBTzIwQyxNQUFyQjtBQUNBLGFBQUt2ekMsSUFBTCxHQUFZLE9BQU9wQixPQUFPb0IsSUFBZCxLQUF1QixRQUF2QixHQUFrQyxNQUFsQyxHQUEyQ3BCLE9BQU9vQixJQUE5RDtBQUNBLGFBQUswMkIsS0FBTCxHQUFhOTNCLE9BQU84M0IsS0FBUCxHQUFlOTNCLE9BQU84M0IsS0FBdEIsR0FBOEJqZixLQUFLaWYsS0FBaEQ7QUFDQSxhQUFLOGMsWUFBTCxHQUFvQjUwQyxPQUFPNDBDLFlBQTNCO0FBQ0EsYUFBS0MsR0FBTCxDQUFValcsTUFBVjtBQUNIOzs7O21DQUVXeCtCLEcsRUFBTTtBQUNkLG1CQUFPMDlCLFlBQVksS0FBSzE4QixJQUFqQixFQUF1QmhCLEdBQXZCLENBQVA7QUFDSDs7OzhCQUVNclQsRyxFQUFLMkUsSyxFQUFRO0FBQ2hCdzNDLG1CQUFNMTNDLEdBQU4sQ0FBYyxLQUFLbWpELE1BQW5CLFNBQTZCNW5ELEdBQTdCLEVBQW9DMkUsS0FBcEM7QUFDSDs7O2lDQUVTM0UsRyxFQUFNO0FBQ1osbUJBQU9tOEMsT0FBTWp5QyxHQUFOLENBQWMsS0FBSzA5QyxNQUFuQixTQUE2QjVuRCxHQUE3QixDQUFQO0FBQ0g7OzsrQkFFT0EsRyxFQUFNO0FBQ1YsbUJBQU9tOEMsT0FBTS9CLE1BQU4sQ0FBaUIsS0FBS3dOLE1BQXRCLFNBQWdDNW5ELEdBQWhDLENBQVA7QUFDSDs7O2tDQUVrQjtBQUNmLGdCQUFNcVMsVUFBVWMsOENBQWhCO0FBQ0EsbUJBQU82QixrQkFBbUIsS0FBSyt5QyxRQUFMLENBQWUxMUMsT0FBZixDQUFuQixFQUE2Q0EsT0FBN0MsQ0FBUDtBQUNIOzs7OEJBRWM7QUFDWCxnQkFBTUEsVUFBVWMsOENBQWhCO0FBQ0EsbUJBQU82QixrQkFBbUIsS0FBS2d6QyxJQUFMLENBQVczMUMsT0FBWCxDQUFuQixFQUF5Q0EsT0FBekMsQ0FBUDtBQUNIOzs7OEJBRWM7QUFDWCxnQkFBTUEsVUFBVWMsOENBQWhCO0FBQ0EsbUJBQU82QixrQkFBbUIsS0FBS2l6QyxJQUFMLENBQVc1MUMsT0FBWCxDQUFuQixFQUF5Q0EsT0FBekMsQ0FBUDtBQUNIOzs7K0JBRWU7QUFDWixnQkFBTUEsVUFBVWMsOENBQWhCO0FBQ0EsbUJBQU82QixrQkFBbUIsS0FBS2t6QyxLQUFMLENBQVk3MUMsT0FBWixDQUFuQixFQUEwQ0EsT0FBMUMsQ0FBUDtBQUNIOzs7a0NBRWlCO0FBQ2QsZ0JBQU1BLFVBQVVjLDhDQUFoQjtBQUNBLG1CQUFPNkIsa0JBQW1CLEtBQUttekMsT0FBTCxDQUFjOTFDLE9BQWQsQ0FBbkIsRUFBNENBLE9BQTVDLENBQVA7QUFDSDs7O2dDQUVnQjtBQUFBOztBQUNiLGdCQUFNQSxVQUFVYyw4Q0FBaEI7QUFDQSxnQkFBSUMsY0FBSjtBQUNBLGdCQUFNNkIsVUFBVXhNLFFBQVFtUSxHQUFSLENBQVksQ0FDeEJwRyxTQUFVSCxPQUFWLEVBQW1CO0FBQ2YwL0IsdUJBQU87QUFDSDUvQiw4QkFBVTtBQURQLGlCQURRO0FBSWZtNkIsMEJBQVU7QUFDTm1HLDhCQUFVO0FBREo7QUFKSyxhQUFuQixDQUR3QixFQVN4QmpnQyxTQUFVSCxPQUFWLEVBQW1CO0FBQ2ZnNkIsMEJBQVU7QUFDTmw2Qiw4QkFBVTtBQURKLGlCQURLO0FBSWZtNkIsMEJBQVU7QUFDTm1HLDhCQUFVO0FBREo7QUFKSyxhQUFuQixDQVR3QixDQUFaLEVBa0JmdjlCLElBbEJlLENBa0JWLFlBQU07QUFDUixvQkFBTTBxQixPQUFPO0FBQ1R3b0IsZ0NBQVksVUFESDtBQUVUL2IsOEJBQVVoNkIsUUFBUWc2QixRQUFSLElBQW9CaDZCLFFBQVEwL0IsS0FGN0I7QUFHVHpGLDhCQUFVajZCLFFBQVFpNkIsUUFIVDtBQUlUK2IsMkJBQU87QUFKRSxpQkFBYjtBQU1BLHVCQUFPLE1BQUtILEtBQUwsQ0FBVztBQUNkNzBDLHlCQUFLLFVBRFM7QUFFZHVzQjtBQUZjLGlCQUFYLENBQVA7QUFJSCxhQTdCZSxFQThCZjFxQixJQTlCZSxDQThCVixVQUFFSCxRQUFGLEVBQWdCO0FBQ2xCM0Isd0JBQVEyQixTQUFTNnFCLElBQVQsQ0FBYzBvQixZQUF0QjtBQUNBLG9CQUFLLE1BQUtULFlBQVYsRUFBeUI7QUFDckIsMEJBQUsxTCxLQUFMLENBQVksT0FBWixFQUFxQi9vQyxLQUFyQjtBQUNIO0FBQ0QsdUJBQU8sTUFBSzQwQyxJQUFMLENBQVcsZUFBWCxFQUE0QjUwQyxLQUE1QixDQUFQO0FBQ0gsYUFwQ2UsRUFxQ2Y4QixJQXJDZSxDQXFDVixVQUFFSCxRQUFGLEVBQWdCO0FBQ2xCLG9CQUFNd3pDLFNBQVMsSUFBSSxNQUFLMVcsTUFBVCxDQUFpQjk4QixTQUFTNnFCLElBQTFCLENBQWY7QUFDQTJvQix1QkFBT24xQyxLQUFQLEdBQWVBLEtBQWY7QUFDQSxvQkFBSyxDQUFDLE1BQUt5K0IsTUFBTCxDQUFZMlcsT0FBbEIsRUFBNEI7QUFDeEIsMEJBQUszVyxNQUFMLENBQVkyVyxPQUFaLEdBQXNCRCxNQUF0QjtBQUNBLHdCQUFLLE1BQUtWLFlBQVYsRUFBeUI7QUFDckIsOEJBQUsxTCxLQUFMLENBQVksUUFBWixFQUFzQm9NLE9BQU94K0MsSUFBN0I7QUFDSDtBQUNKO0FBQ0Qsc0JBQUttSyxJQUFMLENBQVcsT0FBWCxFQUFvQixJQUFJVyxhQUFKLENBQW1CLE9BQW5CLEVBQTRCMHpDLE1BQTVCLENBQXBCO0FBQ0EsdUJBQU9BLE1BQVA7QUFDSCxhQWhEZSxDQUFoQjtBQWlEQSxtQkFBT3Z6QyxrQkFBbUJDLE9BQW5CLEVBQTRCNUMsT0FBNUIsQ0FBUDtBQUNIOzs7aUNBRVE7QUFDTCxpQkFBS3cvQixNQUFMLENBQVkyVyxPQUFaLEdBQXNCemlELFNBQXRCO0FBQ0EsaUJBQUtxMEMsTUFBTCxDQUFhLE9BQWI7QUFDQSxpQkFBS0EsTUFBTCxDQUFhLFFBQWI7QUFDSDs7O2dDQUVRbU8sTSxFQUFTO0FBQ2QsaUJBQUsxVyxNQUFMLENBQVkyVyxPQUFaLEdBQXNCRCxNQUF0QjtBQUNBLGdCQUFLLEtBQUtWLFlBQVYsRUFBeUI7QUFDckIscUJBQUsxTCxLQUFMLENBQVksT0FBWixFQUFxQm9NLE9BQU94YixFQUE1QjtBQUNBLHFCQUFLb1AsS0FBTCxDQUFZLFFBQVosRUFBc0JvTSxPQUFPeCtDLElBQTdCO0FBQ0g7QUFDSjs7OzRCQUVJNndDLE0sRUFBUztBQUNWLGdCQUFLdDdDLE9BQU9pQixTQUFQLENBQWlCWSxjQUFqQixDQUFnQ1QsSUFBaEMsQ0FBc0MsSUFBdEMsRUFBNENrNkMsT0FBT3JqQyxJQUFuRCxDQUFMLEVBQWdFO0FBQzVELHNCQUFNLElBQUkvQixLQUFKLGtFQUF5RW9sQyxPQUFPcmpDLElBQWhGLG9DQUFOO0FBQ0g7QUFDRCxpQkFBS3FqQyxPQUFPcmpDLElBQVosSUFBb0JxakMsT0FBT2pKLFVBQVAsQ0FBbUIsSUFBbkIsQ0FBcEI7QUFDSDs7QUFFRDs7OztpQ0FFVXQvQixPLEVBQVU7QUFBQTs7QUFDaEIsbUJBQU9HLFNBQVVILE9BQVYsRUFBbUI7QUFDdEJnQixxQkFBSztBQUNEby9CLDhCQUFVLElBRFQ7QUFFRHRnQyw4QkFBVTtBQUZUO0FBRGlCLGFBQW5CLEVBTU4rQyxJQU5NLENBTUQsWUFBTTtBQUNSN0Msd0JBQVFnQixHQUFSLEdBQWMsT0FBSzA5QixVQUFMLENBQWlCMStCLFFBQVFnQixHQUF6QixDQUFkO0FBQ0Esb0JBQUssUUFBT2hCLFFBQVF1dEIsSUFBZixNQUF3QixRQUE3QixFQUF3QztBQUNwQ3Z0Qiw0QkFBUXV0QixJQUFSLEdBQWU5VCxLQUFLQyxTQUFMLENBQWdCMVosUUFBUXV0QixJQUF4QixDQUFmO0FBQ0F2dEIsNEJBQVFpNUIsSUFBUixHQUFlLElBQWY7QUFDSDtBQUNELG9CQUFNbDRCLFFBQVFmLFFBQVFlLEtBQVIsSUFBaUIsT0FBS3ExQyxRQUFMLENBQWUsT0FBZixDQUEvQjtBQUNBLG9CQUFLcjFDLFNBQVNmLFFBQVFtZ0MsU0FBUixLQUFzQixLQUFwQyxFQUE0QztBQUN4Q25nQyw0QkFBUSs0QixPQUFSLEdBQWtCcjVCLE1BQU9NLFFBQVErNEIsT0FBZixFQUF3QjtBQUN0Q3NkLG1EQUF5QnQxQztBQURhLHFCQUF4QixDQUFsQjtBQUdIO0FBQ0QsdUJBQU91M0IsUUFBU3Q0QixPQUFULEVBQ042QyxJQURNLENBQ0QsVUFBRUgsUUFBRixFQUFnQjtBQUNsQix3QkFBSyxPQUFPQSxTQUFTNnFCLElBQWhCLEtBQXlCLFFBQTlCLEVBQXlDO0FBQ3JDN3FCLGlDQUFTNnFCLElBQVQsR0FBZ0IsT0FBS21MLEtBQUwsQ0FBWWgyQixTQUFTNnFCLElBQXJCLENBQWhCO0FBQ0g7QUFDRCx3QkFBSzdxQixTQUFTdzVCLFVBQVQsSUFBdUIsR0FBNUIsRUFBa0M7QUFDOUIsK0JBQU85bEMsUUFBUW1LLE1BQVIsQ0FBZ0IsSUFBSTRDLEtBQUosQ0FBV1QsU0FBUzZxQixJQUFwQixDQUFoQixDQUFQO0FBQ0g7QUFDRCwyQkFBSzFyQixJQUFMLENBQVcsVUFBWCxFQUF1QixJQUFJVyxhQUFKLENBQW1CLFVBQW5CLEVBQStCRSxRQUEvQixDQUF2QjtBQUNBLDJCQUFPQSxRQUFQO0FBQ0gsaUJBVk0sQ0FBUDtBQVdILGFBN0JNLENBQVA7QUE4Qkg7OzsrQkFFZTtBQUNaLGdCQUFNNlMsT0FBTzdWLE1BQU0sRUFBTixFQUFVb0IsOENBQVYsRUFBeUM7QUFDbEQwVCx3QkFBUTtBQUQwQyxhQUF6QyxDQUFiO0FBR0EsbUJBQU8sS0FBS2toQyxRQUFMLENBQWVuZ0MsSUFBZixDQUFQO0FBQ0g7OzsrQkFFZTtBQUNaLGdCQUFNQSxPQUFPN1YsTUFBTSxFQUFOLEVBQVVvQiw4Q0FBVixFQUF5QztBQUNsRDBULHdCQUFRLEtBRDBDO0FBRWxEeWtCLHNCQUFNO0FBRjRDLGFBQXpDLENBQWI7QUFJQSxtQkFBTyxLQUFLeWMsUUFBTCxDQUFlbmdDLElBQWYsQ0FBUDtBQUNIOzs7Z0NBRWdCO0FBQ2IsZ0JBQU1BLE9BQU83VixNQUFNLEVBQU4sRUFBVW9CLDhDQUFWLEVBQXlDO0FBQ2xEMFQsd0JBQVEsTUFEMEM7QUFFbER5a0Isc0JBQU07QUFGNEMsYUFBekMsQ0FBYjtBQUlBLG1CQUFPLEtBQUt5YyxRQUFMLENBQWVuZ0MsSUFBZixDQUFQO0FBQ0g7OztrQ0FFa0I7QUFDZixnQkFBTUEsT0FBTzdWLE1BQU0sRUFBTixFQUFVb0IsOENBQVYsRUFBeUM7QUFDbEQwVCx3QkFBUTtBQUQwQyxhQUF6QyxDQUFiO0FBR0EsbUJBQU8sS0FBS2toQyxRQUFMLENBQWVuZ0MsSUFBZixDQUFQO0FBQ0g7Ozs7OztBQUdMKy9CLFNBQVM5eUMsYUFBVCxHQUF5QkEsYUFBekI7O0FBRUE2eUMsYUFBY0MsU0FBU3BuRCxTQUF2Qjs7QUFFQW5DLE9BQU9DLE9BQVAsR0FBaUJzcEQsUUFBakIsQzs7Ozs7Ozs7Ozs7Ozs7OztBQ2pPQSxJQUFNNTFDLFFBQVEsbUJBQUFFLENBQVMsQ0FBVCxDQUFkO0FBQ0EsSUFBTStqQyxPQUFPLG1CQUFBL2pDLENBQVMsRUFBVCxDQUFiO0FBQ0EsSUFBTXkxQyxlQUFlLG1CQUFBejFDLENBQVMsQ0FBVCxDQUFyQjs7QUFFQSxJQUFNTyxXQUFXLG1CQUFBUCxDQUFTLENBQVQsQ0FBakI7QUFDQSxJQUFNa0IscUJBQXFCLG1CQUFBbEIsQ0FBUyxDQUFULENBQTNCO0FBQ0EsSUFBTStDLG9CQUFvQixtQkFBQS9DLENBQVMsQ0FBVCxDQUExQjtBQUNBLElBQU00QyxnQkFBZ0IsbUJBQUE1QyxDQUFTLENBQVQsQ0FBdEI7O0lBRU15L0IsTTtBQUVGLG9CQUFhRSxRQUFiLEVBQXVCakQsUUFBdkIsRUFBaUMxN0IsTUFBakMsRUFBMEM7QUFBQTs7QUFDdEMsYUFBSzIrQixRQUFMLEdBQWdCQSxRQUFoQjtBQUNBLGFBQUtFLElBQUwsR0FBWSxFQUFaO0FBQ0EsYUFBS3AzQixLQUFMLEdBQWEsRUFBYjtBQUNBLGFBQUszUSxJQUFMLEdBQVk0a0MsWUFBWSxFQUF4QjtBQUNBLGFBQUtxRCxVQUFMLEdBQWtCLEVBQWxCO0FBQ0EsWUFBSy8rQixNQUFMLEVBQWM7QUFDVlQscUJBQVM1QyxXQUFULENBQXNCcUQsTUFBdEIsRUFBOEI7QUFDMUIrNUIscUJBQUs7QUFDRDc2Qiw4QkFBVTtBQURUO0FBRHFCLGFBQTlCO0FBS0EsZ0JBQUtjLE9BQU8rNUIsR0FBWixFQUFrQjtBQUNkLHFCQUFLRCxFQUFMLEdBQVU5NUIsT0FBTys1QixHQUFqQjtBQUNIO0FBQ0o7QUFDSjs7OzttQ0FFVTtBQUFFO0FBQ1QsbUJBQU92a0MsUUFBUTZJLE9BQVIsRUFBUDtBQUNIOzs7Z0NBRWdCO0FBQUE7O0FBQ2IsZ0JBQU1lLFVBQVVjLDhDQUFoQjtBQUNBZCxvQkFBUWUsS0FBUixHQUFnQixLQUFLQSxLQUFyQjtBQUNBZixvQkFBUWdCLEdBQVIsR0FBY2hCLFFBQVFnQixHQUFSLElBQWUsS0FBS3MxQyxNQUFMLENBQWEsS0FBYixDQUE3QjtBQUNBLGdCQUFNMXpDLFVBQVUsS0FBS3pDLFFBQUwsQ0FBZSxLQUFmLEVBQXNCSCxPQUF0QixFQUNmNkMsSUFEZSxDQUNWO0FBQUEsdUJBQU0sTUFBSzA4QixRQUFMLENBQWNvVyxJQUFkLENBQW9CMzFDLE9BQXBCLENBQU47QUFBQSxhQURVLEVBRWY2QyxJQUZlLENBRVYsVUFBRUgsUUFBRixFQUFnQjtBQUNsQmhELHNCQUFPLE1BQUtoSSxJQUFaLEVBQWtCaXNDLEtBQU1qaEMsU0FBUzZxQixJQUFmLEVBQXFCLE1BQUtrUyxJQUExQixDQUFsQjtBQUNBLHNCQUFLNTlCLElBQUwsQ0FBVyxPQUFYLEVBQW9CLElBQUlXLGFBQUosQ0FBbUIsT0FBbkIsRUFBNEJFLFFBQTVCLENBQXBCO0FBQ0EsdUJBQU9BLFFBQVA7QUFDSCxhQU5lLENBQWhCO0FBT0EsbUJBQU9DLGtCQUFtQkMsT0FBbkIsRUFBNEI1QyxPQUE1QixDQUFQO0FBQ0g7OzsrQkFFZTtBQUFBOztBQUNaLGdCQUFNQSxVQUFVYyw4Q0FBaEI7QUFDQSxnQkFBS2QsUUFBUXV0QixJQUFiLEVBQW9CO0FBQ2hCLHFCQUFLbjdCLEdBQUwsQ0FBVTROLFFBQVF1dEIsSUFBbEI7QUFDSDtBQUNEdnRCLG9CQUFRZSxLQUFSLEdBQWdCLEtBQUtBLEtBQXJCO0FBQ0FmLG9CQUFRdXRCLElBQVIsR0FBZW9XLEtBQU0sS0FBS2pzQyxJQUFYLEVBQWlCLEtBQUsyUSxLQUF0QixDQUFmO0FBQ0FySSxvQkFBUXdVLE1BQVIsR0FBaUJ4VSxRQUFRd1UsTUFBUixLQUFvQixLQUFLa21CLEVBQUwsR0FBVSxLQUFWLEdBQWtCLE1BQXRDLENBQWpCO0FBQ0ExNkIsb0JBQVFnQixHQUFSLEdBQWNoQixRQUFRZ0IsR0FBUixJQUFlLEtBQUtzMUMsTUFBTCxDQUFhdDJDLFFBQVF3VSxNQUFyQixDQUE3QjtBQUNBLGdCQUFNZSxPQUFPLEtBQUtnaEMsaUJBQUwsQ0FBd0IsTUFBeEIsRUFBZ0N2MkMsT0FBaEMsQ0FBYjtBQUNBLGdCQUFNNEMsVUFBVSxLQUFLekMsUUFBTCxDQUFlb1YsS0FBS2YsTUFBcEIsRUFBNEJlLEtBQUtnWSxJQUFqQyxFQUNmMXFCLElBRGUsQ0FDVjtBQUFBLHVCQUFNLE9BQUswOEIsUUFBTCxDQUFjbVcsUUFBZCxDQUF3Qm5nQyxJQUF4QixDQUFOO0FBQUEsYUFEVSxFQUVmMVMsSUFGZSxDQUVWLFVBQUVILFFBQUYsRUFBZ0I7QUFDbEIsdUJBQUt0USxHQUFMLENBQVVzUSxTQUFTNnFCLElBQW5CO0FBQ0Esb0JBQUs3cUIsU0FBUzZxQixJQUFULENBQWNvTixHQUFuQixFQUF5QjtBQUNyQiwyQkFBS2pqQyxJQUFMLENBQVVpakMsR0FBVixHQUFnQmo0QixTQUFTNnFCLElBQVQsQ0FBY29OLEdBQTlCO0FBQ0EsMkJBQUtELEVBQUwsR0FBVWg0QixTQUFTNnFCLElBQVQsQ0FBY29OLEdBQXhCO0FBQ0g7QUFDRCx1QkFBSzk0QixJQUFMLENBQVcsTUFBWCxFQUFtQixJQUFJVyxhQUFKLENBQW1CLE1BQW5CLEVBQTJCRSxRQUEzQixDQUFuQjtBQUNBLHVCQUFPQSxRQUFQO0FBQ0gsYUFWZSxDQUFoQjtBQVdBLG1CQUFPQyxrQkFBbUJDLE9BQW5CLEVBQTRCNUMsT0FBNUIsQ0FBUDtBQUNIOzs7a0NBRVM7QUFBQTs7QUFDTixtQkFBTyxLQUFLRyxRQUFMLENBQWUsUUFBZixFQUNOMEMsSUFETSxDQUNEO0FBQUEsdUJBQU0sT0FBSzA4QixRQUFMLENBQWN1VyxPQUFkLENBQXVCLE9BQUtRLE1BQUwsQ0FBYSxRQUFiLENBQXZCLENBQU47QUFBQSxhQURDLEVBRU56ekMsSUFGTSxDQUVELFVBQUVILFFBQUYsRUFBZ0I7QUFDbEIsdUJBQUtnNEIsRUFBTCxHQUFVaG5DLFNBQVY7QUFDQSx1QkFBS2dFLElBQUwsQ0FBVWdqQyxFQUFWLEdBQWVobkMsU0FBZjtBQUNBLHVCQUFPZ1AsUUFBUDtBQUNILGFBTk0sQ0FBUDtBQU9IOzs7NEJBRUkrb0MsSSxFQUFPO0FBQ1IsbUJBQU8sT0FBT0EsSUFBUCxLQUFnQixRQUFoQixHQUEyQixLQUFLL3pDLElBQUwsQ0FBVSt6QyxJQUFWLENBQTNCLEdBQTZDOUgsS0FBTSxLQUFLanNDLElBQVgsRUFBaUIrekMsSUFBakIsQ0FBcEQ7QUFDSDs7OzRCQUVJQSxJLEVBQU1uNUMsSyxFQUFRO0FBQ2YsZ0JBQUssUUFBT201QyxJQUFQLHlDQUFPQSxJQUFQLE9BQWdCLFFBQXJCLEVBQWdDO0FBQzVCL3JDLHNCQUFPLEtBQUtoSSxJQUFaLEVBQWtCaXNDLEtBQU04SCxJQUFOLEVBQVksS0FBS3BqQyxLQUFqQixDQUFsQjtBQUNILGFBRkQsTUFHSyxJQUFLLEtBQUtBLEtBQUwsQ0FBV211QyxRQUFYLENBQXFCL0ssSUFBckIsQ0FBTCxFQUFrQztBQUNuQyxxQkFBSy96QyxJQUFMLENBQVUrekMsSUFBVixJQUFrQm41QyxLQUFsQjtBQUNIO0FBQ0o7OzswQ0FFa0JraUIsTSxFQUFRZSxJLEVBQU87QUFDOUIsbUJBQU8sUUFBTyxLQUFLb3FCLFVBQVosTUFBMkIsUUFBM0IsSUFDSCxPQUFPLEtBQUtBLFVBQUwsQ0FBZ0JuckIsTUFBaEIsQ0FBUCxLQUFtQyxVQURoQyxHQUM2QyxLQUFLbXJCLFVBQUwsQ0FBZ0JuckIsTUFBaEIsRUFBeUJlLElBQXpCLENBRDdDLEdBQytFQSxJQUR0RjtBQUVIOzs7aUNBRXdCO0FBQUEsOENBQVA3aUIsSUFBTztBQUFQQSxvQkFBTztBQUFBOztBQUNyQixnQkFBTStqRCw4Q0FBZSxJQUFmLGdCQUF3Qi9qRCxJQUF4QixLQUFOO0FBQ0EsbUJBQU8rakQsU0FBUzdXLElBQVQsR0FDTi84QixJQURNLENBQ0Q7QUFBQSx1QkFBTTR6QyxRQUFOO0FBQUEsYUFEQyxDQUFQO0FBRUg7Ozs7OztBQUtMcEIsYUFBY2hXLE9BQU9ueEMsU0FBckI7O0FBRUFuQyxPQUFPQyxPQUFQLEdBQWlCcXpDLE1BQWpCLEMiLCJmaWxlIjoiZGlzdC9icmlua2JpdC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkJyaW5rYml0XCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIkJyaW5rYml0XCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbiBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNDgpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDg1NmU4Y2M1YTk1YzE2MjhlODgyIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsInZhciBhc3NpZ24gPSBtYWtlX2Fzc2lnbigpXG52YXIgY3JlYXRlID0gbWFrZV9jcmVhdGUoKVxudmFyIHRyaW0gPSBtYWtlX3RyaW0oKVxudmFyIEdsb2JhbCA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbClcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGFzc2lnbjogYXNzaWduLFxuXHRjcmVhdGU6IGNyZWF0ZSxcblx0dHJpbTogdHJpbSxcblx0YmluZDogYmluZCxcblx0c2xpY2U6IHNsaWNlLFxuXHRlYWNoOiBlYWNoLFxuXHRtYXA6IG1hcCxcblx0cGx1Y2s6IHBsdWNrLFxuXHRpc0xpc3Q6IGlzTGlzdCxcblx0aXNGdW5jdGlvbjogaXNGdW5jdGlvbixcblx0aXNPYmplY3Q6IGlzT2JqZWN0LFxuXHRHbG9iYWw6IEdsb2JhbFxufVxuXG5mdW5jdGlvbiBtYWtlX2Fzc2lnbigpIHtcblx0aWYgKE9iamVjdC5hc3NpZ24pIHtcblx0XHRyZXR1cm4gT2JqZWN0LmFzc2lnblxuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBmdW5jdGlvbiBzaGltQXNzaWduKG9iaiwgcHJvcHMxLCBwcm9wczIsIGV0Yykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0ZWFjaChPYmplY3QoYXJndW1lbnRzW2ldKSwgZnVuY3Rpb24odmFsLCBrZXkpIHtcblx0XHRcdFx0XHRvYmpba2V5XSA9IHZhbFxuXHRcdFx0XHR9KVxuXHRcdFx0fVx0XHRcdFxuXHRcdFx0cmV0dXJuIG9ialxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBtYWtlX2NyZWF0ZSgpIHtcblx0aWYgKE9iamVjdC5jcmVhdGUpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gY3JlYXRlKG9iaiwgYXNzaWduUHJvcHMxLCBhc3NpZ25Qcm9wczIsIGV0Yykge1xuXHRcdFx0dmFyIGFzc2lnbkFyZ3NMaXN0ID0gc2xpY2UoYXJndW1lbnRzLCAxKVxuXHRcdFx0cmV0dXJuIGFzc2lnbi5hcHBseSh0aGlzLCBbT2JqZWN0LmNyZWF0ZShvYmopXS5jb25jYXQoYXNzaWduQXJnc0xpc3QpKVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRmdW5jdGlvbiBGKCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1pbm5lci1kZWNsYXJhdGlvbnNcblx0XHRyZXR1cm4gZnVuY3Rpb24gY3JlYXRlKG9iaiwgYXNzaWduUHJvcHMxLCBhc3NpZ25Qcm9wczIsIGV0Yykge1xuXHRcdFx0dmFyIGFzc2lnbkFyZ3NMaXN0ID0gc2xpY2UoYXJndW1lbnRzLCAxKVxuXHRcdFx0Ri5wcm90b3R5cGUgPSBvYmpcblx0XHRcdHJldHVybiBhc3NpZ24uYXBwbHkodGhpcywgW25ldyBGKCldLmNvbmNhdChhc3NpZ25BcmdzTGlzdCkpXG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIG1ha2VfdHJpbSgpIHtcblx0aWYgKFN0cmluZy5wcm90b3R5cGUudHJpbSkge1xuXHRcdHJldHVybiBmdW5jdGlvbiB0cmltKHN0cikge1xuXHRcdFx0cmV0dXJuIFN0cmluZy5wcm90b3R5cGUudHJpbS5jYWxsKHN0cilcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHRyaW0oc3RyKSB7XG5cdFx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLCAnJylcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYmluZChvYmosIGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZm4uYXBwbHkob2JqLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKVxuXHR9XG59XG5cbmZ1bmN0aW9uIHNsaWNlKGFyciwgaW5kZXgpIHtcblx0cmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyciwgaW5kZXggfHwgMClcbn1cblxuZnVuY3Rpb24gZWFjaChvYmosIGZuKSB7XG5cdHBsdWNrKG9iaiwgZnVuY3Rpb24odmFsLCBrZXkpIHtcblx0XHRmbih2YWwsIGtleSlcblx0XHRyZXR1cm4gZmFsc2Vcblx0fSlcbn1cblxuZnVuY3Rpb24gbWFwKG9iaiwgZm4pIHtcblx0dmFyIHJlcyA9IChpc0xpc3Qob2JqKSA/IFtdIDoge30pXG5cdHBsdWNrKG9iaiwgZnVuY3Rpb24odiwgaykge1xuXHRcdHJlc1trXSA9IGZuKHYsIGspXG5cdFx0cmV0dXJuIGZhbHNlXG5cdH0pXG5cdHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gcGx1Y2sob2JqLCBmbikge1xuXHRpZiAoaXNMaXN0KG9iaikpIHtcblx0XHRmb3IgKHZhciBpPTA7IGk8b2JqLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoZm4ob2JqW2ldLCBpKSkge1xuXHRcdFx0XHRyZXR1cm4gb2JqW2ldXG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGZvciAodmFyIGtleSBpbiBvYmopIHtcblx0XHRcdGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRpZiAoZm4ob2JqW2tleV0sIGtleSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqW2tleV1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBpc0xpc3QodmFsKSB7XG5cdHJldHVybiAodmFsICE9IG51bGwgJiYgdHlwZW9mIHZhbCAhPSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWwubGVuZ3RoID09ICdudW1iZXInKVxufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xuXHRyZXR1cm4gdmFsICYmIHt9LnRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJ1xufVxuXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcblx0cmV0dXJuIHZhbCAmJiB7fS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IE9iamVjdF0nXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3N0b3JlL3NyYy91dGlsLmpzIiwiLyoqXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUZsYWdzID0gL1xcdyokLztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBzdXBwb3J0ZWQgYnkgYF8uY2xvbmVgLiAqL1xudmFyIGNsb25lYWJsZVRhZ3MgPSB7fTtcbmNsb25lYWJsZVRhZ3NbYXJnc1RhZ10gPSBjbG9uZWFibGVUYWdzW2FycmF5VGFnXSA9XG5jbG9uZWFibGVUYWdzW2FycmF5QnVmZmVyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0YVZpZXdUYWddID1cbmNsb25lYWJsZVRhZ3NbYm9vbFRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGVUYWddID1cbmNsb25lYWJsZVRhZ3NbZmxvYXQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW2Zsb2F0NjRUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDE2VGFnXSA9XG5jbG9uZWFibGVUYWdzW2ludDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbbWFwVGFnXSA9XG5jbG9uZWFibGVUYWdzW251bWJlclRhZ10gPSBjbG9uZWFibGVUYWdzW29iamVjdFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tyZWdleHBUYWddID0gY2xvbmVhYmxlVGFnc1tzZXRUYWddID1cbmNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3ltYm9sVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cbmNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQWRkcyB0aGUga2V5LXZhbHVlIGBwYWlyYCB0byBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXIgVGhlIGtleS12YWx1ZSBwYWlyIHRvIGFkZC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG1hcGAuXG4gKi9cbmZ1bmN0aW9uIGFkZE1hcEVudHJ5KG1hcCwgcGFpcikge1xuICAvLyBEb24ndCByZXR1cm4gYG1hcC5zZXRgIGJlY2F1c2UgaXQncyBub3QgY2hhaW5hYmxlIGluIElFIDExLlxuICBtYXAuc2V0KHBhaXJbMF0sIHBhaXJbMV0pO1xuICByZXR1cm4gbWFwO1xufVxuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byBgc2V0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFkZC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYHNldGAuXG4gKi9cbmZ1bmN0aW9uIGFkZFNldEVudHJ5KHNldCwgdmFsdWUpIHtcbiAgLy8gRG9uJ3QgcmV0dXJuIGBzZXQuYWRkYCBiZWNhdXNlIGl0J3Mgbm90IGNoYWluYWJsZSBpbiBJRSAxMS5cbiAgc2V0LmFkZCh2YWx1ZSk7XG4gIHJldHVybiBzZXQ7XG59XG5cbi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRBY2N1bV0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXG4gKiAgdGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UmVkdWNlKGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QgaW4gSUUgPCA5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNIb3N0T2JqZWN0KHZhbHVlKSB7XG4gIC8vIE1hbnkgaG9zdCBvYmplY3RzIGFyZSBgT2JqZWN0YCBvYmplY3RzIHRoYXQgY2FuIGNvZXJjZSB0byBzdHJpbmdzXG4gIC8vIGRlc3BpdGUgaGF2aW5nIGltcHJvcGVybHkgZGVmaW5lZCBgdG9TdHJpbmdgIG1ldGhvZHMuXG4gIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gISEodmFsdWUgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXG4gICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgU3ltYm9sID0gcm9vdC5TeW1ib2wsXG4gICAgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheSxcbiAgICBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KSxcbiAgICBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlLFxuICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxcbiAgICBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KSxcbiAgICBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpLFxuICAgIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyksXG4gICAgUHJvbWlzZSA9IGdldE5hdGl2ZShyb290LCAnUHJvbWlzZScpLFxuICAgIFNldCA9IGdldE5hdGl2ZShyb290LCAnU2V0JyksXG4gICAgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpLFxuICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPyBlbnRyaWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICByZXR1cm4gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPyBlbnRyaWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLnNldChrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX19bJ2RlbGV0ZSddKGtleSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgY2FjaGUgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoY2FjaGUgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBjYWNoZS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY2FjaGUgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBjYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIC8vIFNhZmFyaSA4LjEgbWFrZXMgYGFyZ3VtZW50cy5jYWxsZWVgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIC8vIFNhZmFyaSA5IG1ha2VzIGBhcmd1bWVudHMubGVuZ3RoYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxuICB2YXIgcmVzdWx0ID0gKGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSlcbiAgICA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZylcbiAgICA6IFtdO1xuXG4gIHZhciBsZW5ndGggPSByZXN1bHQubGVuZ3RoLFxuICAgICAgc2tpcEluZGV4ZXMgPSAhIWxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChrZXkgPT0gJ2xlbmd0aCcgfHwgaXNJbmRleChrZXksIGxlbmd0aCkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFzc2lnblZhbHVlYCBleGNlcHQgdGhhdCBpdCBkb2Vzbid0IGFzc2lnblxuICogYHVuZGVmaW5lZGAgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmICgodmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZXEob2JqZWN0W2tleV0sIHZhbHVlKSkgfHxcbiAgICAgICh0eXBlb2Yga2V5ID09ICdudW1iZXInICYmIHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCBhbmQgYF8uY2xvbmVEZWVwYCB3aGljaCB0cmFja3NcbiAqIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0Z1bGxdIFNwZWNpZnkgYSBjbG9uZSBpbmNsdWRpbmcgc3ltYm9scy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIG9iamVjdHMgYW5kIHRoZWlyIGNsb25lIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgaXNEZWVwLCBpc0Z1bGwsIGN1c3RvbWl6ZXIsIGtleSwgb2JqZWN0LCBzdGFjaykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoY3VzdG9taXplcikge1xuICAgIHJlc3VsdCA9IG9iamVjdCA/IGN1c3RvbWl6ZXIodmFsdWUsIGtleSwgb2JqZWN0LCBzdGFjaykgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgfVxuICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpO1xuICBpZiAoaXNBcnIpIHtcbiAgICByZXN1bHQgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgaWYgKCFpc0RlZXApIHtcbiAgICAgIHJldHVybiBjb3B5QXJyYXkodmFsdWUsIHJlc3VsdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLFxuICAgICAgICBpc0Z1bmMgPSB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xuXG4gICAgaWYgKGlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGNsb25lQnVmZmVyKHZhbHVlLCBpc0RlZXApO1xuICAgIH1cbiAgICBpZiAodGFnID09IG9iamVjdFRhZyB8fCB0YWcgPT0gYXJnc1RhZyB8fCAoaXNGdW5jICYmICFvYmplY3QpKSB7XG4gICAgICBpZiAoaXNIb3N0T2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGluaXRDbG9uZU9iamVjdChpc0Z1bmMgPyB7fSA6IHZhbHVlKTtcbiAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgIHJldHVybiBjb3B5U3ltYm9scyh2YWx1ZSwgYmFzZUFzc2lnbihyZXN1bHQsIHZhbHVlKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghY2xvbmVhYmxlVGFnc1t0YWddKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPyB2YWx1ZSA6IHt9O1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gaW5pdENsb25lQnlUYWcodmFsdWUsIHRhZywgYmFzZUNsb25lLCBpc0RlZXApO1xuICAgIH1cbiAgfVxuICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyBhbmQgcmV0dXJuIGl0cyBjb3JyZXNwb25kaW5nIGNsb25lLlxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldCh2YWx1ZSk7XG4gIGlmIChzdGFja2VkKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQ7XG4gIH1cbiAgc3RhY2suc2V0KHZhbHVlLCByZXN1bHQpO1xuXG4gIGlmICghaXNBcnIpIHtcbiAgICB2YXIgcHJvcHMgPSBpc0Z1bGwgPyBnZXRBbGxLZXlzKHZhbHVlKSA6IGtleXModmFsdWUpO1xuICB9XG4gIGFycmF5RWFjaChwcm9wcyB8fCB2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgIGlmIChwcm9wcykge1xuICAgICAga2V5ID0gc3ViVmFsdWU7XG4gICAgICBzdWJWYWx1ZSA9IHZhbHVlW2tleV07XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgYXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgaXNEZWVwLCBpc0Z1bGwsIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYmFzZUNyZWF0ZShwcm90bykge1xuICByZXR1cm4gaXNPYmplY3QocHJvdG8pID8gb2JqZWN0Q3JlYXRlKHByb3RvKSA6IHt9O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IChpc0Z1bmN0aW9uKHZhbHVlKSB8fCBpc0hvc3RPYmplY3QodmFsdWUpKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKV07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xuICB9XG4gIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdlZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKG9iamVjdCA9PT0gc291cmNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghKGlzQXJyYXkoc291cmNlKSB8fCBpc1R5cGVkQXJyYXkoc291cmNlKSkpIHtcbiAgICB2YXIgcHJvcHMgPSBiYXNlS2V5c0luKHNvdXJjZSk7XG4gIH1cbiAgYXJyYXlFYWNoKHByb3BzIHx8IHNvdXJjZSwgZnVuY3Rpb24oc3JjVmFsdWUsIGtleSkge1xuICAgIGlmIChwcm9wcykge1xuICAgICAga2V5ID0gc3JjVmFsdWU7XG4gICAgICBzcmNWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgYmFzZU1lcmdlLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgICAgfVxuICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlTWVyZ2VgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgbWVyZ2VzIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIG1lcmdlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gbWVyZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWVyZ2VGdW5jIFRoZSBmdW5jdGlvbiB0byBtZXJnZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgbWVyZ2VGdW5jLCBjdXN0b21pemVyLCBzdGFjaykge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgIHNyY1ZhbHVlID0gc291cmNlW2tleV0sXG4gICAgICBzdGFja2VkID0gc3RhY2suZ2V0KHNyY1ZhbHVlKTtcblxuICBpZiAoc3RhY2tlZCkge1xuICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHN0YWNrZWQpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgPyBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIHZhciBpc0NvbW1vbiA9IG5ld1ZhbHVlID09PSB1bmRlZmluZWQ7XG5cbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICBpZiAoaXNBcnJheShzcmNWYWx1ZSkgfHwgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKSkge1xuICAgICAgaWYgKGlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0FycmF5TGlrZU9iamVjdChvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBjb3B5QXJyYXkob2JqVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gYmFzZUNsb25lKHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChzcmNWYWx1ZSkgfHwgaXNBcmd1bWVudHMoc3JjVmFsdWUpKSB7XG4gICAgICBpZiAoaXNBcmd1bWVudHMob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gdG9QbGFpbk9iamVjdChvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICghaXNPYmplY3Qob2JqVmFsdWUpIHx8IChzcmNJbmRleCAmJiBpc0Z1bmN0aW9uKG9ialZhbHVlKSkpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBiYXNlQ2xvbmUoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgbWVyZ2VGdW5jKG5ld1ZhbHVlLCBzcmNWYWx1ZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xuICB9XG4gIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gYXJyYXk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG4gIGlmIChpc0RlZXApIHtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IG5ldyBidWZmZXIuY29uc3RydWN0b3IoYnVmZmVyLmxlbmd0aCk7XG4gIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGRhdGFWaWV3YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFWaWV3IFRoZSBkYXRhIHZpZXcgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGRhdGEgdmlldy5cbiAqL1xuZnVuY3Rpb24gY2xvbmVEYXRhVmlldyhkYXRhVmlldywgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKGRhdGFWaWV3LmJ1ZmZlcikgOiBkYXRhVmlldy5idWZmZXI7XG4gIHJldHVybiBuZXcgZGF0YVZpZXcuY29uc3RydWN0b3IoYnVmZmVyLCBkYXRhVmlldy5ieXRlT2Zmc2V0LCBkYXRhVmlldy5ieXRlTGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNsb25lRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2xvbmUgdmFsdWVzLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBtYXAuXG4gKi9cbmZ1bmN0aW9uIGNsb25lTWFwKG1hcCwgaXNEZWVwLCBjbG9uZUZ1bmMpIHtcbiAgdmFyIGFycmF5ID0gaXNEZWVwID8gY2xvbmVGdW5jKG1hcFRvQXJyYXkobWFwKSwgdHJ1ZSkgOiBtYXBUb0FycmF5KG1hcCk7XG4gIHJldHVybiBhcnJheVJlZHVjZShhcnJheSwgYWRkTWFwRW50cnksIG5ldyBtYXAuY29uc3RydWN0b3IpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgcmVnZXhwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHJlZ2V4cCBUaGUgcmVnZXhwIHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHJlZ2V4cC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVSZWdFeHAocmVnZXhwKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgcmVnZXhwLmNvbnN0cnVjdG9yKHJlZ2V4cC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhyZWdleHApKTtcbiAgcmVzdWx0Lmxhc3RJbmRleCA9IHJlZ2V4cC5sYXN0SW5kZXg7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBzZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbG9uZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNsb25lIHZhbHVlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc2V0LlxuICovXG5mdW5jdGlvbiBjbG9uZVNldChzZXQsIGlzRGVlcCwgY2xvbmVGdW5jKSB7XG4gIHZhciBhcnJheSA9IGlzRGVlcCA/IGNsb25lRnVuYyhzZXRUb0FycmF5KHNldCksIHRydWUpIDogc2V0VG9BcnJheShzZXQpO1xuICByZXR1cm4gYXJyYXlSZWR1Y2UoYXJyYXksIGFkZFNldEVudHJ5LCBuZXcgc2V0LmNvbnN0cnVjdG9yKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGBzeW1ib2xgIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHN5bWJvbCBUaGUgc3ltYm9sIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzeW1ib2wgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjbG9uZVN5bWJvbChzeW1ib2wpIHtcbiAgcmV0dXJuIHN5bWJvbFZhbHVlT2YgPyBPYmplY3Qoc3ltYm9sVmFsdWVPZi5jYWxsKHN5bWJvbCkpIDoge307XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59XG5cbi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUgPT09IHVuZGVmaW5lZCA/IHNvdXJjZVtrZXldIDogbmV3VmFsdWUpO1xuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbi8qKlxuICogQ29waWVzIG93biBzeW1ib2wgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHMoc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHtcbiAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkLFxuICAgICAgICBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgY3VzdG9taXplciA9IChhc3NpZ25lci5sZW5ndGggPiAzICYmIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpXG4gICAgICA/IChsZW5ndGgtLSwgY3VzdG9taXplcilcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgbGVuZ3RoID0gMTtcbiAgICB9XG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2wgcHJvcGVydGllcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyA9IG5hdGl2ZUdldFN5bWJvbHMgPyBvdmVyQXJnKG5hdGl2ZUdldFN5bWJvbHMsIE9iamVjdCkgOiBzdHViQXJyYXk7XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSxcbi8vIGZvciBkYXRhIHZpZXdzIGluIEVkZ2UgPCAxNCwgYW5kIHByb21pc2VzIGluIE5vZGUuanMuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgLy8gQWRkIHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cbiAgaWYgKGxlbmd0aCAmJiB0eXBlb2YgYXJyYXlbMF0gPT0gJ3N0cmluZycgJiYgaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgJ2luZGV4JykpIHtcbiAgICByZXN1bHQuaW5kZXggPSBhcnJheS5pbmRleDtcbiAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgIDoge307XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lIGJhc2VkIG9uIGl0cyBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY2xvbmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2xvbmVGdW5jIFRoZSBmdW5jdGlvbiB0byBjbG9uZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUJ5VGFnKG9iamVjdCwgdGFnLCBjbG9uZUZ1bmMsIGlzRGVlcCkge1xuICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgcmV0dXJuIGNsb25lQXJyYXlCdWZmZXIob2JqZWN0KTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3IoK29iamVjdCk7XG5cbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgcmV0dXJuIGNsb25lRGF0YVZpZXcob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBmbG9hdDMyVGFnOiBjYXNlIGZsb2F0NjRUYWc6XG4gICAgY2FzZSBpbnQ4VGFnOiBjYXNlIGludDE2VGFnOiBjYXNlIGludDMyVGFnOlxuICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVUeXBlZEFycmF5KG9iamVjdCwgaXNEZWVwKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgcmV0dXJuIGNsb25lTWFwKG9iamVjdCwgaXNEZWVwLCBjbG9uZUZ1bmMpO1xuXG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgcmV0dXJuIGNsb25lUmVnRXhwKG9iamVjdCk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVNldChvYmplY3QsIGlzRGVlcCwgY2xvbmVGdW5jKTtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgcmV0dXJuIGNsb25lU3ltYm9sKG9iamVjdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJlxuICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICkge1xuICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAvLyBTYWZhcmkgOC4xIG1ha2VzIGBhcmd1bWVudHMuY2FsbGVlYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxuICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICghcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpIHx8IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFyZ3NUYWcpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDgtOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gaXNPYmplY3QodmFsdWUpID8gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8XG4gICAgICBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSAhPSBvYmplY3RUYWcgfHwgaXNIb3N0T2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiZcbiAgICBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJiBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmdcbiAqIGtleWVkIHByb3BlcnRpZXMgb2YgYHZhbHVlYCB0byBvd24gcHJvcGVydGllcyBvZiB0aGUgcGxhaW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbyk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBfLnRvUGxhaW5PYmplY3QobmV3IEZvbykpO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAqL1xuZnVuY3Rpb24gdG9QbGFpbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY29weU9iamVjdCh2YWx1ZSwga2V5c0luKHZhbHVlKSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgbWVyZ2VzIG93biBhbmRcbiAqIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIGludG8gdGhlXG4gKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBhcmVcbiAqIHNraXBwZWQgaWYgYSBkZXN0aW5hdGlvbiB2YWx1ZSBleGlzdHMuIEFycmF5IGFuZCBwbGFpbiBvYmplY3QgcHJvcGVydGllc1xuICogYXJlIG1lcmdlZCByZWN1cnNpdmVseS4gT3RoZXIgb2JqZWN0cyBhbmQgdmFsdWUgdHlwZXMgYXJlIG92ZXJyaWRkZW4gYnlcbiAqIGFzc2lnbm1lbnQuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC4gU3Vic2VxdWVudFxuICogc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuNS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7XG4gKiAgICdhJzogW3sgJ2InOiAyIH0sIHsgJ2QnOiA0IH1dXG4gKiB9O1xuICpcbiAqIHZhciBvdGhlciA9IHtcbiAqICAgJ2EnOiBbeyAnYyc6IDMgfSwgeyAnZSc6IDUgfV1cbiAqIH07XG4gKlxuICogXy5tZXJnZShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IDIsICdjJzogMyB9LCB7ICdkJzogNCwgJ2UnOiA1IH1dIH1cbiAqL1xudmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KSB7XG4gIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpO1xufSk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZXJnZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoLm1lcmdlL2luZGV4LmpzIiwiY29uc3QgdmFsaWRhdGVKcyA9IHJlcXVpcmUoICd2YWxpZGF0ZS5qcycgKTtcblxudmFsaWRhdGVKcy52YWxpZGF0b3JzLmRhdGFUeXBlID0gZnVuY3Rpb24gdmFsaWRhdGVEYXRhVHlwZSggdmFsdWUsIG9wdGlvbnMgKSB7XG4gICAgcmV0dXJuICggdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWxpZGF0ZUpzW2BpcyR7dmFsaWRhdGVKcy5jYXBpdGFsaXplKCBvcHRpb25zICl9YF0oIHZhbHVlICkpID8gbnVsbCA6IGBpcyBub3Qgb2YgdHlwZSAke29wdGlvbnN9YDtcbn07XG5cbmNvbnN0IFZhbGlkYXRpb25FcnJvciA9IHJlcXVpcmUoICcuL3ZhbGlkYXRpb25FcnJvcicgKTtcblxuY29uc3QgdmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSggYXR0cmlidXRlcywgY29uc3RyYWludHMgKSB7XG4gICAgY29uc3QgaW52YWxpZCA9IHZhbGlkYXRlSnMoIGF0dHJpYnV0ZXMsIGNvbnN0cmFpbnRzICk7XG4gICAgaWYgKCBpbnZhbGlkICkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoIG5ldyBWYWxpZGF0aW9uRXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogaW52YWxpZC5lcnJvcixcbiAgICAgICAgICAgIGRldGFpbHM6IGludmFsaWQsXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xufTtcblxudmFsaWRhdGUuY29uc3RydWN0b3IgPSBmdW5jdGlvbiB2YWxpZGF0ZUNvbnN0cnVjdG9yKCBjb25maWcsIGNvbnN0cmFpbnRzICkge1xuICAgIGlmICggdHlwZW9mIGNvbmZpZyAhPT0gJ29iamVjdCcgKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoICdjb25maWcgbXVzdCBiZSBhbiBvYmplY3QnICk7XG4gICAgfVxuICAgIGNvbnN0IGludmFsaWQgPSB2YWxpZGF0ZUpzKCBjb25maWcsIGNvbnN0cmFpbnRzICk7XG4gICAgaWYgKCBpbnZhbGlkICkge1xuICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGludmFsaWQuZXJyb3IsXG4gICAgICAgICAgICBkZXRhaWxzOiBpbnZhbGlkLFxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHZhbGlkYXRlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3ZhbGlkYXRlL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVBcmd1bWVudHMoIC4uLmFyZ3MgKSB7XG4gICAgbGV0IG9wdGlvbnMgPSB7fTtcbiAgICBpZiAoIHR5cGVvZiBhcmdzWzBdID09PSAnb2JqZWN0JyApIHtcbiAgICAgICAgb3B0aW9ucyA9IGFyZ3NbMF07XG4gICAgfVxuICAgIGVsc2UgaWYgKCB0eXBlb2YgYXJnc1sxXSA9PT0gJ29iamVjdCcgKSB7XG4gICAgICAgIG9wdGlvbnMgPSBhcmdzWzFdO1xuICAgIH1cbiAgICBlbHNlIGlmICggdHlwZW9mIGFyZ3NbMV0gPT09ICdzdHJpbmcnICkge1xuICAgICAgICBvcHRpb25zLnRva2VuID0gYXJnc1sxXTtcbiAgICB9XG4gICAgaWYgKCB0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgIG9wdGlvbnMudXJpID0gYXJnc1swXTtcbiAgICB9XG4gICAgaWYgKCBhcmdzLmxlbmd0aCA+IDAgJiYgdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgb3B0aW9ucy5jYWxsYmFjayA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3ZhbGlkYXRlL25vcm1hbGl6ZUFyZ3VtZW50cy5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGQgICAgICAgID0gcmVxdWlyZSgnZCcpXG4gICwgY2FsbGFibGUgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC92YWxpZC1jYWxsYWJsZScpXG5cbiAgLCBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSwgY2FsbCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsXG4gICwgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSwgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHlcbiAgLCBkZWZpbmVQcm9wZXJ0aWVzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXNcbiAgLCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBkZXNjcmlwdG9yID0geyBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSB9XG5cbiAgLCBvbiwgb25jZSwgb2ZmLCBlbWl0LCBtZXRob2RzLCBkZXNjcmlwdG9ycywgYmFzZTtcblxub24gPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcblx0dmFyIGRhdGE7XG5cblx0Y2FsbGFibGUobGlzdGVuZXIpO1xuXG5cdGlmICghaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnX19lZV9fJykpIHtcblx0XHRkYXRhID0gZGVzY3JpcHRvci52YWx1ZSA9IGNyZWF0ZShudWxsKTtcblx0XHRkZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX19lZV9fJywgZGVzY3JpcHRvcik7XG5cdFx0ZGVzY3JpcHRvci52YWx1ZSA9IG51bGw7XG5cdH0gZWxzZSB7XG5cdFx0ZGF0YSA9IHRoaXMuX19lZV9fO1xuXHR9XG5cdGlmICghZGF0YVt0eXBlXSkgZGF0YVt0eXBlXSA9IGxpc3RlbmVyO1xuXHRlbHNlIGlmICh0eXBlb2YgZGF0YVt0eXBlXSA9PT0gJ29iamVjdCcpIGRhdGFbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG5cdGVsc2UgZGF0YVt0eXBlXSA9IFtkYXRhW3R5cGVdLCBsaXN0ZW5lcl07XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5vbmNlID0gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XG5cdHZhciBvbmNlLCBzZWxmO1xuXG5cdGNhbGxhYmxlKGxpc3RlbmVyKTtcblx0c2VsZiA9IHRoaXM7XG5cdG9uLmNhbGwodGhpcywgdHlwZSwgb25jZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRvZmYuY2FsbChzZWxmLCB0eXBlLCBvbmNlKTtcblx0XHRhcHBseS5jYWxsKGxpc3RlbmVyLCB0aGlzLCBhcmd1bWVudHMpO1xuXHR9KTtcblxuXHRvbmNlLl9fZWVPbmNlTGlzdGVuZXJfXyA9IGxpc3RlbmVyO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbm9mZiA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xuXHR2YXIgZGF0YSwgbGlzdGVuZXJzLCBjYW5kaWRhdGUsIGk7XG5cblx0Y2FsbGFibGUobGlzdGVuZXIpO1xuXG5cdGlmICghaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnX19lZV9fJykpIHJldHVybiB0aGlzO1xuXHRkYXRhID0gdGhpcy5fX2VlX187XG5cdGlmICghZGF0YVt0eXBlXSkgcmV0dXJuIHRoaXM7XG5cdGxpc3RlbmVycyA9IGRhdGFbdHlwZV07XG5cblx0aWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdvYmplY3QnKSB7XG5cdFx0Zm9yIChpID0gMDsgKGNhbmRpZGF0ZSA9IGxpc3RlbmVyc1tpXSk7ICsraSkge1xuXHRcdFx0aWYgKChjYW5kaWRhdGUgPT09IGxpc3RlbmVyKSB8fFxuXHRcdFx0XHRcdChjYW5kaWRhdGUuX19lZU9uY2VMaXN0ZW5lcl9fID09PSBsaXN0ZW5lcikpIHtcblx0XHRcdFx0aWYgKGxpc3RlbmVycy5sZW5ndGggPT09IDIpIGRhdGFbdHlwZV0gPSBsaXN0ZW5lcnNbaSA/IDAgOiAxXTtcblx0XHRcdFx0ZWxzZSBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRpZiAoKGxpc3RlbmVycyA9PT0gbGlzdGVuZXIpIHx8XG5cdFx0XHRcdChsaXN0ZW5lcnMuX19lZU9uY2VMaXN0ZW5lcl9fID09PSBsaXN0ZW5lcikpIHtcblx0XHRcdGRlbGV0ZSBkYXRhW3R5cGVdO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuZW1pdCA9IGZ1bmN0aW9uICh0eXBlKSB7XG5cdHZhciBpLCBsLCBsaXN0ZW5lciwgbGlzdGVuZXJzLCBhcmdzO1xuXG5cdGlmICghaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnX19lZV9fJykpIHJldHVybjtcblx0bGlzdGVuZXJzID0gdGhpcy5fX2VlX19bdHlwZV07XG5cdGlmICghbGlzdGVuZXJzKSByZXR1cm47XG5cblx0aWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdvYmplY3QnKSB7XG5cdFx0bCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0YXJncyA9IG5ldyBBcnJheShsIC0gMSk7XG5cdFx0Zm9yIChpID0gMTsgaSA8IGw7ICsraSkgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cblx0XHRsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoKTtcblx0XHRmb3IgKGkgPSAwOyAobGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV0pOyArK2kpIHtcblx0XHRcdGFwcGx5LmNhbGwobGlzdGVuZXIsIHRoaXMsIGFyZ3MpO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRjYXNlIDE6XG5cdFx0XHRjYWxsLmNhbGwobGlzdGVuZXJzLCB0aGlzKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgMjpcblx0XHRcdGNhbGwuY2FsbChsaXN0ZW5lcnMsIHRoaXMsIGFyZ3VtZW50c1sxXSk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDM6XG5cdFx0XHRjYWxsLmNhbGwobGlzdGVuZXJzLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG5cdFx0XHRicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0bCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0XHRhcmdzID0gbmV3IEFycmF5KGwgLSAxKTtcblx0XHRcdGZvciAoaSA9IDE7IGkgPCBsOyArK2kpIHtcblx0XHRcdFx0YXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cdFx0XHR9XG5cdFx0XHRhcHBseS5jYWxsKGxpc3RlbmVycywgdGhpcywgYXJncyk7XG5cdFx0fVxuXHR9XG59O1xuXG5tZXRob2RzID0ge1xuXHRvbjogb24sXG5cdG9uY2U6IG9uY2UsXG5cdG9mZjogb2ZmLFxuXHRlbWl0OiBlbWl0XG59O1xuXG5kZXNjcmlwdG9ycyA9IHtcblx0b246IGQob24pLFxuXHRvbmNlOiBkKG9uY2UpLFxuXHRvZmY6IGQob2ZmKSxcblx0ZW1pdDogZChlbWl0KVxufTtcblxuYmFzZSA9IGRlZmluZVByb3BlcnRpZXMoe30sIGRlc2NyaXB0b3JzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZnVuY3Rpb24gKG8pIHtcblx0cmV0dXJuIChvID09IG51bGwpID8gY3JlYXRlKGJhc2UpIDogZGVmaW5lUHJvcGVydGllcyhPYmplY3QobyksIGRlc2NyaXB0b3JzKTtcbn07XG5leHBvcnRzLm1ldGhvZHMgPSBtZXRob2RzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9ldmVudC1lbWl0dGVyL2luZGV4LmpzIiwiY2xhc3MgQnJpbmtiaXRFdmVudCB7XG4gICAgY29uc3RydWN0b3IoIGV2ZW50VHlwZSwgcmVzcG9uc2UgKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IGV2ZW50VHlwZTtcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCcmlua2JpdEV2ZW50O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2V2ZW50cy9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplUmVzcG9uc2UoIHByb21pc2UsIG9wdGlvbnMgKSB7XG4gICAgcmV0dXJuIHByb21pc2UudGhlbigoIGRhdGEgKSA9PiB7XG4gICAgICAgIGlmICggdHlwZW9mIG9wdGlvbnMuY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKCBudWxsLCBkYXRhICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCB0eXBlb2Ygb3B0aW9ucy5zdWNjZXNzID09PSAnZnVuY3Rpb24nICkge1xuICAgICAgICAgICAgb3B0aW9ucy5zdWNjZXNzKCBkYXRhICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSlcbiAgICAuY2F0Y2goKCBlcnJvciApID0+IHtcbiAgICAgICAgaWYgKCB0eXBlb2Ygb3B0aW9ucy5jYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmNhbGxiYWNrKCBlcnJvciApO1xuICAgICAgICB9XG4gICAgICAgIGlmICggdHlwZW9mIG9wdGlvbnMuZXJyb3IgPT09ICdmdW5jdGlvbicgKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5lcnJvciggZXJyb3IgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoIGVycm9yICk7XG4gICAgfSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3ZhbGlkYXRlL25vcm1hbGl6ZVJlc3BvbnNlLmpzIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcHJvY2Vzcy9icm93c2VyLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsImNvbnN0IGN1c3RvbUVycm9yID0gcmVxdWlyZSggJ2N1c3RvbS1lcnJvci1pbnN0YW5jZScgKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjdXN0b21FcnJvciggJ1ZhbGlkYXRpb25FcnJvcicsIHtcbiAgICBtZXNzYWdlOiAnVmFsaWRhdGlvbiBmYWlsZWQnLFxuICAgIGRldGFpbHM6IFtdLFxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdmFsaWRhdGUvdmFsaWRhdGlvbkVycm9yLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcclxuXHR0aHJvdyBuZXcgRXJyb3IoXCJkZWZpbmUgY2Fubm90IGJlIHVzZWQgaW5kaXJlY3RcIik7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2FtZC1kZWZpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIEBwcmVzZXJ2ZVxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE3IFBldGthIEFudG9ub3ZcbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqIFxuICovXG4vKipcbiAqIGJsdWViaXJkIGJ1aWxkIHZlcnNpb24gMy41LjBcbiAqIEZlYXR1cmVzIGVuYWJsZWQ6IGNvcmUsIHJhY2UsIGNhbGxfZ2V0LCBnZW5lcmF0b3JzLCBtYXAsIG5vZGVpZnksIHByb21pc2lmeSwgcHJvcHMsIHJlZHVjZSwgc2V0dGxlLCBzb21lLCB1c2luZywgdGltZXJzLCBmaWx0ZXIsIGFueSwgZWFjaFxuKi9cbiFmdW5jdGlvbihlKXtpZihcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSltb2R1bGUuZXhwb3J0cz1lKCk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQpZGVmaW5lKFtdLGUpO2Vsc2V7dmFyIGY7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz9mPXdpbmRvdzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2Y9Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiYoZj1zZWxmKSxmLlByb21pc2U9ZSgpfX0oZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIF9kZXJlcV89PVwiZnVuY3Rpb25cIiYmX2RlcmVxXztpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgX2RlcmVxXz09XCJmdW5jdGlvblwiJiZfZGVyZXFfO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSkge1xudmFyIFNvbWVQcm9taXNlQXJyYXkgPSBQcm9taXNlLl9Tb21lUHJvbWlzZUFycmF5O1xuZnVuY3Rpb24gYW55KHByb21pc2VzKSB7XG4gICAgdmFyIHJldCA9IG5ldyBTb21lUHJvbWlzZUFycmF5KHByb21pc2VzKTtcbiAgICB2YXIgcHJvbWlzZSA9IHJldC5wcm9taXNlKCk7XG4gICAgcmV0LnNldEhvd01hbnkoMSk7XG4gICAgcmV0LnNldFVud3JhcCgpO1xuICAgIHJldC5pbml0KCk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cblByb21pc2UuYW55ID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgcmV0dXJuIGFueShwcm9taXNlcyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5hbnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFueSh0aGlzKTtcbn07XG5cbn07XG5cbn0se31dLDI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZmlyc3RMaW5lRXJyb3I7XG50cnkge3Rocm93IG5ldyBFcnJvcigpOyB9IGNhdGNoIChlKSB7Zmlyc3RMaW5lRXJyb3IgPSBlO31cbnZhciBzY2hlZHVsZSA9IF9kZXJlcV8oXCIuL3NjaGVkdWxlXCIpO1xudmFyIFF1ZXVlID0gX2RlcmVxXyhcIi4vcXVldWVcIik7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG5cbmZ1bmN0aW9uIEFzeW5jKCkge1xuICAgIHRoaXMuX2N1c3RvbVNjaGVkdWxlciA9IGZhbHNlO1xuICAgIHRoaXMuX2lzVGlja1VzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9sYXRlUXVldWUgPSBuZXcgUXVldWUoMTYpO1xuICAgIHRoaXMuX25vcm1hbFF1ZXVlID0gbmV3IFF1ZXVlKDE2KTtcbiAgICB0aGlzLl9oYXZlRHJhaW5lZFF1ZXVlcyA9IGZhbHNlO1xuICAgIHRoaXMuX3RyYW1wb2xpbmVFbmFibGVkID0gdHJ1ZTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5kcmFpblF1ZXVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5fZHJhaW5RdWV1ZXMoKTtcbiAgICB9O1xuICAgIHRoaXMuX3NjaGVkdWxlID0gc2NoZWR1bGU7XG59XG5cbkFzeW5jLnByb3RvdHlwZS5zZXRTY2hlZHVsZXIgPSBmdW5jdGlvbihmbikge1xuICAgIHZhciBwcmV2ID0gdGhpcy5fc2NoZWR1bGU7XG4gICAgdGhpcy5fc2NoZWR1bGUgPSBmbjtcbiAgICB0aGlzLl9jdXN0b21TY2hlZHVsZXIgPSB0cnVlO1xuICAgIHJldHVybiBwcmV2O1xufTtcblxuQXN5bmMucHJvdG90eXBlLmhhc0N1c3RvbVNjaGVkdWxlciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9jdXN0b21TY2hlZHVsZXI7XG59O1xuXG5Bc3luYy5wcm90b3R5cGUuZW5hYmxlVHJhbXBvbGluZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3RyYW1wb2xpbmVFbmFibGVkID0gdHJ1ZTtcbn07XG5cbkFzeW5jLnByb3RvdHlwZS5kaXNhYmxlVHJhbXBvbGluZUlmTmVjZXNzYXJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHV0aWwuaGFzRGV2VG9vbHMpIHtcbiAgICAgICAgdGhpcy5fdHJhbXBvbGluZUVuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG59O1xuXG5Bc3luYy5wcm90b3R5cGUuaGF2ZUl0ZW1zUXVldWVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1RpY2tVc2VkIHx8IHRoaXMuX2hhdmVEcmFpbmVkUXVldWVzO1xufTtcblxuXG5Bc3luYy5wcm90b3R5cGUuZmF0YWxFcnJvciA9IGZ1bmN0aW9uKGUsIGlzTm9kZSkge1xuICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgcHJvY2Vzcy5zdGRlcnIud3JpdGUoXCJGYXRhbCBcIiArIChlIGluc3RhbmNlb2YgRXJyb3IgPyBlLnN0YWNrIDogZSkgK1xuICAgICAgICAgICAgXCJcXG5cIik7XG4gICAgICAgIHByb2Nlc3MuZXhpdCgyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRocm93TGF0ZXIoZSk7XG4gICAgfVxufTtcblxuQXN5bmMucHJvdG90eXBlLnRocm93TGF0ZXIgPSBmdW5jdGlvbihmbiwgYXJnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgYXJnID0gZm47XG4gICAgICAgIGZuID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBhcmc7IH07XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm4oYXJnKTtcbiAgICAgICAgfSwgMCk7XG4gICAgfSBlbHNlIHRyeSB7XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm4oYXJnKTtcbiAgICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBhc3luYyBzY2hlZHVsZXIgYXZhaWxhYmxlXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBBc3luY0ludm9rZUxhdGVyKGZuLCByZWNlaXZlciwgYXJnKSB7XG4gICAgdGhpcy5fbGF0ZVF1ZXVlLnB1c2goZm4sIHJlY2VpdmVyLCBhcmcpO1xuICAgIHRoaXMuX3F1ZXVlVGljaygpO1xufVxuXG5mdW5jdGlvbiBBc3luY0ludm9rZShmbiwgcmVjZWl2ZXIsIGFyZykge1xuICAgIHRoaXMuX25vcm1hbFF1ZXVlLnB1c2goZm4sIHJlY2VpdmVyLCBhcmcpO1xuICAgIHRoaXMuX3F1ZXVlVGljaygpO1xufVxuXG5mdW5jdGlvbiBBc3luY1NldHRsZVByb21pc2VzKHByb21pc2UpIHtcbiAgICB0aGlzLl9ub3JtYWxRdWV1ZS5fcHVzaE9uZShwcm9taXNlKTtcbiAgICB0aGlzLl9xdWV1ZVRpY2soKTtcbn1cblxuaWYgKCF1dGlsLmhhc0RldlRvb2xzKSB7XG4gICAgQXN5bmMucHJvdG90eXBlLmludm9rZUxhdGVyID0gQXN5bmNJbnZva2VMYXRlcjtcbiAgICBBc3luYy5wcm90b3R5cGUuaW52b2tlID0gQXN5bmNJbnZva2U7XG4gICAgQXN5bmMucHJvdG90eXBlLnNldHRsZVByb21pc2VzID0gQXN5bmNTZXR0bGVQcm9taXNlcztcbn0gZWxzZSB7XG4gICAgQXN5bmMucHJvdG90eXBlLmludm9rZUxhdGVyID0gZnVuY3Rpb24gKGZuLCByZWNlaXZlciwgYXJnKSB7XG4gICAgICAgIGlmICh0aGlzLl90cmFtcG9saW5lRW5hYmxlZCkge1xuICAgICAgICAgICAgQXN5bmNJbnZva2VMYXRlci5jYWxsKHRoaXMsIGZuLCByZWNlaXZlciwgYXJnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGZuLmNhbGwocmVjZWl2ZXIsIGFyZyk7XG4gICAgICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEFzeW5jLnByb3RvdHlwZS5pbnZva2UgPSBmdW5jdGlvbiAoZm4sIHJlY2VpdmVyLCBhcmcpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyYW1wb2xpbmVFbmFibGVkKSB7XG4gICAgICAgICAgICBBc3luY0ludm9rZS5jYWxsKHRoaXMsIGZuLCByZWNlaXZlciwgYXJnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGZuLmNhbGwocmVjZWl2ZXIsIGFyZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBBc3luYy5wcm90b3R5cGUuc2V0dGxlUHJvbWlzZXMgPSBmdW5jdGlvbihwcm9taXNlKSB7XG4gICAgICAgIGlmICh0aGlzLl90cmFtcG9saW5lRW5hYmxlZCkge1xuICAgICAgICAgICAgQXN5bmNTZXR0bGVQcm9taXNlcy5jYWxsKHRoaXMsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fc2V0dGxlUHJvbWlzZXMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuQXN5bmMucHJvdG90eXBlLl9kcmFpblF1ZXVlID0gZnVuY3Rpb24ocXVldWUpIHtcbiAgICB3aGlsZSAocXVldWUubGVuZ3RoKCkgPiAwKSB7XG4gICAgICAgIHZhciBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZm4uX3NldHRsZVByb21pc2VzKCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVjZWl2ZXIgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICB2YXIgYXJnID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgZm4uY2FsbChyZWNlaXZlciwgYXJnKTtcbiAgICB9XG59O1xuXG5Bc3luYy5wcm90b3R5cGUuX2RyYWluUXVldWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2RyYWluUXVldWUodGhpcy5fbm9ybWFsUXVldWUpO1xuICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgdGhpcy5faGF2ZURyYWluZWRRdWV1ZXMgPSB0cnVlO1xuICAgIHRoaXMuX2RyYWluUXVldWUodGhpcy5fbGF0ZVF1ZXVlKTtcbn07XG5cbkFzeW5jLnByb3RvdHlwZS5fcXVldWVUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5faXNUaWNrVXNlZCkge1xuICAgICAgICB0aGlzLl9pc1RpY2tVc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGUodGhpcy5kcmFpblF1ZXVlcyk7XG4gICAgfVxufTtcblxuQXN5bmMucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9pc1RpY2tVc2VkID0gZmFsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFzeW5jO1xubW9kdWxlLmV4cG9ydHMuZmlyc3RMaW5lRXJyb3IgPSBmaXJzdExpbmVFcnJvcjtcblxufSx7XCIuL3F1ZXVlXCI6MjYsXCIuL3NjaGVkdWxlXCI6MjksXCIuL3V0aWxcIjozNn1dLDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIElOVEVSTkFMLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBkZWJ1Zykge1xudmFyIGNhbGxlZEJpbmQgPSBmYWxzZTtcbnZhciByZWplY3RUaGlzID0gZnVuY3Rpb24oXywgZSkge1xuICAgIHRoaXMuX3JlamVjdChlKTtcbn07XG5cbnZhciB0YXJnZXRSZWplY3RlZCA9IGZ1bmN0aW9uKGUsIGNvbnRleHQpIHtcbiAgICBjb250ZXh0LnByb21pc2VSZWplY3Rpb25RdWV1ZWQgPSB0cnVlO1xuICAgIGNvbnRleHQuYmluZGluZ1Byb21pc2UuX3RoZW4ocmVqZWN0VGhpcywgcmVqZWN0VGhpcywgbnVsbCwgdGhpcywgZSk7XG59O1xuXG52YXIgYmluZGluZ1Jlc29sdmVkID0gZnVuY3Rpb24odGhpc0FyZywgY29udGV4dCkge1xuICAgIGlmICgoKHRoaXMuX2JpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSkge1xuICAgICAgICB0aGlzLl9yZXNvbHZlQ2FsbGJhY2soY29udGV4dC50YXJnZXQpO1xuICAgIH1cbn07XG5cbnZhciBiaW5kaW5nUmVqZWN0ZWQgPSBmdW5jdGlvbihlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFjb250ZXh0LnByb21pc2VSZWplY3Rpb25RdWV1ZWQpIHRoaXMuX3JlamVjdChlKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAodGhpc0FyZykge1xuICAgIGlmICghY2FsbGVkQmluZCkge1xuICAgICAgICBjYWxsZWRCaW5kID0gdHJ1ZTtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3Byb3BhZ2F0ZUZyb20gPSBkZWJ1Zy5wcm9wYWdhdGVGcm9tRnVuY3Rpb24oKTtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2JvdW5kVmFsdWUgPSBkZWJ1Zy5ib3VuZFZhbHVlRnVuY3Rpb24oKTtcbiAgICB9XG4gICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UodGhpc0FyZyk7XG4gICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICByZXQuX3Byb3BhZ2F0ZUZyb20odGhpcywgMSk7XG4gICAgdmFyIHRhcmdldCA9IHRoaXMuX3RhcmdldCgpO1xuICAgIHJldC5fc2V0Qm91bmRUbyhtYXliZVByb21pc2UpO1xuICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgICAgICAgcHJvbWlzZVJlamVjdGlvblF1ZXVlZDogZmFsc2UsXG4gICAgICAgICAgICBwcm9taXNlOiByZXQsXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgIGJpbmRpbmdQcm9taXNlOiBtYXliZVByb21pc2VcbiAgICAgICAgfTtcbiAgICAgICAgdGFyZ2V0Ll90aGVuKElOVEVSTkFMLCB0YXJnZXRSZWplY3RlZCwgdW5kZWZpbmVkLCByZXQsIGNvbnRleHQpO1xuICAgICAgICBtYXliZVByb21pc2UuX3RoZW4oXG4gICAgICAgICAgICBiaW5kaW5nUmVzb2x2ZWQsIGJpbmRpbmdSZWplY3RlZCwgdW5kZWZpbmVkLCByZXQsIGNvbnRleHQpO1xuICAgICAgICByZXQuX3NldE9uQ2FuY2VsKG1heWJlUHJvbWlzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0Ll9yZXNvbHZlQ2FsbGJhY2sodGFyZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRCb3VuZFRvID0gZnVuY3Rpb24gKG9iaikge1xuICAgIGlmIChvYmogIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMjA5NzE1MjtcbiAgICAgICAgdGhpcy5fYm91bmRUbyA9IG9iajtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkICYgKH4yMDk3MTUyKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNCb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMjA5NzE1MikgPT09IDIwOTcxNTI7XG59O1xuXG5Qcm9taXNlLmJpbmQgPSBmdW5jdGlvbiAodGhpc0FyZywgdmFsdWUpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS5iaW5kKHRoaXNBcmcpO1xufTtcbn07XG5cbn0se31dLDQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgb2xkO1xuaWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiKSBvbGQgPSBQcm9taXNlO1xuZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICB0cnkgeyBpZiAoUHJvbWlzZSA9PT0gYmx1ZWJpcmQpIFByb21pc2UgPSBvbGQ7IH1cbiAgICBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gYmx1ZWJpcmQ7XG59XG52YXIgYmx1ZWJpcmQgPSBfZGVyZXFfKFwiLi9wcm9taXNlXCIpKCk7XG5ibHVlYmlyZC5ub0NvbmZsaWN0ID0gbm9Db25mbGljdDtcbm1vZHVsZS5leHBvcnRzID0gYmx1ZWJpcmQ7XG5cbn0se1wiLi9wcm9taXNlXCI6MjJ9XSw1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xudmFyIGNyID0gT2JqZWN0LmNyZWF0ZTtcbmlmIChjcikge1xuICAgIHZhciBjYWxsZXJDYWNoZSA9IGNyKG51bGwpO1xuICAgIHZhciBnZXR0ZXJDYWNoZSA9IGNyKG51bGwpO1xuICAgIGNhbGxlckNhY2hlW1wiIHNpemVcIl0gPSBnZXR0ZXJDYWNoZVtcIiBzaXplXCJdID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlKSB7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG52YXIgY2FuRXZhbHVhdGUgPSB1dGlsLmNhbkV2YWx1YXRlO1xudmFyIGlzSWRlbnRpZmllciA9IHV0aWwuaXNJZGVudGlmaWVyO1xuXG52YXIgZ2V0TWV0aG9kQ2FsbGVyO1xudmFyIGdldEdldHRlcjtcbmlmICghdHJ1ZSkge1xudmFyIG1ha2VNZXRob2RDYWxsZXIgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJlbnN1cmVNZXRob2RcIiwgXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgZW5zdXJlTWV0aG9kKG9iaiwgJ21ldGhvZE5hbWUnKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgc3dpdGNoKGxlbikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG9iai5tZXRob2ROYW1lKHRoaXNbMF0pOyAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG9iai5tZXRob2ROYW1lKHRoaXNbMF0sIHRoaXNbMV0pOyAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIG9iai5tZXRob2ROYW1lKHRoaXNbMF0sIHRoaXNbMV0sIHRoaXNbMl0pOyAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG9iai5tZXRob2ROYW1lKCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqLm1ldGhvZE5hbWUuYXBwbHkob2JqLCB0aGlzKTsgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICB9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICBcIi5yZXBsYWNlKC9tZXRob2ROYW1lL2csIG1ldGhvZE5hbWUpKShlbnN1cmVNZXRob2QpO1xufTtcblxudmFyIG1ha2VHZXR0ZXIgPSBmdW5jdGlvbiAocHJvcGVydHlOYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcIm9ialwiLCBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICd1c2Ugc3RyaWN0JzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIHJldHVybiBvYmoucHJvcGVydHlOYW1lOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIFwiLnJlcGxhY2UoXCJwcm9wZXJ0eU5hbWVcIiwgcHJvcGVydHlOYW1lKSk7XG59O1xuXG52YXIgZ2V0Q29tcGlsZWQgPSBmdW5jdGlvbihuYW1lLCBjb21waWxlciwgY2FjaGUpIHtcbiAgICB2YXIgcmV0ID0gY2FjaGVbbmFtZV07XG4gICAgaWYgKHR5cGVvZiByZXQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBpZiAoIWlzSWRlbnRpZmllcihuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0ID0gY29tcGlsZXIobmFtZSk7XG4gICAgICAgIGNhY2hlW25hbWVdID0gcmV0O1xuICAgICAgICBjYWNoZVtcIiBzaXplXCJdKys7XG4gICAgICAgIGlmIChjYWNoZVtcIiBzaXplXCJdID4gNTEyKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNhY2hlKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIGRlbGV0ZSBjYWNoZVtrZXlzW2ldXTtcbiAgICAgICAgICAgIGNhY2hlW1wiIHNpemVcIl0gPSBrZXlzLmxlbmd0aCAtIDI1NjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuZ2V0TWV0aG9kQ2FsbGVyID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiBnZXRDb21waWxlZChuYW1lLCBtYWtlTWV0aG9kQ2FsbGVyLCBjYWxsZXJDYWNoZSk7XG59O1xuXG5nZXRHZXR0ZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIGdldENvbXBpbGVkKG5hbWUsIG1ha2VHZXR0ZXIsIGdldHRlckNhY2hlKTtcbn07XG59XG5cbmZ1bmN0aW9uIGVuc3VyZU1ldGhvZChvYmosIG1ldGhvZE5hbWUpIHtcbiAgICB2YXIgZm47XG4gICAgaWYgKG9iaiAhPSBudWxsKSBmbiA9IG9ialttZXRob2ROYW1lXTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIk9iamVjdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcob2JqKSArIFwiIGhhcyBubyBtZXRob2QgJ1wiICtcbiAgICAgICAgICAgIHV0aWwudG9TdHJpbmcobWV0aG9kTmFtZSkgKyBcIidcIjtcbiAgICAgICAgdGhyb3cgbmV3IFByb21pc2UuVHlwZUVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gZm47XG59XG5cbmZ1bmN0aW9uIGNhbGxlcihvYmopIHtcbiAgICB2YXIgbWV0aG9kTmFtZSA9IHRoaXMucG9wKCk7XG4gICAgdmFyIGZuID0gZW5zdXJlTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSk7XG4gICAgcmV0dXJuIGZuLmFwcGx5KG9iaiwgdGhpcyk7XG59XG5Qcm9taXNlLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTs7XG4gICAgaWYgKCF0cnVlKSB7XG4gICAgICAgIGlmIChjYW5FdmFsdWF0ZSkge1xuICAgICAgICAgICAgdmFyIG1heWJlQ2FsbGVyID0gZ2V0TWV0aG9kQ2FsbGVyKG1ldGhvZE5hbWUpO1xuICAgICAgICAgICAgaWYgKG1heWJlQ2FsbGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RoZW4oXG4gICAgICAgICAgICAgICAgICAgIG1heWJlQ2FsbGVyLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJncywgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhcmdzLnB1c2gobWV0aG9kTmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuX3RoZW4oY2FsbGVyLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJncywgdW5kZWZpbmVkKTtcbn07XG5cbmZ1bmN0aW9uIG5hbWVkR2V0dGVyKG9iaikge1xuICAgIHJldHVybiBvYmpbdGhpc107XG59XG5mdW5jdGlvbiBpbmRleGVkR2V0dGVyKG9iaikge1xuICAgIHZhciBpbmRleCA9ICt0aGlzO1xuICAgIGlmIChpbmRleCA8IDApIGluZGV4ID0gTWF0aC5tYXgoMCwgaW5kZXggKyBvYmoubGVuZ3RoKTtcbiAgICByZXR1cm4gb2JqW2luZGV4XTtcbn1cblByb21pc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUpIHtcbiAgICB2YXIgaXNJbmRleCA9ICh0eXBlb2YgcHJvcGVydHlOYW1lID09PSBcIm51bWJlclwiKTtcbiAgICB2YXIgZ2V0dGVyO1xuICAgIGlmICghaXNJbmRleCkge1xuICAgICAgICBpZiAoY2FuRXZhbHVhdGUpIHtcbiAgICAgICAgICAgIHZhciBtYXliZUdldHRlciA9IGdldEdldHRlcihwcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgZ2V0dGVyID0gbWF5YmVHZXR0ZXIgIT09IG51bGwgPyBtYXliZUdldHRlciA6IG5hbWVkR2V0dGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2V0dGVyID0gbmFtZWRHZXR0ZXI7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBnZXR0ZXIgPSBpbmRleGVkR2V0dGVyO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdGhlbihnZXR0ZXIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBwcm9wZXJ0eU5hbWUsIHVuZGVmaW5lZCk7XG59O1xufTtcblxufSx7XCIuL3V0aWxcIjozNn1dLDY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIFByb21pc2VBcnJheSwgYXBpUmVqZWN0aW9uLCBkZWJ1Zykge1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG52YXIgYXN5bmMgPSBQcm9taXNlLl9hc3luYztcblxuUHJvbWlzZS5wcm90b3R5cGVbXCJicmVha1wiXSA9IFByb21pc2UucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghZGVidWcuY2FuY2VsbGF0aW9uKCkpIHJldHVybiB0aGlzLl93YXJuKFwiY2FuY2VsbGF0aW9uIGlzIGRpc2FibGVkXCIpO1xuXG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuICAgIHZhciBjaGlsZCA9IHByb21pc2U7XG4gICAgd2hpbGUgKHByb21pc2UuX2lzQ2FuY2VsbGFibGUoKSkge1xuICAgICAgICBpZiAoIXByb21pc2UuX2NhbmNlbEJ5KGNoaWxkKSkge1xuICAgICAgICAgICAgaWYgKGNoaWxkLl9pc0ZvbGxvd2luZygpKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuX2ZvbGxvd2VlKCkuY2FuY2VsKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoaWxkLl9jYW5jZWxCcmFuY2hlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyZW50ID0gcHJvbWlzZS5fY2FuY2VsbGF0aW9uUGFyZW50O1xuICAgICAgICBpZiAocGFyZW50ID09IG51bGwgfHwgIXBhcmVudC5faXNDYW5jZWxsYWJsZSgpKSB7XG4gICAgICAgICAgICBpZiAocHJvbWlzZS5faXNGb2xsb3dpbmcoKSkge1xuICAgICAgICAgICAgICAgIHByb21pc2UuX2ZvbGxvd2VlKCkuY2FuY2VsKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb21pc2UuX2NhbmNlbEJyYW5jaGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwcm9taXNlLl9pc0ZvbGxvd2luZygpKSBwcm9taXNlLl9mb2xsb3dlZSgpLmNhbmNlbCgpO1xuICAgICAgICAgICAgcHJvbWlzZS5fc2V0V2lsbEJlQ2FuY2VsbGVkKCk7XG4gICAgICAgICAgICBjaGlsZCA9IHByb21pc2U7XG4gICAgICAgICAgICBwcm9taXNlID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2JyYW5jaEhhc0NhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2JyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWwtLTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9lbm91Z2hCcmFuY2hlc0hhdmVDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgIHRoaXMuX2JyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWwgPD0gMDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9jYW5jZWxCeSA9IGZ1bmN0aW9uKGNhbmNlbGxlcikge1xuICAgIGlmIChjYW5jZWxsZXIgPT09IHRoaXMpIHtcbiAgICAgICAgdGhpcy5fYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbCA9IDA7XG4gICAgICAgIHRoaXMuX2ludm9rZU9uQ2FuY2VsKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2JyYW5jaEhhc0NhbmNlbGxlZCgpO1xuICAgICAgICBpZiAodGhpcy5fZW5vdWdoQnJhbmNoZXNIYXZlQ2FuY2VsbGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludm9rZU9uQ2FuY2VsKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fY2FuY2VsQnJhbmNoZWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fZW5vdWdoQnJhbmNoZXNIYXZlQ2FuY2VsbGVkKCkpIHtcbiAgICAgICAgdGhpcy5fY2FuY2VsKCk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2NhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5faXNDYW5jZWxsYWJsZSgpKSByZXR1cm47XG4gICAgdGhpcy5fc2V0Q2FuY2VsbGVkKCk7XG4gICAgYXN5bmMuaW52b2tlKHRoaXMuX2NhbmNlbFByb21pc2VzLCB0aGlzLCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2NhbmNlbFByb21pc2VzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xlbmd0aCgpID4gMCkgdGhpcy5fc2V0dGxlUHJvbWlzZXMoKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl91bnNldE9uQ2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fb25DYW5jZWxGaWVsZCA9IHVuZGVmaW5lZDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pc0NhbmNlbGxhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNQZW5kaW5nKCkgJiYgIXRoaXMuX2lzQ2FuY2VsbGVkKCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5pc0NhbmNlbGxhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNQZW5kaW5nKCkgJiYgIXRoaXMuaXNDYW5jZWxsZWQoKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9kb0ludm9rZU9uQ2FuY2VsID0gZnVuY3Rpb24ob25DYW5jZWxDYWxsYmFjaywgaW50ZXJuYWxPbmx5KSB7XG4gICAgaWYgKHV0aWwuaXNBcnJheShvbkNhbmNlbENhbGxiYWNrKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9uQ2FuY2VsQ2FsbGJhY2subGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMuX2RvSW52b2tlT25DYW5jZWwob25DYW5jZWxDYWxsYmFja1tpXSwgaW50ZXJuYWxPbmx5KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAob25DYW5jZWxDYWxsYmFjayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb25DYW5jZWxDYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAoIWludGVybmFsT25seSkge1xuICAgICAgICAgICAgICAgIHZhciBlID0gdHJ5Q2F0Y2gob25DYW5jZWxDYWxsYmFjaykuY2FsbCh0aGlzLl9ib3VuZFZhbHVlKCkpO1xuICAgICAgICAgICAgICAgIGlmIChlID09PSBlcnJvck9iaikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdHRhY2hFeHRyYVRyYWNlKGUuZSk7XG4gICAgICAgICAgICAgICAgICAgIGFzeW5jLnRocm93TGF0ZXIoZS5lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvbkNhbmNlbENhbGxiYWNrLl9yZXN1bHRDYW5jZWxsZWQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faW52b2tlT25DYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb25DYW5jZWxDYWxsYmFjayA9IHRoaXMuX29uQ2FuY2VsKCk7XG4gICAgdGhpcy5fdW5zZXRPbkNhbmNlbCgpO1xuICAgIGFzeW5jLmludm9rZSh0aGlzLl9kb0ludm9rZU9uQ2FuY2VsLCB0aGlzLCBvbkNhbmNlbENhbGxiYWNrKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pbnZva2VJbnRlcm5hbE9uQ2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2lzQ2FuY2VsbGFibGUoKSkge1xuICAgICAgICB0aGlzLl9kb0ludm9rZU9uQ2FuY2VsKHRoaXMuX29uQ2FuY2VsKCksIHRydWUpO1xuICAgICAgICB0aGlzLl91bnNldE9uQ2FuY2VsKCk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Jlc3VsdENhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2FuY2VsKCk7XG59O1xuXG59O1xuXG59LHtcIi4vdXRpbFwiOjM2fV0sNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkVYVF9GSUxURVIpIHtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcbnZhciBnZXRLZXlzID0gX2RlcmVxXyhcIi4vZXM1XCIpLmtleXM7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcblxuZnVuY3Rpb24gY2F0Y2hGaWx0ZXIoaW5zdGFuY2VzLCBjYiwgcHJvbWlzZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBib3VuZFRvID0gcHJvbWlzZS5fYm91bmRWYWx1ZSgpO1xuICAgICAgICBwcmVkaWNhdGVMb29wOiBmb3IgKHZhciBpID0gMDsgaSA8IGluc3RhbmNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBpbnN0YW5jZXNbaV07XG5cbiAgICAgICAgICAgIGlmIChpdGVtID09PSBFcnJvciB8fFxuICAgICAgICAgICAgICAgIChpdGVtICE9IG51bGwgJiYgaXRlbS5wcm90b3R5cGUgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyeUNhdGNoKGNiKS5jYWxsKGJvdW5kVG8sIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzUHJlZGljYXRlID0gdHJ5Q2F0Y2goaXRlbSkuY2FsbChib3VuZFRvLCBlKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlc1ByZWRpY2F0ZSA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXNQcmVkaWNhdGU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaGVzUHJlZGljYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnlDYXRjaChjYikuY2FsbChib3VuZFRvLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHV0aWwuaXNPYmplY3QoZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IGdldEtleXMoaXRlbSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbVtrZXldICE9IGVba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgcHJlZGljYXRlTG9vcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ5Q2F0Y2goY2IpLmNhbGwoYm91bmRUbywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5FWFRfRklMVEVSO1xuICAgIH07XG59XG5cbnJldHVybiBjYXRjaEZpbHRlcjtcbn07XG5cbn0se1wiLi9lczVcIjoxMyxcIi4vdXRpbFwiOjM2fV0sODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSkge1xudmFyIGxvbmdTdGFja1RyYWNlcyA9IGZhbHNlO1xudmFyIGNvbnRleHRTdGFjayA9IFtdO1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcHJvbWlzZUNyZWF0ZWQgPSBmdW5jdGlvbigpIHt9O1xuUHJvbWlzZS5wcm90b3R5cGUuX3B1c2hDb250ZXh0ID0gZnVuY3Rpb24oKSB7fTtcblByb21pc2UucHJvdG90eXBlLl9wb3BDb250ZXh0ID0gZnVuY3Rpb24oKSB7cmV0dXJuIG51bGw7fTtcblByb21pc2UuX3BlZWtDb250ZXh0ID0gUHJvbWlzZS5wcm90b3R5cGUuX3BlZWtDb250ZXh0ID0gZnVuY3Rpb24oKSB7fTtcblxuZnVuY3Rpb24gQ29udGV4dCgpIHtcbiAgICB0aGlzLl90cmFjZSA9IG5ldyBDb250ZXh0LkNhcHR1cmVkVHJhY2UocGVla0NvbnRleHQoKSk7XG59XG5Db250ZXh0LnByb3RvdHlwZS5fcHVzaENvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3RyYWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fdHJhY2UuX3Byb21pc2VDcmVhdGVkID0gbnVsbDtcbiAgICAgICAgY29udGV4dFN0YWNrLnB1c2godGhpcy5fdHJhY2UpO1xuICAgIH1cbn07XG5cbkNvbnRleHQucHJvdG90eXBlLl9wb3BDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl90cmFjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciB0cmFjZSA9IGNvbnRleHRTdGFjay5wb3AoKTtcbiAgICAgICAgdmFyIHJldCA9IHRyYWNlLl9wcm9taXNlQ3JlYXRlZDtcbiAgICAgICAgdHJhY2UuX3Byb21pc2VDcmVhdGVkID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0KCkge1xuICAgIGlmIChsb25nU3RhY2tUcmFjZXMpIHJldHVybiBuZXcgQ29udGV4dCgpO1xufVxuXG5mdW5jdGlvbiBwZWVrQ29udGV4dCgpIHtcbiAgICB2YXIgbGFzdEluZGV4ID0gY29udGV4dFN0YWNrLmxlbmd0aCAtIDE7XG4gICAgaWYgKGxhc3RJbmRleCA+PSAwKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0U3RhY2tbbGFzdEluZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbkNvbnRleHQuQ2FwdHVyZWRUcmFjZSA9IG51bGw7XG5Db250ZXh0LmNyZWF0ZSA9IGNyZWF0ZUNvbnRleHQ7XG5Db250ZXh0LmRlYWN0aXZhdGVMb25nU3RhY2tUcmFjZXMgPSBmdW5jdGlvbigpIHt9O1xuQ29udGV4dC5hY3RpdmF0ZUxvbmdTdGFja1RyYWNlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBQcm9taXNlX3B1c2hDb250ZXh0ID0gUHJvbWlzZS5wcm90b3R5cGUuX3B1c2hDb250ZXh0O1xuICAgIHZhciBQcm9taXNlX3BvcENvbnRleHQgPSBQcm9taXNlLnByb3RvdHlwZS5fcG9wQ29udGV4dDtcbiAgICB2YXIgUHJvbWlzZV9QZWVrQ29udGV4dCA9IFByb21pc2UuX3BlZWtDb250ZXh0O1xuICAgIHZhciBQcm9taXNlX3BlZWtDb250ZXh0ID0gUHJvbWlzZS5wcm90b3R5cGUuX3BlZWtDb250ZXh0O1xuICAgIHZhciBQcm9taXNlX3Byb21pc2VDcmVhdGVkID0gUHJvbWlzZS5wcm90b3R5cGUuX3Byb21pc2VDcmVhdGVkO1xuICAgIENvbnRleHQuZGVhY3RpdmF0ZUxvbmdTdGFja1RyYWNlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fcHVzaENvbnRleHQgPSBQcm9taXNlX3B1c2hDb250ZXh0O1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fcG9wQ29udGV4dCA9IFByb21pc2VfcG9wQ29udGV4dDtcbiAgICAgICAgUHJvbWlzZS5fcGVla0NvbnRleHQgPSBQcm9taXNlX1BlZWtDb250ZXh0O1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fcGVla0NvbnRleHQgPSBQcm9taXNlX3BlZWtDb250ZXh0O1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fcHJvbWlzZUNyZWF0ZWQgPSBQcm9taXNlX3Byb21pc2VDcmVhdGVkO1xuICAgICAgICBsb25nU3RhY2tUcmFjZXMgPSBmYWxzZTtcbiAgICB9O1xuICAgIGxvbmdTdGFja1RyYWNlcyA9IHRydWU7XG4gICAgUHJvbWlzZS5wcm90b3R5cGUuX3B1c2hDb250ZXh0ID0gQ29udGV4dC5wcm90b3R5cGUuX3B1c2hDb250ZXh0O1xuICAgIFByb21pc2UucHJvdG90eXBlLl9wb3BDb250ZXh0ID0gQ29udGV4dC5wcm90b3R5cGUuX3BvcENvbnRleHQ7XG4gICAgUHJvbWlzZS5fcGVla0NvbnRleHQgPSBQcm9taXNlLnByb3RvdHlwZS5fcGVla0NvbnRleHQgPSBwZWVrQ29udGV4dDtcbiAgICBQcm9taXNlLnByb3RvdHlwZS5fcHJvbWlzZUNyZWF0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuX3BlZWtDb250ZXh0KCk7XG4gICAgICAgIGlmIChjdHggJiYgY3R4Ll9wcm9taXNlQ3JlYXRlZCA9PSBudWxsKSBjdHguX3Byb21pc2VDcmVhdGVkID0gdGhpcztcbiAgICB9O1xufTtcbnJldHVybiBDb250ZXh0O1xufTtcblxufSx7fV0sOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgQ29udGV4dCkge1xudmFyIGdldERvbWFpbiA9IFByb21pc2UuX2dldERvbWFpbjtcbnZhciBhc3luYyA9IFByb21pc2UuX2FzeW5jO1xudmFyIFdhcm5pbmcgPSBfZGVyZXFfKFwiLi9lcnJvcnNcIikuV2FybmluZztcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcbnZhciBjYW5BdHRhY2hUcmFjZSA9IHV0aWwuY2FuQXR0YWNoVHJhY2U7XG52YXIgdW5oYW5kbGVkUmVqZWN0aW9uSGFuZGxlZDtcbnZhciBwb3NzaWJseVVuaGFuZGxlZFJlamVjdGlvbjtcbnZhciBibHVlYmlyZEZyYW1lUGF0dGVybiA9XG4gICAgL1tcXFxcXFwvXWJsdWViaXJkW1xcXFxcXC9danNbXFxcXFxcL10ocmVsZWFzZXxkZWJ1Z3xpbnN0cnVtZW50ZWQpLztcbnZhciBub2RlRnJhbWVQYXR0ZXJuID0gL1xcKCg/OnRpbWVyc1xcLmpzKTpcXGQrOlxcZCtcXCkvO1xudmFyIHBhcnNlTGluZVBhdHRlcm4gPSAvW1xcLzxcXChdKC4rPyk6KFxcZCspOihcXGQrKVxcKT9cXHMqJC87XG52YXIgc3RhY2tGcmFtZVBhdHRlcm4gPSBudWxsO1xudmFyIGZvcm1hdFN0YWNrID0gbnVsbDtcbnZhciBpbmRlbnRTdGFja0ZyYW1lcyA9IGZhbHNlO1xudmFyIHByaW50V2FybmluZztcbnZhciBkZWJ1Z2dpbmcgPSAhISh1dGlsLmVudihcIkJMVUVCSVJEX0RFQlVHXCIpICE9IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICh0cnVlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5lbnYoXCJCTFVFQklSRF9ERUJVR1wiKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuZW52KFwiTk9ERV9FTlZcIikgPT09IFwiZGV2ZWxvcG1lbnRcIikpO1xuXG52YXIgd2FybmluZ3MgPSAhISh1dGlsLmVudihcIkJMVUVCSVJEX1dBUk5JTkdTXCIpICE9IDAgJiZcbiAgICAoZGVidWdnaW5nIHx8IHV0aWwuZW52KFwiQkxVRUJJUkRfV0FSTklOR1NcIikpKTtcblxudmFyIGxvbmdTdGFja1RyYWNlcyA9ICEhKHV0aWwuZW52KFwiQkxVRUJJUkRfTE9OR19TVEFDS19UUkFDRVNcIikgIT0gMCAmJlxuICAgIChkZWJ1Z2dpbmcgfHwgdXRpbC5lbnYoXCJCTFVFQklSRF9MT05HX1NUQUNLX1RSQUNFU1wiKSkpO1xuXG52YXIgd0ZvcmdvdHRlblJldHVybiA9IHV0aWwuZW52KFwiQkxVRUJJUkRfV19GT1JHT1RURU5fUkVUVVJOXCIpICE9IDAgJiZcbiAgICAod2FybmluZ3MgfHwgISF1dGlsLmVudihcIkJMVUVCSVJEX1dfRk9SR09UVEVOX1JFVFVSTlwiKSk7XG5cblByb21pc2UucHJvdG90eXBlLnN1cHByZXNzVW5oYW5kbGVkUmVqZWN0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXQoKTtcbiAgICB0YXJnZXQuX2JpdEZpZWxkID0gKCh0YXJnZXQuX2JpdEZpZWxkICYgKH4xMDQ4NTc2KSkgfFxuICAgICAgICAgICAgICAgICAgICAgIDUyNDI4OCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fZW5zdXJlUG9zc2libGVSZWplY3Rpb25IYW5kbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICgodGhpcy5fYml0RmllbGQgJiA1MjQyODgpICE9PSAwKSByZXR1cm47XG4gICAgdGhpcy5fc2V0UmVqZWN0aW9uSXNVbmhhbmRsZWQoKTtcbiAgICBhc3luYy5pbnZva2VMYXRlcih0aGlzLl9ub3RpZnlVbmhhbmRsZWRSZWplY3Rpb24sIHRoaXMsIHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fbm90aWZ5VW5oYW5kbGVkUmVqZWN0aW9uSXNIYW5kbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIGZpcmVSZWplY3Rpb25FdmVudChcInJlamVjdGlvbkhhbmRsZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmhhbmRsZWRSZWplY3Rpb25IYW5kbGVkLCB1bmRlZmluZWQsIHRoaXMpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldFJldHVybmVkTm9uVW5kZWZpbmVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDI2ODQzNTQ1Njtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZXR1cm5lZE5vblVuZGVmaW5lZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiAyNjg0MzU0NTYpICE9PSAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX25vdGlmeVVuaGFuZGxlZFJlamVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5faXNSZWplY3Rpb25VbmhhbmRsZWQoKSkge1xuICAgICAgICB2YXIgcmVhc29uID0gdGhpcy5fc2V0dGxlZFZhbHVlKCk7XG4gICAgICAgIHRoaXMuX3NldFVuaGFuZGxlZFJlamVjdGlvbklzTm90aWZpZWQoKTtcbiAgICAgICAgZmlyZVJlamVjdGlvbkV2ZW50KFwidW5oYW5kbGVkUmVqZWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3NpYmx5VW5oYW5kbGVkUmVqZWN0aW9uLCByZWFzb24sIHRoaXMpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRVbmhhbmRsZWRSZWplY3Rpb25Jc05vdGlmaWVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCAyNjIxNDQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fdW5zZXRVbmhhbmRsZWRSZWplY3Rpb25Jc05vdGlmaWVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgJiAofjI2MjE0NCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNVbmhhbmRsZWRSZWplY3Rpb25Ob3RpZmllZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMjYyMTQ0KSA+IDA7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0UmVqZWN0aW9uSXNVbmhhbmRsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDEwNDg1NzY7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fdW5zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkICYgKH4xMDQ4NTc2KTtcbiAgICBpZiAodGhpcy5faXNVbmhhbmRsZWRSZWplY3Rpb25Ob3RpZmllZCgpKSB7XG4gICAgICAgIHRoaXMuX3Vuc2V0VW5oYW5kbGVkUmVqZWN0aW9uSXNOb3RpZmllZCgpO1xuICAgICAgICB0aGlzLl9ub3RpZnlVbmhhbmRsZWRSZWplY3Rpb25Jc0hhbmRsZWQoKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNSZWplY3Rpb25VbmhhbmRsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDEwNDg1NzYpID4gMDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl93YXJuID0gZnVuY3Rpb24obWVzc2FnZSwgc2hvdWxkVXNlT3duVHJhY2UsIHByb21pc2UpIHtcbiAgICByZXR1cm4gd2FybihtZXNzYWdlLCBzaG91bGRVc2VPd25UcmFjZSwgcHJvbWlzZSB8fCB0aGlzKTtcbn07XG5cblByb21pc2Uub25Qb3NzaWJseVVuaGFuZGxlZFJlamVjdGlvbiA9IGZ1bmN0aW9uIChmbikge1xuICAgIHZhciBkb21haW4gPSBnZXREb21haW4oKTtcbiAgICBwb3NzaWJseVVuaGFuZGxlZFJlamVjdGlvbiA9XG4gICAgICAgIHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiID8gKGRvbWFpbiA9PT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuIDogdXRpbC5kb21haW5CaW5kKGRvbWFpbiwgZm4pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG59O1xuXG5Qcm9taXNlLm9uVW5oYW5kbGVkUmVqZWN0aW9uSGFuZGxlZCA9IGZ1bmN0aW9uIChmbikge1xuICAgIHZhciBkb21haW4gPSBnZXREb21haW4oKTtcbiAgICB1bmhhbmRsZWRSZWplY3Rpb25IYW5kbGVkID1cbiAgICAgICAgdHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIgPyAoZG9tYWluID09PSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4gOiB1dGlsLmRvbWFpbkJpbmQoZG9tYWluLCBmbikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbn07XG5cbnZhciBkaXNhYmxlTG9uZ1N0YWNrVHJhY2VzID0gZnVuY3Rpb24oKSB7fTtcblByb21pc2UubG9uZ1N0YWNrVHJhY2VzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChhc3luYy5oYXZlSXRlbXNRdWV1ZWQoKSAmJiAhY29uZmlnLmxvbmdTdGFja1RyYWNlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZW5hYmxlIGxvbmcgc3RhY2sgdHJhY2VzIGFmdGVyIHByb21pc2VzIGhhdmUgYmVlbiBjcmVhdGVkXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgaWYgKCFjb25maWcubG9uZ1N0YWNrVHJhY2VzICYmIGxvbmdTdGFja1RyYWNlc0lzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgdmFyIFByb21pc2VfY2FwdHVyZVN0YWNrVHJhY2UgPSBQcm9taXNlLnByb3RvdHlwZS5fY2FwdHVyZVN0YWNrVHJhY2U7XG4gICAgICAgIHZhciBQcm9taXNlX2F0dGFjaEV4dHJhVHJhY2UgPSBQcm9taXNlLnByb3RvdHlwZS5fYXR0YWNoRXh0cmFUcmFjZTtcbiAgICAgICAgY29uZmlnLmxvbmdTdGFja1RyYWNlcyA9IHRydWU7XG4gICAgICAgIGRpc2FibGVMb25nU3RhY2tUcmFjZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChhc3luYy5oYXZlSXRlbXNRdWV1ZWQoKSAmJiAhY29uZmlnLmxvbmdTdGFja1RyYWNlcykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBlbmFibGUgbG9uZyBzdGFjayB0cmFjZXMgYWZ0ZXIgcHJvbWlzZXMgaGF2ZSBiZWVuIGNyZWF0ZWRcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2NhcHR1cmVTdGFja1RyYWNlID0gUHJvbWlzZV9jYXB0dXJlU3RhY2tUcmFjZTtcbiAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9hdHRhY2hFeHRyYVRyYWNlID0gUHJvbWlzZV9hdHRhY2hFeHRyYVRyYWNlO1xuICAgICAgICAgICAgQ29udGV4dC5kZWFjdGl2YXRlTG9uZ1N0YWNrVHJhY2VzKCk7XG4gICAgICAgICAgICBhc3luYy5lbmFibGVUcmFtcG9saW5lKCk7XG4gICAgICAgICAgICBjb25maWcubG9uZ1N0YWNrVHJhY2VzID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9jYXB0dXJlU3RhY2tUcmFjZSA9IGxvbmdTdGFja1RyYWNlc0NhcHR1cmVTdGFja1RyYWNlO1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fYXR0YWNoRXh0cmFUcmFjZSA9IGxvbmdTdGFja1RyYWNlc0F0dGFjaEV4dHJhVHJhY2U7XG4gICAgICAgIENvbnRleHQuYWN0aXZhdGVMb25nU3RhY2tUcmFjZXMoKTtcbiAgICAgICAgYXN5bmMuZGlzYWJsZVRyYW1wb2xpbmVJZk5lY2Vzc2FyeSgpO1xuICAgIH1cbn07XG5cblByb21pc2UuaGFzTG9uZ1N0YWNrVHJhY2VzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjb25maWcubG9uZ1N0YWNrVHJhY2VzICYmIGxvbmdTdGFja1RyYWNlc0lzU3VwcG9ydGVkKCk7XG59O1xuXG52YXIgZmlyZURvbUV2ZW50ID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgQ3VzdG9tRXZlbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7XG4gICAgICAgICAgICB1dGlsLmdsb2JhbC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihuYW1lLCBldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBkb21FdmVudCA9IG5ldyBDdXN0b21FdmVudChuYW1lLnRvTG93ZXJDYXNlKCksIHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiAhdXRpbC5nbG9iYWwuZGlzcGF0Y2hFdmVudChkb21FdmVudCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBFdmVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoXCJDdXN0b21FdmVudFwiKTtcbiAgICAgICAgICAgIHV0aWwuZ2xvYmFsLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUsIGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvbUV2ZW50ID0gbmV3IEV2ZW50KG5hbWUudG9Mb3dlckNhc2UoKSwge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZG9tRXZlbnQuZGV0YWlsID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuICF1dGlsLmdsb2JhbC5kaXNwYXRjaEV2ZW50KGRvbUV2ZW50KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpO1xuICAgICAgICAgICAgZXZlbnQuaW5pdEN1c3RvbUV2ZW50KFwidGVzdGluZ3RoZWV2ZW50XCIsIGZhbHNlLCB0cnVlLCB7fSk7XG4gICAgICAgICAgICB1dGlsLmdsb2JhbC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihuYW1lLCBldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBkb21FdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7XG4gICAgICAgICAgICAgICAgZG9tRXZlbnQuaW5pdEN1c3RvbUV2ZW50KG5hbWUudG9Mb3dlckNhc2UoKSwgZmFsc2UsIHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXV0aWwuZ2xvYmFsLmRpc3BhdGNoRXZlbnQoZG9tRXZlbnQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn0pKCk7XG5cbnZhciBmaXJlR2xvYmFsRXZlbnQgPSAoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHV0aWwuaXNOb2RlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9jZXNzLmVtaXQuYXBwbHkocHJvY2VzcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXV0aWwuZ2xvYmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSBcIm9uXCIgKyBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gdXRpbC5nbG9iYWxbbWV0aG9kTmFtZV07XG4gICAgICAgICAgICBpZiAoIW1ldGhvZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbWV0aG9kLmFwcGx5KHV0aWwuZ2xvYmFsLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgfVxufSkoKTtcblxuZnVuY3Rpb24gZ2VuZXJhdGVQcm9taXNlTGlmZWN5Y2xlRXZlbnRPYmplY3QobmFtZSwgcHJvbWlzZSkge1xuICAgIHJldHVybiB7cHJvbWlzZTogcHJvbWlzZX07XG59XG5cbnZhciBldmVudFRvT2JqZWN0R2VuZXJhdG9yID0ge1xuICAgIHByb21pc2VDcmVhdGVkOiBnZW5lcmF0ZVByb21pc2VMaWZlY3ljbGVFdmVudE9iamVjdCxcbiAgICBwcm9taXNlRnVsZmlsbGVkOiBnZW5lcmF0ZVByb21pc2VMaWZlY3ljbGVFdmVudE9iamVjdCxcbiAgICBwcm9taXNlUmVqZWN0ZWQ6IGdlbmVyYXRlUHJvbWlzZUxpZmVjeWNsZUV2ZW50T2JqZWN0LFxuICAgIHByb21pc2VSZXNvbHZlZDogZ2VuZXJhdGVQcm9taXNlTGlmZWN5Y2xlRXZlbnRPYmplY3QsXG4gICAgcHJvbWlzZUNhbmNlbGxlZDogZ2VuZXJhdGVQcm9taXNlTGlmZWN5Y2xlRXZlbnRPYmplY3QsXG4gICAgcHJvbWlzZUNoYWluZWQ6IGZ1bmN0aW9uKG5hbWUsIHByb21pc2UsIGNoaWxkKSB7XG4gICAgICAgIHJldHVybiB7cHJvbWlzZTogcHJvbWlzZSwgY2hpbGQ6IGNoaWxkfTtcbiAgICB9LFxuICAgIHdhcm5pbmc6IGZ1bmN0aW9uKG5hbWUsIHdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIHt3YXJuaW5nOiB3YXJuaW5nfTtcbiAgICB9LFxuICAgIHVuaGFuZGxlZFJlamVjdGlvbjogZnVuY3Rpb24gKG5hbWUsIHJlYXNvbiwgcHJvbWlzZSkge1xuICAgICAgICByZXR1cm4ge3JlYXNvbjogcmVhc29uLCBwcm9taXNlOiBwcm9taXNlfTtcbiAgICB9LFxuICAgIHJlamVjdGlvbkhhbmRsZWQ6IGdlbmVyYXRlUHJvbWlzZUxpZmVjeWNsZUV2ZW50T2JqZWN0XG59O1xuXG52YXIgYWN0aXZlRmlyZUV2ZW50ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgZ2xvYmFsRXZlbnRGaXJlZCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIGdsb2JhbEV2ZW50RmlyZWQgPSBmaXJlR2xvYmFsRXZlbnQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGFzeW5jLnRocm93TGF0ZXIoZSk7XG4gICAgICAgIGdsb2JhbEV2ZW50RmlyZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBkb21FdmVudEZpcmVkID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgZG9tRXZlbnRGaXJlZCA9IGZpcmVEb21FdmVudChuYW1lLFxuICAgICAgICAgICAgICAgICAgICBldmVudFRvT2JqZWN0R2VuZXJhdG9yW25hbWVdLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgYXN5bmMudGhyb3dMYXRlcihlKTtcbiAgICAgICAgZG9tRXZlbnRGaXJlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvbUV2ZW50RmlyZWQgfHwgZ2xvYmFsRXZlbnRGaXJlZDtcbn07XG5cblByb21pc2UuY29uZmlnID0gZnVuY3Rpb24ob3B0cykge1xuICAgIG9wdHMgPSBPYmplY3Qob3B0cyk7XG4gICAgaWYgKFwibG9uZ1N0YWNrVHJhY2VzXCIgaW4gb3B0cykge1xuICAgICAgICBpZiAob3B0cy5sb25nU3RhY2tUcmFjZXMpIHtcbiAgICAgICAgICAgIFByb21pc2UubG9uZ1N0YWNrVHJhY2VzKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIW9wdHMubG9uZ1N0YWNrVHJhY2VzICYmIFByb21pc2UuaGFzTG9uZ1N0YWNrVHJhY2VzKCkpIHtcbiAgICAgICAgICAgIGRpc2FibGVMb25nU3RhY2tUcmFjZXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoXCJ3YXJuaW5nc1wiIGluIG9wdHMpIHtcbiAgICAgICAgdmFyIHdhcm5pbmdzT3B0aW9uID0gb3B0cy53YXJuaW5ncztcbiAgICAgICAgY29uZmlnLndhcm5pbmdzID0gISF3YXJuaW5nc09wdGlvbjtcbiAgICAgICAgd0ZvcmdvdHRlblJldHVybiA9IGNvbmZpZy53YXJuaW5ncztcblxuICAgICAgICBpZiAodXRpbC5pc09iamVjdCh3YXJuaW5nc09wdGlvbikpIHtcbiAgICAgICAgICAgIGlmIChcIndGb3Jnb3R0ZW5SZXR1cm5cIiBpbiB3YXJuaW5nc09wdGlvbikge1xuICAgICAgICAgICAgICAgIHdGb3Jnb3R0ZW5SZXR1cm4gPSAhIXdhcm5pbmdzT3B0aW9uLndGb3Jnb3R0ZW5SZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKFwiY2FuY2VsbGF0aW9uXCIgaW4gb3B0cyAmJiBvcHRzLmNhbmNlbGxhdGlvbiAmJiAhY29uZmlnLmNhbmNlbGxhdGlvbikge1xuICAgICAgICBpZiAoYXN5bmMuaGF2ZUl0ZW1zUXVldWVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBcImNhbm5vdCBlbmFibGUgY2FuY2VsbGF0aW9uIGFmdGVyIHByb21pc2VzIGFyZSBpbiB1c2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2NsZWFyQ2FuY2VsbGF0aW9uRGF0YSA9XG4gICAgICAgICAgICBjYW5jZWxsYXRpb25DbGVhckNhbmNlbGxhdGlvbkRhdGE7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9wcm9wYWdhdGVGcm9tID0gY2FuY2VsbGF0aW9uUHJvcGFnYXRlRnJvbTtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX29uQ2FuY2VsID0gY2FuY2VsbGF0aW9uT25DYW5jZWw7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9zZXRPbkNhbmNlbCA9IGNhbmNlbGxhdGlvblNldE9uQ2FuY2VsO1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fYXR0YWNoQ2FuY2VsbGF0aW9uQ2FsbGJhY2sgPVxuICAgICAgICAgICAgY2FuY2VsbGF0aW9uQXR0YWNoQ2FuY2VsbGF0aW9uQ2FsbGJhY2s7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9leGVjdXRlID0gY2FuY2VsbGF0aW9uRXhlY3V0ZTtcbiAgICAgICAgcHJvcGFnYXRlRnJvbUZ1bmN0aW9uID0gY2FuY2VsbGF0aW9uUHJvcGFnYXRlRnJvbTtcbiAgICAgICAgY29uZmlnLmNhbmNlbGxhdGlvbiA9IHRydWU7XG4gICAgfVxuICAgIGlmIChcIm1vbml0b3JpbmdcIiBpbiBvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzLm1vbml0b3JpbmcgJiYgIWNvbmZpZy5tb25pdG9yaW5nKSB7XG4gICAgICAgICAgICBjb25maWcubW9uaXRvcmluZyA9IHRydWU7XG4gICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fZmlyZUV2ZW50ID0gYWN0aXZlRmlyZUV2ZW50O1xuICAgICAgICB9IGVsc2UgaWYgKCFvcHRzLm1vbml0b3JpbmcgJiYgY29uZmlnLm1vbml0b3JpbmcpIHtcbiAgICAgICAgICAgIGNvbmZpZy5tb25pdG9yaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fZmlyZUV2ZW50ID0gZGVmYXVsdEZpcmVFdmVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZTtcbn07XG5cbmZ1bmN0aW9uIGRlZmF1bHRGaXJlRXZlbnQoKSB7IHJldHVybiBmYWxzZTsgfVxuXG5Qcm9taXNlLnByb3RvdHlwZS5fZmlyZUV2ZW50ID0gZGVmYXVsdEZpcmVFdmVudDtcblByb21pc2UucHJvdG90eXBlLl9leGVjdXRlID0gZnVuY3Rpb24oZXhlY3V0b3IsIHJlc29sdmUsIHJlamVjdCkge1xuICAgIHRyeSB7XG4gICAgICAgIGV4ZWN1dG9yKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG59O1xuUHJvbWlzZS5wcm90b3R5cGUuX29uQ2FuY2VsID0gZnVuY3Rpb24gKCkge307XG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0T25DYW5jZWwgPSBmdW5jdGlvbiAoaGFuZGxlcikgeyA7IH07XG5Qcm9taXNlLnByb3RvdHlwZS5fYXR0YWNoQ2FuY2VsbGF0aW9uQ2FsbGJhY2sgPSBmdW5jdGlvbihvbkNhbmNlbCkge1xuICAgIDtcbn07XG5Qcm9taXNlLnByb3RvdHlwZS5fY2FwdHVyZVN0YWNrVHJhY2UgPSBmdW5jdGlvbiAoKSB7fTtcblByb21pc2UucHJvdG90eXBlLl9hdHRhY2hFeHRyYVRyYWNlID0gZnVuY3Rpb24gKCkge307XG5Qcm9taXNlLnByb3RvdHlwZS5fY2xlYXJDYW5jZWxsYXRpb25EYXRhID0gZnVuY3Rpb24oKSB7fTtcblByb21pc2UucHJvdG90eXBlLl9wcm9wYWdhdGVGcm9tID0gZnVuY3Rpb24gKHBhcmVudCwgZmxhZ3MpIHtcbiAgICA7XG4gICAgO1xufTtcblxuZnVuY3Rpb24gY2FuY2VsbGF0aW9uRXhlY3V0ZShleGVjdXRvciwgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuICAgIHRyeSB7XG4gICAgICAgIGV4ZWN1dG9yKHJlc29sdmUsIHJlamVjdCwgZnVuY3Rpb24ob25DYW5jZWwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25DYW5jZWwgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJvbkNhbmNlbCBtdXN0IGJlIGEgZnVuY3Rpb24sIGdvdDogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC50b1N0cmluZyhvbkNhbmNlbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvbWlzZS5fYXR0YWNoQ2FuY2VsbGF0aW9uQ2FsbGJhY2sob25DYW5jZWwpO1xuICAgICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY2FuY2VsbGF0aW9uQXR0YWNoQ2FuY2VsbGF0aW9uQ2FsbGJhY2sob25DYW5jZWwpIHtcbiAgICBpZiAoIXRoaXMuX2lzQ2FuY2VsbGFibGUoKSkgcmV0dXJuIHRoaXM7XG5cbiAgICB2YXIgcHJldmlvdXNPbkNhbmNlbCA9IHRoaXMuX29uQ2FuY2VsKCk7XG4gICAgaWYgKHByZXZpb3VzT25DYW5jZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodXRpbC5pc0FycmF5KHByZXZpb3VzT25DYW5jZWwpKSB7XG4gICAgICAgICAgICBwcmV2aW91c09uQ2FuY2VsLnB1c2gob25DYW5jZWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2V0T25DYW5jZWwoW3ByZXZpb3VzT25DYW5jZWwsIG9uQ2FuY2VsXSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zZXRPbkNhbmNlbChvbkNhbmNlbCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjYW5jZWxsYXRpb25PbkNhbmNlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fb25DYW5jZWxGaWVsZDtcbn1cblxuZnVuY3Rpb24gY2FuY2VsbGF0aW9uU2V0T25DYW5jZWwob25DYW5jZWwpIHtcbiAgICB0aGlzLl9vbkNhbmNlbEZpZWxkID0gb25DYW5jZWw7XG59XG5cbmZ1bmN0aW9uIGNhbmNlbGxhdGlvbkNsZWFyQ2FuY2VsbGF0aW9uRGF0YSgpIHtcbiAgICB0aGlzLl9jYW5jZWxsYXRpb25QYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fb25DYW5jZWxGaWVsZCA9IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gY2FuY2VsbGF0aW9uUHJvcGFnYXRlRnJvbShwYXJlbnQsIGZsYWdzKSB7XG4gICAgaWYgKChmbGFncyAmIDEpICE9PSAwKSB7XG4gICAgICAgIHRoaXMuX2NhbmNlbGxhdGlvblBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdmFyIGJyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWwgPSBwYXJlbnQuX2JyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWw7XG4gICAgICAgIGlmIChicmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudC5fYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbCA9IGJyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWwgKyAxO1xuICAgIH1cbiAgICBpZiAoKGZsYWdzICYgMikgIT09IDAgJiYgcGFyZW50Ll9pc0JvdW5kKCkpIHtcbiAgICAgICAgdGhpcy5fc2V0Qm91bmRUbyhwYXJlbnQuX2JvdW5kVG8pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYmluZGluZ1Byb3BhZ2F0ZUZyb20ocGFyZW50LCBmbGFncykge1xuICAgIGlmICgoZmxhZ3MgJiAyKSAhPT0gMCAmJiBwYXJlbnQuX2lzQm91bmQoKSkge1xuICAgICAgICB0aGlzLl9zZXRCb3VuZFRvKHBhcmVudC5fYm91bmRUbyk7XG4gICAgfVxufVxudmFyIHByb3BhZ2F0ZUZyb21GdW5jdGlvbiA9IGJpbmRpbmdQcm9wYWdhdGVGcm9tO1xuXG5mdW5jdGlvbiBib3VuZFZhbHVlRnVuY3Rpb24oKSB7XG4gICAgdmFyIHJldCA9IHRoaXMuX2JvdW5kVG87XG4gICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChyZXQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICBpZiAocmV0LmlzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0LnZhbHVlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gbG9uZ1N0YWNrVHJhY2VzQ2FwdHVyZVN0YWNrVHJhY2UoKSB7XG4gICAgdGhpcy5fdHJhY2UgPSBuZXcgQ2FwdHVyZWRUcmFjZSh0aGlzLl9wZWVrQ29udGV4dCgpKTtcbn1cblxuZnVuY3Rpb24gbG9uZ1N0YWNrVHJhY2VzQXR0YWNoRXh0cmFUcmFjZShlcnJvciwgaWdub3JlU2VsZikge1xuICAgIGlmIChjYW5BdHRhY2hUcmFjZShlcnJvcikpIHtcbiAgICAgICAgdmFyIHRyYWNlID0gdGhpcy5fdHJhY2U7XG4gICAgICAgIGlmICh0cmFjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoaWdub3JlU2VsZikgdHJhY2UgPSB0cmFjZS5fcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0cmFjZS5hdHRhY2hFeHRyYVRyYWNlKGVycm9yKTtcbiAgICAgICAgfSBlbHNlIGlmICghZXJyb3IuX19zdGFja0NsZWFuZWRfXykge1xuICAgICAgICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlU3RhY2tBbmRNZXNzYWdlKGVycm9yKTtcbiAgICAgICAgICAgIHV0aWwubm90RW51bWVyYWJsZVByb3AoZXJyb3IsIFwic3RhY2tcIixcbiAgICAgICAgICAgICAgICBwYXJzZWQubWVzc2FnZSArIFwiXFxuXCIgKyBwYXJzZWQuc3RhY2suam9pbihcIlxcblwiKSk7XG4gICAgICAgICAgICB1dGlsLm5vdEVudW1lcmFibGVQcm9wKGVycm9yLCBcIl9fc3RhY2tDbGVhbmVkX19cIiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yZ290dGVuUmV0dXJucyhyZXR1cm5WYWx1ZSwgcHJvbWlzZUNyZWF0ZWQsIG5hbWUsIHByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50KSB7XG4gICAgaWYgKHJldHVyblZhbHVlID09PSB1bmRlZmluZWQgJiYgcHJvbWlzZUNyZWF0ZWQgIT09IG51bGwgJiZcbiAgICAgICAgd0ZvcmdvdHRlblJldHVybikge1xuICAgICAgICBpZiAocGFyZW50ICE9PSB1bmRlZmluZWQgJiYgcGFyZW50Ll9yZXR1cm5lZE5vblVuZGVmaW5lZCgpKSByZXR1cm47XG4gICAgICAgIGlmICgocHJvbWlzZS5fYml0RmllbGQgJiA2NTUzNSkgPT09IDApIHJldHVybjtcblxuICAgICAgICBpZiAobmFtZSkgbmFtZSA9IG5hbWUgKyBcIiBcIjtcbiAgICAgICAgdmFyIGhhbmRsZXJMaW5lID0gXCJcIjtcbiAgICAgICAgdmFyIGNyZWF0b3JMaW5lID0gXCJcIjtcbiAgICAgICAgaWYgKHByb21pc2VDcmVhdGVkLl90cmFjZSkge1xuICAgICAgICAgICAgdmFyIHRyYWNlTGluZXMgPSBwcm9taXNlQ3JlYXRlZC5fdHJhY2Uuc3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBjbGVhblN0YWNrKHRyYWNlTGluZXMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmUgPSBzdGFja1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGVGcmFtZVBhdHRlcm4udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZU1hdGNoZXMgPSBsaW5lLm1hdGNoKHBhcnNlTGluZVBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGluZU1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJMaW5lICA9IFwiYXQgXCIgKyBsaW5lTWF0Y2hlc1sxXSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI6XCIgKyBsaW5lTWF0Y2hlc1syXSArIFwiOlwiICsgbGluZU1hdGNoZXNbM10gKyBcIiBcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0VXNlckxpbmUgPSBzdGFja1swXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNlTGluZXMubGVuZ3RoOyArK2kpIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2VMaW5lc1tpXSA9PT0gZmlyc3RVc2VyTGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRvckxpbmUgPSBcIlxcblwiICsgdHJhY2VMaW5lc1tpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBtc2cgPSBcImEgcHJvbWlzZSB3YXMgY3JlYXRlZCBpbiBhIFwiICsgbmFtZSArXG4gICAgICAgICAgICBcImhhbmRsZXIgXCIgKyBoYW5kbGVyTGluZSArIFwiYnV0IHdhcyBub3QgcmV0dXJuZWQgZnJvbSBpdCwgXCIgK1xuICAgICAgICAgICAgXCJzZWUgaHR0cDovL2dvby5nbC9yUnFNVXdcIiArXG4gICAgICAgICAgICBjcmVhdG9yTGluZTtcbiAgICAgICAgcHJvbWlzZS5fd2Fybihtc2csIHRydWUsIHByb21pc2VDcmVhdGVkKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZWQobmFtZSwgcmVwbGFjZW1lbnQpIHtcbiAgICB2YXIgbWVzc2FnZSA9IG5hbWUgK1xuICAgICAgICBcIiBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi5cIjtcbiAgICBpZiAocmVwbGFjZW1lbnQpIG1lc3NhZ2UgKz0gXCIgVXNlIFwiICsgcmVwbGFjZW1lbnQgKyBcIiBpbnN0ZWFkLlwiO1xuICAgIHJldHVybiB3YXJuKG1lc3NhZ2UpO1xufVxuXG5mdW5jdGlvbiB3YXJuKG1lc3NhZ2UsIHNob3VsZFVzZU93blRyYWNlLCBwcm9taXNlKSB7XG4gICAgaWYgKCFjb25maWcud2FybmluZ3MpIHJldHVybjtcbiAgICB2YXIgd2FybmluZyA9IG5ldyBXYXJuaW5nKG1lc3NhZ2UpO1xuICAgIHZhciBjdHg7XG4gICAgaWYgKHNob3VsZFVzZU93blRyYWNlKSB7XG4gICAgICAgIHByb21pc2UuX2F0dGFjaEV4dHJhVHJhY2Uod2FybmluZyk7XG4gICAgfSBlbHNlIGlmIChjb25maWcubG9uZ1N0YWNrVHJhY2VzICYmIChjdHggPSBQcm9taXNlLl9wZWVrQ29udGV4dCgpKSkge1xuICAgICAgICBjdHguYXR0YWNoRXh0cmFUcmFjZSh3YXJuaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcGFyc2VkID0gcGFyc2VTdGFja0FuZE1lc3NhZ2Uod2FybmluZyk7XG4gICAgICAgIHdhcm5pbmcuc3RhY2sgPSBwYXJzZWQubWVzc2FnZSArIFwiXFxuXCIgKyBwYXJzZWQuc3RhY2suam9pbihcIlxcblwiKTtcbiAgICB9XG5cbiAgICBpZiAoIWFjdGl2ZUZpcmVFdmVudChcIndhcm5pbmdcIiwgd2FybmluZykpIHtcbiAgICAgICAgZm9ybWF0QW5kTG9nRXJyb3Iod2FybmluZywgXCJcIiwgdHJ1ZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWNvbnN0cnVjdFN0YWNrKG1lc3NhZ2UsIHN0YWNrcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2tzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICBzdGFja3NbaV0ucHVzaChcIkZyb20gcHJldmlvdXMgZXZlbnQ6XCIpO1xuICAgICAgICBzdGFja3NbaV0gPSBzdGFja3NbaV0uam9pbihcIlxcblwiKTtcbiAgICB9XG4gICAgaWYgKGkgPCBzdGFja3MubGVuZ3RoKSB7XG4gICAgICAgIHN0YWNrc1tpXSA9IHN0YWNrc1tpXS5qb2luKFwiXFxuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZSArIFwiXFxuXCIgKyBzdGFja3Muam9pbihcIlxcblwiKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlT3JFbXB0eUp1bXBzKHN0YWNrcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2tzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChzdGFja3NbaV0ubGVuZ3RoID09PSAwIHx8XG4gICAgICAgICAgICAoKGkgKyAxIDwgc3RhY2tzLmxlbmd0aCkgJiYgc3RhY2tzW2ldWzBdID09PSBzdGFja3NbaSsxXVswXSkpIHtcbiAgICAgICAgICAgIHN0YWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNvbW1vblJvb3RzKHN0YWNrcykge1xuICAgIHZhciBjdXJyZW50ID0gc3RhY2tzWzBdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc3RhY2tzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBwcmV2ID0gc3RhY2tzW2ldO1xuICAgICAgICB2YXIgY3VycmVudExhc3RJbmRleCA9IGN1cnJlbnQubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGN1cnJlbnRMYXN0TGluZSA9IGN1cnJlbnRbY3VycmVudExhc3RJbmRleF07XG4gICAgICAgIHZhciBjb21tb25Sb290TWVldFBvaW50ID0gLTE7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IHByZXYubGVuZ3RoIC0gMTsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgICAgIGlmIChwcmV2W2pdID09PSBjdXJyZW50TGFzdExpbmUpIHtcbiAgICAgICAgICAgICAgICBjb21tb25Sb290TWVldFBvaW50ID0gajtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSBjb21tb25Sb290TWVldFBvaW50OyBqID49IDA7IC0taikge1xuICAgICAgICAgICAgdmFyIGxpbmUgPSBwcmV2W2pdO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRbY3VycmVudExhc3RJbmRleF0gPT09IGxpbmUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50LnBvcCgpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMYXN0SW5kZXgtLTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IHByZXY7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjbGVhblN0YWNrKHN0YWNrKSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBzdGFja1tpXTtcbiAgICAgICAgdmFyIGlzVHJhY2VMaW5lID0gXCIgICAgKE5vIHN0YWNrIHRyYWNlKVwiID09PSBsaW5lIHx8XG4gICAgICAgICAgICBzdGFja0ZyYW1lUGF0dGVybi50ZXN0KGxpbmUpO1xuICAgICAgICB2YXIgaXNJbnRlcm5hbEZyYW1lID0gaXNUcmFjZUxpbmUgJiYgc2hvdWxkSWdub3JlKGxpbmUpO1xuICAgICAgICBpZiAoaXNUcmFjZUxpbmUgJiYgIWlzSW50ZXJuYWxGcmFtZSkge1xuICAgICAgICAgICAgaWYgKGluZGVudFN0YWNrRnJhbWVzICYmIGxpbmUuY2hhckF0KDApICE9PSBcIiBcIikge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBcIiAgICBcIiArIGxpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXQucHVzaChsaW5lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBzdGFja0ZyYW1lc0FzQXJyYXkoZXJyb3IpIHtcbiAgICB2YXIgc3RhY2sgPSBlcnJvci5zdGFjay5yZXBsYWNlKC9cXHMrJC9nLCBcIlwiKS5zcGxpdChcIlxcblwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBsaW5lID0gc3RhY2tbaV07XG4gICAgICAgIGlmIChcIiAgICAoTm8gc3RhY2sgdHJhY2UpXCIgPT09IGxpbmUgfHwgc3RhY2tGcmFtZVBhdHRlcm4udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgPiAwICYmIGVycm9yLm5hbWUgIT0gXCJTeW50YXhFcnJvclwiKSB7XG4gICAgICAgIHN0YWNrID0gc3RhY2suc2xpY2UoaSk7XG4gICAgfVxuICAgIHJldHVybiBzdGFjaztcbn1cblxuZnVuY3Rpb24gcGFyc2VTdGFja0FuZE1lc3NhZ2UoZXJyb3IpIHtcbiAgICB2YXIgc3RhY2sgPSBlcnJvci5zdGFjaztcbiAgICB2YXIgbWVzc2FnZSA9IGVycm9yLnRvU3RyaW5nKCk7XG4gICAgc3RhY2sgPSB0eXBlb2Ygc3RhY2sgPT09IFwic3RyaW5nXCIgJiYgc3RhY2subGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgID8gc3RhY2tGcmFtZXNBc0FycmF5KGVycm9yKSA6IFtcIiAgICAoTm8gc3RhY2sgdHJhY2UpXCJdO1xuICAgIHJldHVybiB7XG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgIHN0YWNrOiBlcnJvci5uYW1lID09IFwiU3ludGF4RXJyb3JcIiA/IHN0YWNrIDogY2xlYW5TdGFjayhzdGFjaylcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBmb3JtYXRBbmRMb2dFcnJvcihlcnJvciwgdGl0bGUsIGlzU29mdCkge1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB2YXIgbWVzc2FnZTtcbiAgICAgICAgaWYgKHV0aWwuaXNPYmplY3QoZXJyb3IpKSB7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBlcnJvci5zdGFjaztcbiAgICAgICAgICAgIG1lc3NhZ2UgPSB0aXRsZSArIGZvcm1hdFN0YWNrKHN0YWNrLCBlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gdGl0bGUgKyBTdHJpbmcoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcHJpbnRXYXJuaW5nID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHByaW50V2FybmluZyhtZXNzYWdlLCBpc1NvZnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb25zb2xlLmxvZyA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgICAgICAgICB0eXBlb2YgY29uc29sZS5sb2cgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmaXJlUmVqZWN0aW9uRXZlbnQobmFtZSwgbG9jYWxIYW5kbGVyLCByZWFzb24sIHByb21pc2UpIHtcbiAgICB2YXIgbG9jYWxFdmVudEZpcmVkID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhbEhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgbG9jYWxFdmVudEZpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSBcInJlamVjdGlvbkhhbmRsZWRcIikge1xuICAgICAgICAgICAgICAgIGxvY2FsSGFuZGxlcihwcm9taXNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9jYWxIYW5kbGVyKHJlYXNvbiwgcHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGFzeW5jLnRocm93TGF0ZXIoZSk7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09IFwidW5oYW5kbGVkUmVqZWN0aW9uXCIpIHtcbiAgICAgICAgaWYgKCFhY3RpdmVGaXJlRXZlbnQobmFtZSwgcmVhc29uLCBwcm9taXNlKSAmJiAhbG9jYWxFdmVudEZpcmVkKSB7XG4gICAgICAgICAgICBmb3JtYXRBbmRMb2dFcnJvcihyZWFzb24sIFwiVW5oYW5kbGVkIHJlamVjdGlvbiBcIik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmVGaXJlRXZlbnQobmFtZSwgcHJvbWlzZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmb3JtYXROb25FcnJvcihvYmopIHtcbiAgICB2YXIgc3RyO1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgc3RyID0gXCJbZnVuY3Rpb24gXCIgK1xuICAgICAgICAgICAgKG9iai5uYW1lIHx8IFwiYW5vbnltb3VzXCIpICtcbiAgICAgICAgICAgIFwiXVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IG9iaiAmJiB0eXBlb2Ygb2JqLnRvU3RyaW5nID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8gb2JqLnRvU3RyaW5nKCkgOiB1dGlsLnRvU3RyaW5nKG9iaik7XG4gICAgICAgIHZhciBydXNlbGVzc1RvU3RyaW5nID0gL1xcW29iamVjdCBbYS16QS1aMC05JF9dK1xcXS87XG4gICAgICAgIGlmIChydXNlbGVzc1RvU3RyaW5nLnRlc3Qoc3RyKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3U3RyID0gSlNPTi5zdHJpbmdpZnkob2JqKTtcbiAgICAgICAgICAgICAgICBzdHIgPSBuZXdTdHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaChlKSB7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgc3RyID0gXCIoZW1wdHkgYXJyYXkpXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChcIig8XCIgKyBzbmlwKHN0cikgKyBcIj4sIG5vIHN0YWNrIHRyYWNlKVwiKTtcbn1cblxuZnVuY3Rpb24gc25pcChzdHIpIHtcbiAgICB2YXIgbWF4Q2hhcnMgPSA0MTtcbiAgICBpZiAoc3RyLmxlbmd0aCA8IG1heENoYXJzKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIHJldHVybiBzdHIuc3Vic3RyKDAsIG1heENoYXJzIC0gMykgKyBcIi4uLlwiO1xufVxuXG5mdW5jdGlvbiBsb25nU3RhY2tUcmFjZXNJc1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdHlwZW9mIGNhcHR1cmVTdGFja1RyYWNlID09PSBcImZ1bmN0aW9uXCI7XG59XG5cbnZhciBzaG91bGRJZ25vcmUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9O1xudmFyIHBhcnNlTGluZUluZm9SZWdleCA9IC9bXFwvPFxcKF0oW146XFwvXSspOihcXGQrKTooPzpcXGQrKVxcKT9cXHMqJC87XG5mdW5jdGlvbiBwYXJzZUxpbmVJbmZvKGxpbmUpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IGxpbmUubWF0Y2gocGFyc2VMaW5lSW5mb1JlZ2V4KTtcbiAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmlsZU5hbWU6IG1hdGNoZXNbMV0sXG4gICAgICAgICAgICBsaW5lOiBwYXJzZUludChtYXRjaGVzWzJdLCAxMClcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNldEJvdW5kcyhmaXJzdExpbmVFcnJvciwgbGFzdExpbmVFcnJvcikge1xuICAgIGlmICghbG9uZ1N0YWNrVHJhY2VzSXNTdXBwb3J0ZWQoKSkgcmV0dXJuO1xuICAgIHZhciBmaXJzdFN0YWNrTGluZXMgPSBmaXJzdExpbmVFcnJvci5zdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICB2YXIgbGFzdFN0YWNrTGluZXMgPSBsYXN0TGluZUVycm9yLnN0YWNrLnNwbGl0KFwiXFxuXCIpO1xuICAgIHZhciBmaXJzdEluZGV4ID0gLTE7XG4gICAgdmFyIGxhc3RJbmRleCA9IC0xO1xuICAgIHZhciBmaXJzdEZpbGVOYW1lO1xuICAgIHZhciBsYXN0RmlsZU5hbWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaXJzdFN0YWNrTGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlTGluZUluZm8oZmlyc3RTdGFja0xpbmVzW2ldKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgZmlyc3RGaWxlTmFtZSA9IHJlc3VsdC5maWxlTmFtZTtcbiAgICAgICAgICAgIGZpcnN0SW5kZXggPSByZXN1bHQubGluZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdFN0YWNrTGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlTGluZUluZm8obGFzdFN0YWNrTGluZXNbaV0pO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICBsYXN0RmlsZU5hbWUgPSByZXN1bHQuZmlsZU5hbWU7XG4gICAgICAgICAgICBsYXN0SW5kZXggPSByZXN1bHQubGluZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChmaXJzdEluZGV4IDwgMCB8fCBsYXN0SW5kZXggPCAwIHx8ICFmaXJzdEZpbGVOYW1lIHx8ICFsYXN0RmlsZU5hbWUgfHxcbiAgICAgICAgZmlyc3RGaWxlTmFtZSAhPT0gbGFzdEZpbGVOYW1lIHx8IGZpcnN0SW5kZXggPj0gbGFzdEluZGV4KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzaG91bGRJZ25vcmUgPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgIGlmIChibHVlYmlyZEZyYW1lUGF0dGVybi50ZXN0KGxpbmUpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdmFyIGluZm8gPSBwYXJzZUxpbmVJbmZvKGxpbmUpO1xuICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgICAgaWYgKGluZm8uZmlsZU5hbWUgPT09IGZpcnN0RmlsZU5hbWUgJiZcbiAgICAgICAgICAgICAgICAoZmlyc3RJbmRleCA8PSBpbmZvLmxpbmUgJiYgaW5mby5saW5lIDw9IGxhc3RJbmRleCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gQ2FwdHVyZWRUcmFjZShwYXJlbnQpIHtcbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5fcHJvbWlzZXNDcmVhdGVkID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5fbGVuZ3RoID0gMSArIChwYXJlbnQgPT09IHVuZGVmaW5lZCA/IDAgOiBwYXJlbnQuX2xlbmd0aCk7XG4gICAgY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQ2FwdHVyZWRUcmFjZSk7XG4gICAgaWYgKGxlbmd0aCA+IDMyKSB0aGlzLnVuY3ljbGUoKTtcbn1cbnV0aWwuaW5oZXJpdHMoQ2FwdHVyZWRUcmFjZSwgRXJyb3IpO1xuQ29udGV4dC5DYXB0dXJlZFRyYWNlID0gQ2FwdHVyZWRUcmFjZTtcblxuQ2FwdHVyZWRUcmFjZS5wcm90b3R5cGUudW5jeWNsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLl9sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA8IDIpIHJldHVybjtcbiAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICB2YXIgc3RhY2tUb0luZGV4ID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbm9kZSA9IHRoaXM7IG5vZGUgIT09IHVuZGVmaW5lZDsgKytpKSB7XG4gICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIG5vZGUgPSBub2RlLl9wYXJlbnQ7XG4gICAgfVxuICAgIGxlbmd0aCA9IHRoaXMuX2xlbmd0aCA9IGk7XG4gICAgZm9yICh2YXIgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBzdGFjayA9IG5vZGVzW2ldLnN0YWNrO1xuICAgICAgICBpZiAoc3RhY2tUb0luZGV4W3N0YWNrXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdGFja1RvSW5kZXhbc3RhY2tdID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjdXJyZW50U3RhY2sgPSBub2Rlc1tpXS5zdGFjaztcbiAgICAgICAgdmFyIGluZGV4ID0gc3RhY2tUb0luZGV4W2N1cnJlbnRTdGFja107XG4gICAgICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmIGluZGV4ICE9PSBpKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgbm9kZXNbaW5kZXggLSAxXS5fcGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIG5vZGVzW2luZGV4IC0gMV0uX2xlbmd0aCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2Rlc1tpXS5fcGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgbm9kZXNbaV0uX2xlbmd0aCA9IDE7XG4gICAgICAgICAgICB2YXIgY3ljbGVFZGdlTm9kZSA9IGkgPiAwID8gbm9kZXNbaSAtIDFdIDogdGhpcztcblxuICAgICAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIGN5Y2xlRWRnZU5vZGUuX3BhcmVudCA9IG5vZGVzW2luZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgY3ljbGVFZGdlTm9kZS5fcGFyZW50LnVuY3ljbGUoKTtcbiAgICAgICAgICAgICAgICBjeWNsZUVkZ2VOb2RlLl9sZW5ndGggPVxuICAgICAgICAgICAgICAgICAgICBjeWNsZUVkZ2VOb2RlLl9wYXJlbnQuX2xlbmd0aCArIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN5Y2xlRWRnZU5vZGUuX3BhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBjeWNsZUVkZ2VOb2RlLl9sZW5ndGggPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGN1cnJlbnRDaGlsZExlbmd0aCA9IGN5Y2xlRWRnZU5vZGUuX2xlbmd0aCArIDE7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gaSAtIDI7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgICAgICAgICAgbm9kZXNbal0uX2xlbmd0aCA9IGN1cnJlbnRDaGlsZExlbmd0aDtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2hpbGRMZW5ndGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkNhcHR1cmVkVHJhY2UucHJvdG90eXBlLmF0dGFjaEV4dHJhVHJhY2UgPSBmdW5jdGlvbihlcnJvcikge1xuICAgIGlmIChlcnJvci5fX3N0YWNrQ2xlYW5lZF9fKSByZXR1cm47XG4gICAgdGhpcy51bmN5Y2xlKCk7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlU3RhY2tBbmRNZXNzYWdlKGVycm9yKTtcbiAgICB2YXIgbWVzc2FnZSA9IHBhcnNlZC5tZXNzYWdlO1xuICAgIHZhciBzdGFja3MgPSBbcGFyc2VkLnN0YWNrXTtcblxuICAgIHZhciB0cmFjZSA9IHRoaXM7XG4gICAgd2hpbGUgKHRyYWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3RhY2tzLnB1c2goY2xlYW5TdGFjayh0cmFjZS5zdGFjay5zcGxpdChcIlxcblwiKSkpO1xuICAgICAgICB0cmFjZSA9IHRyYWNlLl9wYXJlbnQ7XG4gICAgfVxuICAgIHJlbW92ZUNvbW1vblJvb3RzKHN0YWNrcyk7XG4gICAgcmVtb3ZlRHVwbGljYXRlT3JFbXB0eUp1bXBzKHN0YWNrcyk7XG4gICAgdXRpbC5ub3RFbnVtZXJhYmxlUHJvcChlcnJvciwgXCJzdGFja1wiLCByZWNvbnN0cnVjdFN0YWNrKG1lc3NhZ2UsIHN0YWNrcykpO1xuICAgIHV0aWwubm90RW51bWVyYWJsZVByb3AoZXJyb3IsIFwiX19zdGFja0NsZWFuZWRfX1wiLCB0cnVlKTtcbn07XG5cbnZhciBjYXB0dXJlU3RhY2tUcmFjZSA9IChmdW5jdGlvbiBzdGFja0RldGVjdGlvbigpIHtcbiAgICB2YXIgdjhzdGFja0ZyYW1lUGF0dGVybiA9IC9eXFxzKmF0XFxzKi87XG4gICAgdmFyIHY4c3RhY2tGb3JtYXR0ZXIgPSBmdW5jdGlvbihzdGFjaywgZXJyb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGFjayA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHN0YWNrO1xuXG4gICAgICAgIGlmIChlcnJvci5uYW1lICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdE5vbkVycm9yKGVycm9yKTtcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBFcnJvci5zdGFja1RyYWNlTGltaXQgPT09IFwibnVtYmVyXCIgJiZcbiAgICAgICAgdHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ICs9IDY7XG4gICAgICAgIHN0YWNrRnJhbWVQYXR0ZXJuID0gdjhzdGFja0ZyYW1lUGF0dGVybjtcbiAgICAgICAgZm9ybWF0U3RhY2sgPSB2OHN0YWNrRm9ybWF0dGVyO1xuICAgICAgICB2YXIgY2FwdHVyZVN0YWNrVHJhY2UgPSBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZTtcblxuICAgICAgICBzaG91bGRJZ25vcmUgPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gYmx1ZWJpcmRGcmFtZVBhdHRlcm4udGVzdChsaW5lKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHJlY2VpdmVyLCBpZ25vcmVVbnRpbCkge1xuICAgICAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ICs9IDY7XG4gICAgICAgICAgICBjYXB0dXJlU3RhY2tUcmFjZShyZWNlaXZlciwgaWdub3JlVW50aWwpO1xuICAgICAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0IC09IDY7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcblxuICAgIGlmICh0eXBlb2YgZXJyLnN0YWNrID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgIGVyci5zdGFjay5zcGxpdChcIlxcblwiKVswXS5pbmRleE9mKFwic3RhY2tEZXRlY3Rpb25AXCIpID49IDApIHtcbiAgICAgICAgc3RhY2tGcmFtZVBhdHRlcm4gPSAvQC87XG4gICAgICAgIGZvcm1hdFN0YWNrID0gdjhzdGFja0Zvcm1hdHRlcjtcbiAgICAgICAgaW5kZW50U3RhY2tGcmFtZXMgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY2FwdHVyZVN0YWNrVHJhY2Uobykge1xuICAgICAgICAgICAgby5zdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBoYXNTdGFja0FmdGVyVGhyb3c7XG4gICAgdHJ5IHsgdGhyb3cgbmV3IEVycm9yKCk7IH1cbiAgICBjYXRjaChlKSB7XG4gICAgICAgIGhhc1N0YWNrQWZ0ZXJUaHJvdyA9IChcInN0YWNrXCIgaW4gZSk7XG4gICAgfVxuICAgIGlmICghKFwic3RhY2tcIiBpbiBlcnIpICYmIGhhc1N0YWNrQWZ0ZXJUaHJvdyAmJlxuICAgICAgICB0eXBlb2YgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHN0YWNrRnJhbWVQYXR0ZXJuID0gdjhzdGFja0ZyYW1lUGF0dGVybjtcbiAgICAgICAgZm9ybWF0U3RhY2sgPSB2OHN0YWNrRm9ybWF0dGVyO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY2FwdHVyZVN0YWNrVHJhY2Uobykge1xuICAgICAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ICs9IDY7XG4gICAgICAgICAgICB0cnkgeyB0aHJvdyBuZXcgRXJyb3IoKTsgfVxuICAgICAgICAgICAgY2F0Y2goZSkgeyBvLnN0YWNrID0gZS5zdGFjazsgfVxuICAgICAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0IC09IDY7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZm9ybWF0U3RhY2sgPSBmdW5jdGlvbihzdGFjaywgZXJyb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGFjayA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHN0YWNrO1xuXG4gICAgICAgIGlmICgodHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiIHx8XG4gICAgICAgICAgICB0eXBlb2YgZXJyb3IgPT09IFwiZnVuY3Rpb25cIikgJiZcbiAgICAgICAgICAgIGVycm9yLm5hbWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgZXJyb3IubWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3IudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0Tm9uRXJyb3IoZXJyb3IpO1xuICAgIH07XG5cbiAgICByZXR1cm4gbnVsbDtcblxufSkoW10pO1xuXG5pZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGNvbnNvbGUud2FybiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9O1xuICAgIGlmICh1dGlsLmlzTm9kZSAmJiBwcm9jZXNzLnN0ZGVyci5pc1RUWSkge1xuICAgICAgICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbihtZXNzYWdlLCBpc1NvZnQpIHtcbiAgICAgICAgICAgIHZhciBjb2xvciA9IGlzU29mdCA/IFwiXFx1MDAxYlszM21cIiA6IFwiXFx1MDAxYlszMW1cIjtcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybihjb2xvciArIG1lc3NhZ2UgKyBcIlxcdTAwMWJbMG1cXG5cIik7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmICghdXRpbC5pc05vZGUgJiYgdHlwZW9mIChuZXcgRXJyb3IoKS5zdGFjaykgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24obWVzc2FnZSwgaXNTb2Z0KSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCIlY1wiICsgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU29mdCA/IFwiY29sb3I6IGRhcmtvcmFuZ2VcIiA6IFwiY29sb3I6IHJlZFwiKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbnZhciBjb25maWcgPSB7XG4gICAgd2FybmluZ3M6IHdhcm5pbmdzLFxuICAgIGxvbmdTdGFja1RyYWNlczogZmFsc2UsXG4gICAgY2FuY2VsbGF0aW9uOiBmYWxzZSxcbiAgICBtb25pdG9yaW5nOiBmYWxzZVxufTtcblxuaWYgKGxvbmdTdGFja1RyYWNlcykgUHJvbWlzZS5sb25nU3RhY2tUcmFjZXMoKTtcblxucmV0dXJuIHtcbiAgICBsb25nU3RhY2tUcmFjZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY29uZmlnLmxvbmdTdGFja1RyYWNlcztcbiAgICB9LFxuICAgIHdhcm5pbmdzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy53YXJuaW5ncztcbiAgICB9LFxuICAgIGNhbmNlbGxhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjb25maWcuY2FuY2VsbGF0aW9uO1xuICAgIH0sXG4gICAgbW9uaXRvcmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjb25maWcubW9uaXRvcmluZztcbiAgICB9LFxuICAgIHByb3BhZ2F0ZUZyb21GdW5jdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBwcm9wYWdhdGVGcm9tRnVuY3Rpb247XG4gICAgfSxcbiAgICBib3VuZFZhbHVlRnVuY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYm91bmRWYWx1ZUZ1bmN0aW9uO1xuICAgIH0sXG4gICAgY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zOiBjaGVja0ZvcmdvdHRlblJldHVybnMsXG4gICAgc2V0Qm91bmRzOiBzZXRCb3VuZHMsXG4gICAgd2Fybjogd2FybixcbiAgICBkZXByZWNhdGVkOiBkZXByZWNhdGVkLFxuICAgIENhcHR1cmVkVHJhY2U6IENhcHR1cmVkVHJhY2UsXG4gICAgZmlyZURvbUV2ZW50OiBmaXJlRG9tRXZlbnQsXG4gICAgZmlyZUdsb2JhbEV2ZW50OiBmaXJlR2xvYmFsRXZlbnRcbn07XG59O1xuXG59LHtcIi4vZXJyb3JzXCI6MTIsXCIuL3V0aWxcIjozNn1dLDEwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlKSB7XG5mdW5jdGlvbiByZXR1cm5lcigpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbn1cbmZ1bmN0aW9uIHRocm93ZXIoKSB7XG4gICAgdGhyb3cgdGhpcy5yZWFzb247XG59XG5cblByb21pc2UucHJvdG90eXBlW1wicmV0dXJuXCJdID1cblByb21pc2UucHJvdG90eXBlLnRoZW5SZXR1cm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB2YWx1ZS5zdXBwcmVzc1VuaGFuZGxlZFJlamVjdGlvbnMoKTtcbiAgICByZXR1cm4gdGhpcy5fdGhlbihcbiAgICAgICAgcmV0dXJuZXIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7dmFsdWU6IHZhbHVlfSwgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlW1widGhyb3dcIl0gPVxuUHJvbWlzZS5wcm90b3R5cGUudGhlblRocm93ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHJldHVybiB0aGlzLl90aGVuKFxuICAgICAgICB0aHJvd2VyLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwge3JlYXNvbjogcmVhc29ufSwgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmNhdGNoVGhyb3cgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGhlbihcbiAgICAgICAgICAgIHVuZGVmaW5lZCwgdGhyb3dlciwgdW5kZWZpbmVkLCB7cmVhc29uOiByZWFzb259LCB1bmRlZmluZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfcmVhc29uID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCkge3Rocm93IF9yZWFzb247fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2F1Z2h0KHJlYXNvbiwgaGFuZGxlcik7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2hSZXR1cm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHZhbHVlLnN1cHByZXNzVW5oYW5kbGVkUmVqZWN0aW9ucygpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdGhlbihcbiAgICAgICAgICAgIHVuZGVmaW5lZCwgcmV0dXJuZXIsIHVuZGVmaW5lZCwge3ZhbHVlOiB2YWx1ZX0sIHVuZGVmaW5lZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF92YWx1ZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgaWYgKF92YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIF92YWx1ZS5zdXBwcmVzc1VuaGFuZGxlZFJlamVjdGlvbnMoKTtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbigpIHtyZXR1cm4gX3ZhbHVlO307XG4gICAgICAgIHJldHVybiB0aGlzLmNhdWdodCh2YWx1ZSwgaGFuZGxlcik7XG4gICAgfVxufTtcbn07XG5cbn0se31dLDExOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCkge1xudmFyIFByb21pc2VSZWR1Y2UgPSBQcm9taXNlLnJlZHVjZTtcbnZhciBQcm9taXNlQWxsID0gUHJvbWlzZS5hbGw7XG5cbmZ1bmN0aW9uIHByb21pc2VBbGxUaGlzKCkge1xuICAgIHJldHVybiBQcm9taXNlQWxsKHRoaXMpO1xufVxuXG5mdW5jdGlvbiBQcm9taXNlTWFwU2VyaWVzKHByb21pc2VzLCBmbikge1xuICAgIHJldHVybiBQcm9taXNlUmVkdWNlKHByb21pc2VzLCBmbiwgSU5URVJOQUwsIElOVEVSTkFMKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuZWFjaCA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBQcm9taXNlUmVkdWNlKHRoaXMsIGZuLCBJTlRFUk5BTCwgMClcbiAgICAgICAgICAgICAgLl90aGVuKHByb21pc2VBbGxUaGlzLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdGhpcywgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm1hcFNlcmllcyA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBQcm9taXNlUmVkdWNlKHRoaXMsIGZuLCBJTlRFUk5BTCwgSU5URVJOQUwpO1xufTtcblxuUHJvbWlzZS5lYWNoID0gZnVuY3Rpb24gKHByb21pc2VzLCBmbikge1xuICAgIHJldHVybiBQcm9taXNlUmVkdWNlKHByb21pc2VzLCBmbiwgSU5URVJOQUwsIDApXG4gICAgICAgICAgICAgIC5fdGhlbihwcm9taXNlQWxsVGhpcywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHByb21pc2VzLCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5tYXBTZXJpZXMgPSBQcm9taXNlTWFwU2VyaWVzO1xufTtcblxuXG59LHt9XSwxMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbnZhciBlczUgPSBfZGVyZXFfKFwiLi9lczVcIik7XG52YXIgT2JqZWN0ZnJlZXplID0gZXM1LmZyZWV6ZTtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcbnZhciBpbmhlcml0cyA9IHV0aWwuaW5oZXJpdHM7XG52YXIgbm90RW51bWVyYWJsZVByb3AgPSB1dGlsLm5vdEVudW1lcmFibGVQcm9wO1xuXG5mdW5jdGlvbiBzdWJFcnJvcihuYW1lUHJvcGVydHksIGRlZmF1bHRNZXNzYWdlKSB7XG4gICAgZnVuY3Rpb24gU3ViRXJyb3IobWVzc2FnZSkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3ViRXJyb3IpKSByZXR1cm4gbmV3IFN1YkVycm9yKG1lc3NhZ2UpO1xuICAgICAgICBub3RFbnVtZXJhYmxlUHJvcCh0aGlzLCBcIm1lc3NhZ2VcIixcbiAgICAgICAgICAgIHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8gbWVzc2FnZSA6IGRlZmF1bHRNZXNzYWdlKTtcbiAgICAgICAgbm90RW51bWVyYWJsZVByb3AodGhpcywgXCJuYW1lXCIsIG5hbWVQcm9wZXJ0eSk7XG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBFcnJvci5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaGVyaXRzKFN1YkVycm9yLCBFcnJvcik7XG4gICAgcmV0dXJuIFN1YkVycm9yO1xufVxuXG52YXIgX1R5cGVFcnJvciwgX1JhbmdlRXJyb3I7XG52YXIgV2FybmluZyA9IHN1YkVycm9yKFwiV2FybmluZ1wiLCBcIndhcm5pbmdcIik7XG52YXIgQ2FuY2VsbGF0aW9uRXJyb3IgPSBzdWJFcnJvcihcIkNhbmNlbGxhdGlvbkVycm9yXCIsIFwiY2FuY2VsbGF0aW9uIGVycm9yXCIpO1xudmFyIFRpbWVvdXRFcnJvciA9IHN1YkVycm9yKFwiVGltZW91dEVycm9yXCIsIFwidGltZW91dCBlcnJvclwiKTtcbnZhciBBZ2dyZWdhdGVFcnJvciA9IHN1YkVycm9yKFwiQWdncmVnYXRlRXJyb3JcIiwgXCJhZ2dyZWdhdGUgZXJyb3JcIik7XG50cnkge1xuICAgIF9UeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG4gICAgX1JhbmdlRXJyb3IgPSBSYW5nZUVycm9yO1xufSBjYXRjaChlKSB7XG4gICAgX1R5cGVFcnJvciA9IHN1YkVycm9yKFwiVHlwZUVycm9yXCIsIFwidHlwZSBlcnJvclwiKTtcbiAgICBfUmFuZ2VFcnJvciA9IHN1YkVycm9yKFwiUmFuZ2VFcnJvclwiLCBcInJhbmdlIGVycm9yXCIpO1xufVxuXG52YXIgbWV0aG9kcyA9IChcImpvaW4gcG9wIHB1c2ggc2hpZnQgdW5zaGlmdCBzbGljZSBmaWx0ZXIgZm9yRWFjaCBzb21lIFwiICtcbiAgICBcImV2ZXJ5IG1hcCBpbmRleE9mIGxhc3RJbmRleE9mIHJlZHVjZSByZWR1Y2VSaWdodCBzb3J0IHJldmVyc2VcIikuc3BsaXQoXCIgXCIpO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IG1ldGhvZHMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAodHlwZW9mIEFycmF5LnByb3RvdHlwZVttZXRob2RzW2ldXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIEFnZ3JlZ2F0ZUVycm9yLnByb3RvdHlwZVttZXRob2RzW2ldXSA9IEFycmF5LnByb3RvdHlwZVttZXRob2RzW2ldXTtcbiAgICB9XG59XG5cbmVzNS5kZWZpbmVQcm9wZXJ0eShBZ2dyZWdhdGVFcnJvci5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICB2YWx1ZTogMCxcbiAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWVcbn0pO1xuQWdncmVnYXRlRXJyb3IucHJvdG90eXBlW1wiaXNPcGVyYXRpb25hbFwiXSA9IHRydWU7XG52YXIgbGV2ZWwgPSAwO1xuQWdncmVnYXRlRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGluZGVudCA9IEFycmF5KGxldmVsICogNCArIDEpLmpvaW4oXCIgXCIpO1xuICAgIHZhciByZXQgPSBcIlxcblwiICsgaW5kZW50ICsgXCJBZ2dyZWdhdGVFcnJvciBvZjpcIiArIFwiXFxuXCI7XG4gICAgbGV2ZWwrKztcbiAgICBpbmRlbnQgPSBBcnJheShsZXZlbCAqIDQgKyAxKS5qb2luKFwiIFwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHN0ciA9IHRoaXNbaV0gPT09IHRoaXMgPyBcIltDaXJjdWxhciBBZ2dyZWdhdGVFcnJvcl1cIiA6IHRoaXNbaV0gKyBcIlwiO1xuICAgICAgICB2YXIgbGluZXMgPSBzdHIuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIGxpbmVzW2pdID0gaW5kZW50ICsgbGluZXNbal07XG4gICAgICAgIH1cbiAgICAgICAgc3RyID0gbGluZXMuam9pbihcIlxcblwiKTtcbiAgICAgICAgcmV0ICs9IHN0ciArIFwiXFxuXCI7XG4gICAgfVxuICAgIGxldmVsLS07XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIE9wZXJhdGlvbmFsRXJyb3IobWVzc2FnZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBPcGVyYXRpb25hbEVycm9yKSlcbiAgICAgICAgcmV0dXJuIG5ldyBPcGVyYXRpb25hbEVycm9yKG1lc3NhZ2UpO1xuICAgIG5vdEVudW1lcmFibGVQcm9wKHRoaXMsIFwibmFtZVwiLCBcIk9wZXJhdGlvbmFsRXJyb3JcIik7XG4gICAgbm90RW51bWVyYWJsZVByb3AodGhpcywgXCJtZXNzYWdlXCIsIG1lc3NhZ2UpO1xuICAgIHRoaXMuY2F1c2UgPSBtZXNzYWdlO1xuICAgIHRoaXNbXCJpc09wZXJhdGlvbmFsXCJdID0gdHJ1ZTtcblxuICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgbm90RW51bWVyYWJsZVByb3AodGhpcywgXCJtZXNzYWdlXCIsIG1lc3NhZ2UubWVzc2FnZSk7XG4gICAgICAgIG5vdEVudW1lcmFibGVQcm9wKHRoaXMsIFwic3RhY2tcIiwgbWVzc2FnZS5zdGFjayk7XG4gICAgfSBlbHNlIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG5cbn1cbmluaGVyaXRzKE9wZXJhdGlvbmFsRXJyb3IsIEVycm9yKTtcblxudmFyIGVycm9yVHlwZXMgPSBFcnJvcltcIl9fQmx1ZWJpcmRFcnJvclR5cGVzX19cIl07XG5pZiAoIWVycm9yVHlwZXMpIHtcbiAgICBlcnJvclR5cGVzID0gT2JqZWN0ZnJlZXplKHtcbiAgICAgICAgQ2FuY2VsbGF0aW9uRXJyb3I6IENhbmNlbGxhdGlvbkVycm9yLFxuICAgICAgICBUaW1lb3V0RXJyb3I6IFRpbWVvdXRFcnJvcixcbiAgICAgICAgT3BlcmF0aW9uYWxFcnJvcjogT3BlcmF0aW9uYWxFcnJvcixcbiAgICAgICAgUmVqZWN0aW9uRXJyb3I6IE9wZXJhdGlvbmFsRXJyb3IsXG4gICAgICAgIEFnZ3JlZ2F0ZUVycm9yOiBBZ2dyZWdhdGVFcnJvclxuICAgIH0pO1xuICAgIGVzNS5kZWZpbmVQcm9wZXJ0eShFcnJvciwgXCJfX0JsdWViaXJkRXJyb3JUeXBlc19fXCIsIHtcbiAgICAgICAgdmFsdWU6IGVycm9yVHlwZXMsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgRXJyb3I6IEVycm9yLFxuICAgIFR5cGVFcnJvcjogX1R5cGVFcnJvcixcbiAgICBSYW5nZUVycm9yOiBfUmFuZ2VFcnJvcixcbiAgICBDYW5jZWxsYXRpb25FcnJvcjogZXJyb3JUeXBlcy5DYW5jZWxsYXRpb25FcnJvcixcbiAgICBPcGVyYXRpb25hbEVycm9yOiBlcnJvclR5cGVzLk9wZXJhdGlvbmFsRXJyb3IsXG4gICAgVGltZW91dEVycm9yOiBlcnJvclR5cGVzLlRpbWVvdXRFcnJvcixcbiAgICBBZ2dyZWdhdGVFcnJvcjogZXJyb3JUeXBlcy5BZ2dyZWdhdGVFcnJvcixcbiAgICBXYXJuaW5nOiBXYXJuaW5nXG59O1xuXG59LHtcIi4vZXM1XCI6MTMsXCIuL3V0aWxcIjozNn1dLDEzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBpc0VTNSA9IChmdW5jdGlvbigpe1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHJldHVybiB0aGlzID09PSB1bmRlZmluZWQ7XG59KSgpO1xuXG5pZiAoaXNFUzUpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgZnJlZXplOiBPYmplY3QuZnJlZXplLFxuICAgICAgICBkZWZpbmVQcm9wZXJ0eTogT2JqZWN0LmRlZmluZVByb3BlcnR5LFxuICAgICAgICBnZXREZXNjcmlwdG9yOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAgICAgICBrZXlzOiBPYmplY3Qua2V5cyxcbiAgICAgICAgbmFtZXM6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAgICAgICBnZXRQcm90b3R5cGVPZjogT2JqZWN0LmdldFByb3RvdHlwZU9mLFxuICAgICAgICBpc0FycmF5OiBBcnJheS5pc0FycmF5LFxuICAgICAgICBpc0VTNTogaXNFUzUsXG4gICAgICAgIHByb3BlcnR5SXNXcml0YWJsZTogZnVuY3Rpb24ob2JqLCBwcm9wKSB7XG4gICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBwcm9wKTtcbiAgICAgICAgICAgIHJldHVybiAhISghZGVzY3JpcHRvciB8fCBkZXNjcmlwdG9yLndyaXRhYmxlIHx8IGRlc2NyaXB0b3Iuc2V0KTtcbiAgICAgICAgfVxuICAgIH07XG59IGVsc2Uge1xuICAgIHZhciBoYXMgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbiAgICB2YXIgc3RyID0ge30udG9TdHJpbmc7XG4gICAgdmFyIHByb3RvID0ge30uY29uc3RydWN0b3IucHJvdG90eXBlO1xuXG4gICAgdmFyIE9iamVjdEtleXMgPSBmdW5jdGlvbiAobykge1xuICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvKSB7XG4gICAgICAgICAgICBpZiAoaGFzLmNhbGwobywga2V5KSkge1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgdmFyIE9iamVjdEdldERlc2NyaXB0b3IgPSBmdW5jdGlvbihvLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHt2YWx1ZTogb1trZXldfTtcbiAgICB9O1xuXG4gICAgdmFyIE9iamVjdERlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG8sIGtleSwgZGVzYykge1xuICAgICAgICBvW2tleV0gPSBkZXNjLnZhbHVlO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuXG4gICAgdmFyIE9iamVjdEZyZWV6ZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuXG4gICAgdmFyIE9iamVjdEdldFByb3RvdHlwZU9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdChvYmopLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBBcnJheUlzQXJyYXkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgaXNBcnJheTogQXJyYXlJc0FycmF5LFxuICAgICAgICBrZXlzOiBPYmplY3RLZXlzLFxuICAgICAgICBuYW1lczogT2JqZWN0S2V5cyxcbiAgICAgICAgZGVmaW5lUHJvcGVydHk6IE9iamVjdERlZmluZVByb3BlcnR5LFxuICAgICAgICBnZXREZXNjcmlwdG9yOiBPYmplY3RHZXREZXNjcmlwdG9yLFxuICAgICAgICBmcmVlemU6IE9iamVjdEZyZWV6ZSxcbiAgICAgICAgZ2V0UHJvdG90eXBlT2Y6IE9iamVjdEdldFByb3RvdHlwZU9mLFxuICAgICAgICBpc0VTNTogaXNFUzUsXG4gICAgICAgIHByb3BlcnR5SXNXcml0YWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbn0se31dLDE0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCkge1xudmFyIFByb21pc2VNYXAgPSBQcm9taXNlLm1hcDtcblxuUHJvbWlzZS5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKGZuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFByb21pc2VNYXAodGhpcywgZm4sIG9wdGlvbnMsIElOVEVSTkFMKTtcbn07XG5cblByb21pc2UuZmlsdGVyID0gZnVuY3Rpb24gKHByb21pc2VzLCBmbiwgb3B0aW9ucykge1xuICAgIHJldHVybiBQcm9taXNlTWFwKHByb21pc2VzLCBmbiwgb3B0aW9ucywgSU5URVJOQUwpO1xufTtcbn07XG5cbn0se31dLDE1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBORVhUX0ZJTFRFUikge1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xudmFyIENhbmNlbGxhdGlvbkVycm9yID0gUHJvbWlzZS5DYW5jZWxsYXRpb25FcnJvcjtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG52YXIgY2F0Y2hGaWx0ZXIgPSBfZGVyZXFfKFwiLi9jYXRjaF9maWx0ZXJcIikoTkVYVF9GSUxURVIpO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaEhhbmRsZXJDb250ZXh0KHByb21pc2UsIHR5cGUsIGhhbmRsZXIpIHtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICB0aGlzLmNhbGxlZCA9IGZhbHNlO1xuICAgIHRoaXMuY2FuY2VsUHJvbWlzZSA9IG51bGw7XG59XG5cblBhc3NUaHJvdWdoSGFuZGxlckNvbnRleHQucHJvdG90eXBlLmlzRmluYWxseUhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSAwO1xufTtcblxuZnVuY3Rpb24gRmluYWxseUhhbmRsZXJDYW5jZWxSZWFjdGlvbihmaW5hbGx5SGFuZGxlcikge1xuICAgIHRoaXMuZmluYWxseUhhbmRsZXIgPSBmaW5hbGx5SGFuZGxlcjtcbn1cblxuRmluYWxseUhhbmRsZXJDYW5jZWxSZWFjdGlvbi5wcm90b3R5cGUuX3Jlc3VsdENhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGNoZWNrQ2FuY2VsKHRoaXMuZmluYWxseUhhbmRsZXIpO1xufTtcblxuZnVuY3Rpb24gY2hlY2tDYW5jZWwoY3R4LCByZWFzb24pIHtcbiAgICBpZiAoY3R4LmNhbmNlbFByb21pc2UgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGN0eC5jYW5jZWxQcm9taXNlLl9yZWplY3QocmVhc29uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5jYW5jZWxQcm9taXNlLl9jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguY2FuY2VsUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHN1Y2NlZWQoKSB7XG4gICAgcmV0dXJuIGZpbmFsbHlIYW5kbGVyLmNhbGwodGhpcywgdGhpcy5wcm9taXNlLl90YXJnZXQoKS5fc2V0dGxlZFZhbHVlKCkpO1xufVxuZnVuY3Rpb24gZmFpbChyZWFzb24pIHtcbiAgICBpZiAoY2hlY2tDYW5jZWwodGhpcywgcmVhc29uKSkgcmV0dXJuO1xuICAgIGVycm9yT2JqLmUgPSByZWFzb247XG4gICAgcmV0dXJuIGVycm9yT2JqO1xufVxuZnVuY3Rpb24gZmluYWxseUhhbmRsZXIocmVhc29uT3JWYWx1ZSkge1xuICAgIHZhciBwcm9taXNlID0gdGhpcy5wcm9taXNlO1xuICAgIHZhciBoYW5kbGVyID0gdGhpcy5oYW5kbGVyO1xuXG4gICAgaWYgKCF0aGlzLmNhbGxlZCkge1xuICAgICAgICB0aGlzLmNhbGxlZCA9IHRydWU7XG4gICAgICAgIHZhciByZXQgPSB0aGlzLmlzRmluYWxseUhhbmRsZXIoKVxuICAgICAgICAgICAgPyBoYW5kbGVyLmNhbGwocHJvbWlzZS5fYm91bmRWYWx1ZSgpKVxuICAgICAgICAgICAgOiBoYW5kbGVyLmNhbGwocHJvbWlzZS5fYm91bmRWYWx1ZSgpLCByZWFzb25PclZhbHVlKTtcbiAgICAgICAgaWYgKHJldCA9PT0gTkVYVF9GSUxURVIpIHtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0gZWxzZSBpZiAocmV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHByb21pc2UuX3NldFJldHVybmVkTm9uVW5kZWZpbmVkKCk7XG4gICAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZShyZXQsIHByb21pc2UpO1xuICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jYW5jZWxQcm9taXNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZS5faXNDYW5jZWxsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlYXNvbiA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IENhbmNlbGxhdGlvbkVycm9yKFwibGF0ZSBjYW5jZWxsYXRpb24gb2JzZXJ2ZXJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9hdHRhY2hFeHRyYVRyYWNlKHJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvck9iai5lID0gcmVhc29uO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yT2JqO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1heWJlUHJvbWlzZS5pc1BlbmRpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl9hdHRhY2hDYW5jZWxsYXRpb25DYWxsYmFjayhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgRmluYWxseUhhbmRsZXJDYW5jZWxSZWFjdGlvbih0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1heWJlUHJvbWlzZS5fdGhlbihcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VlZCwgZmFpbCwgdW5kZWZpbmVkLCB0aGlzLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb21pc2UuaXNSZWplY3RlZCgpKSB7XG4gICAgICAgIGNoZWNrQ2FuY2VsKHRoaXMpO1xuICAgICAgICBlcnJvck9iai5lID0gcmVhc29uT3JWYWx1ZTtcbiAgICAgICAgcmV0dXJuIGVycm9yT2JqO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNoZWNrQ2FuY2VsKHRoaXMpO1xuICAgICAgICByZXR1cm4gcmVhc29uT3JWYWx1ZTtcbiAgICB9XG59XG5cblByb21pc2UucHJvdG90eXBlLl9wYXNzVGhyb3VnaCA9IGZ1bmN0aW9uKGhhbmRsZXIsIHR5cGUsIHN1Y2Nlc3MsIGZhaWwpIHtcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRoaXMudGhlbigpO1xuICAgIHJldHVybiB0aGlzLl90aGVuKHN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgZmFpbCxcbiAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgbmV3IFBhc3NUaHJvdWdoSGFuZGxlckNvbnRleHQodGhpcywgdHlwZSwgaGFuZGxlciksXG4gICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmxhc3RseSA9XG5Qcm9taXNlLnByb3RvdHlwZVtcImZpbmFsbHlcIl0gPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgIHJldHVybiB0aGlzLl9wYXNzVGhyb3VnaChoYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5SGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseUhhbmRsZXIpO1xufTtcblxuXG5Qcm9taXNlLnByb3RvdHlwZS50YXAgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgIHJldHVybiB0aGlzLl9wYXNzVGhyb3VnaChoYW5kbGVyLCAxLCBmaW5hbGx5SGFuZGxlcik7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50YXBDYXRjaCA9IGZ1bmN0aW9uIChoYW5kbGVyT3JQcmVkaWNhdGUpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZihsZW4gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bhc3NUaHJvdWdoKGhhbmRsZXJPclByZWRpY2F0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5SGFuZGxlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgIHZhciBjYXRjaEluc3RhbmNlcyA9IG5ldyBBcnJheShsZW4gLSAxKSxcbiAgICAgICAgICAgIGogPSAwLCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuIC0gMTsgKytpKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGlmICh1dGlsLmlzT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgY2F0Y2hJbnN0YW5jZXNbaisrXSA9IGl0ZW07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcInRhcENhdGNoIHN0YXRlbWVudCBwcmVkaWNhdGU6IFwiXG4gICAgICAgICAgICAgICAgICAgICsgXCJleHBlY3RpbmcgYW4gb2JqZWN0IGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGl0ZW0pXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2hJbnN0YW5jZXMubGVuZ3RoID0gajtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBhcmd1bWVudHNbaV07XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXNzVGhyb3VnaChjYXRjaEZpbHRlcihjYXRjaEluc3RhbmNlcywgaGFuZGxlciwgdGhpcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseUhhbmRsZXIpO1xuICAgIH1cblxufTtcblxucmV0dXJuIFBhc3NUaHJvdWdoSGFuZGxlckNvbnRleHQ7XG59O1xuXG59LHtcIi4vY2F0Y2hfZmlsdGVyXCI6NyxcIi4vdXRpbFwiOjM2fV0sMTY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFwaVJlamVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRyeUNvbnZlcnRUb1Byb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFByb3h5YWJsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcpIHtcbnZhciBlcnJvcnMgPSBfZGVyZXFfKFwiLi9lcnJvcnNcIik7XG52YXIgVHlwZUVycm9yID0gZXJyb3JzLlR5cGVFcnJvcjtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xudmFyIHlpZWxkSGFuZGxlcnMgPSBbXTtcblxuZnVuY3Rpb24gcHJvbWlzZUZyb21ZaWVsZEhhbmRsZXIodmFsdWUsIHlpZWxkSGFuZGxlcnMsIHRyYWNlUGFyZW50KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB5aWVsZEhhbmRsZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHRyYWNlUGFyZW50Ll9wdXNoQ29udGV4dCgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2goeWllbGRIYW5kbGVyc1tpXSkodmFsdWUpO1xuICAgICAgICB0cmFjZVBhcmVudC5fcG9wQ29udGV4dCgpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikge1xuICAgICAgICAgICAgdHJhY2VQYXJlbnQuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgICAgICB2YXIgcmV0ID0gUHJvbWlzZS5yZWplY3QoZXJyb3JPYmouZSk7XG4gICAgICAgICAgICB0cmFjZVBhcmVudC5fcG9wQ29udGV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZShyZXN1bHQsIHRyYWNlUGFyZW50KTtcbiAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHJldHVybiBtYXliZVByb21pc2U7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBQcm9taXNlU3Bhd24oZ2VuZXJhdG9yRnVuY3Rpb24sIHJlY2VpdmVyLCB5aWVsZEhhbmRsZXIsIHN0YWNrKSB7XG4gICAgaWYgKGRlYnVnLmNhbmNlbGxhdGlvbigpKSB7XG4gICAgICAgIHZhciBpbnRlcm5hbCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgdmFyIF9maW5hbGx5UHJvbWlzZSA9IHRoaXMuX2ZpbmFsbHlQcm9taXNlID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICB0aGlzLl9wcm9taXNlID0gaW50ZXJuYWwubGFzdGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9maW5hbGx5UHJvbWlzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGludGVybmFsLl9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgICAgICBpbnRlcm5hbC5fc2V0T25DYW5jZWwodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl9wcm9taXNlID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICBwcm9taXNlLl9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgIH1cbiAgICB0aGlzLl9zdGFjayA9IHN0YWNrO1xuICAgIHRoaXMuX2dlbmVyYXRvckZ1bmN0aW9uID0gZ2VuZXJhdG9yRnVuY3Rpb247XG4gICAgdGhpcy5fcmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICB0aGlzLl9nZW5lcmF0b3IgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5feWllbGRIYW5kbGVycyA9IHR5cGVvZiB5aWVsZEhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/IFt5aWVsZEhhbmRsZXJdLmNvbmNhdCh5aWVsZEhhbmRsZXJzKVxuICAgICAgICA6IHlpZWxkSGFuZGxlcnM7XG4gICAgdGhpcy5feWllbGRlZFByb21pc2UgPSBudWxsO1xuICAgIHRoaXMuX2NhbmNlbGxhdGlvblBoYXNlID0gZmFsc2U7XG59XG51dGlsLmluaGVyaXRzKFByb21pc2VTcGF3biwgUHJveHlhYmxlKTtcblxuUHJvbWlzZVNwYXduLnByb3RvdHlwZS5faXNSZXNvbHZlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm9taXNlID09PSBudWxsO1xufTtcblxuUHJvbWlzZVNwYXduLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3Byb21pc2UgPSB0aGlzLl9nZW5lcmF0b3IgPSBudWxsO1xuICAgIGlmIChkZWJ1Zy5jYW5jZWxsYXRpb24oKSAmJiB0aGlzLl9maW5hbGx5UHJvbWlzZSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9maW5hbGx5UHJvbWlzZS5fZnVsZmlsbCgpO1xuICAgICAgICB0aGlzLl9maW5hbGx5UHJvbWlzZSA9IG51bGw7XG4gICAgfVxufTtcblxuUHJvbWlzZVNwYXduLnByb3RvdHlwZS5fcHJvbWlzZUNhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9pc1Jlc29sdmVkKCkpIHJldHVybjtcbiAgICB2YXIgaW1wbGVtZW50c1JldHVybiA9IHR5cGVvZiB0aGlzLl9nZW5lcmF0b3JbXCJyZXR1cm5cIl0gIT09IFwidW5kZWZpbmVkXCI7XG5cbiAgICB2YXIgcmVzdWx0O1xuICAgIGlmICghaW1wbGVtZW50c1JldHVybikge1xuICAgICAgICB2YXIgcmVhc29uID0gbmV3IFByb21pc2UuQ2FuY2VsbGF0aW9uRXJyb3IoXG4gICAgICAgICAgICBcImdlbmVyYXRvciAucmV0dXJuKCkgc2VudGluZWxcIik7XG4gICAgICAgIFByb21pc2UuY29yb3V0aW5lLnJldHVyblNlbnRpbmVsID0gcmVhc29uO1xuICAgICAgICB0aGlzLl9wcm9taXNlLl9hdHRhY2hFeHRyYVRyYWNlKHJlYXNvbik7XG4gICAgICAgIHRoaXMuX3Byb21pc2UuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgIHJlc3VsdCA9IHRyeUNhdGNoKHRoaXMuX2dlbmVyYXRvcltcInRocm93XCJdKS5jYWxsKHRoaXMuX2dlbmVyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbik7XG4gICAgICAgIHRoaXMuX3Byb21pc2UuX3BvcENvbnRleHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9wcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgICAgICByZXN1bHQgPSB0cnlDYXRjaCh0aGlzLl9nZW5lcmF0b3JbXCJyZXR1cm5cIl0pLmNhbGwodGhpcy5fZ2VuZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuX3Byb21pc2UuX3BvcENvbnRleHQoKTtcbiAgICB9XG4gICAgdGhpcy5fY2FuY2VsbGF0aW9uUGhhc2UgPSB0cnVlO1xuICAgIHRoaXMuX3lpZWxkZWRQcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLl9jb250aW51ZShyZXN1bHQpO1xufTtcblxuUHJvbWlzZVNwYXduLnByb3RvdHlwZS5fcHJvbWlzZUZ1bGZpbGxlZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5feWllbGRlZFByb21pc2UgPSBudWxsO1xuICAgIHRoaXMuX3Byb21pc2UuX3B1c2hDb250ZXh0KCk7XG4gICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHRoaXMuX2dlbmVyYXRvci5uZXh0KS5jYWxsKHRoaXMuX2dlbmVyYXRvciwgdmFsdWUpO1xuICAgIHRoaXMuX3Byb21pc2UuX3BvcENvbnRleHQoKTtcbiAgICB0aGlzLl9jb250aW51ZShyZXN1bHQpO1xufTtcblxuUHJvbWlzZVNwYXduLnByb3RvdHlwZS5fcHJvbWlzZVJlamVjdGVkID0gZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgdGhpcy5feWllbGRlZFByb21pc2UgPSBudWxsO1xuICAgIHRoaXMuX3Byb21pc2UuX2F0dGFjaEV4dHJhVHJhY2UocmVhc29uKTtcbiAgICB0aGlzLl9wcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaCh0aGlzLl9nZW5lcmF0b3JbXCJ0aHJvd1wiXSlcbiAgICAgICAgLmNhbGwodGhpcy5fZ2VuZXJhdG9yLCByZWFzb24pO1xuICAgIHRoaXMuX3Byb21pc2UuX3BvcENvbnRleHQoKTtcbiAgICB0aGlzLl9jb250aW51ZShyZXN1bHQpO1xufTtcblxuUHJvbWlzZVNwYXduLnByb3RvdHlwZS5fcmVzdWx0Q2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3lpZWxkZWRQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3lpZWxkZWRQcm9taXNlO1xuICAgICAgICB0aGlzLl95aWVsZGVkUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHByb21pc2UuY2FuY2VsKCk7XG4gICAgfVxufTtcblxuUHJvbWlzZVNwYXduLnByb3RvdHlwZS5wcm9taXNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm9taXNlO1xufTtcblxuUHJvbWlzZVNwYXduLnByb3RvdHlwZS5fcnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2dlbmVyYXRvciA9IHRoaXMuX2dlbmVyYXRvckZ1bmN0aW9uLmNhbGwodGhpcy5fcmVjZWl2ZXIpO1xuICAgIHRoaXMuX3JlY2VpdmVyID1cbiAgICAgICAgdGhpcy5fZ2VuZXJhdG9yRnVuY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcHJvbWlzZUZ1bGZpbGxlZCh1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZVNwYXduLnByb3RvdHlwZS5fY29udGludWUgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzLl9wcm9taXNlO1xuICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICAgICAgaWYgKHRoaXMuX2NhbmNlbGxhdGlvblBoYXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS5jYW5jZWwoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLl9yZWplY3RDYWxsYmFjayhyZXN1bHQuZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgIGlmIChyZXN1bHQuZG9uZSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgICAgIGlmICh0aGlzLl9jYW5jZWxsYXRpb25QaGFzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UuY2FuY2VsKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS5fcmVzb2x2ZUNhbGxiYWNrKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHZhbHVlLCB0aGlzLl9wcm9taXNlKTtcbiAgICAgICAgaWYgKCEobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZSA9XG4gICAgICAgICAgICAgICAgcHJvbWlzZUZyb21ZaWVsZEhhbmRsZXIobWF5YmVQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3lpZWxkSGFuZGxlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvbWlzZSk7XG4gICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvbWlzZVJlamVjdGVkKFxuICAgICAgICAgICAgICAgICAgICBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJBIHZhbHVlICVzIHdhcyB5aWVsZGVkIHRoYXQgY291bGQgbm90IGJlIHRyZWF0ZWQgYXMgYSBwcm9taXNlXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVxcdTAwMGFcIi5yZXBsYWNlKFwiJXNcIiwgU3RyaW5nKHZhbHVlKSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJGcm9tIGNvcm91dGluZTpcXHUwMDBhXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2suc3BsaXQoXCJcXG5cIikuc2xpY2UoMSwgLTcpLmpvaW4oXCJcXG5cIilcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1heWJlUHJvbWlzZSA9IG1heWJlUHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgICAgIHZhciBiaXRGaWVsZCA9IG1heWJlUHJvbWlzZS5fYml0RmllbGQ7XG4gICAgICAgIDtcbiAgICAgICAgaWYgKCgoYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApKSB7XG4gICAgICAgICAgICB0aGlzLl95aWVsZGVkUHJvbWlzZSA9IG1heWJlUHJvbWlzZTtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fcHJveHkodGhpcywgbnVsbCk7XG4gICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDMzNTU0NDMyKSAhPT0gMCkpIHtcbiAgICAgICAgICAgIFByb21pc2UuX2FzeW5jLmludm9rZShcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9taXNlRnVsZmlsbGVkLCB0aGlzLCBtYXliZVByb21pc2UuX3ZhbHVlKClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkpIHtcbiAgICAgICAgICAgIFByb21pc2UuX2FzeW5jLmludm9rZShcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9taXNlUmVqZWN0ZWQsIHRoaXMsIG1heWJlUHJvbWlzZS5fcmVhc29uKClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9taXNlQ2FuY2VsbGVkKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5Qcm9taXNlLmNvcm91dGluZSA9IGZ1bmN0aW9uIChnZW5lcmF0b3JGdW5jdGlvbiwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgZ2VuZXJhdG9yRnVuY3Rpb24gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZ2VuZXJhdG9yRnVuY3Rpb24gbXVzdCBiZSBhIGZ1bmN0aW9uXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgdmFyIHlpZWxkSGFuZGxlciA9IE9iamVjdChvcHRpb25zKS55aWVsZEhhbmRsZXI7XG4gICAgdmFyIFByb21pc2VTcGF3biQgPSBQcm9taXNlU3Bhd247XG4gICAgdmFyIHN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGdlbmVyYXRvciA9IGdlbmVyYXRvckZ1bmN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBzcGF3biA9IG5ldyBQcm9taXNlU3Bhd24kKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB5aWVsZEhhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrKTtcbiAgICAgICAgdmFyIHJldCA9IHNwYXduLnByb21pc2UoKTtcbiAgICAgICAgc3Bhd24uX2dlbmVyYXRvciA9IGdlbmVyYXRvcjtcbiAgICAgICAgc3Bhd24uX3Byb21pc2VGdWxmaWxsZWQodW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xufTtcblxuUHJvbWlzZS5jb3JvdXRpbmUuYWRkWWllbGRIYW5kbGVyID0gZnVuY3Rpb24oZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGZuKSk7XG4gICAgfVxuICAgIHlpZWxkSGFuZGxlcnMucHVzaChmbik7XG59O1xuXG5Qcm9taXNlLnNwYXduID0gZnVuY3Rpb24gKGdlbmVyYXRvckZ1bmN0aW9uKSB7XG4gICAgZGVidWcuZGVwcmVjYXRlZChcIlByb21pc2Uuc3Bhd24oKVwiLCBcIlByb21pc2UuY29yb3V0aW5lKClcIik7XG4gICAgaWYgKHR5cGVvZiBnZW5lcmF0b3JGdW5jdGlvbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJnZW5lcmF0b3JGdW5jdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb25cXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xuICAgIH1cbiAgICB2YXIgc3Bhd24gPSBuZXcgUHJvbWlzZVNwYXduKGdlbmVyYXRvckZ1bmN0aW9uLCB0aGlzKTtcbiAgICB2YXIgcmV0ID0gc3Bhd24ucHJvbWlzZSgpO1xuICAgIHNwYXduLl9ydW4oUHJvbWlzZS5zcGF3bik7XG4gICAgcmV0dXJuIHJldDtcbn07XG59O1xuXG59LHtcIi4vZXJyb3JzXCI6MTIsXCIuL3V0aWxcIjozNn1dLDE3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPVxuZnVuY3Rpb24oUHJvbWlzZSwgUHJvbWlzZUFycmF5LCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBJTlRFUk5BTCwgYXN5bmMsXG4gICAgICAgICBnZXREb21haW4pIHtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcbnZhciBjYW5FdmFsdWF0ZSA9IHV0aWwuY2FuRXZhbHVhdGU7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcbnZhciByZWplY3Q7XG5cbmlmICghdHJ1ZSkge1xuaWYgKGNhbkV2YWx1YXRlKSB7XG4gICAgdmFyIHRoZW5DYWxsYmFjayA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcInZhbHVlXCIsIFwiaG9sZGVyXCIsIFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgaG9sZGVyLnBJbmRleCA9IHZhbHVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgaG9sZGVyLmNoZWNrRnVsZmlsbG1lbnQodGhpcyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgXCIucmVwbGFjZSgvSW5kZXgvZywgaSkpO1xuICAgIH07XG5cbiAgICB2YXIgcHJvbWlzZVNldHRlciA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcInByb21pc2VcIiwgXCJob2xkZXJcIiwgXCIgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgaG9sZGVyLnBJbmRleCA9IHByb21pc2U7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgXCIucmVwbGFjZSgvSW5kZXgvZywgaSkpO1xuICAgIH07XG5cbiAgICB2YXIgZ2VuZXJhdGVIb2xkZXJDbGFzcyA9IGZ1bmN0aW9uKHRvdGFsKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IG5ldyBBcnJheSh0b3RhbCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHByb3BzW2ldID0gXCJ0aGlzLnBcIiArIChpKzEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhc3NpZ25tZW50ID0gcHJvcHMuam9pbihcIiA9IFwiKSArIFwiID0gbnVsbDtcIjtcbiAgICAgICAgdmFyIGNhbmNlbGxhdGlvbkNvZGU9IFwidmFyIHByb21pc2U7XFxuXCIgKyBwcm9wcy5tYXAoZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gXCIgKyBwcm9wICsgXCI7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGlmIChwcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLmNhbmNlbCgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgXCI7XG4gICAgICAgIH0pLmpvaW4oXCJcXG5cIik7XG4gICAgICAgIHZhciBwYXNzZWRBcmd1bWVudHMgPSBwcm9wcy5qb2luKFwiLCBcIik7XG4gICAgICAgIHZhciBuYW1lID0gXCJIb2xkZXIkXCIgKyB0b3RhbDtcblxuXG4gICAgICAgIHZhciBjb2RlID0gXCJyZXR1cm4gZnVuY3Rpb24odHJ5Q2F0Y2gsIGVycm9yT2JqLCBQcm9taXNlLCBhc3luYykgeyAgICBcXG5cXFxuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgZnVuY3Rpb24gW1RoZU5hbWVdKGZuKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIFtUaGVQcm9wZXJ0aWVzXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHRoaXMuZm4gPSBmbjsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHRoaXMuYXN5bmNOZWVkZWQgPSB0cnVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHRoaXMubm93ID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgW1RoZU5hbWVdLnByb3RvdHlwZS5fY2FsbEZ1bmN0aW9uID0gZnVuY3Rpb24ocHJvbWlzZSkgeyAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHByb21pc2UuX3B1c2hDb250ZXh0KCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHZhciByZXQgPSB0cnlDYXRjaCh0aGlzLmZuKShbVGhlUGFzc2VkQXJndW1lbnRzXSk7ICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHByb21pc2UuX3BvcENvbnRleHQoKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGlmIChyZXQgPT09IGVycm9yT2JqKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9yZWplY3RDYWxsYmFjayhyZXQuZSwgZmFsc2UpOyAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2socmV0KTsgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgW1RoZU5hbWVdLnByb3RvdHlwZS5jaGVja0Z1bGZpbGxtZW50ID0gZnVuY3Rpb24ocHJvbWlzZSkgeyAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHZhciBub3cgPSArK3RoaXMubm93OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGlmIChub3cgPT09IFtUaGVUb3RhbF0pIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hc3luY05lZWRlZCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmMuaW52b2tlKHRoaXMuX2NhbGxGdW5jdGlvbiwgdGhpcywgcHJvbWlzZSk7ICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsbEZ1bmN0aW9uKHByb21pc2UpOyAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgW1RoZU5hbWVdLnByb3RvdHlwZS5fcmVzdWx0Q2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7ICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIFtDYW5jZWxsYXRpb25Db2RlXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgcmV0dXJuIFtUaGVOYW1lXTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICB9KHRyeUNhdGNoLCBlcnJvck9iaiwgUHJvbWlzZSwgYXN5bmMpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICBcIjtcblxuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKC9cXFtUaGVOYW1lXFxdL2csIG5hbWUpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxbVGhlVG90YWxcXF0vZywgdG90YWwpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxbVGhlUGFzc2VkQXJndW1lbnRzXFxdL2csIHBhc3NlZEFyZ3VtZW50cylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXFtUaGVQcm9wZXJ0aWVzXFxdL2csIGFzc2lnbm1lbnQpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxbQ2FuY2VsbGF0aW9uQ29kZVxcXS9nLCBjYW5jZWxsYXRpb25Db2RlKTtcblxuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwidHJ5Q2F0Y2hcIiwgXCJlcnJvck9ialwiLCBcIlByb21pc2VcIiwgXCJhc3luY1wiLCBjb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRyeUNhdGNoLCBlcnJvck9iaiwgUHJvbWlzZSwgYXN5bmMpO1xuICAgIH07XG5cbiAgICB2YXIgaG9sZGVyQ2xhc3NlcyA9IFtdO1xuICAgIHZhciB0aGVuQ2FsbGJhY2tzID0gW107XG4gICAgdmFyIHByb21pc2VTZXR0ZXJzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7ICsraSkge1xuICAgICAgICBob2xkZXJDbGFzc2VzLnB1c2goZ2VuZXJhdGVIb2xkZXJDbGFzcyhpICsgMSkpO1xuICAgICAgICB0aGVuQ2FsbGJhY2tzLnB1c2godGhlbkNhbGxiYWNrKGkgKyAxKSk7XG4gICAgICAgIHByb21pc2VTZXR0ZXJzLnB1c2gocHJvbWlzZVNldHRlcihpICsgMSkpO1xuICAgIH1cblxuICAgIHJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgdGhpcy5fcmVqZWN0KHJlYXNvbik7XG4gICAgfTtcbn19XG5cblByb21pc2Uuam9pbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGFzdCA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICAgIHZhciBmbjtcbiAgICBpZiAobGFzdCA+IDAgJiYgdHlwZW9mIGFyZ3VtZW50c1tsYXN0XSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGZuID0gYXJndW1lbnRzW2xhc3RdO1xuICAgICAgICBpZiAoIXRydWUpIHtcbiAgICAgICAgICAgIGlmIChsYXN0IDw9IDggJiYgY2FuRXZhbHVhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICAgICAgICAgIHJldC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICAgICAgICAgICAgICB2YXIgSG9sZGVyQ2xhc3MgPSBob2xkZXJDbGFzc2VzW2xhc3QgLSAxXTtcbiAgICAgICAgICAgICAgICB2YXIgaG9sZGVyID0gbmV3IEhvbGRlckNsYXNzKGZuKTtcbiAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2tzID0gdGhlbkNhbGxiYWNrcztcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKGFyZ3VtZW50c1tpXSwgcmV0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZSA9IG1heWJlUHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYml0RmllbGQgPSBtYXliZVByb21pc2UuX2JpdEZpZWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgoYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl90aGVuKGNhbGxiYWNrc1tpXSwgcmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsIHJldCwgaG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlU2V0dGVyc1tpXShtYXliZVByb21pc2UsIGhvbGRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmFzeW5jTmVlZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzW2ldLmNhbGwocmV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fdmFsdWUoKSwgaG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQuX3JlamVjdChtYXliZVByb21pc2UuX3JlYXNvbigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0Ll9jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrc1tpXS5jYWxsKHJldCwgbWF5YmVQcm9taXNlLCBob2xkZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFyZXQuX2lzRmF0ZVNlYWxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChob2xkZXIuYXN5bmNOZWVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb21haW4gPSBnZXREb21haW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb21haW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIuZm4gPSB1dGlsLmRvbWFpbkJpbmQoZG9tYWluLCBob2xkZXIuZm4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldC5fc2V0QXN5bmNHdWFyYW50ZWVkKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldC5fc2V0T25DYW5jZWwoaG9sZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTs7XG4gICAgaWYgKGZuKSBhcmdzLnBvcCgpO1xuICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZUFycmF5KGFyZ3MpLnByb21pc2UoKTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZCA/IHJldC5zcHJlYWQoZm4pIDogcmV0O1xufTtcblxufTtcblxufSx7XCIuL3V0aWxcIjozNn1dLDE4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlQXJyYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFwaVJlamVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5Q29udmVydFRvUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKSB7XG52YXIgZ2V0RG9tYWluID0gUHJvbWlzZS5fZ2V0RG9tYWluO1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG52YXIgYXN5bmMgPSBQcm9taXNlLl9hc3luYztcblxuZnVuY3Rpb24gTWFwcGluZ1Byb21pc2VBcnJheShwcm9taXNlcywgZm4sIGxpbWl0LCBfZmlsdGVyKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciQocHJvbWlzZXMpO1xuICAgIHRoaXMuX3Byb21pc2UuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgdmFyIGRvbWFpbiA9IGdldERvbWFpbigpO1xuICAgIHRoaXMuX2NhbGxiYWNrID0gZG9tYWluID09PSBudWxsID8gZm4gOiB1dGlsLmRvbWFpbkJpbmQoZG9tYWluLCBmbik7XG4gICAgdGhpcy5fcHJlc2VydmVkVmFsdWVzID0gX2ZpbHRlciA9PT0gSU5URVJOQUxcbiAgICAgICAgPyBuZXcgQXJyYXkodGhpcy5sZW5ndGgoKSlcbiAgICAgICAgOiBudWxsO1xuICAgIHRoaXMuX2xpbWl0ID0gbGltaXQ7XG4gICAgdGhpcy5faW5GbGlnaHQgPSAwO1xuICAgIHRoaXMuX3F1ZXVlID0gW107XG4gICAgYXN5bmMuaW52b2tlKHRoaXMuX2FzeW5jSW5pdCwgdGhpcywgdW5kZWZpbmVkKTtcbn1cbnV0aWwuaW5oZXJpdHMoTWFwcGluZ1Byb21pc2VBcnJheSwgUHJvbWlzZUFycmF5KTtcblxuTWFwcGluZ1Byb21pc2VBcnJheS5wcm90b3R5cGUuX2FzeW5jSW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2luaXQkKHVuZGVmaW5lZCwgLTIpO1xufTtcblxuTWFwcGluZ1Byb21pc2VBcnJheS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoKSB7fTtcblxuTWFwcGluZ1Byb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgdmFyIHZhbHVlcyA9IHRoaXMuX3ZhbHVlcztcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcbiAgICB2YXIgcHJlc2VydmVkVmFsdWVzID0gdGhpcy5fcHJlc2VydmVkVmFsdWVzO1xuICAgIHZhciBsaW1pdCA9IHRoaXMuX2xpbWl0O1xuXG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCA9IChpbmRleCAqIC0xKSAtIDE7XG4gICAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKGxpbWl0ID49IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX2luRmxpZ2h0LS07XG4gICAgICAgICAgICB0aGlzLl9kcmFpblF1ZXVlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNSZXNvbHZlZCgpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChsaW1pdCA+PSAxICYmIHRoaXMuX2luRmxpZ2h0ID49IGxpbWl0KSB7XG4gICAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJlc2VydmVkVmFsdWVzICE9PSBudWxsKSBwcmVzZXJ2ZWRWYWx1ZXNbaW5kZXhdID0gdmFsdWU7XG5cbiAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl9wcm9taXNlO1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLl9jYWxsYmFjaztcbiAgICAgICAgdmFyIHJlY2VpdmVyID0gcHJvbWlzZS5fYm91bmRWYWx1ZSgpO1xuICAgICAgICBwcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgICAgICB2YXIgcmV0ID0gdHJ5Q2F0Y2goY2FsbGJhY2spLmNhbGwocmVjZWl2ZXIsIHZhbHVlLCBpbmRleCwgbGVuZ3RoKTtcbiAgICAgICAgdmFyIHByb21pc2VDcmVhdGVkID0gcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgICAgICBkZWJ1Zy5jaGVja0ZvcmdvdHRlblJldHVybnMoXG4gICAgICAgICAgICByZXQsXG4gICAgICAgICAgICBwcm9taXNlQ3JlYXRlZCxcbiAgICAgICAgICAgIHByZXNlcnZlZFZhbHVlcyAhPT0gbnVsbCA/IFwiUHJvbWlzZS5maWx0ZXJcIiA6IFwiUHJvbWlzZS5tYXBcIixcbiAgICAgICAgICAgIHByb21pc2VcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgIHRoaXMuX3JlamVjdChyZXQuZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHJldCwgdGhpcy5fcHJvbWlzZSk7XG4gICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UgPSBtYXliZVByb21pc2UuX3RhcmdldCgpO1xuICAgICAgICAgICAgdmFyIGJpdEZpZWxkID0gbWF5YmVQcm9taXNlLl9iaXRGaWVsZDtcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGlmICgoKGJpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSkge1xuICAgICAgICAgICAgICAgIGlmIChsaW1pdCA+PSAxKSB0aGlzLl9pbkZsaWdodCsrO1xuICAgICAgICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSBtYXliZVByb21pc2U7XG4gICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl9wcm94eSh0aGlzLCAoaW5kZXggKyAxKSAqIC0xKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gbWF5YmVQcm9taXNlLl92YWx1ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMTY3NzcyMTYpICE9PSAwKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlamVjdChtYXliZVByb21pc2UuX3JlYXNvbigpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzW2luZGV4XSA9IHJldDtcbiAgICB9XG4gICAgdmFyIHRvdGFsUmVzb2x2ZWQgPSArK3RoaXMuX3RvdGFsUmVzb2x2ZWQ7XG4gICAgaWYgKHRvdGFsUmVzb2x2ZWQgPj0gbGVuZ3RoKSB7XG4gICAgICAgIGlmIChwcmVzZXJ2ZWRWYWx1ZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbHRlcih2YWx1ZXMsIHByZXNlcnZlZFZhbHVlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbk1hcHBpbmdQcm9taXNlQXJyYXkucHJvdG90eXBlLl9kcmFpblF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBxdWV1ZSA9IHRoaXMuX3F1ZXVlO1xuICAgIHZhciBsaW1pdCA9IHRoaXMuX2xpbWl0O1xuICAgIHZhciB2YWx1ZXMgPSB0aGlzLl92YWx1ZXM7XG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDAgJiYgdGhpcy5faW5GbGlnaHQgPCBsaW1pdCkge1xuICAgICAgICBpZiAodGhpcy5faXNSZXNvbHZlZCgpKSByZXR1cm47XG4gICAgICAgIHZhciBpbmRleCA9IHF1ZXVlLnBvcCgpO1xuICAgICAgICB0aGlzLl9wcm9taXNlRnVsZmlsbGVkKHZhbHVlc1tpbmRleF0sIGluZGV4KTtcbiAgICB9XG59O1xuXG5NYXBwaW5nUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fZmlsdGVyID0gZnVuY3Rpb24gKGJvb2xlYW5zLCB2YWx1ZXMpIHtcbiAgICB2YXIgbGVuID0gdmFsdWVzLmxlbmd0aDtcbiAgICB2YXIgcmV0ID0gbmV3IEFycmF5KGxlbik7XG4gICAgdmFyIGogPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgaWYgKGJvb2xlYW5zW2ldKSByZXRbaisrXSA9IHZhbHVlc1tpXTtcbiAgICB9XG4gICAgcmV0Lmxlbmd0aCA9IGo7XG4gICAgdGhpcy5fcmVzb2x2ZShyZXQpO1xufTtcblxuTWFwcGluZ1Byb21pc2VBcnJheS5wcm90b3R5cGUucHJlc2VydmVkVmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9wcmVzZXJ2ZWRWYWx1ZXM7XG59O1xuXG5mdW5jdGlvbiBtYXAocHJvbWlzZXMsIGZuLCBvcHRpb25zLCBfZmlsdGVyKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhmbikpO1xuICAgIH1cblxuICAgIHZhciBsaW1pdCA9IDA7XG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNvbmN1cnJlbmN5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICAgICAgICAgICAgICBuZXcgVHlwZUVycm9yKFwiJ2NvbmN1cnJlbmN5JyBtdXN0IGJlIGEgbnVtYmVyIGJ1dCBpdCBpcyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmNsYXNzU3RyaW5nKG9wdGlvbnMuY29uY3VycmVuY3kpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW1pdCA9IG9wdGlvbnMuY29uY3VycmVuY3k7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9wdGlvbnMgYXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3QgYnV0IGl0IGlzIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5jbGFzc1N0cmluZyhvcHRpb25zKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxpbWl0ID0gdHlwZW9mIGxpbWl0ID09PSBcIm51bWJlclwiICYmXG4gICAgICAgIGlzRmluaXRlKGxpbWl0KSAmJiBsaW1pdCA+PSAxID8gbGltaXQgOiAwO1xuICAgIHJldHVybiBuZXcgTWFwcGluZ1Byb21pc2VBcnJheShwcm9taXNlcywgZm4sIGxpbWl0LCBfZmlsdGVyKS5wcm9taXNlKCk7XG59XG5cblByb21pc2UucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmbiwgb3B0aW9ucykge1xuICAgIHJldHVybiBtYXAodGhpcywgZm4sIG9wdGlvbnMsIG51bGwpO1xufTtcblxuUHJvbWlzZS5tYXAgPSBmdW5jdGlvbiAocHJvbWlzZXMsIGZuLCBvcHRpb25zLCBfZmlsdGVyKSB7XG4gICAgcmV0dXJuIG1hcChwcm9taXNlcywgZm4sIG9wdGlvbnMsIF9maWx0ZXIpO1xufTtcblxuXG59O1xuXG59LHtcIi4vdXRpbFwiOjM2fV0sMTk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9XG5mdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgYXBpUmVqZWN0aW9uLCBkZWJ1Zykge1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcblxuUHJvbWlzZS5tZXRob2QgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFByb21pc2UuVHlwZUVycm9yKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZm4pKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgcmV0Ll9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgICAgICByZXQuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRyeUNhdGNoKGZuKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB2YXIgcHJvbWlzZUNyZWF0ZWQgPSByZXQuX3BvcENvbnRleHQoKTtcbiAgICAgICAgZGVidWcuY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zKFxuICAgICAgICAgICAgdmFsdWUsIHByb21pc2VDcmVhdGVkLCBcIlByb21pc2UubWV0aG9kXCIsIHJldCk7XG4gICAgICAgIHJldC5fcmVzb2x2ZUZyb21TeW5jVmFsdWUodmFsdWUpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG59O1xuXG5Qcm9taXNlLmF0dGVtcHQgPSBQcm9taXNlW1widHJ5XCJdID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhmbikpO1xuICAgIH1cbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIHJldC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICByZXQuX3B1c2hDb250ZXh0KCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBkZWJ1Zy5kZXByZWNhdGVkKFwiY2FsbGluZyBQcm9taXNlLnRyeSB3aXRoIG1vcmUgdGhhbiAxIGFyZ3VtZW50XCIpO1xuICAgICAgICB2YXIgYXJnID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB2YXIgY3R4ID0gYXJndW1lbnRzWzJdO1xuICAgICAgICB2YWx1ZSA9IHV0aWwuaXNBcnJheShhcmcpID8gdHJ5Q2F0Y2goZm4pLmFwcGx5KGN0eCwgYXJnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdHJ5Q2F0Y2goZm4pLmNhbGwoY3R4LCBhcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gdHJ5Q2F0Y2goZm4pKCk7XG4gICAgfVxuICAgIHZhciBwcm9taXNlQ3JlYXRlZCA9IHJldC5fcG9wQ29udGV4dCgpO1xuICAgIGRlYnVnLmNoZWNrRm9yZ290dGVuUmV0dXJucyhcbiAgICAgICAgdmFsdWUsIHByb21pc2VDcmVhdGVkLCBcIlByb21pc2UudHJ5XCIsIHJldCk7XG4gICAgcmV0Ll9yZXNvbHZlRnJvbVN5bmNWYWx1ZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZXNvbHZlRnJvbVN5bmNWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdXRpbC5lcnJvck9iaikge1xuICAgICAgICB0aGlzLl9yZWplY3RDYWxsYmFjayh2YWx1ZS5lLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUNhbGxiYWNrKHZhbHVlLCB0cnVlKTtcbiAgICB9XG59O1xufTtcblxufSx7XCIuL3V0aWxcIjozNn1dLDIwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xudmFyIG1heWJlV3JhcEFzRXJyb3IgPSB1dGlsLm1heWJlV3JhcEFzRXJyb3I7XG52YXIgZXJyb3JzID0gX2RlcmVxXyhcIi4vZXJyb3JzXCIpO1xudmFyIE9wZXJhdGlvbmFsRXJyb3IgPSBlcnJvcnMuT3BlcmF0aW9uYWxFcnJvcjtcbnZhciBlczUgPSBfZGVyZXFfKFwiLi9lczVcIik7XG5cbmZ1bmN0aW9uIGlzVW50eXBlZEVycm9yKG9iaikge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgICBlczUuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PT0gRXJyb3IucHJvdG90eXBlO1xufVxuXG52YXIgckVycm9yS2V5ID0gL14oPzpuYW1lfG1lc3NhZ2V8c3RhY2t8Y2F1c2UpJC87XG5mdW5jdGlvbiB3cmFwQXNPcGVyYXRpb25hbEVycm9yKG9iaikge1xuICAgIHZhciByZXQ7XG4gICAgaWYgKGlzVW50eXBlZEVycm9yKG9iaikpIHtcbiAgICAgICAgcmV0ID0gbmV3IE9wZXJhdGlvbmFsRXJyb3Iob2JqKTtcbiAgICAgICAgcmV0Lm5hbWUgPSBvYmoubmFtZTtcbiAgICAgICAgcmV0Lm1lc3NhZ2UgPSBvYmoubWVzc2FnZTtcbiAgICAgICAgcmV0LnN0YWNrID0gb2JqLnN0YWNrO1xuICAgICAgICB2YXIga2V5cyA9IGVzNS5rZXlzKG9iaik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiAoIXJFcnJvcktleS50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIHV0aWwubWFya0FzT3JpZ2luYXRpbmdGcm9tUmVqZWN0aW9uKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gbm9kZWJhY2tGb3JQcm9taXNlKHByb21pc2UsIG11bHRpQXJncykge1xuICAgIHJldHVybiBmdW5jdGlvbihlcnIsIHZhbHVlKSB7XG4gICAgICAgIGlmIChwcm9taXNlID09PSBudWxsKSByZXR1cm47XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHZhciB3cmFwcGVkID0gd3JhcEFzT3BlcmF0aW9uYWxFcnJvcihtYXliZVdyYXBBc0Vycm9yKGVycikpO1xuICAgICAgICAgICAgcHJvbWlzZS5fYXR0YWNoRXh0cmFUcmFjZSh3cmFwcGVkKTtcbiAgICAgICAgICAgIHByb21pc2UuX3JlamVjdCh3cmFwcGVkKTtcbiAgICAgICAgfSBlbHNlIGlmICghbXVsdGlBcmdzKSB7XG4gICAgICAgICAgICBwcm9taXNlLl9mdWxmaWxsKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOztcbiAgICAgICAgICAgIHByb21pc2UuX2Z1bGZpbGwoYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvbWlzZSA9IG51bGw7XG4gICAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBub2RlYmFja0ZvclByb21pc2U7XG5cbn0se1wiLi9lcnJvcnNcIjoxMixcIi4vZXM1XCI6MTMsXCIuL3V0aWxcIjozNn1dLDIxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlKSB7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG52YXIgYXN5bmMgPSBQcm9taXNlLl9hc3luYztcbnZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG52YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xuXG5mdW5jdGlvbiBzcHJlYWRBZGFwdGVyKHZhbCwgbm9kZWJhY2spIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgaWYgKCF1dGlsLmlzQXJyYXkodmFsKSkgcmV0dXJuIHN1Y2Nlc3NBZGFwdGVyLmNhbGwocHJvbWlzZSwgdmFsLCBub2RlYmFjayk7XG4gICAgdmFyIHJldCA9XG4gICAgICAgIHRyeUNhdGNoKG5vZGViYWNrKS5hcHBseShwcm9taXNlLl9ib3VuZFZhbHVlKCksIFtudWxsXS5jb25jYXQodmFsKSk7XG4gICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgYXN5bmMudGhyb3dMYXRlcihyZXQuZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzdWNjZXNzQWRhcHRlcih2YWwsIG5vZGViYWNrKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuICAgIHZhciByZWNlaXZlciA9IHByb21pc2UuX2JvdW5kVmFsdWUoKTtcbiAgICB2YXIgcmV0ID0gdmFsID09PSB1bmRlZmluZWRcbiAgICAgICAgPyB0cnlDYXRjaChub2RlYmFjaykuY2FsbChyZWNlaXZlciwgbnVsbClcbiAgICAgICAgOiB0cnlDYXRjaChub2RlYmFjaykuY2FsbChyZWNlaXZlciwgbnVsbCwgdmFsKTtcbiAgICBpZiAocmV0ID09PSBlcnJvck9iaikge1xuICAgICAgICBhc3luYy50aHJvd0xhdGVyKHJldC5lKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlcnJvckFkYXB0ZXIocmVhc29uLCBub2RlYmFjaykge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICBpZiAoIXJlYXNvbikge1xuICAgICAgICB2YXIgbmV3UmVhc29uID0gbmV3IEVycm9yKHJlYXNvbiArIFwiXCIpO1xuICAgICAgICBuZXdSZWFzb24uY2F1c2UgPSByZWFzb247XG4gICAgICAgIHJlYXNvbiA9IG5ld1JlYXNvbjtcbiAgICB9XG4gICAgdmFyIHJldCA9IHRyeUNhdGNoKG5vZGViYWNrKS5jYWxsKHByb21pc2UuX2JvdW5kVmFsdWUoKSwgcmVhc29uKTtcbiAgICBpZiAocmV0ID09PSBlcnJvck9iaikge1xuICAgICAgICBhc3luYy50aHJvd0xhdGVyKHJldC5lKTtcbiAgICB9XG59XG5cblByb21pc2UucHJvdG90eXBlLmFzQ2FsbGJhY2sgPSBQcm9taXNlLnByb3RvdHlwZS5ub2RlaWZ5ID0gZnVuY3Rpb24gKG5vZGViYWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygbm9kZWJhY2sgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHZhciBhZGFwdGVyID0gc3VjY2Vzc0FkYXB0ZXI7XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgT2JqZWN0KG9wdGlvbnMpLnNwcmVhZCkge1xuICAgICAgICAgICAgYWRhcHRlciA9IHNwcmVhZEFkYXB0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGhlbihcbiAgICAgICAgICAgIGFkYXB0ZXIsXG4gICAgICAgICAgICBlcnJvckFkYXB0ZXIsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgbm9kZWJhY2tcbiAgICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xufTtcblxufSx7XCIuL3V0aWxcIjozNn1dLDIyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbnZhciBtYWtlU2VsZlJlc29sdXRpb25FcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihcImNpcmN1bGFyIHByb21pc2UgcmVzb2x1dGlvbiBjaGFpblxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG59O1xudmFyIHJlZmxlY3RIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlLlByb21pc2VJbnNwZWN0aW9uKHRoaXMuX3RhcmdldCgpKTtcbn07XG52YXIgYXBpUmVqZWN0aW9uID0gZnVuY3Rpb24obXNnKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IobXNnKSk7XG59O1xuZnVuY3Rpb24gUHJveHlhYmxlKCkge31cbnZhciBVTkRFRklORURfQklORElORyA9IHt9O1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xuXG52YXIgZ2V0RG9tYWluO1xuaWYgKHV0aWwuaXNOb2RlKSB7XG4gICAgZ2V0RG9tYWluID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXQgPSBwcm9jZXNzLmRvbWFpbjtcbiAgICAgICAgaWYgKHJldCA9PT0gdW5kZWZpbmVkKSByZXQgPSBudWxsO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG59IGVsc2Uge1xuICAgIGdldERvbWFpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xufVxudXRpbC5ub3RFbnVtZXJhYmxlUHJvcChQcm9taXNlLCBcIl9nZXREb21haW5cIiwgZ2V0RG9tYWluKTtcblxudmFyIGVzNSA9IF9kZXJlcV8oXCIuL2VzNVwiKTtcbnZhciBBc3luYyA9IF9kZXJlcV8oXCIuL2FzeW5jXCIpO1xudmFyIGFzeW5jID0gbmV3IEFzeW5jKCk7XG5lczUuZGVmaW5lUHJvcGVydHkoUHJvbWlzZSwgXCJfYXN5bmNcIiwge3ZhbHVlOiBhc3luY30pO1xudmFyIGVycm9ycyA9IF9kZXJlcV8oXCIuL2Vycm9yc1wiKTtcbnZhciBUeXBlRXJyb3IgPSBQcm9taXNlLlR5cGVFcnJvciA9IGVycm9ycy5UeXBlRXJyb3I7XG5Qcm9taXNlLlJhbmdlRXJyb3IgPSBlcnJvcnMuUmFuZ2VFcnJvcjtcbnZhciBDYW5jZWxsYXRpb25FcnJvciA9IFByb21pc2UuQ2FuY2VsbGF0aW9uRXJyb3IgPSBlcnJvcnMuQ2FuY2VsbGF0aW9uRXJyb3I7XG5Qcm9taXNlLlRpbWVvdXRFcnJvciA9IGVycm9ycy5UaW1lb3V0RXJyb3I7XG5Qcm9taXNlLk9wZXJhdGlvbmFsRXJyb3IgPSBlcnJvcnMuT3BlcmF0aW9uYWxFcnJvcjtcblByb21pc2UuUmVqZWN0aW9uRXJyb3IgPSBlcnJvcnMuT3BlcmF0aW9uYWxFcnJvcjtcblByb21pc2UuQWdncmVnYXRlRXJyb3IgPSBlcnJvcnMuQWdncmVnYXRlRXJyb3I7XG52YXIgSU5URVJOQUwgPSBmdW5jdGlvbigpe307XG52YXIgQVBQTFkgPSB7fTtcbnZhciBORVhUX0ZJTFRFUiA9IHt9O1xudmFyIHRyeUNvbnZlcnRUb1Byb21pc2UgPSBfZGVyZXFfKFwiLi90aGVuYWJsZXNcIikoUHJvbWlzZSwgSU5URVJOQUwpO1xudmFyIFByb21pc2VBcnJheSA9XG4gICAgX2RlcmVxXyhcIi4vcHJvbWlzZV9hcnJheVwiKShQcm9taXNlLCBJTlRFUk5BTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnlDb252ZXJ0VG9Qcm9taXNlLCBhcGlSZWplY3Rpb24sIFByb3h5YWJsZSk7XG52YXIgQ29udGV4dCA9IF9kZXJlcV8oXCIuL2NvbnRleHRcIikoUHJvbWlzZSk7XG4gLypqc2hpbnQgdW51c2VkOmZhbHNlKi9cbnZhciBjcmVhdGVDb250ZXh0ID0gQ29udGV4dC5jcmVhdGU7XG52YXIgZGVidWcgPSBfZGVyZXFfKFwiLi9kZWJ1Z2dhYmlsaXR5XCIpKFByb21pc2UsIENvbnRleHQpO1xudmFyIENhcHR1cmVkVHJhY2UgPSBkZWJ1Zy5DYXB0dXJlZFRyYWNlO1xudmFyIFBhc3NUaHJvdWdoSGFuZGxlckNvbnRleHQgPVxuICAgIF9kZXJlcV8oXCIuL2ZpbmFsbHlcIikoUHJvbWlzZSwgdHJ5Q29udmVydFRvUHJvbWlzZSwgTkVYVF9GSUxURVIpO1xudmFyIGNhdGNoRmlsdGVyID0gX2RlcmVxXyhcIi4vY2F0Y2hfZmlsdGVyXCIpKE5FWFRfRklMVEVSKTtcbnZhciBub2RlYmFja0ZvclByb21pc2UgPSBfZGVyZXFfKFwiLi9ub2RlYmFja1wiKTtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xuZnVuY3Rpb24gY2hlY2soc2VsZiwgZXhlY3V0b3IpIHtcbiAgICBpZiAoc2VsZiA9PSBudWxsIHx8IHNlbGYuY29uc3RydWN0b3IgIT09IFByb21pc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInRoZSBwcm9taXNlIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBpbnZva2VkIGRpcmVjdGx5XFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhleGVjdXRvcikpO1xuICAgIH1cblxufVxuXG5mdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgaWYgKGV4ZWN1dG9yICE9PSBJTlRFUk5BTCkge1xuICAgICAgICBjaGVjayh0aGlzLCBleGVjdXRvcik7XG4gICAgfVxuICAgIHRoaXMuX2JpdEZpZWxkID0gMDtcbiAgICB0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXIwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3Byb21pc2UwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JlY2VpdmVyMCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yZXNvbHZlRnJvbUV4ZWN1dG9yKGV4ZWN1dG9yKTtcbiAgICB0aGlzLl9wcm9taXNlQ3JlYXRlZCgpO1xuICAgIHRoaXMuX2ZpcmVFdmVudChcInByb21pc2VDcmVhdGVkXCIsIHRoaXMpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IFByb21pc2VdXCI7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5jYXVnaHQgPSBQcm9taXNlLnByb3RvdHlwZVtcImNhdGNoXCJdID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgdmFyIGNhdGNoSW5zdGFuY2VzID0gbmV3IEFycmF5KGxlbiAtIDEpLFxuICAgICAgICAgICAgaiA9IDAsIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW4gLSAxOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNPYmplY3QoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBjYXRjaEluc3RhbmNlc1tqKytdID0gaXRlbTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcIkNhdGNoIHN0YXRlbWVudCBwcmVkaWNhdGU6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJleHBlY3RpbmcgYW4gb2JqZWN0IGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGl0ZW0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaEluc3RhbmNlcy5sZW5ndGggPSBqO1xuICAgICAgICBmbiA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIGNhdGNoRmlsdGVyKGNhdGNoSW5zdGFuY2VzLCBmbiwgdGhpcykpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgZm4pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUucmVmbGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGhlbihyZWZsZWN0SGFuZGxlcixcbiAgICAgICAgcmVmbGVjdEhhbmRsZXIsIHVuZGVmaW5lZCwgdGhpcywgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAoZGlkRnVsZmlsbCwgZGlkUmVqZWN0KSB7XG4gICAgaWYgKGRlYnVnLndhcm5pbmdzKCkgJiYgYXJndW1lbnRzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgdHlwZW9mIGRpZEZ1bGZpbGwgIT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICB0eXBlb2YgZGlkUmVqZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFyIG1zZyA9IFwiLnRoZW4oKSBvbmx5IGFjY2VwdHMgZnVuY3Rpb25zIGJ1dCB3YXMgcGFzc2VkOiBcIiArXG4gICAgICAgICAgICAgICAgdXRpbC5jbGFzc1N0cmluZyhkaWRGdWxmaWxsKTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBtc2cgKz0gXCIsIFwiICsgdXRpbC5jbGFzc1N0cmluZyhkaWRSZWplY3QpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dhcm4obXNnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3RoZW4oZGlkRnVsZmlsbCwgZGlkUmVqZWN0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmRvbmUgPSBmdW5jdGlvbiAoZGlkRnVsZmlsbCwgZGlkUmVqZWN0KSB7XG4gICAgdmFyIHByb21pc2UgPVxuICAgICAgICB0aGlzLl90aGVuKGRpZEZ1bGZpbGwsIGRpZFJlamVjdCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgcHJvbWlzZS5fc2V0SXNGaW5hbCgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuc3ByZWFkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhmbikpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hbGwoKS5fdGhlbihmbiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIEFQUExZLCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXQgPSB7XG4gICAgICAgIGlzRnVsZmlsbGVkOiBmYWxzZSxcbiAgICAgICAgaXNSZWplY3RlZDogZmFsc2UsXG4gICAgICAgIGZ1bGZpbGxtZW50VmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgcmVqZWN0aW9uUmVhc29uOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIGlmICh0aGlzLmlzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgcmV0LmZ1bGZpbGxtZW50VmFsdWUgPSB0aGlzLnZhbHVlKCk7XG4gICAgICAgIHJldC5pc0Z1bGZpbGxlZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzUmVqZWN0ZWQoKSkge1xuICAgICAgICByZXQucmVqZWN0aW9uUmVhc29uID0gdGhpcy5yZWFzb24oKTtcbiAgICAgICAgcmV0LmlzUmVqZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuYWxsID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLl93YXJuKFwiLmFsbCgpIHdhcyBwYXNzZWQgYXJndW1lbnRzIGJ1dCBpdCBkb2VzIG5vdCB0YWtlIGFueVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlQXJyYXkodGhpcykucHJvbWlzZSgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gdGhpcy5jYXVnaHQodXRpbC5vcmlnaW5hdGVzRnJvbVJlamVjdGlvbiwgZm4pO1xufTtcblxuUHJvbWlzZS5nZXROZXdMaWJyYXJ5Q29weSA9IG1vZHVsZS5leHBvcnRzO1xuXG5Qcm9taXNlLmlzID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiB2YWwgaW5zdGFuY2VvZiBQcm9taXNlO1xufTtcblxuUHJvbWlzZS5mcm9tTm9kZSA9IFByb21pc2UuZnJvbUNhbGxiYWNrID0gZnVuY3Rpb24oZm4pIHtcbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIHJldC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICB2YXIgbXVsdGlBcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyAhIU9iamVjdChhcmd1bWVudHNbMV0pLm11bHRpQXJnc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZhbHNlO1xuICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaChmbikobm9kZWJhY2tGb3JQcm9taXNlKHJldCwgbXVsdGlBcmdzKSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgcmV0Ll9yZWplY3RDYWxsYmFjayhyZXN1bHQuZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmICghcmV0Ll9pc0ZhdGVTZWFsZWQoKSkgcmV0Ll9zZXRBc3luY0d1YXJhbnRlZWQoKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5hbGwgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2VBcnJheShwcm9taXNlcykucHJvbWlzZSgpO1xufTtcblxuUHJvbWlzZS5jYXN0ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciByZXQgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKG9iaik7XG4gICAgaWYgKCEocmV0IGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcbiAgICAgICAgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICByZXQuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgICAgIHJldC5fc2V0RnVsZmlsbGVkKCk7XG4gICAgICAgIHJldC5fcmVqZWN0aW9uSGFuZGxlcjAgPSBvYmo7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnJlc29sdmUgPSBQcm9taXNlLmZ1bGZpbGxlZCA9IFByb21pc2UuY2FzdDtcblxuUHJvbWlzZS5yZWplY3QgPSBQcm9taXNlLnJlamVjdGVkID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgcmV0Ll9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgIHJldC5fcmVqZWN0Q2FsbGJhY2socmVhc29uLCB0cnVlKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5zZXRTY2hlZHVsZXIgPSBmdW5jdGlvbihmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZm4pKTtcbiAgICB9XG4gICAgcmV0dXJuIGFzeW5jLnNldFNjaGVkdWxlcihmbik7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fdGhlbiA9IGZ1bmN0aW9uIChcbiAgICBkaWRGdWxmaWxsLFxuICAgIGRpZFJlamVjdCxcbiAgICBfLCAgICByZWNlaXZlcixcbiAgICBpbnRlcm5hbERhdGFcbikge1xuICAgIHZhciBoYXZlSW50ZXJuYWxEYXRhID0gaW50ZXJuYWxEYXRhICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIHByb21pc2UgPSBoYXZlSW50ZXJuYWxEYXRhID8gaW50ZXJuYWxEYXRhIDogbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXQoKTtcbiAgICB2YXIgYml0RmllbGQgPSB0YXJnZXQuX2JpdEZpZWxkO1xuXG4gICAgaWYgKCFoYXZlSW50ZXJuYWxEYXRhKSB7XG4gICAgICAgIHByb21pc2UuX3Byb3BhZ2F0ZUZyb20odGhpcywgMyk7XG4gICAgICAgIHByb21pc2UuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgICAgIGlmIChyZWNlaXZlciA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAoKHRoaXMuX2JpdEZpZWxkICYgMjA5NzE1MikgIT09IDApKSB7XG4gICAgICAgICAgICBpZiAoISgoYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIgPSB0aGlzLl9ib3VuZFZhbHVlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVyID0gdGFyZ2V0ID09PSB0aGlzID8gdW5kZWZpbmVkIDogdGhpcy5fYm91bmRUbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9maXJlRXZlbnQoXCJwcm9taXNlQ2hhaW5lZFwiLCB0aGlzLCBwcm9taXNlKTtcbiAgICB9XG5cbiAgICB2YXIgZG9tYWluID0gZ2V0RG9tYWluKCk7XG4gICAgaWYgKCEoKGJpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSkge1xuICAgICAgICB2YXIgaGFuZGxlciwgdmFsdWUsIHNldHRsZXIgPSB0YXJnZXQuX3NldHRsZVByb21pc2VDdHg7XG4gICAgICAgIGlmICgoKGJpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB0YXJnZXQuX3JlamVjdGlvbkhhbmRsZXIwO1xuICAgICAgICAgICAgaGFuZGxlciA9IGRpZEZ1bGZpbGw7XG4gICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGFyZ2V0Ll9mdWxmaWxsbWVudEhhbmRsZXIwO1xuICAgICAgICAgICAgaGFuZGxlciA9IGRpZFJlamVjdDtcbiAgICAgICAgICAgIHRhcmdldC5fdW5zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0dGxlciA9IHRhcmdldC5fc2V0dGxlUHJvbWlzZUxhdGVDYW5jZWxsYXRpb25PYnNlcnZlcjtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IENhbmNlbGxhdGlvbkVycm9yKFwibGF0ZSBjYW5jZWxsYXRpb24gb2JzZXJ2ZXJcIik7XG4gICAgICAgICAgICB0YXJnZXQuX2F0dGFjaEV4dHJhVHJhY2UodmFsdWUpO1xuICAgICAgICAgICAgaGFuZGxlciA9IGRpZFJlamVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGFzeW5jLmludm9rZShzZXR0bGVyLCB0YXJnZXQsIHtcbiAgICAgICAgICAgIGhhbmRsZXI6IGRvbWFpbiA9PT0gbnVsbCA/IGhhbmRsZXJcbiAgICAgICAgICAgICAgICA6ICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAgICAgICAgIHV0aWwuZG9tYWluQmluZChkb21haW4sIGhhbmRsZXIpKSxcbiAgICAgICAgICAgIHByb21pc2U6IHByb21pc2UsXG4gICAgICAgICAgICByZWNlaXZlcjogcmVjZWl2ZXIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0Ll9hZGRDYWxsYmFja3MoZGlkRnVsZmlsbCwgZGlkUmVqZWN0LCBwcm9taXNlLCByZWNlaXZlciwgZG9tYWluKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JpdEZpZWxkICYgNjU1MzU7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNGYXRlU2VhbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiAxMTc1MDYwNDgpICE9PSAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2lzRm9sbG93aW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiA2NzEwODg2NCkgPT09IDY3MTA4ODY0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldExlbmd0aCA9IGZ1bmN0aW9uIChsZW4pIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9ICh0aGlzLl9iaXRGaWVsZCAmIC02NTUzNikgfFxuICAgICAgICAobGVuICYgNjU1MzUpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldEZ1bGZpbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMzM1NTQ0MzI7XG4gICAgdGhpcy5fZmlyZUV2ZW50KFwicHJvbWlzZUZ1bGZpbGxlZFwiLCB0aGlzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRSZWplY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMTY3NzcyMTY7XG4gICAgdGhpcy5fZmlyZUV2ZW50KFwicHJvbWlzZVJlamVjdGVkXCIsIHRoaXMpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldEZvbGxvd2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgNjcxMDg4NjQ7XG4gICAgdGhpcy5fZmlyZUV2ZW50KFwicHJvbWlzZVJlc29sdmVkXCIsIHRoaXMpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldElzRmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDQxOTQzMDQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNGaW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgNDE5NDMwNCkgPiAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Vuc2V0Q2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCAmICh+NjU1MzYpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldENhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCA2NTUzNjtcbiAgICB0aGlzLl9maXJlRXZlbnQoXCJwcm9taXNlQ2FuY2VsbGVkXCIsIHRoaXMpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldFdpbGxCZUNhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCA4Mzg4NjA4O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldEFzeW5jR3VhcmFudGVlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChhc3luYy5oYXNDdXN0b21TY2hlZHVsZXIoKSkgcmV0dXJuO1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCAxMzQyMTc3Mjg7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVjZWl2ZXJBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHZhciByZXQgPSBpbmRleCA9PT0gMCA/IHRoaXMuX3JlY2VpdmVyMCA6IHRoaXNbXG4gICAgICAgICAgICBpbmRleCAqIDQgLSA0ICsgM107XG4gICAgaWYgKHJldCA9PT0gVU5ERUZJTkVEX0JJTkRJTkcpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHJldCA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2lzQm91bmQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm91bmRWYWx1ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Byb21pc2VBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiB0aGlzW1xuICAgICAgICAgICAgaW5kZXggKiA0IC0gNCArIDJdO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2Z1bGZpbGxtZW50SGFuZGxlckF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXNbXG4gICAgICAgICAgICBpbmRleCAqIDQgLSA0ICsgMF07XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVqZWN0aW9uSGFuZGxlckF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXNbXG4gICAgICAgICAgICBpbmRleCAqIDQgLSA0ICsgMV07XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fYm91bmRWYWx1ZSA9IGZ1bmN0aW9uKCkge307XG5cblByb21pc2UucHJvdG90eXBlLl9taWdyYXRlQ2FsbGJhY2swID0gZnVuY3Rpb24gKGZvbGxvd2VyKSB7XG4gICAgdmFyIGJpdEZpZWxkID0gZm9sbG93ZXIuX2JpdEZpZWxkO1xuICAgIHZhciBmdWxmaWxsID0gZm9sbG93ZXIuX2Z1bGZpbGxtZW50SGFuZGxlcjA7XG4gICAgdmFyIHJlamVjdCA9IGZvbGxvd2VyLl9yZWplY3Rpb25IYW5kbGVyMDtcbiAgICB2YXIgcHJvbWlzZSA9IGZvbGxvd2VyLl9wcm9taXNlMDtcbiAgICB2YXIgcmVjZWl2ZXIgPSBmb2xsb3dlci5fcmVjZWl2ZXJBdCgwKTtcbiAgICBpZiAocmVjZWl2ZXIgPT09IHVuZGVmaW5lZCkgcmVjZWl2ZXIgPSBVTkRFRklORURfQklORElORztcbiAgICB0aGlzLl9hZGRDYWxsYmFja3MoZnVsZmlsbCwgcmVqZWN0LCBwcm9taXNlLCByZWNlaXZlciwgbnVsbCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fbWlncmF0ZUNhbGxiYWNrQXQgPSBmdW5jdGlvbiAoZm9sbG93ZXIsIGluZGV4KSB7XG4gICAgdmFyIGZ1bGZpbGwgPSBmb2xsb3dlci5fZnVsZmlsbG1lbnRIYW5kbGVyQXQoaW5kZXgpO1xuICAgIHZhciByZWplY3QgPSBmb2xsb3dlci5fcmVqZWN0aW9uSGFuZGxlckF0KGluZGV4KTtcbiAgICB2YXIgcHJvbWlzZSA9IGZvbGxvd2VyLl9wcm9taXNlQXQoaW5kZXgpO1xuICAgIHZhciByZWNlaXZlciA9IGZvbGxvd2VyLl9yZWNlaXZlckF0KGluZGV4KTtcbiAgICBpZiAocmVjZWl2ZXIgPT09IHVuZGVmaW5lZCkgcmVjZWl2ZXIgPSBVTkRFRklORURfQklORElORztcbiAgICB0aGlzLl9hZGRDYWxsYmFja3MoZnVsZmlsbCwgcmVqZWN0LCBwcm9taXNlLCByZWNlaXZlciwgbnVsbCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fYWRkQ2FsbGJhY2tzID0gZnVuY3Rpb24gKFxuICAgIGZ1bGZpbGwsXG4gICAgcmVqZWN0LFxuICAgIHByb21pc2UsXG4gICAgcmVjZWl2ZXIsXG4gICAgZG9tYWluXG4pIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9sZW5ndGgoKTtcblxuICAgIGlmIChpbmRleCA+PSA2NTUzNSAtIDQpIHtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICB0aGlzLl9zZXRMZW5ndGgoMCk7XG4gICAgfVxuXG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3Byb21pc2UwID0gcHJvbWlzZTtcbiAgICAgICAgdGhpcy5fcmVjZWl2ZXIwID0gcmVjZWl2ZXI7XG4gICAgICAgIGlmICh0eXBlb2YgZnVsZmlsbCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXIwID1cbiAgICAgICAgICAgICAgICBkb21haW4gPT09IG51bGwgPyBmdWxmaWxsIDogdXRpbC5kb21haW5CaW5kKGRvbWFpbiwgZnVsZmlsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByZWplY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5fcmVqZWN0aW9uSGFuZGxlcjAgPVxuICAgICAgICAgICAgICAgIGRvbWFpbiA9PT0gbnVsbCA/IHJlamVjdCA6IHV0aWwuZG9tYWluQmluZChkb21haW4sIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYmFzZSA9IGluZGV4ICogNCAtIDQ7XG4gICAgICAgIHRoaXNbYmFzZSArIDJdID0gcHJvbWlzZTtcbiAgICAgICAgdGhpc1tiYXNlICsgM10gPSByZWNlaXZlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBmdWxmaWxsID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXNbYmFzZSArIDBdID1cbiAgICAgICAgICAgICAgICBkb21haW4gPT09IG51bGwgPyBmdWxmaWxsIDogdXRpbC5kb21haW5CaW5kKGRvbWFpbiwgZnVsZmlsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByZWplY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpc1tiYXNlICsgMV0gPVxuICAgICAgICAgICAgICAgIGRvbWFpbiA9PT0gbnVsbCA/IHJlamVjdCA6IHV0aWwuZG9tYWluQmluZChkb21haW4sIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fc2V0TGVuZ3RoKGluZGV4ICsgMSk7XG4gICAgcmV0dXJuIGluZGV4O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Byb3h5ID0gZnVuY3Rpb24gKHByb3h5YWJsZSwgYXJnKSB7XG4gICAgdGhpcy5fYWRkQ2FsbGJhY2tzKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcmcsIHByb3h5YWJsZSwgbnVsbCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVzb2x2ZUNhbGxiYWNrID0gZnVuY3Rpb24odmFsdWUsIHNob3VsZEJpbmQpIHtcbiAgICBpZiAoKCh0aGlzLl9iaXRGaWVsZCAmIDExNzUwNjA0OCkgIT09IDApKSByZXR1cm47XG4gICAgaWYgKHZhbHVlID09PSB0aGlzKVxuICAgICAgICByZXR1cm4gdGhpcy5fcmVqZWN0Q2FsbGJhY2sobWFrZVNlbGZSZXNvbHV0aW9uRXJyb3IoKSwgZmFsc2UpO1xuICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHZhbHVlLCB0aGlzKTtcbiAgICBpZiAoIShtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSkgcmV0dXJuIHRoaXMuX2Z1bGZpbGwodmFsdWUpO1xuXG4gICAgaWYgKHNob3VsZEJpbmQpIHRoaXMuX3Byb3BhZ2F0ZUZyb20obWF5YmVQcm9taXNlLCAyKTtcblxuICAgIHZhciBwcm9taXNlID0gbWF5YmVQcm9taXNlLl90YXJnZXQoKTtcblxuICAgIGlmIChwcm9taXNlID09PSB0aGlzKSB7XG4gICAgICAgIHRoaXMuX3JlamVjdChtYWtlU2VsZlJlc29sdXRpb25FcnJvcigpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBiaXRGaWVsZCA9IHByb21pc2UuX2JpdEZpZWxkO1xuICAgIGlmICgoKGJpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSkge1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5fbGVuZ3RoKCk7XG4gICAgICAgIGlmIChsZW4gPiAwKSBwcm9taXNlLl9taWdyYXRlQ2FsbGJhY2swKHRoaXMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBwcm9taXNlLl9taWdyYXRlQ2FsbGJhY2tBdCh0aGlzLCBpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRGb2xsb3dpbmcoKTtcbiAgICAgICAgdGhpcy5fc2V0TGVuZ3RoKDApO1xuICAgICAgICB0aGlzLl9zZXRGb2xsb3dlZShwcm9taXNlKTtcbiAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgIHRoaXMuX2Z1bGZpbGwocHJvbWlzZS5fdmFsdWUoKSk7XG4gICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMTY3NzcyMTYpICE9PSAwKSkge1xuICAgICAgICB0aGlzLl9yZWplY3QocHJvbWlzZS5fcmVhc29uKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZWFzb24gPSBuZXcgQ2FuY2VsbGF0aW9uRXJyb3IoXCJsYXRlIGNhbmNlbGxhdGlvbiBvYnNlcnZlclwiKTtcbiAgICAgICAgcHJvbWlzZS5fYXR0YWNoRXh0cmFUcmFjZShyZWFzb24pO1xuICAgICAgICB0aGlzLl9yZWplY3QocmVhc29uKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVqZWN0Q2FsbGJhY2sgPVxuZnVuY3Rpb24ocmVhc29uLCBzeW5jaHJvbm91cywgaWdub3JlTm9uRXJyb3JXYXJuaW5ncykge1xuICAgIHZhciB0cmFjZSA9IHV0aWwuZW5zdXJlRXJyb3JPYmplY3QocmVhc29uKTtcbiAgICB2YXIgaGFzU3RhY2sgPSB0cmFjZSA9PT0gcmVhc29uO1xuICAgIGlmICghaGFzU3RhY2sgJiYgIWlnbm9yZU5vbkVycm9yV2FybmluZ3MgJiYgZGVidWcud2FybmluZ3MoKSkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IFwiYSBwcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGEgbm9uLWVycm9yOiBcIiArXG4gICAgICAgICAgICB1dGlsLmNsYXNzU3RyaW5nKHJlYXNvbik7XG4gICAgICAgIHRoaXMuX3dhcm4obWVzc2FnZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMuX2F0dGFjaEV4dHJhVHJhY2UodHJhY2UsIHN5bmNocm9ub3VzID8gaGFzU3RhY2sgOiBmYWxzZSk7XG4gICAgdGhpcy5fcmVqZWN0KHJlYXNvbik7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVzb2x2ZUZyb21FeGVjdXRvciA9IGZ1bmN0aW9uIChleGVjdXRvcikge1xuICAgIGlmIChleGVjdXRvciA9PT0gSU5URVJOQUwpIHJldHVybjtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgdGhpcy5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICB0aGlzLl9wdXNoQ29udGV4dCgpO1xuICAgIHZhciBzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgdmFyIHIgPSB0aGlzLl9leGVjdXRlKGV4ZWN1dG9yLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBwcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2sodmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2socmVhc29uLCBzeW5jaHJvbm91cyk7XG4gICAgfSk7XG4gICAgc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICB0aGlzLl9wb3BDb250ZXh0KCk7XG5cbiAgICBpZiAociAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKHIsIHRydWUpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXR0bGVQcm9taXNlRnJvbUhhbmRsZXIgPSBmdW5jdGlvbiAoXG4gICAgaGFuZGxlciwgcmVjZWl2ZXIsIHZhbHVlLCBwcm9taXNlXG4pIHtcbiAgICB2YXIgYml0RmllbGQgPSBwcm9taXNlLl9iaXRGaWVsZDtcbiAgICBpZiAoKChiaXRGaWVsZCAmIDY1NTM2KSAhPT0gMCkpIHJldHVybjtcbiAgICBwcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgIHZhciB4O1xuICAgIGlmIChyZWNlaXZlciA9PT0gQVBQTFkpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUubGVuZ3RoICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB4ID0gZXJyb3JPYmo7XG4gICAgICAgICAgICB4LmUgPSBuZXcgVHlwZUVycm9yKFwiY2Fubm90IC5zcHJlYWQoKSBhIG5vbi1hcnJheTogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5jbGFzc1N0cmluZyh2YWx1ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeCA9IHRyeUNhdGNoKGhhbmRsZXIpLmFwcGx5KHRoaXMuX2JvdW5kVmFsdWUoKSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHRyeUNhdGNoKGhhbmRsZXIpLmNhbGwocmVjZWl2ZXIsIHZhbHVlKTtcbiAgICB9XG4gICAgdmFyIHByb21pc2VDcmVhdGVkID0gcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgIGJpdEZpZWxkID0gcHJvbWlzZS5fYml0RmllbGQ7XG4gICAgaWYgKCgoYml0RmllbGQgJiA2NTUzNikgIT09IDApKSByZXR1cm47XG5cbiAgICBpZiAoeCA9PT0gTkVYVF9GSUxURVIpIHtcbiAgICAgICAgcHJvbWlzZS5fcmVqZWN0KHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHggPT09IGVycm9yT2JqKSB7XG4gICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKHguZSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnLmNoZWNrRm9yZ290dGVuUmV0dXJucyh4LCBwcm9taXNlQ3JlYXRlZCwgXCJcIiwgIHByb21pc2UsIHRoaXMpO1xuICAgICAgICBwcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2soeCk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3RhcmdldCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXQgPSB0aGlzO1xuICAgIHdoaWxlIChyZXQuX2lzRm9sbG93aW5nKCkpIHJldCA9IHJldC5fZm9sbG93ZWUoKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2ZvbGxvd2VlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldEZvbGxvd2VlID0gZnVuY3Rpb24ocHJvbWlzZSkge1xuICAgIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwID0gcHJvbWlzZTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXR0bGVQcm9taXNlID0gZnVuY3Rpb24ocHJvbWlzZSwgaGFuZGxlciwgcmVjZWl2ZXIsIHZhbHVlKSB7XG4gICAgdmFyIGlzUHJvbWlzZSA9IHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlO1xuICAgIHZhciBiaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkO1xuICAgIHZhciBhc3luY0d1YXJhbnRlZWQgPSAoKGJpdEZpZWxkICYgMTM0MjE3NzI4KSAhPT0gMCk7XG4gICAgaWYgKCgoYml0RmllbGQgJiA2NTUzNikgIT09IDApKSB7XG4gICAgICAgIGlmIChpc1Byb21pc2UpIHByb21pc2UuX2ludm9rZUludGVybmFsT25DYW5jZWwoKTtcblxuICAgICAgICBpZiAocmVjZWl2ZXIgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaEhhbmRsZXJDb250ZXh0ICYmXG4gICAgICAgICAgICByZWNlaXZlci5pc0ZpbmFsbHlIYW5kbGVyKCkpIHtcbiAgICAgICAgICAgIHJlY2VpdmVyLmNhbmNlbFByb21pc2UgPSBwcm9taXNlO1xuICAgICAgICAgICAgaWYgKHRyeUNhdGNoKGhhbmRsZXIpLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9yZWplY3QoZXJyb3JPYmouZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9PT0gcmVmbGVjdEhhbmRsZXIpIHtcbiAgICAgICAgICAgIHByb21pc2UuX2Z1bGZpbGwocmVmbGVjdEhhbmRsZXIuY2FsbChyZWNlaXZlcikpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlY2VpdmVyIGluc3RhbmNlb2YgUHJveHlhYmxlKSB7XG4gICAgICAgICAgICByZWNlaXZlci5fcHJvbWlzZUNhbmNlbGxlZChwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1Byb21pc2UgfHwgcHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2VBcnJheSkge1xuICAgICAgICAgICAgcHJvbWlzZS5fY2FuY2VsKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWNlaXZlci5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBpZiAoIWlzUHJvbWlzZSkge1xuICAgICAgICAgICAgaGFuZGxlci5jYWxsKHJlY2VpdmVyLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYXN5bmNHdWFyYW50ZWVkKSBwcm9taXNlLl9zZXRBc3luY0d1YXJhbnRlZWQoKTtcbiAgICAgICAgICAgIHRoaXMuX3NldHRsZVByb21pc2VGcm9tSGFuZGxlcihoYW5kbGVyLCByZWNlaXZlciwgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChyZWNlaXZlciBpbnN0YW5jZW9mIFByb3h5YWJsZSkge1xuICAgICAgICBpZiAoIXJlY2VpdmVyLl9pc1Jlc29sdmVkKCkpIHtcbiAgICAgICAgICAgIGlmICgoKGJpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwKSkge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVyLl9wcm9taXNlRnVsZmlsbGVkKHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIuX3Byb21pc2VSZWplY3RlZCh2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJvbWlzZSkge1xuICAgICAgICBpZiAoYXN5bmNHdWFyYW50ZWVkKSBwcm9taXNlLl9zZXRBc3luY0d1YXJhbnRlZWQoKTtcbiAgICAgICAgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgICAgICBwcm9taXNlLl9mdWxmaWxsKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb21pc2UuX3JlamVjdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZUxhdGVDYW5jZWxsYXRpb25PYnNlcnZlciA9IGZ1bmN0aW9uKGN0eCkge1xuICAgIHZhciBoYW5kbGVyID0gY3R4LmhhbmRsZXI7XG4gICAgdmFyIHByb21pc2UgPSBjdHgucHJvbWlzZTtcbiAgICB2YXIgcmVjZWl2ZXIgPSBjdHgucmVjZWl2ZXI7XG4gICAgdmFyIHZhbHVlID0gY3R4LnZhbHVlO1xuICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGlmICghKHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgICAgICAgaGFuZGxlci5jYWxsKHJlY2VpdmVyLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zZXR0bGVQcm9taXNlRnJvbUhhbmRsZXIoaGFuZGxlciwgcmVjZWl2ZXIsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcHJvbWlzZS5fcmVqZWN0KHZhbHVlKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZUN0eCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgIHRoaXMuX3NldHRsZVByb21pc2UoY3R4LnByb21pc2UsIGN0eC5oYW5kbGVyLCBjdHgucmVjZWl2ZXIsIGN0eC52YWx1ZSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZTAgPSBmdW5jdGlvbihoYW5kbGVyLCB2YWx1ZSwgYml0RmllbGQpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2UwO1xuICAgIHZhciByZWNlaXZlciA9IHRoaXMuX3JlY2VpdmVyQXQoMCk7XG4gICAgdGhpcy5fcHJvbWlzZTAgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmVjZWl2ZXIwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NldHRsZVByb21pc2UocHJvbWlzZSwgaGFuZGxlciwgcmVjZWl2ZXIsIHZhbHVlKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9jbGVhckNhbGxiYWNrRGF0YUF0SW5kZXggPSBmdW5jdGlvbihpbmRleCkge1xuICAgIHZhciBiYXNlID0gaW5kZXggKiA0IC0gNDtcbiAgICB0aGlzW2Jhc2UgKyAyXSA9XG4gICAgdGhpc1tiYXNlICsgM10gPVxuICAgIHRoaXNbYmFzZSArIDBdID1cbiAgICB0aGlzW2Jhc2UgKyAxXSA9IHVuZGVmaW5lZDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9mdWxmaWxsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIGJpdEZpZWxkID0gdGhpcy5fYml0RmllbGQ7XG4gICAgaWYgKCgoYml0RmllbGQgJiAxMTc1MDYwNDgpID4+PiAxNikpIHJldHVybjtcbiAgICBpZiAodmFsdWUgPT09IHRoaXMpIHtcbiAgICAgICAgdmFyIGVyciA9IG1ha2VTZWxmUmVzb2x1dGlvbkVycm9yKCk7XG4gICAgICAgIHRoaXMuX2F0dGFjaEV4dHJhVHJhY2UoZXJyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlamVjdChlcnIpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRGdWxmaWxsZWQoKTtcbiAgICB0aGlzLl9yZWplY3Rpb25IYW5kbGVyMCA9IHZhbHVlO1xuXG4gICAgaWYgKChiaXRGaWVsZCAmIDY1NTM1KSA+IDApIHtcbiAgICAgICAgaWYgKCgoYml0RmllbGQgJiAxMzQyMTc3MjgpICE9PSAwKSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0dGxlUHJvbWlzZXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFzeW5jLnNldHRsZVByb21pc2VzKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3JlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB2YXIgYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZDtcbiAgICBpZiAoKChiaXRGaWVsZCAmIDExNzUwNjA0OCkgPj4+IDE2KSkgcmV0dXJuO1xuICAgIHRoaXMuX3NldFJlamVjdGVkKCk7XG4gICAgdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyMCA9IHJlYXNvbjtcblxuICAgIGlmICh0aGlzLl9pc0ZpbmFsKCkpIHtcbiAgICAgICAgcmV0dXJuIGFzeW5jLmZhdGFsRXJyb3IocmVhc29uLCB1dGlsLmlzTm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKChiaXRGaWVsZCAmIDY1NTM1KSA+IDApIHtcbiAgICAgICAgYXN5bmMuc2V0dGxlUHJvbWlzZXModGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZW5zdXJlUG9zc2libGVSZWplY3Rpb25IYW5kbGVkKCk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2Z1bGZpbGxQcm9taXNlcyA9IGZ1bmN0aW9uIChsZW4sIHZhbHVlKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlckF0KGkpO1xuICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2VBdChpKTtcbiAgICAgICAgdmFyIHJlY2VpdmVyID0gdGhpcy5fcmVjZWl2ZXJBdChpKTtcbiAgICAgICAgdGhpcy5fY2xlYXJDYWxsYmFja0RhdGFBdEluZGV4KGkpO1xuICAgICAgICB0aGlzLl9zZXR0bGVQcm9taXNlKHByb21pc2UsIGhhbmRsZXIsIHJlY2VpdmVyLCB2YWx1ZSk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3JlamVjdFByb21pc2VzID0gZnVuY3Rpb24gKGxlbiwgcmVhc29uKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMuX3JlamVjdGlvbkhhbmRsZXJBdChpKTtcbiAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl9wcm9taXNlQXQoaSk7XG4gICAgICAgIHZhciByZWNlaXZlciA9IHRoaXMuX3JlY2VpdmVyQXQoaSk7XG4gICAgICAgIHRoaXMuX2NsZWFyQ2FsbGJhY2tEYXRhQXRJbmRleChpKTtcbiAgICAgICAgdGhpcy5fc2V0dGxlUHJvbWlzZShwcm9taXNlLCBoYW5kbGVyLCByZWNlaXZlciwgcmVhc29uKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJpdEZpZWxkID0gdGhpcy5fYml0RmllbGQ7XG4gICAgdmFyIGxlbiA9IChiaXRGaWVsZCAmIDY1NTM1KTtcblxuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIGlmICgoKGJpdEZpZWxkICYgMTY4NDI3NTIpICE9PSAwKSkge1xuICAgICAgICAgICAgdmFyIHJlYXNvbiA9IHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcjA7XG4gICAgICAgICAgICB0aGlzLl9zZXR0bGVQcm9taXNlMCh0aGlzLl9yZWplY3Rpb25IYW5kbGVyMCwgcmVhc29uLCBiaXRGaWVsZCk7XG4gICAgICAgICAgICB0aGlzLl9yZWplY3RQcm9taXNlcyhsZW4sIHJlYXNvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9yZWplY3Rpb25IYW5kbGVyMDtcbiAgICAgICAgICAgIHRoaXMuX3NldHRsZVByb21pc2UwKHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcjAsIHZhbHVlLCBiaXRGaWVsZCk7XG4gICAgICAgICAgICB0aGlzLl9mdWxmaWxsUHJvbWlzZXMobGVuLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0TGVuZ3RoKDApO1xuICAgIH1cbiAgICB0aGlzLl9jbGVhckNhbmNlbGxhdGlvbkRhdGEoKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXR0bGVkVmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZDtcbiAgICBpZiAoKChiaXRGaWVsZCAmIDMzNTU0NDMyKSAhPT0gMCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwO1xuICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcjA7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gZGVmZXJSZXNvbHZlKHYpIHt0aGlzLnByb21pc2UuX3Jlc29sdmVDYWxsYmFjayh2KTt9XG5mdW5jdGlvbiBkZWZlclJlamVjdCh2KSB7dGhpcy5wcm9taXNlLl9yZWplY3RDYWxsYmFjayh2LCBmYWxzZSk7fVxuXG5Qcm9taXNlLmRlZmVyID0gUHJvbWlzZS5wZW5kaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcuZGVwcmVjYXRlZChcIlByb21pc2UuZGVmZXJcIiwgXCJuZXcgUHJvbWlzZVwiKTtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9taXNlOiBwcm9taXNlLFxuICAgICAgICByZXNvbHZlOiBkZWZlclJlc29sdmUsXG4gICAgICAgIHJlamVjdDogZGVmZXJSZWplY3RcbiAgICB9O1xufTtcblxudXRpbC5ub3RFbnVtZXJhYmxlUHJvcChQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICBcIl9tYWtlU2VsZlJlc29sdXRpb25FcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICBtYWtlU2VsZlJlc29sdXRpb25FcnJvcik7XG5cbl9kZXJlcV8oXCIuL21ldGhvZFwiKShQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgYXBpUmVqZWN0aW9uLFxuICAgIGRlYnVnKTtcbl9kZXJlcV8oXCIuL2JpbmRcIikoUHJvbWlzZSwgSU5URVJOQUwsIHRyeUNvbnZlcnRUb1Byb21pc2UsIGRlYnVnKTtcbl9kZXJlcV8oXCIuL2NhbmNlbFwiKShQcm9taXNlLCBQcm9taXNlQXJyYXksIGFwaVJlamVjdGlvbiwgZGVidWcpO1xuX2RlcmVxXyhcIi4vZGlyZWN0X3Jlc29sdmVcIikoUHJvbWlzZSk7XG5fZGVyZXFfKFwiLi9zeW5jaHJvbm91c19pbnNwZWN0aW9uXCIpKFByb21pc2UpO1xuX2RlcmVxXyhcIi4vam9pblwiKShcbiAgICBQcm9taXNlLCBQcm9taXNlQXJyYXksIHRyeUNvbnZlcnRUb1Byb21pc2UsIElOVEVSTkFMLCBhc3luYywgZ2V0RG9tYWluKTtcblByb21pc2UuUHJvbWlzZSA9IFByb21pc2U7XG5Qcm9taXNlLnZlcnNpb24gPSBcIjMuNS4wXCI7XG5fZGVyZXFfKCcuL21hcC5qcycpKFByb21pc2UsIFByb21pc2VBcnJheSwgYXBpUmVqZWN0aW9uLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBJTlRFUk5BTCwgZGVidWcpO1xuX2RlcmVxXygnLi9jYWxsX2dldC5qcycpKFByb21pc2UpO1xuX2RlcmVxXygnLi91c2luZy5qcycpKFByb21pc2UsIGFwaVJlamVjdGlvbiwgdHJ5Q29udmVydFRvUHJvbWlzZSwgY3JlYXRlQ29udGV4dCwgSU5URVJOQUwsIGRlYnVnKTtcbl9kZXJlcV8oJy4vdGltZXJzLmpzJykoUHJvbWlzZSwgSU5URVJOQUwsIGRlYnVnKTtcbl9kZXJlcV8oJy4vZ2VuZXJhdG9ycy5qcycpKFByb21pc2UsIGFwaVJlamVjdGlvbiwgSU5URVJOQUwsIHRyeUNvbnZlcnRUb1Byb21pc2UsIFByb3h5YWJsZSwgZGVidWcpO1xuX2RlcmVxXygnLi9ub2RlaWZ5LmpzJykoUHJvbWlzZSk7XG5fZGVyZXFfKCcuL3Byb21pc2lmeS5qcycpKFByb21pc2UsIElOVEVSTkFMKTtcbl9kZXJlcV8oJy4vcHJvcHMuanMnKShQcm9taXNlLCBQcm9taXNlQXJyYXksIHRyeUNvbnZlcnRUb1Byb21pc2UsIGFwaVJlamVjdGlvbik7XG5fZGVyZXFfKCcuL3JhY2UuanMnKShQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgYXBpUmVqZWN0aW9uKTtcbl9kZXJlcV8oJy4vcmVkdWNlLmpzJykoUHJvbWlzZSwgUHJvbWlzZUFycmF5LCBhcGlSZWplY3Rpb24sIHRyeUNvbnZlcnRUb1Byb21pc2UsIElOVEVSTkFMLCBkZWJ1Zyk7XG5fZGVyZXFfKCcuL3NldHRsZS5qcycpKFByb21pc2UsIFByb21pc2VBcnJheSwgZGVidWcpO1xuX2RlcmVxXygnLi9zb21lLmpzJykoUHJvbWlzZSwgUHJvbWlzZUFycmF5LCBhcGlSZWplY3Rpb24pO1xuX2RlcmVxXygnLi9maWx0ZXIuanMnKShQcm9taXNlLCBJTlRFUk5BTCk7XG5fZGVyZXFfKCcuL2VhY2guanMnKShQcm9taXNlLCBJTlRFUk5BTCk7XG5fZGVyZXFfKCcuL2FueS5qcycpKFByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgdXRpbC50b0Zhc3RQcm9wZXJ0aWVzKFByb21pc2UpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIHV0aWwudG9GYXN0UHJvcGVydGllcyhQcm9taXNlLnByb3RvdHlwZSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmdW5jdGlvbiBmaWxsVHlwZXModmFsdWUpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIHZhciBwID0gbmV3IFByb21pc2UoSU5URVJOQUwpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICBwLl9mdWxmaWxsbWVudEhhbmRsZXIwID0gdmFsdWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgcC5fcmVqZWN0aW9uSGFuZGxlcjAgPSB2YWx1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIHAuX3Byb21pc2UwID0gdmFsdWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICBwLl9yZWNlaXZlcjAgPSB2YWx1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgLy8gQ29tcGxldGUgc2xhY2sgdHJhY2tpbmcsIG9wdCBvdXQgb2YgZmllbGQtdHlwZSB0cmFja2luZyBhbmQgICAgICAgICAgIFxuICAgIC8vIHN0YWJpbGl6ZSBtYXAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmaWxsVHlwZXMoe2E6IDF9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZmlsbFR5cGVzKHtiOiAyfSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGZpbGxUeXBlcyh7YzogM30pOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmaWxsVHlwZXMoMSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZmlsbFR5cGVzKGZ1bmN0aW9uKCl7fSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGZpbGxUeXBlcyh1bmRlZmluZWQpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmaWxsVHlwZXMoZmFsc2UpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZmlsbFR5cGVzKG5ldyBQcm9taXNlKElOVEVSTkFMKSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGRlYnVnLnNldEJvdW5kcyhBc3luYy5maXJzdExpbmVFcnJvciwgdXRpbC5sYXN0TGluZUVycm9yKTsgICAgICAgICAgICAgICBcbiAgICByZXR1cm4gUHJvbWlzZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cbn07XG5cbn0se1wiLi9hbnkuanNcIjoxLFwiLi9hc3luY1wiOjIsXCIuL2JpbmRcIjozLFwiLi9jYWxsX2dldC5qc1wiOjUsXCIuL2NhbmNlbFwiOjYsXCIuL2NhdGNoX2ZpbHRlclwiOjcsXCIuL2NvbnRleHRcIjo4LFwiLi9kZWJ1Z2dhYmlsaXR5XCI6OSxcIi4vZGlyZWN0X3Jlc29sdmVcIjoxMCxcIi4vZWFjaC5qc1wiOjExLFwiLi9lcnJvcnNcIjoxMixcIi4vZXM1XCI6MTMsXCIuL2ZpbHRlci5qc1wiOjE0LFwiLi9maW5hbGx5XCI6MTUsXCIuL2dlbmVyYXRvcnMuanNcIjoxNixcIi4vam9pblwiOjE3LFwiLi9tYXAuanNcIjoxOCxcIi4vbWV0aG9kXCI6MTksXCIuL25vZGViYWNrXCI6MjAsXCIuL25vZGVpZnkuanNcIjoyMSxcIi4vcHJvbWlzZV9hcnJheVwiOjIzLFwiLi9wcm9taXNpZnkuanNcIjoyNCxcIi4vcHJvcHMuanNcIjoyNSxcIi4vcmFjZS5qc1wiOjI3LFwiLi9yZWR1Y2UuanNcIjoyOCxcIi4vc2V0dGxlLmpzXCI6MzAsXCIuL3NvbWUuanNcIjozMSxcIi4vc3luY2hyb25vdXNfaW5zcGVjdGlvblwiOjMyLFwiLi90aGVuYWJsZXNcIjozMyxcIi4vdGltZXJzLmpzXCI6MzQsXCIuL3VzaW5nLmpzXCI6MzUsXCIuL3V0aWxcIjozNn1dLDIzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSxcbiAgICBhcGlSZWplY3Rpb24sIFByb3h5YWJsZSkge1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xudmFyIGlzQXJyYXkgPSB1dGlsLmlzQXJyYXk7XG5cbmZ1bmN0aW9uIHRvUmVzb2x1dGlvblZhbHVlKHZhbCkge1xuICAgIHN3aXRjaCh2YWwpIHtcbiAgICBjYXNlIC0yOiByZXR1cm4gW107XG4gICAgY2FzZSAtMzogcmV0dXJuIHt9O1xuICAgIGNhc2UgLTY6IHJldHVybiBuZXcgTWFwKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBQcm9taXNlQXJyYXkodmFsdWVzKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzLl9wcm9taXNlID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIGlmICh2YWx1ZXMgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHByb21pc2UuX3Byb3BhZ2F0ZUZyb20odmFsdWVzLCAzKTtcbiAgICB9XG4gICAgcHJvbWlzZS5fc2V0T25DYW5jZWwodGhpcyk7XG4gICAgdGhpcy5fdmFsdWVzID0gdmFsdWVzO1xuICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgdGhpcy5fdG90YWxSZXNvbHZlZCA9IDA7XG4gICAgdGhpcy5faW5pdCh1bmRlZmluZWQsIC0yKTtcbn1cbnV0aWwuaW5oZXJpdHMoUHJvbWlzZUFycmF5LCBQcm94eWFibGUpO1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGVuZ3RoO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5wcm9taXNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm9taXNlO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQoXywgcmVzb2x2ZVZhbHVlSWZFbXB0eSkge1xuICAgIHZhciB2YWx1ZXMgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHRoaXMuX3ZhbHVlcywgdGhpcy5fcHJvbWlzZSk7XG4gICAgaWYgKHZhbHVlcyBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgdmFsdWVzID0gdmFsdWVzLl90YXJnZXQoKTtcbiAgICAgICAgdmFyIGJpdEZpZWxkID0gdmFsdWVzLl9iaXRGaWVsZDtcbiAgICAgICAgO1xuICAgICAgICB0aGlzLl92YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgICAgICAgaWYgKCgoYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9taXNlLl9zZXRBc3luY0d1YXJhbnRlZWQoKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXMuX3RoZW4oXG4gICAgICAgICAgICAgICAgaW5pdCxcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWplY3QsXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZVZhbHVlSWZFbXB0eVxuICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuX3ZhbHVlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWplY3QodmFsdWVzLl9yZWFzb24oKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFsdWVzID0gdXRpbC5hc0FycmF5KHZhbHVlcyk7XG4gICAgaWYgKHZhbHVlcyA9PT0gbnVsbCkge1xuICAgICAgICB2YXIgZXJyID0gYXBpUmVqZWN0aW9uKFxuICAgICAgICAgICAgXCJleHBlY3RpbmcgYW4gYXJyYXkgb3IgYW4gaXRlcmFibGUgb2JqZWN0IGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKHZhbHVlcykpLnJlYXNvbigpO1xuICAgICAgICB0aGlzLl9wcm9taXNlLl9yZWplY3RDYWxsYmFjayhlcnIsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlmIChyZXNvbHZlVmFsdWVJZkVtcHR5ID09PSAtNSkge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZUVtcHR5QXJyYXkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUodG9SZXNvbHV0aW9uVmFsdWUocmVzb2x2ZVZhbHVlSWZFbXB0eSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5faXRlcmF0ZSh2YWx1ZXMpO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faXRlcmF0ZSA9IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgIHZhciBsZW4gPSB0aGlzLmdldEFjdHVhbExlbmd0aCh2YWx1ZXMubGVuZ3RoKTtcbiAgICB0aGlzLl9sZW5ndGggPSBsZW47XG4gICAgdGhpcy5fdmFsdWVzID0gdGhpcy5zaG91bGRDb3B5VmFsdWVzKCkgPyBuZXcgQXJyYXkobGVuKSA6IHRoaXMuX3ZhbHVlcztcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5fcHJvbWlzZTtcbiAgICB2YXIgaXNSZXNvbHZlZCA9IGZhbHNlO1xuICAgIHZhciBiaXRGaWVsZCA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZSh2YWx1ZXNbaV0sIHJlc3VsdCk7XG5cbiAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZSA9IG1heWJlUHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgICAgICAgICBiaXRGaWVsZCA9IG1heWJlUHJvbWlzZS5fYml0RmllbGQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiaXRGaWVsZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNSZXNvbHZlZCkge1xuICAgICAgICAgICAgaWYgKGJpdEZpZWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLnN1cHByZXNzVW5oYW5kbGVkUmVqZWN0aW9ucygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGJpdEZpZWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoKChiaXRGaWVsZCAmIDUwMzk3MTg0KSA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICBtYXliZVByb21pc2UuX3Byb3h5KHRoaXMsIGkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1tpXSA9IG1heWJlUHJvbWlzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDMzNTU0NDMyKSAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICBpc1Jlc29sdmVkID0gdGhpcy5fcHJvbWlzZUZ1bGZpbGxlZChtYXliZVByb21pc2UuX3ZhbHVlKCksIGkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMTY3NzcyMTYpICE9PSAwKSkge1xuICAgICAgICAgICAgICAgIGlzUmVzb2x2ZWQgPSB0aGlzLl9wcm9taXNlUmVqZWN0ZWQobWF5YmVQcm9taXNlLl9yZWFzb24oKSwgaSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzUmVzb2x2ZWQgPSB0aGlzLl9wcm9taXNlQ2FuY2VsbGVkKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXNSZXNvbHZlZCA9IHRoaXMuX3Byb21pc2VGdWxmaWxsZWQobWF5YmVQcm9taXNlLCBpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzUmVzb2x2ZWQpIHJlc3VsdC5fc2V0QXN5bmNHdWFyYW50ZWVkKCk7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9pc1Jlc29sdmVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZXMgPT09IG51bGw7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5fdmFsdWVzID0gbnVsbDtcbiAgICB0aGlzLl9wcm9taXNlLl9mdWxmaWxsKHZhbHVlKTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX2NhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9pc1Jlc29sdmVkKCkgfHwgIXRoaXMuX3Byb21pc2UuX2lzQ2FuY2VsbGFibGUoKSkgcmV0dXJuO1xuICAgIHRoaXMuX3ZhbHVlcyA9IG51bGw7XG4gICAgdGhpcy5fcHJvbWlzZS5fY2FuY2VsKCk7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9yZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgdGhpcy5fdmFsdWVzID0gbnVsbDtcbiAgICB0aGlzLl9wcm9taXNlLl9yZWplY3RDYWxsYmFjayhyZWFzb24sIGZhbHNlKTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgdGhpcy5fdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgIHZhciB0b3RhbFJlc29sdmVkID0gKyt0aGlzLl90b3RhbFJlc29sdmVkO1xuICAgIGlmICh0b3RhbFJlc29sdmVkID49IHRoaXMuX2xlbmd0aCkge1xuICAgICAgICB0aGlzLl9yZXNvbHZlKHRoaXMuX3ZhbHVlcyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlQ2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY2FuY2VsKCk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlUmVqZWN0ZWQgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgdGhpcy5fdG90YWxSZXNvbHZlZCsrO1xuICAgIHRoaXMuX3JlamVjdChyZWFzb24pO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVzdWx0Q2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2lzUmVzb2x2ZWQoKSkgcmV0dXJuO1xuICAgIHZhciB2YWx1ZXMgPSB0aGlzLl92YWx1ZXM7XG4gICAgdGhpcy5fY2FuY2VsKCk7XG4gICAgaWYgKHZhbHVlcyBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgdmFsdWVzLmNhbmNlbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzW2ldIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlc1tpXS5jYW5jZWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuc2hvdWxkQ29weVZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuZ2V0QWN0dWFsTGVuZ3RoID0gZnVuY3Rpb24gKGxlbikge1xuICAgIHJldHVybiBsZW47XG59O1xuXG5yZXR1cm4gUHJvbWlzZUFycmF5O1xufTtcblxufSx7XCIuL3V0aWxcIjozNn1dLDI0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCkge1xudmFyIFRISVMgPSB7fTtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcbnZhciBub2RlYmFja0ZvclByb21pc2UgPSBfZGVyZXFfKFwiLi9ub2RlYmFja1wiKTtcbnZhciB3aXRoQXBwZW5kZWQgPSB1dGlsLndpdGhBcHBlbmRlZDtcbnZhciBtYXliZVdyYXBBc0Vycm9yID0gdXRpbC5tYXliZVdyYXBBc0Vycm9yO1xudmFyIGNhbkV2YWx1YXRlID0gdXRpbC5jYW5FdmFsdWF0ZTtcbnZhciBUeXBlRXJyb3IgPSBfZGVyZXFfKFwiLi9lcnJvcnNcIikuVHlwZUVycm9yO1xudmFyIGRlZmF1bHRTdWZmaXggPSBcIkFzeW5jXCI7XG52YXIgZGVmYXVsdFByb21pc2lmaWVkID0ge19faXNQcm9taXNpZmllZF9fOiB0cnVlfTtcbnZhciBub0NvcHlQcm9wcyA9IFtcbiAgICBcImFyaXR5XCIsICAgIFwibGVuZ3RoXCIsXG4gICAgXCJuYW1lXCIsXG4gICAgXCJhcmd1bWVudHNcIixcbiAgICBcImNhbGxlclwiLFxuICAgIFwiY2FsbGVlXCIsXG4gICAgXCJwcm90b3R5cGVcIixcbiAgICBcIl9faXNQcm9taXNpZmllZF9fXCJcbl07XG52YXIgbm9Db3B5UHJvcHNQYXR0ZXJuID0gbmV3IFJlZ0V4cChcIl4oPzpcIiArIG5vQ29weVByb3BzLmpvaW4oXCJ8XCIpICsgXCIpJFwiKTtcblxudmFyIGRlZmF1bHRGaWx0ZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHV0aWwuaXNJZGVudGlmaWVyKG5hbWUpICYmXG4gICAgICAgIG5hbWUuY2hhckF0KDApICE9PSBcIl9cIiAmJlxuICAgICAgICBuYW1lICE9PSBcImNvbnN0cnVjdG9yXCI7XG59O1xuXG5mdW5jdGlvbiBwcm9wc0ZpbHRlcihrZXkpIHtcbiAgICByZXR1cm4gIW5vQ29weVByb3BzUGF0dGVybi50ZXN0KGtleSk7XG59XG5cbmZ1bmN0aW9uIGlzUHJvbWlzaWZpZWQoZm4pIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZm4uX19pc1Byb21pc2lmaWVkX18gPT09IHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGhhc1Byb21pc2lmaWVkKG9iaiwga2V5LCBzdWZmaXgpIHtcbiAgICB2YXIgdmFsID0gdXRpbC5nZXREYXRhUHJvcGVydHlPckRlZmF1bHQob2JqLCBrZXkgKyBzdWZmaXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRQcm9taXNpZmllZCk7XG4gICAgcmV0dXJuIHZhbCA/IGlzUHJvbWlzaWZpZWQodmFsKSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gY2hlY2tWYWxpZChyZXQsIHN1ZmZpeCwgc3VmZml4UmVnZXhwKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgdmFyIGtleSA9IHJldFtpXTtcbiAgICAgICAgaWYgKHN1ZmZpeFJlZ2V4cC50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgIHZhciBrZXlXaXRob3V0QXN5bmNTdWZmaXggPSBrZXkucmVwbGFjZShzdWZmaXhSZWdleHAsIFwiXCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXQubGVuZ3RoOyBqICs9IDIpIHtcbiAgICAgICAgICAgICAgICBpZiAocmV0W2pdID09PSBrZXlXaXRob3V0QXN5bmNTdWZmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBwcm9taXNpZnkgYW4gQVBJIHRoYXQgaGFzIG5vcm1hbCBtZXRob2RzIHdpdGggJyVzJy1zdWZmaXhcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKFwiJXNcIiwgc3VmZml4KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwcm9taXNpZmlhYmxlTWV0aG9kcyhvYmosIHN1ZmZpeCwgc3VmZml4UmVnZXhwLCBmaWx0ZXIpIHtcbiAgICB2YXIga2V5cyA9IHV0aWwuaW5oZXJpdGVkRGF0YUtleXMob2JqKTtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgICAgdmFyIHBhc3Nlc0RlZmF1bHRGaWx0ZXIgPSBmaWx0ZXIgPT09IGRlZmF1bHRGaWx0ZXJcbiAgICAgICAgICAgID8gdHJ1ZSA6IGRlZmF1bHRGaWx0ZXIoa2V5LCB2YWx1ZSwgb2JqKTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAhaXNQcm9taXNpZmllZCh2YWx1ZSkgJiZcbiAgICAgICAgICAgICFoYXNQcm9taXNpZmllZChvYmosIGtleSwgc3VmZml4KSAmJlxuICAgICAgICAgICAgZmlsdGVyKGtleSwgdmFsdWUsIG9iaiwgcGFzc2VzRGVmYXVsdEZpbHRlcikpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrVmFsaWQocmV0LCBzdWZmaXgsIHN1ZmZpeFJlZ2V4cCk7XG4gICAgcmV0dXJuIHJldDtcbn1cblxudmFyIGVzY2FwZUlkZW50UmVnZXggPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbJF0pLywgXCJcXFxcJFwiKTtcbn07XG5cbnZhciBtYWtlTm9kZVByb21pc2lmaWVkRXZhbDtcbmlmICghdHJ1ZSkge1xudmFyIHN3aXRjaENhc2VBcmd1bWVudE9yZGVyID0gZnVuY3Rpb24obGlrZWx5QXJndW1lbnRDb3VudCkge1xuICAgIHZhciByZXQgPSBbbGlrZWx5QXJndW1lbnRDb3VudF07XG4gICAgdmFyIG1pbiA9IE1hdGgubWF4KDAsIGxpa2VseUFyZ3VtZW50Q291bnQgLSAxIC0gMyk7XG4gICAgZm9yKHZhciBpID0gbGlrZWx5QXJndW1lbnRDb3VudCAtIDE7IGkgPj0gbWluOyAtLWkpIHtcbiAgICAgICAgcmV0LnB1c2goaSk7XG4gICAgfVxuICAgIGZvcih2YXIgaSA9IGxpa2VseUFyZ3VtZW50Q291bnQgKyAxOyBpIDw9IDM7ICsraSkge1xuICAgICAgICByZXQucHVzaChpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbnZhciBhcmd1bWVudFNlcXVlbmNlID0gZnVuY3Rpb24oYXJndW1lbnRDb3VudCkge1xuICAgIHJldHVybiB1dGlsLmZpbGxlZFJhbmdlKGFyZ3VtZW50Q291bnQsIFwiX2FyZ1wiLCBcIlwiKTtcbn07XG5cbnZhciBwYXJhbWV0ZXJEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uKHBhcmFtZXRlckNvdW50KSB7XG4gICAgcmV0dXJuIHV0aWwuZmlsbGVkUmFuZ2UoXG4gICAgICAgIE1hdGgubWF4KHBhcmFtZXRlckNvdW50LCAzKSwgXCJfYXJnXCIsIFwiXCIpO1xufTtcblxudmFyIHBhcmFtZXRlckNvdW50ID0gZnVuY3Rpb24oZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4oZm4ubGVuZ3RoLCAxMDIzICsgMSksIDApO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn07XG5cbm1ha2VOb2RlUHJvbWlzaWZpZWRFdmFsID1cbmZ1bmN0aW9uKGNhbGxiYWNrLCByZWNlaXZlciwgb3JpZ2luYWxOYW1lLCBmbiwgXywgbXVsdGlBcmdzKSB7XG4gICAgdmFyIG5ld1BhcmFtZXRlckNvdW50ID0gTWF0aC5tYXgoMCwgcGFyYW1ldGVyQ291bnQoZm4pIC0gMSk7XG4gICAgdmFyIGFyZ3VtZW50T3JkZXIgPSBzd2l0Y2hDYXNlQXJndW1lbnRPcmRlcihuZXdQYXJhbWV0ZXJDb3VudCk7XG4gICAgdmFyIHNob3VsZFByb3h5VGhpcyA9IHR5cGVvZiBjYWxsYmFjayA9PT0gXCJzdHJpbmdcIiB8fCByZWNlaXZlciA9PT0gVEhJUztcblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlQ2FsbEZvckFyZ3VtZW50Q291bnQoY291bnQpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudFNlcXVlbmNlKGNvdW50KS5qb2luKFwiLCBcIik7XG4gICAgICAgIHZhciBjb21tYSA9IGNvdW50ID4gMCA/IFwiLCBcIiA6IFwiXCI7XG4gICAgICAgIHZhciByZXQ7XG4gICAgICAgIGlmIChzaG91bGRQcm94eVRoaXMpIHtcbiAgICAgICAgICAgIHJldCA9IFwicmV0ID0gY2FsbGJhY2suY2FsbCh0aGlzLCB7e2FyZ3N9fSwgbm9kZWJhY2spOyBicmVhaztcXG5cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldCA9IHJlY2VpdmVyID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IFwicmV0ID0gY2FsbGJhY2soe3thcmdzfX0sIG5vZGViYWNrKTsgYnJlYWs7XFxuXCJcbiAgICAgICAgICAgICAgICA6IFwicmV0ID0gY2FsbGJhY2suY2FsbChyZWNlaXZlciwge3thcmdzfX0sIG5vZGViYWNrKTsgYnJlYWs7XFxuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldC5yZXBsYWNlKFwie3thcmdzfX1cIiwgYXJncykucmVwbGFjZShcIiwgXCIsIGNvbW1hKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUFyZ3VtZW50U3dpdGNoQ2FzZSgpIHtcbiAgICAgICAgdmFyIHJldCA9IFwiXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRPcmRlci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmV0ICs9IFwiY2FzZSBcIiArIGFyZ3VtZW50T3JkZXJbaV0gK1wiOlwiICtcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZUNhbGxGb3JBcmd1bWVudENvdW50KGFyZ3VtZW50T3JkZXJbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0ICs9IFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIGRlZmF1bHQ6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4gKyAxKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB2YXIgaSA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBhcmdzW2ldID0gbm9kZWJhY2s7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBbQ29kZUZvckNhbGxdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBicmVhazsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIFwiLnJlcGxhY2UoXCJbQ29kZUZvckNhbGxdXCIsIChzaG91bGRQcm94eVRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcInJldCA9IGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpO1xcblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJyZXQgPSBjYWxsYmFjay5hcHBseShyZWNlaXZlciwgYXJncyk7XFxuXCIpKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICB2YXIgZ2V0RnVuY3Rpb25Db2RlID0gdHlwZW9mIGNhbGxiYWNrID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKFwidGhpcyAhPSBudWxsID8gdGhpc1snXCIrY2FsbGJhY2srXCInXSA6IGZuXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJmblwiO1xuICAgIHZhciBib2R5ID0gXCIndXNlIHN0cmljdCc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgdmFyIHJldCA9IGZ1bmN0aW9uIChQYXJhbWV0ZXJzKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoSU5URVJOQUwpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHByb21pc2UuX2NhcHR1cmVTdGFja1RyYWNlKCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHZhciBub2RlYmFjayA9IG5vZGViYWNrRm9yUHJvbWlzZShwcm9taXNlLCBcIiArIG11bHRpQXJncyArIFwiKTsgICBcXG5cXFxuICAgICAgICAgICAgdmFyIHJldDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gdHJ5Q2F0Y2goW0dldEZ1bmN0aW9uQ29kZV0pOyAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgc3dpdGNoKGxlbikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIFtDb2RlRm9yU3dpdGNoQ2FzZV0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKG1heWJlV3JhcEFzRXJyb3IocmV0LmUpLCB0cnVlLCB0cnVlKTtcXG5cXFxuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgaWYgKCFwcm9taXNlLl9pc0ZhdGVTZWFsZWQoKSkgcHJvbWlzZS5fc2V0QXN5bmNHdWFyYW50ZWVkKCk7ICAgICBcXG5cXFxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICB9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICBub3RFbnVtZXJhYmxlUHJvcChyZXQsICdfX2lzUHJvbWlzaWZpZWRfXycsIHRydWUpOyAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICByZXR1cm4gcmV0OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgIFwiLnJlcGxhY2UoXCJbQ29kZUZvclN3aXRjaENhc2VdXCIsIGdlbmVyYXRlQXJndW1lbnRTd2l0Y2hDYXNlKCkpXG4gICAgICAgIC5yZXBsYWNlKFwiW0dldEZ1bmN0aW9uQ29kZV1cIiwgZ2V0RnVuY3Rpb25Db2RlKTtcbiAgICBib2R5ID0gYm9keS5yZXBsYWNlKFwiUGFyYW1ldGVyc1wiLCBwYXJhbWV0ZXJEZWNsYXJhdGlvbihuZXdQYXJhbWV0ZXJDb3VudCkpO1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJQcm9taXNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImZuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInJlY2VpdmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIndpdGhBcHBlbmRlZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXliZVdyYXBBc0Vycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm5vZGViYWNrRm9yUHJvbWlzZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0cnlDYXRjaFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJlcnJvck9ialwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJub3RFbnVtZXJhYmxlUHJvcFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJJTlRFUk5BTFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSkoXG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgIGZuLFxuICAgICAgICAgICAgICAgICAgICByZWNlaXZlcixcbiAgICAgICAgICAgICAgICAgICAgd2l0aEFwcGVuZGVkLFxuICAgICAgICAgICAgICAgICAgICBtYXliZVdyYXBBc0Vycm9yLFxuICAgICAgICAgICAgICAgICAgICBub2RlYmFja0ZvclByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgIHV0aWwudHJ5Q2F0Y2gsXG4gICAgICAgICAgICAgICAgICAgIHV0aWwuZXJyb3JPYmosXG4gICAgICAgICAgICAgICAgICAgIHV0aWwubm90RW51bWVyYWJsZVByb3AsXG4gICAgICAgICAgICAgICAgICAgIElOVEVSTkFMKTtcbn07XG59XG5cbmZ1bmN0aW9uIG1ha2VOb2RlUHJvbWlzaWZpZWRDbG9zdXJlKGNhbGxiYWNrLCByZWNlaXZlciwgXywgZm4sIF9fLCBtdWx0aUFyZ3MpIHtcbiAgICB2YXIgZGVmYXVsdFRoaXMgPSAoZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXM7fSkoKTtcbiAgICB2YXIgbWV0aG9kID0gY2FsbGJhY2s7XG4gICAgaWYgKHR5cGVvZiBtZXRob2QgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBmbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvbWlzaWZpZWQoKSB7XG4gICAgICAgIHZhciBfcmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgaWYgKHJlY2VpdmVyID09PSBUSElTKSBfcmVjZWl2ZXIgPSB0aGlzO1xuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgcHJvbWlzZS5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICAgICAgdmFyIGNiID0gdHlwZW9mIG1ldGhvZCA9PT0gXCJzdHJpbmdcIiAmJiB0aGlzICE9PSBkZWZhdWx0VGhpc1xuICAgICAgICAgICAgPyB0aGlzW21ldGhvZF0gOiBjYWxsYmFjaztcbiAgICAgICAgdmFyIGZuID0gbm9kZWJhY2tGb3JQcm9taXNlKHByb21pc2UsIG11bHRpQXJncyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjYi5hcHBseShfcmVjZWl2ZXIsIHdpdGhBcHBlbmRlZChhcmd1bWVudHMsIGZuKSk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2sobWF5YmVXcmFwQXNFcnJvcihlKSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcm9taXNlLl9pc0ZhdGVTZWFsZWQoKSkgcHJvbWlzZS5fc2V0QXN5bmNHdWFyYW50ZWVkKCk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICB1dGlsLm5vdEVudW1lcmFibGVQcm9wKHByb21pc2lmaWVkLCBcIl9faXNQcm9taXNpZmllZF9fXCIsIHRydWUpO1xuICAgIHJldHVybiBwcm9taXNpZmllZDtcbn1cblxudmFyIG1ha2VOb2RlUHJvbWlzaWZpZWQgPSBjYW5FdmFsdWF0ZVxuICAgID8gbWFrZU5vZGVQcm9taXNpZmllZEV2YWxcbiAgICA6IG1ha2VOb2RlUHJvbWlzaWZpZWRDbG9zdXJlO1xuXG5mdW5jdGlvbiBwcm9taXNpZnlBbGwob2JqLCBzdWZmaXgsIGZpbHRlciwgcHJvbWlzaWZpZXIsIG11bHRpQXJncykge1xuICAgIHZhciBzdWZmaXhSZWdleHAgPSBuZXcgUmVnRXhwKGVzY2FwZUlkZW50UmVnZXgoc3VmZml4KSArIFwiJFwiKTtcbiAgICB2YXIgbWV0aG9kcyA9XG4gICAgICAgIHByb21pc2lmaWFibGVNZXRob2RzKG9iaiwgc3VmZml4LCBzdWZmaXhSZWdleHAsIGZpbHRlcik7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbWV0aG9kcy5sZW5ndGg7IGkgPCBsZW47IGkrPSAyKSB7XG4gICAgICAgIHZhciBrZXkgPSBtZXRob2RzW2ldO1xuICAgICAgICB2YXIgZm4gPSBtZXRob2RzW2krMV07XG4gICAgICAgIHZhciBwcm9taXNpZmllZEtleSA9IGtleSArIHN1ZmZpeDtcbiAgICAgICAgaWYgKHByb21pc2lmaWVyID09PSBtYWtlTm9kZVByb21pc2lmaWVkKSB7XG4gICAgICAgICAgICBvYmpbcHJvbWlzaWZpZWRLZXldID1cbiAgICAgICAgICAgICAgICBtYWtlTm9kZVByb21pc2lmaWVkKGtleSwgVEhJUywga2V5LCBmbiwgc3VmZml4LCBtdWx0aUFyZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHByb21pc2lmaWVkID0gcHJvbWlzaWZpZXIoZm4sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlTm9kZVByb21pc2lmaWVkKGtleSwgVEhJUywga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuLCBzdWZmaXgsIG11bHRpQXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHV0aWwubm90RW51bWVyYWJsZVByb3AocHJvbWlzaWZpZWQsIFwiX19pc1Byb21pc2lmaWVkX19cIiwgdHJ1ZSk7XG4gICAgICAgICAgICBvYmpbcHJvbWlzaWZpZWRLZXldID0gcHJvbWlzaWZpZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXRpbC50b0Zhc3RQcm9wZXJ0aWVzKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gcHJvbWlzaWZ5KGNhbGxiYWNrLCByZWNlaXZlciwgbXVsdGlBcmdzKSB7XG4gICAgcmV0dXJuIG1ha2VOb2RlUHJvbWlzaWZpZWQoY2FsbGJhY2ssIHJlY2VpdmVyLCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLCBudWxsLCBtdWx0aUFyZ3MpO1xufVxuXG5Qcm9taXNlLnByb21pc2lmeSA9IGZ1bmN0aW9uIChmbiwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZm4pKTtcbiAgICB9XG4gICAgaWYgKGlzUHJvbWlzaWZpZWQoZm4pKSB7XG4gICAgICAgIHJldHVybiBmbjtcbiAgICB9XG4gICAgb3B0aW9ucyA9IE9iamVjdChvcHRpb25zKTtcbiAgICB2YXIgcmVjZWl2ZXIgPSBvcHRpb25zLmNvbnRleHQgPT09IHVuZGVmaW5lZCA/IFRISVMgOiBvcHRpb25zLmNvbnRleHQ7XG4gICAgdmFyIG11bHRpQXJncyA9ICEhb3B0aW9ucy5tdWx0aUFyZ3M7XG4gICAgdmFyIHJldCA9IHByb21pc2lmeShmbiwgcmVjZWl2ZXIsIG11bHRpQXJncyk7XG4gICAgdXRpbC5jb3B5RGVzY3JpcHRvcnMoZm4sIHJldCwgcHJvcHNGaWx0ZXIpO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnByb21pc2lmeUFsbCA9IGZ1bmN0aW9uICh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInRoZSB0YXJnZXQgb2YgcHJvbWlzaWZ5QWxsIG11c3QgYmUgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb25cXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xuICAgIH1cbiAgICBvcHRpb25zID0gT2JqZWN0KG9wdGlvbnMpO1xuICAgIHZhciBtdWx0aUFyZ3MgPSAhIW9wdGlvbnMubXVsdGlBcmdzO1xuICAgIHZhciBzdWZmaXggPSBvcHRpb25zLnN1ZmZpeDtcbiAgICBpZiAodHlwZW9mIHN1ZmZpeCAhPT0gXCJzdHJpbmdcIikgc3VmZml4ID0gZGVmYXVsdFN1ZmZpeDtcbiAgICB2YXIgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gICAgaWYgKHR5cGVvZiBmaWx0ZXIgIT09IFwiZnVuY3Rpb25cIikgZmlsdGVyID0gZGVmYXVsdEZpbHRlcjtcbiAgICB2YXIgcHJvbWlzaWZpZXIgPSBvcHRpb25zLnByb21pc2lmaWVyO1xuICAgIGlmICh0eXBlb2YgcHJvbWlzaWZpZXIgIT09IFwiZnVuY3Rpb25cIikgcHJvbWlzaWZpZXIgPSBtYWtlTm9kZVByb21pc2lmaWVkO1xuXG4gICAgaWYgKCF1dGlsLmlzSWRlbnRpZmllcihzdWZmaXgpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwic3VmZml4IG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IHV0aWwuaW5oZXJpdGVkRGF0YUtleXModGFyZ2V0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGFyZ2V0W2tleXNbaV1dO1xuICAgICAgICBpZiAoa2V5c1tpXSAhPT0gXCJjb25zdHJ1Y3RvclwiICYmXG4gICAgICAgICAgICB1dGlsLmlzQ2xhc3ModmFsdWUpKSB7XG4gICAgICAgICAgICBwcm9taXNpZnlBbGwodmFsdWUucHJvdG90eXBlLCBzdWZmaXgsIGZpbHRlciwgcHJvbWlzaWZpZXIsXG4gICAgICAgICAgICAgICAgbXVsdGlBcmdzKTtcbiAgICAgICAgICAgIHByb21pc2lmeUFsbCh2YWx1ZSwgc3VmZml4LCBmaWx0ZXIsIHByb21pc2lmaWVyLCBtdWx0aUFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2lmeUFsbCh0YXJnZXQsIHN1ZmZpeCwgZmlsdGVyLCBwcm9taXNpZmllciwgbXVsdGlBcmdzKTtcbn07XG59O1xuXG5cbn0se1wiLi9lcnJvcnNcIjoxMixcIi4vbm9kZWJhY2tcIjoyMCxcIi4vdXRpbFwiOjM2fV0sMjU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFxuICAgIFByb21pc2UsIFByb21pc2VBcnJheSwgdHJ5Q29udmVydFRvUHJvbWlzZSwgYXBpUmVqZWN0aW9uKSB7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG52YXIgaXNPYmplY3QgPSB1dGlsLmlzT2JqZWN0O1xudmFyIGVzNSA9IF9kZXJlcV8oXCIuL2VzNVwiKTtcbnZhciBFczZNYXA7XG5pZiAodHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiKSBFczZNYXAgPSBNYXA7XG5cbnZhciBtYXBUb0VudHJpZXMgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgc2l6ZSA9IDA7XG5cbiAgICBmdW5jdGlvbiBleHRyYWN0RW50cnkodmFsdWUsIGtleSkge1xuICAgICAgICB0aGlzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICB0aGlzW2luZGV4ICsgc2l6ZV0gPSBrZXk7XG4gICAgICAgIGluZGV4Kys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1hcFRvRW50cmllcyhtYXApIHtcbiAgICAgICAgc2l6ZSA9IG1hcC5zaXplO1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIHZhciByZXQgPSBuZXcgQXJyYXkobWFwLnNpemUgKiAyKTtcbiAgICAgICAgbWFwLmZvckVhY2goZXh0cmFjdEVudHJ5LCByZXQpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG59KSgpO1xuXG52YXIgZW50cmllc1RvTWFwID0gZnVuY3Rpb24oZW50cmllcykge1xuICAgIHZhciByZXQgPSBuZXcgRXM2TWFwKCk7XG4gICAgdmFyIGxlbmd0aCA9IGVudHJpZXMubGVuZ3RoIC8gMiB8IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0gZW50cmllc1tsZW5ndGggKyBpXTtcbiAgICAgICAgdmFyIHZhbHVlID0gZW50cmllc1tpXTtcbiAgICAgICAgcmV0LnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIFByb3BlcnRpZXNQcm9taXNlQXJyYXkob2JqKSB7XG4gICAgdmFyIGlzTWFwID0gZmFsc2U7XG4gICAgdmFyIGVudHJpZXM7XG4gICAgaWYgKEVzNk1hcCAhPT0gdW5kZWZpbmVkICYmIG9iaiBpbnN0YW5jZW9mIEVzNk1hcCkge1xuICAgICAgICBlbnRyaWVzID0gbWFwVG9FbnRyaWVzKG9iaik7XG4gICAgICAgIGlzTWFwID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIga2V5cyA9IGVzNS5rZXlzKG9iaik7XG4gICAgICAgIHZhciBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgZW50cmllcyA9IG5ldyBBcnJheShsZW4gKiAyKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBlbnRyaWVzW2ldID0gb2JqW2tleV07XG4gICAgICAgICAgICBlbnRyaWVzW2kgKyBsZW5dID0ga2V5O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuY29uc3RydWN0b3IkKGVudHJpZXMpO1xuICAgIHRoaXMuX2lzTWFwID0gaXNNYXA7XG4gICAgdGhpcy5faW5pdCQodW5kZWZpbmVkLCBpc01hcCA/IC02IDogLTMpO1xufVxudXRpbC5pbmhlcml0cyhQcm9wZXJ0aWVzUHJvbWlzZUFycmF5LCBQcm9taXNlQXJyYXkpO1xuXG5Qcm9wZXJ0aWVzUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHt9O1xuXG5Qcm9wZXJ0aWVzUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZUZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICB0aGlzLl92YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgdmFyIHRvdGFsUmVzb2x2ZWQgPSArK3RoaXMuX3RvdGFsUmVzb2x2ZWQ7XG4gICAgaWYgKHRvdGFsUmVzb2x2ZWQgPj0gdGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWw7XG4gICAgICAgIGlmICh0aGlzLl9pc01hcCkge1xuICAgICAgICAgICAgdmFsID0gZW50cmllc1RvTWFwKHRoaXMuX3ZhbHVlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWwgPSB7fTtcbiAgICAgICAgICAgIHZhciBrZXlPZmZzZXQgPSB0aGlzLmxlbmd0aCgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMubGVuZ3RoKCk7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgIHZhbFt0aGlzLl92YWx1ZXNbaSArIGtleU9mZnNldF1dID0gdGhpcy5fdmFsdWVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jlc29sdmUodmFsKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblByb3BlcnRpZXNQcm9taXNlQXJyYXkucHJvdG90eXBlLnNob3VsZENvcHlWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuUHJvcGVydGllc1Byb21pc2VBcnJheS5wcm90b3R5cGUuZ2V0QWN0dWFsTGVuZ3RoID0gZnVuY3Rpb24gKGxlbikge1xuICAgIHJldHVybiBsZW4gPj4gMTtcbn07XG5cbmZ1bmN0aW9uIHByb3BzKHByb21pc2VzKSB7XG4gICAgdmFyIHJldDtcbiAgICB2YXIgY2FzdFZhbHVlID0gdHJ5Q29udmVydFRvUHJvbWlzZShwcm9taXNlcyk7XG5cbiAgICBpZiAoIWlzT2JqZWN0KGNhc3RWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImNhbm5vdCBhd2FpdCBwcm9wZXJ0aWVzIG9mIGEgbm9uLW9iamVjdFxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG4gICAgfSBlbHNlIGlmIChjYXN0VmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHJldCA9IGNhc3RWYWx1ZS5fdGhlbihcbiAgICAgICAgICAgIFByb21pc2UucHJvcHMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gbmV3IFByb3BlcnRpZXNQcm9taXNlQXJyYXkoY2FzdFZhbHVlKS5wcm9taXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKGNhc3RWYWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0Ll9wcm9wYWdhdGVGcm9tKGNhc3RWYWx1ZSwgMik7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cblByb21pc2UucHJvdG90eXBlLnByb3BzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwcm9wcyh0aGlzKTtcbn07XG5cblByb21pc2UucHJvcHMgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gcHJvcHMocHJvbWlzZXMpO1xufTtcbn07XG5cbn0se1wiLi9lczVcIjoxMyxcIi4vdXRpbFwiOjM2fV0sMjY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBhcnJheU1vdmUoc3JjLCBzcmNJbmRleCwgZHN0LCBkc3RJbmRleCwgbGVuKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW47ICsraikge1xuICAgICAgICBkc3RbaiArIGRzdEluZGV4XSA9IHNyY1tqICsgc3JjSW5kZXhdO1xuICAgICAgICBzcmNbaiArIHNyY0luZGV4XSA9IHZvaWQgMDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIFF1ZXVlKGNhcGFjaXR5KSB7XG4gICAgdGhpcy5fY2FwYWNpdHkgPSBjYXBhY2l0eTtcbiAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgIHRoaXMuX2Zyb250ID0gMDtcbn1cblxuUXVldWUucHJvdG90eXBlLl93aWxsQmVPdmVyQ2FwYWNpdHkgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgIHJldHVybiB0aGlzLl9jYXBhY2l0eSA8IHNpemU7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUuX3B1c2hPbmUgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG4gICAgdGhpcy5fY2hlY2tDYXBhY2l0eShsZW5ndGggKyAxKTtcbiAgICB2YXIgaSA9ICh0aGlzLl9mcm9udCArIGxlbmd0aCkgJiAodGhpcy5fY2FwYWNpdHkgLSAxKTtcbiAgICB0aGlzW2ldID0gYXJnO1xuICAgIHRoaXMuX2xlbmd0aCA9IGxlbmd0aCArIDE7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChmbiwgcmVjZWl2ZXIsIGFyZykge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpICsgMztcbiAgICBpZiAodGhpcy5fd2lsbEJlT3ZlckNhcGFjaXR5KGxlbmd0aCkpIHtcbiAgICAgICAgdGhpcy5fcHVzaE9uZShmbik7XG4gICAgICAgIHRoaXMuX3B1c2hPbmUocmVjZWl2ZXIpO1xuICAgICAgICB0aGlzLl9wdXNoT25lKGFyZyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGogPSB0aGlzLl9mcm9udCArIGxlbmd0aCAtIDM7XG4gICAgdGhpcy5fY2hlY2tDYXBhY2l0eShsZW5ndGgpO1xuICAgIHZhciB3cmFwTWFzayA9IHRoaXMuX2NhcGFjaXR5IC0gMTtcbiAgICB0aGlzWyhqICsgMCkgJiB3cmFwTWFza10gPSBmbjtcbiAgICB0aGlzWyhqICsgMSkgJiB3cmFwTWFza10gPSByZWNlaXZlcjtcbiAgICB0aGlzWyhqICsgMikgJiB3cmFwTWFza10gPSBhcmc7XG4gICAgdGhpcy5fbGVuZ3RoID0gbGVuZ3RoO1xufTtcblxuUXVldWUucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmcm9udCA9IHRoaXMuX2Zyb250LFxuICAgICAgICByZXQgPSB0aGlzW2Zyb250XTtcblxuICAgIHRoaXNbZnJvbnRdID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2Zyb250ID0gKGZyb250ICsgMSkgJiAodGhpcy5fY2FwYWNpdHkgLSAxKTtcbiAgICB0aGlzLl9sZW5ndGgtLTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUXVldWUucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGVuZ3RoO1xufTtcblxuUXVldWUucHJvdG90eXBlLl9jaGVja0NhcGFjaXR5ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICBpZiAodGhpcy5fY2FwYWNpdHkgPCBzaXplKSB7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZVRvKHRoaXMuX2NhcGFjaXR5IDw8IDEpO1xuICAgIH1cbn07XG5cblF1ZXVlLnByb3RvdHlwZS5fcmVzaXplVG8gPSBmdW5jdGlvbiAoY2FwYWNpdHkpIHtcbiAgICB2YXIgb2xkQ2FwYWNpdHkgPSB0aGlzLl9jYXBhY2l0eTtcbiAgICB0aGlzLl9jYXBhY2l0eSA9IGNhcGFjaXR5O1xuICAgIHZhciBmcm9udCA9IHRoaXMuX2Zyb250O1xuICAgIHZhciBsZW5ndGggPSB0aGlzLl9sZW5ndGg7XG4gICAgdmFyIG1vdmVJdGVtc0NvdW50ID0gKGZyb250ICsgbGVuZ3RoKSAmIChvbGRDYXBhY2l0eSAtIDEpO1xuICAgIGFycmF5TW92ZSh0aGlzLCAwLCB0aGlzLCBvbGRDYXBhY2l0eSwgbW92ZUl0ZW1zQ291bnQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBRdWV1ZTtcblxufSx7fV0sMjc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFxuICAgIFByb21pc2UsIElOVEVSTkFMLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBhcGlSZWplY3Rpb24pIHtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcblxudmFyIHJhY2VMYXRlciA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbihhcnJheSkge1xuICAgICAgICByZXR1cm4gcmFjZShhcnJheSwgcHJvbWlzZSk7XG4gICAgfSk7XG59O1xuXG5mdW5jdGlvbiByYWNlKHByb21pc2VzLCBwYXJlbnQpIHtcbiAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZShwcm9taXNlcyk7XG5cbiAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gcmFjZUxhdGVyKG1heWJlUHJvbWlzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZXMgPSB1dGlsLmFzQXJyYXkocHJvbWlzZXMpO1xuICAgICAgICBpZiAocHJvbWlzZXMgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZXhwZWN0aW5nIGFuIGFycmF5IG9yIGFuIGl0ZXJhYmxlIG9iamVjdCBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhwcm9taXNlcykpO1xuICAgIH1cblxuICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgaWYgKHBhcmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldC5fcHJvcGFnYXRlRnJvbShwYXJlbnQsIDMpO1xuICAgIH1cbiAgICB2YXIgZnVsZmlsbCA9IHJldC5fZnVsZmlsbDtcbiAgICB2YXIgcmVqZWN0ID0gcmV0Ll9yZWplY3Q7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHByb21pc2VzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHZhciB2YWwgPSBwcm9taXNlc1tpXTtcblxuICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQgJiYgIShpIGluIHByb21pc2VzKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBQcm9taXNlLmNhc3QodmFsKS5fdGhlbihmdWxmaWxsLCByZWplY3QsIHVuZGVmaW5lZCwgcmV0LCBudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuUHJvbWlzZS5yYWNlID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgcmV0dXJuIHJhY2UocHJvbWlzZXMsIHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5yYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByYWNlKHRoaXMsIHVuZGVmaW5lZCk7XG59O1xuXG59O1xuXG59LHtcIi4vdXRpbFwiOjM2fV0sMjg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2VBcnJheSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpUmVqZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0cnlDb252ZXJ0VG9Qcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBJTlRFUk5BTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcpIHtcbnZhciBnZXREb21haW4gPSBQcm9taXNlLl9nZXREb21haW47XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xuXG5mdW5jdGlvbiBSZWR1Y3Rpb25Qcm9taXNlQXJyYXkocHJvbWlzZXMsIGZuLCBpbml0aWFsVmFsdWUsIF9lYWNoKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciQocHJvbWlzZXMpO1xuICAgIHZhciBkb21haW4gPSBnZXREb21haW4oKTtcbiAgICB0aGlzLl9mbiA9IGRvbWFpbiA9PT0gbnVsbCA/IGZuIDogdXRpbC5kb21haW5CaW5kKGRvbWFpbiwgZm4pO1xuICAgIGlmIChpbml0aWFsVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpbml0aWFsVmFsdWUgPSBQcm9taXNlLnJlc29sdmUoaW5pdGlhbFZhbHVlKTtcbiAgICAgICAgaW5pdGlhbFZhbHVlLl9hdHRhY2hDYW5jZWxsYXRpb25DYWxsYmFjayh0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5faW5pdGlhbFZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgIHRoaXMuX2N1cnJlbnRDYW5jZWxsYWJsZSA9IG51bGw7XG4gICAgaWYoX2VhY2ggPT09IElOVEVSTkFMKSB7XG4gICAgICAgIHRoaXMuX2VhY2hWYWx1ZXMgPSBBcnJheSh0aGlzLl9sZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAoX2VhY2ggPT09IDApIHtcbiAgICAgICAgdGhpcy5fZWFjaFZhbHVlcyA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZWFjaFZhbHVlcyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdGhpcy5fcHJvbWlzZS5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICB0aGlzLl9pbml0JCh1bmRlZmluZWQsIC01KTtcbn1cbnV0aWwuaW5oZXJpdHMoUmVkdWN0aW9uUHJvbWlzZUFycmF5LCBQcm9taXNlQXJyYXkpO1xuXG5SZWR1Y3Rpb25Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9nb3RBY2N1bSA9IGZ1bmN0aW9uKGFjY3VtKSB7XG4gICAgaWYgKHRoaXMuX2VhY2hWYWx1ZXMgIT09IHVuZGVmaW5lZCAmJiBcbiAgICAgICAgdGhpcy5fZWFjaFZhbHVlcyAhPT0gbnVsbCAmJiBcbiAgICAgICAgYWNjdW0gIT09IElOVEVSTkFMKSB7XG4gICAgICAgIHRoaXMuX2VhY2hWYWx1ZXMucHVzaChhY2N1bSk7XG4gICAgfVxufTtcblxuUmVkdWN0aW9uUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fZWFjaENvbXBsZXRlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodGhpcy5fZWFjaFZhbHVlcyAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9lYWNoVmFsdWVzLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZWFjaFZhbHVlcztcbn07XG5cblJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbigpIHt9O1xuXG5SZWR1Y3Rpb25Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9yZXNvbHZlRW1wdHlBcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3Jlc29sdmUodGhpcy5fZWFjaFZhbHVlcyAhPT0gdW5kZWZpbmVkID8gdGhpcy5fZWFjaFZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5faW5pdGlhbFZhbHVlKTtcbn07XG5cblJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuc2hvdWxkQ29weVZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5SZWR1Y3Rpb25Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9yZXNvbHZlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB0aGlzLl9wcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2sodmFsdWUpO1xuICAgIHRoaXMuX3ZhbHVlcyA9IG51bGw7XG59O1xuXG5SZWR1Y3Rpb25Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9yZXN1bHRDYW5jZWxsZWQgPSBmdW5jdGlvbihzZW5kZXIpIHtcbiAgICBpZiAoc2VuZGVyID09PSB0aGlzLl9pbml0aWFsVmFsdWUpIHJldHVybiB0aGlzLl9jYW5jZWwoKTtcbiAgICBpZiAodGhpcy5faXNSZXNvbHZlZCgpKSByZXR1cm47XG4gICAgdGhpcy5fcmVzdWx0Q2FuY2VsbGVkJCgpO1xuICAgIGlmICh0aGlzLl9jdXJyZW50Q2FuY2VsbGFibGUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRDYW5jZWxsYWJsZS5jYW5jZWwoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2luaXRpYWxWYWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgdGhpcy5faW5pdGlhbFZhbHVlLmNhbmNlbCgpO1xuICAgIH1cbn07XG5cblJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuX2l0ZXJhdGUgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgdGhpcy5fdmFsdWVzID0gdmFsdWVzO1xuICAgIHZhciB2YWx1ZTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcbiAgICBpZiAodGhpcy5faW5pdGlhbFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLl9pbml0aWFsVmFsdWU7XG4gICAgICAgIGkgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gUHJvbWlzZS5yZXNvbHZlKHZhbHVlc1swXSk7XG4gICAgICAgIGkgPSAxO1xuICAgIH1cblxuICAgIHRoaXMuX2N1cnJlbnRDYW5jZWxsYWJsZSA9IHZhbHVlO1xuXG4gICAgaWYgKCF2YWx1ZS5pc1JlamVjdGVkKCkpIHtcbiAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGN0eCA9IHtcbiAgICAgICAgICAgICAgICBhY2N1bTogbnVsbCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVzW2ldLFxuICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgICAgICAgICAgICAgIGFycmF5OiB0aGlzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5fdGhlbihnb3RBY2N1bSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGN0eCwgdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9lYWNoVmFsdWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZVxuICAgICAgICAgICAgLl90aGVuKHRoaXMuX2VhY2hDb21wbGV0ZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRoaXMsIHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHZhbHVlLl90aGVuKGNvbXBsZXRlZCwgY29tcGxldGVkLCB1bmRlZmluZWQsIHZhbHVlLCB0aGlzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uIChmbiwgaW5pdGlhbFZhbHVlKSB7XG4gICAgcmV0dXJuIHJlZHVjZSh0aGlzLCBmbiwgaW5pdGlhbFZhbHVlLCBudWxsKTtcbn07XG5cblByb21pc2UucmVkdWNlID0gZnVuY3Rpb24gKHByb21pc2VzLCBmbiwgaW5pdGlhbFZhbHVlLCBfZWFjaCkge1xuICAgIHJldHVybiByZWR1Y2UocHJvbWlzZXMsIGZuLCBpbml0aWFsVmFsdWUsIF9lYWNoKTtcbn07XG5cbmZ1bmN0aW9uIGNvbXBsZXRlZCh2YWx1ZU9yUmVhc29uLCBhcnJheSkge1xuICAgIGlmICh0aGlzLmlzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgYXJyYXkuX3Jlc29sdmUodmFsdWVPclJlYXNvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXkuX3JlamVjdCh2YWx1ZU9yUmVhc29uKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlZHVjZShwcm9taXNlcywgZm4sIGluaXRpYWxWYWx1ZSwgX2VhY2gpIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGZuKSk7XG4gICAgfVxuICAgIHZhciBhcnJheSA9IG5ldyBSZWR1Y3Rpb25Qcm9taXNlQXJyYXkocHJvbWlzZXMsIGZuLCBpbml0aWFsVmFsdWUsIF9lYWNoKTtcbiAgICByZXR1cm4gYXJyYXkucHJvbWlzZSgpO1xufVxuXG5mdW5jdGlvbiBnb3RBY2N1bShhY2N1bSkge1xuICAgIHRoaXMuYWNjdW0gPSBhY2N1bTtcbiAgICB0aGlzLmFycmF5Ll9nb3RBY2N1bShhY2N1bSk7XG4gICAgdmFyIHZhbHVlID0gdHJ5Q29udmVydFRvUHJvbWlzZSh0aGlzLnZhbHVlLCB0aGlzLmFycmF5Ll9wcm9taXNlKTtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHRoaXMuYXJyYXkuX2N1cnJlbnRDYW5jZWxsYWJsZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdmFsdWUuX3RoZW4oZ290VmFsdWUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0aGlzLCB1bmRlZmluZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBnb3RWYWx1ZS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdvdFZhbHVlKHZhbHVlKSB7XG4gICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheTtcbiAgICB2YXIgcHJvbWlzZSA9IGFycmF5Ll9wcm9taXNlO1xuICAgIHZhciBmbiA9IHRyeUNhdGNoKGFycmF5Ll9mbik7XG4gICAgcHJvbWlzZS5fcHVzaENvbnRleHQoKTtcbiAgICB2YXIgcmV0O1xuICAgIGlmIChhcnJheS5fZWFjaFZhbHVlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldCA9IGZuLmNhbGwocHJvbWlzZS5fYm91bmRWYWx1ZSgpLCB2YWx1ZSwgdGhpcy5pbmRleCwgdGhpcy5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGZuLmNhbGwocHJvbWlzZS5fYm91bmRWYWx1ZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY2N1bSwgdmFsdWUsIHRoaXMuaW5kZXgsIHRoaXMubGVuZ3RoKTtcbiAgICB9XG4gICAgaWYgKHJldCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgYXJyYXkuX2N1cnJlbnRDYW5jZWxsYWJsZSA9IHJldDtcbiAgICB9XG4gICAgdmFyIHByb21pc2VDcmVhdGVkID0gcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgIGRlYnVnLmNoZWNrRm9yZ290dGVuUmV0dXJucyhcbiAgICAgICAgcmV0LFxuICAgICAgICBwcm9taXNlQ3JlYXRlZCxcbiAgICAgICAgYXJyYXkuX2VhY2hWYWx1ZXMgIT09IHVuZGVmaW5lZCA/IFwiUHJvbWlzZS5lYWNoXCIgOiBcIlByb21pc2UucmVkdWNlXCIsXG4gICAgICAgIHByb21pc2VcbiAgICApO1xuICAgIHJldHVybiByZXQ7XG59XG59O1xuXG59LHtcIi4vdXRpbFwiOjM2fV0sMjk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG52YXIgc2NoZWR1bGU7XG52YXIgbm9Bc3luY1NjaGVkdWxlciA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGFzeW5jIHNjaGVkdWxlciBhdmFpbGFibGVcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xufTtcbnZhciBOYXRpdmVQcm9taXNlID0gdXRpbC5nZXROYXRpdmVQcm9taXNlKCk7XG5pZiAodXRpbC5pc05vZGUgJiYgdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YXIgR2xvYmFsU2V0SW1tZWRpYXRlID0gZ2xvYmFsLnNldEltbWVkaWF0ZTtcbiAgICB2YXIgUHJvY2Vzc05leHRUaWNrID0gcHJvY2Vzcy5uZXh0VGljaztcbiAgICBzY2hlZHVsZSA9IHV0aWwuaXNSZWNlbnROb2RlXG4gICAgICAgICAgICAgICAgPyBmdW5jdGlvbihmbikgeyBHbG9iYWxTZXRJbW1lZGlhdGUuY2FsbChnbG9iYWwsIGZuKTsgfVxuICAgICAgICAgICAgICAgIDogZnVuY3Rpb24oZm4pIHsgUHJvY2Vzc05leHRUaWNrLmNhbGwocHJvY2VzcywgZm4pOyB9O1xufSBlbHNlIGlmICh0eXBlb2YgTmF0aXZlUHJvbWlzZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgIHR5cGVvZiBOYXRpdmVQcm9taXNlLnJlc29sdmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBuYXRpdmVQcm9taXNlID0gTmF0aXZlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgc2NoZWR1bGUgPSBmdW5jdGlvbihmbikge1xuICAgICAgICBuYXRpdmVQcm9taXNlLnRoZW4oZm4pO1xuICAgIH07XG59IGVsc2UgaWYgKCh0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gXCJ1bmRlZmluZWRcIikgJiZcbiAgICAgICAgICAhKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIHdpbmRvdy5uYXZpZ2F0b3IgJiZcbiAgICAgICAgICAgICh3aW5kb3cubmF2aWdhdG9yLnN0YW5kYWxvbmUgfHwgd2luZG93LmNvcmRvdmEpKSkge1xuICAgIHNjaGVkdWxlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdmFyIG9wdHMgPSB7YXR0cmlidXRlczogdHJ1ZX07XG4gICAgICAgIHZhciB0b2dnbGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGRpdjIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB2YXIgbzIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZm9vXCIpO1xuICAgICAgICAgICAgdG9nZ2xlU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBvMi5vYnNlcnZlKGRpdjIsIG9wdHMpO1xuXG4gICAgICAgIHZhciBzY2hlZHVsZVRvZ2dsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRvZ2dsZVNjaGVkdWxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgdG9nZ2xlU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGRpdjIuY2xhc3NMaXN0LnRvZ2dsZShcImZvb1wiKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc2NoZWR1bGUoZm4pIHtcbiAgICAgICAgICAgIHZhciBvID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgby5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgby5vYnNlcnZlKGRpdiwgb3B0cyk7XG4gICAgICAgICAgICBzY2hlZHVsZVRvZ2dsZSgpO1xuICAgICAgICB9O1xuICAgIH0pKCk7XG59IGVsc2UgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBzY2hlZHVsZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICBzZXRJbW1lZGlhdGUoZm4pO1xuICAgIH07XG59IGVsc2UgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgc2NoZWR1bGUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0gZWxzZSB7XG4gICAgc2NoZWR1bGUgPSBub0FzeW5jU2NoZWR1bGVyO1xufVxubW9kdWxlLmV4cG9ydHMgPSBzY2hlZHVsZTtcblxufSx7XCIuL3V0aWxcIjozNn1dLDMwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPVxuICAgIGZ1bmN0aW9uKFByb21pc2UsIFByb21pc2VBcnJheSwgZGVidWcpIHtcbnZhciBQcm9taXNlSW5zcGVjdGlvbiA9IFByb21pc2UuUHJvbWlzZUluc3BlY3Rpb247XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG5cbmZ1bmN0aW9uIFNldHRsZWRQcm9taXNlQXJyYXkodmFsdWVzKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciQodmFsdWVzKTtcbn1cbnV0aWwuaW5oZXJpdHMoU2V0dGxlZFByb21pc2VBcnJheSwgUHJvbWlzZUFycmF5KTtcblxuU2V0dGxlZFByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VSZXNvbHZlZCA9IGZ1bmN0aW9uIChpbmRleCwgaW5zcGVjdGlvbikge1xuICAgIHRoaXMuX3ZhbHVlc1tpbmRleF0gPSBpbnNwZWN0aW9uO1xuICAgIHZhciB0b3RhbFJlc29sdmVkID0gKyt0aGlzLl90b3RhbFJlc29sdmVkO1xuICAgIGlmICh0b3RhbFJlc29sdmVkID49IHRoaXMuX2xlbmd0aCkge1xuICAgICAgICB0aGlzLl9yZXNvbHZlKHRoaXMuX3ZhbHVlcyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5TZXR0bGVkUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZUZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2VJbnNwZWN0aW9uKCk7XG4gICAgcmV0Ll9iaXRGaWVsZCA9IDMzNTU0NDMyO1xuICAgIHJldC5fc2V0dGxlZFZhbHVlRmllbGQgPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZVJlc29sdmVkKGluZGV4LCByZXQpO1xufTtcblNldHRsZWRQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlUmVqZWN0ZWQgPSBmdW5jdGlvbiAocmVhc29uLCBpbmRleCkge1xuICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZUluc3BlY3Rpb24oKTtcbiAgICByZXQuX2JpdEZpZWxkID0gMTY3NzcyMTY7XG4gICAgcmV0Ll9zZXR0bGVkVmFsdWVGaWVsZCA9IHJlYXNvbjtcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZVJlc29sdmVkKGluZGV4LCByZXQpO1xufTtcblxuUHJvbWlzZS5zZXR0bGUgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICBkZWJ1Zy5kZXByZWNhdGVkKFwiLnNldHRsZSgpXCIsIFwiLnJlZmxlY3QoKVwiKTtcbiAgICByZXR1cm4gbmV3IFNldHRsZWRQcm9taXNlQXJyYXkocHJvbWlzZXMpLnByb21pc2UoKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnNldHRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5zZXR0bGUodGhpcyk7XG59O1xufTtcblxufSx7XCIuL3V0aWxcIjozNn1dLDMxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPVxuZnVuY3Rpb24oUHJvbWlzZSwgUHJvbWlzZUFycmF5LCBhcGlSZWplY3Rpb24pIHtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcbnZhciBSYW5nZUVycm9yID0gX2RlcmVxXyhcIi4vZXJyb3JzXCIpLlJhbmdlRXJyb3I7XG52YXIgQWdncmVnYXRlRXJyb3IgPSBfZGVyZXFfKFwiLi9lcnJvcnNcIikuQWdncmVnYXRlRXJyb3I7XG52YXIgaXNBcnJheSA9IHV0aWwuaXNBcnJheTtcbnZhciBDQU5DRUxMQVRJT04gPSB7fTtcblxuXG5mdW5jdGlvbiBTb21lUHJvbWlzZUFycmF5KHZhbHVlcykge1xuICAgIHRoaXMuY29uc3RydWN0b3IkKHZhbHVlcyk7XG4gICAgdGhpcy5faG93TWFueSA9IDA7XG4gICAgdGhpcy5fdW53cmFwID0gZmFsc2U7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbn1cbnV0aWwuaW5oZXJpdHMoU29tZVByb21pc2VBcnJheSwgUHJvbWlzZUFycmF5KTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9ob3dNYW55ID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmUoW10pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2luaXQkKHVuZGVmaW5lZCwgLTUpO1xuICAgIHZhciBpc0FycmF5UmVzb2x2ZWQgPSBpc0FycmF5KHRoaXMuX3ZhbHVlcyk7XG4gICAgaWYgKCF0aGlzLl9pc1Jlc29sdmVkKCkgJiZcbiAgICAgICAgaXNBcnJheVJlc29sdmVkICYmXG4gICAgICAgIHRoaXMuX2hvd01hbnkgPiB0aGlzLl9jYW5Qb3NzaWJseUZ1bGZpbGwoKSkge1xuICAgICAgICB0aGlzLl9yZWplY3QodGhpcy5fZ2V0UmFuZ2VFcnJvcih0aGlzLmxlbmd0aCgpKSk7XG4gICAgfVxufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgdGhpcy5faW5pdCgpO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuc2V0VW53cmFwID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3Vud3JhcCA9IHRydWU7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5ob3dNYW55ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9ob3dNYW55O1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuc2V0SG93TWFueSA9IGZ1bmN0aW9uIChjb3VudCkge1xuICAgIHRoaXMuX2hvd01hbnkgPSBjb3VudDtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5fYWRkRnVsZmlsbGVkKHZhbHVlKTtcbiAgICBpZiAodGhpcy5fZnVsZmlsbGVkKCkgPT09IHRoaXMuaG93TWFueSgpKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlcy5sZW5ndGggPSB0aGlzLmhvd01hbnkoKTtcbiAgICAgICAgaWYgKHRoaXMuaG93TWFueSgpID09PSAxICYmIHRoaXMuX3Vud3JhcCkge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZSh0aGlzLl92YWx1ZXNbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZSh0aGlzLl92YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG5cbn07XG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZVJlamVjdGVkID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRoaXMuX2FkZFJlamVjdGVkKHJlYXNvbik7XG4gICAgcmV0dXJuIHRoaXMuX2NoZWNrT3V0Y29tZSgpO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VDYW5jZWxsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3ZhbHVlcyBpbnN0YW5jZW9mIFByb21pc2UgfHwgdGhpcy5fdmFsdWVzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbmNlbCgpO1xuICAgIH1cbiAgICB0aGlzLl9hZGRSZWplY3RlZChDQU5DRUxMQVRJT04pO1xuICAgIHJldHVybiB0aGlzLl9jaGVja091dGNvbWUoKTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9jaGVja091dGNvbWUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5ob3dNYW55KCkgPiB0aGlzLl9jYW5Qb3NzaWJseUZ1bGZpbGwoKSkge1xuICAgICAgICB2YXIgZSA9IG5ldyBBZ2dyZWdhdGVFcnJvcigpO1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGgoKTsgaSA8IHRoaXMuX3ZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ZhbHVlc1tpXSAhPT0gQ0FOQ0VMTEFUSU9OKSB7XG4gICAgICAgICAgICAgICAgZS5wdXNoKHRoaXMuX3ZhbHVlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fcmVqZWN0KGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9mdWxmaWxsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RvdGFsUmVzb2x2ZWQ7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVqZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlcy5sZW5ndGggLSB0aGlzLmxlbmd0aCgpO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX2FkZFJlamVjdGVkID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRoaXMuX3ZhbHVlcy5wdXNoKHJlYXNvbik7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fYWRkRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5fdmFsdWVzW3RoaXMuX3RvdGFsUmVzb2x2ZWQrK10gPSB2YWx1ZTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9jYW5Qb3NzaWJseUZ1bGZpbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoKCkgLSB0aGlzLl9yZWplY3RlZCgpO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX2dldFJhbmdlRXJyb3IgPSBmdW5jdGlvbiAoY291bnQpIHtcbiAgICB2YXIgbWVzc2FnZSA9IFwiSW5wdXQgYXJyYXkgbXVzdCBjb250YWluIGF0IGxlYXN0IFwiICtcbiAgICAgICAgICAgIHRoaXMuX2hvd01hbnkgKyBcIiBpdGVtcyBidXQgY29udGFpbnMgb25seSBcIiArIGNvdW50ICsgXCIgaXRlbXNcIjtcbiAgICByZXR1cm4gbmV3IFJhbmdlRXJyb3IobWVzc2FnZSk7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVzb2x2ZUVtcHR5QXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcmVqZWN0KHRoaXMuX2dldFJhbmdlRXJyb3IoMCkpO1xufTtcblxuZnVuY3Rpb24gc29tZShwcm9taXNlcywgaG93TWFueSkge1xuICAgIGlmICgoaG93TWFueSB8IDApICE9PSBob3dNYW55IHx8IGhvd01hbnkgPCAwKSB7XG4gICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJleHBlY3RpbmcgYSBwb3NpdGl2ZSBpbnRlZ2VyXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgdmFyIHJldCA9IG5ldyBTb21lUHJvbWlzZUFycmF5KHByb21pc2VzKTtcbiAgICB2YXIgcHJvbWlzZSA9IHJldC5wcm9taXNlKCk7XG4gICAgcmV0LnNldEhvd01hbnkoaG93TWFueSk7XG4gICAgcmV0LmluaXQoKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuUHJvbWlzZS5zb21lID0gZnVuY3Rpb24gKHByb21pc2VzLCBob3dNYW55KSB7XG4gICAgcmV0dXJuIHNvbWUocHJvbWlzZXMsIGhvd01hbnkpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuc29tZSA9IGZ1bmN0aW9uIChob3dNYW55KSB7XG4gICAgcmV0dXJuIHNvbWUodGhpcywgaG93TWFueSk7XG59O1xuXG5Qcm9taXNlLl9Tb21lUHJvbWlzZUFycmF5ID0gU29tZVByb21pc2VBcnJheTtcbn07XG5cbn0se1wiLi9lcnJvcnNcIjoxMixcIi4vdXRpbFwiOjM2fV0sMzI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UpIHtcbmZ1bmN0aW9uIFByb21pc2VJbnNwZWN0aW9uKHByb21pc2UpIHtcbiAgICBpZiAocHJvbWlzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb21pc2UgPSBwcm9taXNlLl90YXJnZXQoKTtcbiAgICAgICAgdGhpcy5fYml0RmllbGQgPSBwcm9taXNlLl9iaXRGaWVsZDtcbiAgICAgICAgdGhpcy5fc2V0dGxlZFZhbHVlRmllbGQgPSBwcm9taXNlLl9pc0ZhdGVTZWFsZWQoKVxuICAgICAgICAgICAgPyBwcm9taXNlLl9zZXR0bGVkVmFsdWUoKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX2JpdEZpZWxkID0gMDtcbiAgICAgICAgdGhpcy5fc2V0dGxlZFZhbHVlRmllbGQgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuXG5Qcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUuX3NldHRsZWRWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9zZXR0bGVkVmFsdWVGaWVsZDtcbn07XG5cbnZhciB2YWx1ZSA9IFByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuaXNGdWxmaWxsZWQoKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2Fubm90IGdldCBmdWxmaWxsbWVudCB2YWx1ZSBvZiBhIG5vbi1mdWxmaWxsZWQgcHJvbWlzZVxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zZXR0bGVkVmFsdWUoKTtcbn07XG5cbnZhciByZWFzb24gPSBQcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUuZXJyb3IgPVxuUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLnJlYXNvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuaXNSZWplY3RlZCgpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW5ub3QgZ2V0IHJlamVjdGlvbiByZWFzb24gb2YgYSBub24tcmVqZWN0ZWQgcHJvbWlzZVxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zZXR0bGVkVmFsdWUoKTtcbn07XG5cbnZhciBpc0Z1bGZpbGxlZCA9IFByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5pc0Z1bGZpbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDA7XG59O1xuXG52YXIgaXNSZWplY3RlZCA9IFByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5pc1JlamVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiAxNjc3NzIxNikgIT09IDA7XG59O1xuXG52YXIgaXNQZW5kaW5nID0gUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLmlzUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgNTAzOTcxODQpID09PSAwO1xufTtcblxudmFyIGlzUmVzb2x2ZWQgPSBQcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUuaXNSZXNvbHZlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgNTAzMzE2NDgpICE9PSAwO1xufTtcblxuUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLmlzQ2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDg0NTQxNDQpICE9PSAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX19pc0NhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiA2NTUzNikgPT09IDY1NTM2O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2lzQ2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RhcmdldCgpLl9faXNDYW5jZWxsZWQoKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmlzQ2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICh0aGlzLl90YXJnZXQoKS5fYml0RmllbGQgJiA4NDU0MTQ0KSAhPT0gMDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmlzUGVuZGluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpc1BlbmRpbmcuY2FsbCh0aGlzLl90YXJnZXQoKSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5pc1JlamVjdGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlzUmVqZWN0ZWQuY2FsbCh0aGlzLl90YXJnZXQoKSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5pc0Z1bGZpbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpc0Z1bGZpbGxlZC5jYWxsKHRoaXMuX3RhcmdldCgpKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmlzUmVzb2x2ZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaXNSZXNvbHZlZC5jYWxsKHRoaXMuX3RhcmdldCgpKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlLmNhbGwodGhpcy5fdGFyZ2V0KCkpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUucmVhc29uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRhcmdldCA9IHRoaXMuX3RhcmdldCgpO1xuICAgIHRhcmdldC5fdW5zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCgpO1xuICAgIHJldHVybiByZWFzb24uY2FsbCh0YXJnZXQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3ZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NldHRsZWRWYWx1ZSgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3JlYXNvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3Vuc2V0UmVqZWN0aW9uSXNVbmhhbmRsZWQoKTtcbiAgICByZXR1cm4gdGhpcy5fc2V0dGxlZFZhbHVlKCk7XG59O1xuXG5Qcm9taXNlLlByb21pc2VJbnNwZWN0aW9uID0gUHJvbWlzZUluc3BlY3Rpb247XG59O1xuXG59LHt9XSwzMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgSU5URVJOQUwpIHtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG52YXIgaXNPYmplY3QgPSB1dGlsLmlzT2JqZWN0O1xuXG5mdW5jdGlvbiB0cnlDb252ZXJ0VG9Qcm9taXNlKG9iaiwgY29udGV4dCkge1xuICAgIGlmIChpc09iamVjdChvYmopKSB7XG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBQcm9taXNlKSByZXR1cm4gb2JqO1xuICAgICAgICB2YXIgdGhlbiA9IGdldFRoZW4ob2JqKTtcbiAgICAgICAgaWYgKHRoZW4gPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dCkgY29udGV4dC5fcHVzaENvbnRleHQoKTtcbiAgICAgICAgICAgIHZhciByZXQgPSBQcm9taXNlLnJlamVjdCh0aGVuLmUpO1xuICAgICAgICAgICAgaWYgKGNvbnRleHQpIGNvbnRleHQuX3BvcENvbnRleHQoKTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgaWYgKGlzQW55Qmx1ZWJpcmRQcm9taXNlKG9iaikpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICAgICAgICAgIG9iai5fdGhlbihcbiAgICAgICAgICAgICAgICAgICAgcmV0Ll9mdWxmaWxsLFxuICAgICAgICAgICAgICAgICAgICByZXQuX3JlamVjdCxcbiAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICByZXQsXG4gICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZG9UaGVuYWJsZShvYmosIHRoZW4sIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIGRvR2V0VGhlbihvYmopIHtcbiAgICByZXR1cm4gb2JqLnRoZW47XG59XG5cbmZ1bmN0aW9uIGdldFRoZW4ob2JqKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRvR2V0VGhlbihvYmopO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3JPYmouZSA9IGU7XG4gICAgICAgIHJldHVybiBlcnJvck9iajtcbiAgICB9XG59XG5cbnZhciBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBpc0FueUJsdWViaXJkUHJvbWlzZShvYmopIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gaGFzUHJvcC5jYWxsKG9iaiwgXCJfcHJvbWlzZTBcIik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkb1RoZW5hYmxlKHgsIHRoZW4sIGNvbnRleHQpIHtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICB2YXIgcmV0ID0gcHJvbWlzZTtcbiAgICBpZiAoY29udGV4dCkgY29udGV4dC5fcHVzaENvbnRleHQoKTtcbiAgICBwcm9taXNlLl9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgIGlmIChjb250ZXh0KSBjb250ZXh0Ll9wb3BDb250ZXh0KCk7XG4gICAgdmFyIHN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICB2YXIgcmVzdWx0ID0gdXRpbC50cnlDYXRjaCh0aGVuKS5jYWxsKHgsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgc3luY2hyb25vdXMgPSBmYWxzZTtcblxuICAgIGlmIChwcm9taXNlICYmIHJlc3VsdCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2socmVzdWx0LmUsIHRydWUsIHRydWUpO1xuICAgICAgICBwcm9taXNlID0gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlKHZhbHVlKSB7XG4gICAgICAgIGlmICghcHJvbWlzZSkgcmV0dXJuO1xuICAgICAgICBwcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2sodmFsdWUpO1xuICAgICAgICBwcm9taXNlID0gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gICAgICAgIGlmICghcHJvbWlzZSkgcmV0dXJuO1xuICAgICAgICBwcm9taXNlLl9yZWplY3RDYWxsYmFjayhyZWFzb24sIHN5bmNocm9ub3VzLCB0cnVlKTtcbiAgICAgICAgcHJvbWlzZSA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbnJldHVybiB0cnlDb252ZXJ0VG9Qcm9taXNlO1xufTtcblxufSx7XCIuL3V0aWxcIjozNn1dLDM0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCwgZGVidWcpIHtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcbnZhciBUaW1lb3V0RXJyb3IgPSBQcm9taXNlLlRpbWVvdXRFcnJvcjtcblxuZnVuY3Rpb24gSGFuZGxlV3JhcHBlcihoYW5kbGUpICB7XG4gICAgdGhpcy5oYW5kbGUgPSBoYW5kbGU7XG59XG5cbkhhbmRsZVdyYXBwZXIucHJvdG90eXBlLl9yZXN1bHRDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5oYW5kbGUpO1xufTtcblxudmFyIGFmdGVyVmFsdWUgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gZGVsYXkoK3RoaXMpLnRoZW5SZXR1cm4odmFsdWUpOyB9O1xudmFyIGRlbGF5ID0gUHJvbWlzZS5kZWxheSA9IGZ1bmN0aW9uIChtcywgdmFsdWUpIHtcbiAgICB2YXIgcmV0O1xuICAgIHZhciBoYW5kbGU7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0ID0gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKVxuICAgICAgICAgICAgICAgIC5fdGhlbihhZnRlclZhbHVlLCBudWxsLCBudWxsLCBtcywgdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKGRlYnVnLmNhbmNlbGxhdGlvbigpICYmIHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0Ll9zZXRPbkNhbmNlbCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgIGhhbmRsZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHJldC5fZnVsZmlsbCgpOyB9LCArbXMpO1xuICAgICAgICBpZiAoZGVidWcuY2FuY2VsbGF0aW9uKCkpIHtcbiAgICAgICAgICAgIHJldC5fc2V0T25DYW5jZWwobmV3IEhhbmRsZVdyYXBwZXIoaGFuZGxlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0Ll9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgIH1cbiAgICByZXQuX3NldEFzeW5jR3VhcmFudGVlZCgpO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uIChtcykge1xuICAgIHJldHVybiBkZWxheShtcywgdGhpcyk7XG59O1xuXG52YXIgYWZ0ZXJUaW1lb3V0ID0gZnVuY3Rpb24gKHByb21pc2UsIG1lc3NhZ2UsIHBhcmVudCkge1xuICAgIHZhciBlcnI7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIGVyciA9IG1lc3NhZ2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnIgPSBuZXcgVGltZW91dEVycm9yKFwib3BlcmF0aW9uIHRpbWVkIG91dFwiKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGVyciA9IG5ldyBUaW1lb3V0RXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHV0aWwubWFya0FzT3JpZ2luYXRpbmdGcm9tUmVqZWN0aW9uKGVycik7XG4gICAgcHJvbWlzZS5fYXR0YWNoRXh0cmFUcmFjZShlcnIpO1xuICAgIHByb21pc2UuX3JlamVjdChlcnIpO1xuXG4gICAgaWYgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgIHBhcmVudC5jYW5jZWwoKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBzdWNjZXNzQ2xlYXIodmFsdWUpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5oYW5kbGUpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZmFpbHVyZUNsZWFyKHJlYXNvbikge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmhhbmRsZSk7XG4gICAgdGhyb3cgcmVhc29uO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gKG1zLCBtZXNzYWdlKSB7XG4gICAgbXMgPSArbXM7XG4gICAgdmFyIHJldCwgcGFyZW50O1xuXG4gICAgdmFyIGhhbmRsZVdyYXBwZXIgPSBuZXcgSGFuZGxlV3JhcHBlcihzZXRUaW1lb3V0KGZ1bmN0aW9uIHRpbWVvdXRUaW1lb3V0KCkge1xuICAgICAgICBpZiAocmV0LmlzUGVuZGluZygpKSB7XG4gICAgICAgICAgICBhZnRlclRpbWVvdXQocmV0LCBtZXNzYWdlLCBwYXJlbnQpO1xuICAgICAgICB9XG4gICAgfSwgbXMpKTtcblxuICAgIGlmIChkZWJ1Zy5jYW5jZWxsYXRpb24oKSkge1xuICAgICAgICBwYXJlbnQgPSB0aGlzLnRoZW4oKTtcbiAgICAgICAgcmV0ID0gcGFyZW50Ll90aGVuKHN1Y2Nlc3NDbGVhciwgZmFpbHVyZUNsZWFyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgaGFuZGxlV3JhcHBlciwgdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0Ll9zZXRPbkNhbmNlbChoYW5kbGVXcmFwcGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSB0aGlzLl90aGVuKHN1Y2Nlc3NDbGVhciwgZmFpbHVyZUNsZWFyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgaGFuZGxlV3JhcHBlciwgdW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xufTtcblxufTtcblxufSx7XCIuL3V0aWxcIjozNn1dLDM1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoUHJvbWlzZSwgYXBpUmVqZWN0aW9uLCB0cnlDb252ZXJ0VG9Qcm9taXNlLFxuICAgIGNyZWF0ZUNvbnRleHQsIElOVEVSTkFMLCBkZWJ1Zykge1xuICAgIHZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcbiAgICB2YXIgVHlwZUVycm9yID0gX2RlcmVxXyhcIi4vZXJyb3JzXCIpLlR5cGVFcnJvcjtcbiAgICB2YXIgaW5oZXJpdHMgPSBfZGVyZXFfKFwiLi91dGlsXCIpLmluaGVyaXRzO1xuICAgIHZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG4gICAgdmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcbiAgICB2YXIgTlVMTCA9IHt9O1xuXG4gICAgZnVuY3Rpb24gdGhyb3dlcihlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXt0aHJvdyBlO30sIDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhc3RQcmVzZXJ2aW5nRGlzcG9zYWJsZSh0aGVuYWJsZSkge1xuICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZSh0aGVuYWJsZSk7XG4gICAgICAgIGlmIChtYXliZVByb21pc2UgIT09IHRoZW5hYmxlICYmXG4gICAgICAgICAgICB0eXBlb2YgdGhlbmFibGUuX2lzRGlzcG9zYWJsZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICB0eXBlb2YgdGhlbmFibGUuX2dldERpc3Bvc2VyID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgIHRoZW5hYmxlLl9pc0Rpc3Bvc2FibGUoKSkge1xuICAgICAgICAgICAgbWF5YmVQcm9taXNlLl9zZXREaXNwb3NhYmxlKHRoZW5hYmxlLl9nZXREaXNwb3NlcigpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF5YmVQcm9taXNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNwb3NlKHJlc291cmNlcywgaW5zcGVjdGlvbikge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsZW4gPSByZXNvdXJjZXMubGVuZ3RoO1xuICAgICAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICBmdW5jdGlvbiBpdGVyYXRvcigpIHtcbiAgICAgICAgICAgIGlmIChpID49IGxlbikgcmV0dXJuIHJldC5fZnVsZmlsbCgpO1xuICAgICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGNhc3RQcmVzZXJ2aW5nRGlzcG9zYWJsZShyZXNvdXJjZXNbaSsrXSk7XG4gICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSAmJlxuICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5faXNEaXNwb3NhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl9nZXREaXNwb3NlcigpLnRyeURpc3Bvc2UoaW5zcGVjdGlvbiksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZXMucHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dlcihlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1heWJlUHJvbWlzZS5fdGhlbihpdGVyYXRvciwgdGhyb3dlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVyYXRvcigpO1xuICAgICAgICB9XG4gICAgICAgIGl0ZXJhdG9yKCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRGlzcG9zZXIoZGF0YSwgcHJvbWlzZSwgY29udGV4dCkge1xuICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5fcHJvbWlzZSA9IHByb21pc2U7XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cblxuICAgIERpc3Bvc2VyLnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICB9O1xuXG4gICAgRGlzcG9zZXIucHJvdG90eXBlLnByb21pc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9taXNlO1xuICAgIH07XG5cbiAgICBEaXNwb3Nlci5wcm90b3R5cGUucmVzb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb21pc2UoKS5pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlKCkudmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTlVMTDtcbiAgICB9O1xuXG4gICAgRGlzcG9zZXIucHJvdG90eXBlLnRyeURpc3Bvc2UgPSBmdW5jdGlvbihpbnNwZWN0aW9uKSB7XG4gICAgICAgIHZhciByZXNvdXJjZSA9IHRoaXMucmVzb3VyY2UoKTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xuICAgICAgICBpZiAoY29udGV4dCAhPT0gdW5kZWZpbmVkKSBjb250ZXh0Ll9wdXNoQ29udGV4dCgpO1xuICAgICAgICB2YXIgcmV0ID0gcmVzb3VyY2UgIT09IE5VTExcbiAgICAgICAgICAgID8gdGhpcy5kb0Rpc3Bvc2UocmVzb3VyY2UsIGluc3BlY3Rpb24pIDogbnVsbDtcbiAgICAgICAgaWYgKGNvbnRleHQgIT09IHVuZGVmaW5lZCkgY29udGV4dC5fcG9wQ29udGV4dCgpO1xuICAgICAgICB0aGlzLl9wcm9taXNlLl91bnNldERpc3Bvc2FibGUoKTtcbiAgICAgICAgdGhpcy5fZGF0YSA9IG51bGw7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIERpc3Bvc2VyLmlzRGlzcG9zZXIgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gKGQgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBkLnJlc291cmNlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZC50cnlEaXNwb3NlID09PSBcImZ1bmN0aW9uXCIpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBGdW5jdGlvbkRpc3Bvc2VyKGZuLCBwcm9taXNlLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IkKGZuLCBwcm9taXNlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaW5oZXJpdHMoRnVuY3Rpb25EaXNwb3NlciwgRGlzcG9zZXIpO1xuXG4gICAgRnVuY3Rpb25EaXNwb3Nlci5wcm90b3R5cGUuZG9EaXNwb3NlID0gZnVuY3Rpb24gKHJlc291cmNlLCBpbnNwZWN0aW9uKSB7XG4gICAgICAgIHZhciBmbiA9IHRoaXMuZGF0YSgpO1xuICAgICAgICByZXR1cm4gZm4uY2FsbChyZXNvdXJjZSwgcmVzb3VyY2UsIGluc3BlY3Rpb24pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBtYXliZVVud3JhcERpc3Bvc2VyKHZhbHVlKSB7XG4gICAgICAgIGlmIChEaXNwb3Nlci5pc0Rpc3Bvc2VyKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5yZXNvdXJjZXNbdGhpcy5pbmRleF0uX3NldERpc3Bvc2FibGUodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnByb21pc2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUmVzb3VyY2VMaXN0KGxlbmd0aCkge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbnVsbDtcbiAgICAgICAgdGhpc1tsZW5ndGgtMV0gPSBudWxsO1xuICAgIH1cblxuICAgIFJlc291cmNlTGlzdC5wcm90b3R5cGUuX3Jlc3VsdENhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gdGhpc1tpXTtcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uY2FuY2VsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgUHJvbWlzZS51c2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPCAyKSByZXR1cm4gYXBpUmVqZWN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ5b3UgbXVzdCBwYXNzIGF0IGxlYXN0IDIgYXJndW1lbnRzIHRvIFByb21pc2UudXNpbmdcIik7XG4gICAgICAgIHZhciBmbiA9IGFyZ3VtZW50c1tsZW4gLSAxXTtcbiAgICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZm4pKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5wdXQ7XG4gICAgICAgIHZhciBzcHJlYWRBcmdzID0gdHJ1ZTtcbiAgICAgICAgaWYgKGxlbiA9PT0gMiAmJiBBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgICAgIGlucHV0ID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgbGVuID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgc3ByZWFkQXJncyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXQgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICBsZW4tLTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzb3VyY2VzID0gbmV3IFJlc291cmNlTGlzdChsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICB2YXIgcmVzb3VyY2UgPSBpbnB1dFtpXTtcbiAgICAgICAgICAgIGlmIChEaXNwb3Nlci5pc0Rpc3Bvc2VyKHJlc291cmNlKSkge1xuICAgICAgICAgICAgICAgIHZhciBkaXNwb3NlciA9IHJlc291cmNlO1xuICAgICAgICAgICAgICAgIHJlc291cmNlID0gcmVzb3VyY2UucHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgIHJlc291cmNlLl9zZXREaXNwb3NhYmxlKGRpc3Bvc2VyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UocmVzb3VyY2UpO1xuICAgICAgICAgICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fdGhlbihtYXliZVVud3JhcERpc3Bvc2VyLCBudWxsLCBudWxsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VzOiByZXNvdXJjZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgICAgICAgICAgfSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvdXJjZXNbaV0gPSByZXNvdXJjZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWZsZWN0ZWRSZXNvdXJjZXMgPSBuZXcgQXJyYXkocmVzb3VyY2VzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVmbGVjdGVkUmVzb3VyY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZWZsZWN0ZWRSZXNvdXJjZXNbaV0gPSBQcm9taXNlLnJlc29sdmUocmVzb3VyY2VzW2ldKS5yZWZsZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0UHJvbWlzZSA9IFByb21pc2UuYWxsKHJlZmxlY3RlZFJlc291cmNlcylcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGluc3BlY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnNwZWN0aW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5zcGVjdGlvbiA9IGluc3BlY3Rpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zcGVjdGlvbi5pc1JlamVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yT2JqLmUgPSBpbnNwZWN0aW9uLmVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JPYmo7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWluc3BlY3Rpb24uaXNGdWxmaWxsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0UHJvbWlzZS5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbnNwZWN0aW9uc1tpXSA9IGluc3BlY3Rpb24udmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fcHVzaENvbnRleHQoKTtcblxuICAgICAgICAgICAgICAgIGZuID0gdHJ5Q2F0Y2goZm4pO1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSBzcHJlYWRBcmdzXG4gICAgICAgICAgICAgICAgICAgID8gZm4uYXBwbHkodW5kZWZpbmVkLCBpbnNwZWN0aW9ucykgOiBmbihpbnNwZWN0aW9ucyk7XG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2VDcmVhdGVkID0gcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgICAgICAgICAgICAgIGRlYnVnLmNoZWNrRm9yZ290dGVuUmV0dXJucyhcbiAgICAgICAgICAgICAgICAgICAgcmV0LCBwcm9taXNlQ3JlYXRlZCwgXCJQcm9taXNlLnVzaW5nXCIsIHByb21pc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcHJvbWlzZSA9IHJlc3VsdFByb21pc2UubGFzdGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGluc3BlY3Rpb24gPSBuZXcgUHJvbWlzZS5Qcm9taXNlSW5zcGVjdGlvbihyZXN1bHRQcm9taXNlKTtcbiAgICAgICAgICAgIHJldHVybiBkaXNwb3NlKHJlc291cmNlcywgaW5zcGVjdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXNvdXJjZXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgICAgIHByb21pc2UuX3NldE9uQ2FuY2VsKHJlc291cmNlcyk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG5cbiAgICBQcm9taXNlLnByb3RvdHlwZS5fc2V0RGlzcG9zYWJsZSA9IGZ1bmN0aW9uIChkaXNwb3Nlcikge1xuICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMTMxMDcyO1xuICAgICAgICB0aGlzLl9kaXNwb3NlciA9IGRpc3Bvc2VyO1xuICAgIH07XG5cbiAgICBQcm9taXNlLnByb3RvdHlwZS5faXNEaXNwb3NhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMTMxMDcyKSA+IDA7XG4gICAgfTtcblxuICAgIFByb21pc2UucHJvdG90eXBlLl9nZXREaXNwb3NlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3Bvc2VyO1xuICAgIH07XG5cbiAgICBQcm9taXNlLnByb3RvdHlwZS5fdW5zZXREaXNwb3NhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkICYgKH4xMzEwNzIpO1xuICAgICAgICB0aGlzLl9kaXNwb3NlciA9IHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgUHJvbWlzZS5wcm90b3R5cGUuZGlzcG9zZXIgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uRGlzcG9zZXIoZm4sIHRoaXMsIGNyZWF0ZUNvbnRleHQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgIH07XG5cbn07XG5cbn0se1wiLi9lcnJvcnNcIjoxMixcIi4vdXRpbFwiOjM2fV0sMzY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZXM1ID0gX2RlcmVxXyhcIi4vZXM1XCIpO1xudmFyIGNhbkV2YWx1YXRlID0gdHlwZW9mIG5hdmlnYXRvciA9PSBcInVuZGVmaW5lZFwiO1xuXG52YXIgZXJyb3JPYmogPSB7ZToge319O1xudmFyIHRyeUNhdGNoVGFyZ2V0O1xudmFyIGdsb2JhbE9iamVjdCA9IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6XG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6XG4gICAgdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6XG4gICAgdGhpcyAhPT0gdW5kZWZpbmVkID8gdGhpcyA6IG51bGw7XG5cbmZ1bmN0aW9uIHRyeUNhdGNoZXIoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHRyeUNhdGNoVGFyZ2V0O1xuICAgICAgICB0cnlDYXRjaFRhcmdldCA9IG51bGw7XG4gICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yT2JqLmUgPSBlO1xuICAgICAgICByZXR1cm4gZXJyb3JPYmo7XG4gICAgfVxufVxuZnVuY3Rpb24gdHJ5Q2F0Y2goZm4pIHtcbiAgICB0cnlDYXRjaFRhcmdldCA9IGZuO1xuICAgIHJldHVybiB0cnlDYXRjaGVyO1xufVxuXG52YXIgaW5oZXJpdHMgPSBmdW5jdGlvbihDaGlsZCwgUGFyZW50KSB7XG4gICAgdmFyIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICAgIGZ1bmN0aW9uIFQoKSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBDaGlsZDtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciQgPSBQYXJlbnQ7XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5TmFtZSBpbiBQYXJlbnQucHJvdG90eXBlKSB7XG4gICAgICAgICAgICBpZiAoaGFzUHJvcC5jYWxsKFBhcmVudC5wcm90b3R5cGUsIHByb3BlcnR5TmFtZSkgJiZcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWUuY2hhckF0KHByb3BlcnR5TmFtZS5sZW5ndGgtMSkgIT09IFwiJFwiXG4gICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRoaXNbcHJvcGVydHlOYW1lICsgXCIkXCJdID0gUGFyZW50LnByb3RvdHlwZVtwcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFQucHJvdG90eXBlID0gUGFyZW50LnByb3RvdHlwZTtcbiAgICBDaGlsZC5wcm90b3R5cGUgPSBuZXcgVCgpO1xuICAgIHJldHVybiBDaGlsZC5wcm90b3R5cGU7XG59O1xuXG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKHZhbCkge1xuICAgIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IHRydWUgfHwgdmFsID09PSBmYWxzZSB8fFxuICAgICAgICB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCI7XG5cbn1cblxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgfHxcbiAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBtYXliZVdyYXBBc0Vycm9yKG1heWJlRXJyb3IpIHtcbiAgICBpZiAoIWlzUHJpbWl0aXZlKG1heWJlRXJyb3IpKSByZXR1cm4gbWF5YmVFcnJvcjtcblxuICAgIHJldHVybiBuZXcgRXJyb3Ioc2FmZVRvU3RyaW5nKG1heWJlRXJyb3IpKTtcbn1cblxuZnVuY3Rpb24gd2l0aEFwcGVuZGVkKHRhcmdldCwgYXBwZW5kZWUpIHtcbiAgICB2YXIgbGVuID0gdGFyZ2V0Lmxlbmd0aDtcbiAgICB2YXIgcmV0ID0gbmV3IEFycmF5KGxlbiArIDEpO1xuICAgIHZhciBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICByZXRbaV0gPSB0YXJnZXRbaV07XG4gICAgfVxuICAgIHJldFtpXSA9IGFwcGVuZGVlO1xuICAgIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGdldERhdGFQcm9wZXJ0eU9yRGVmYXVsdChvYmosIGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKGVzNS5pc0VTNSkge1xuICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuXG4gICAgICAgIGlmIChkZXNjICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBkZXNjLmdldCA9PSBudWxsICYmIGRlc2Muc2V0ID09IG51bGxcbiAgICAgICAgICAgICAgICAgICAgPyBkZXNjLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHt9Lmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpID8gb2JqW2tleV0gOiB1bmRlZmluZWQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBub3RFbnVtZXJhYmxlUHJvcChvYmosIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKGlzUHJpbWl0aXZlKG9iaikpIHJldHVybiBvYmo7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9O1xuICAgIGVzNS5kZWZpbmVQcm9wZXJ0eShvYmosIG5hbWUsIGRlc2NyaXB0b3IpO1xuICAgIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIHRocm93ZXIocikge1xuICAgIHRocm93IHI7XG59XG5cbnZhciBpbmhlcml0ZWREYXRhS2V5cyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgZXhjbHVkZWRQcm90b3R5cGVzID0gW1xuICAgICAgICBBcnJheS5wcm90b3R5cGUsXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUsXG4gICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZVxuICAgIF07XG5cbiAgICB2YXIgaXNFeGNsdWRlZFByb3RvID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhjbHVkZWRQcm90b3R5cGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoZXhjbHVkZWRQcm90b3R5cGVzW2ldID09PSB2YWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIGlmIChlczUuaXNFUzUpIHtcbiAgICAgICAgdmFyIGdldEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICAgICAgdmFyIHZpc2l0ZWRLZXlzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIHdoaWxlIChvYmogIT0gbnVsbCAmJiAhaXNFeGNsdWRlZFByb3RvKG9iaikpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5cztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBrZXlzID0gZ2V0S2V5cyhvYmopO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmlzaXRlZEtleXNba2V5XSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIHZpc2l0ZWRLZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVzYyAhPSBudWxsICYmIGRlc2MuZ2V0ID09IG51bGwgJiYgZGVzYy5zZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmogPSBlczUuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgaWYgKGlzRXhjbHVkZWRQcm90byhvYmopKSByZXR1cm4gW107XG4gICAgICAgICAgICB2YXIgcmV0ID0gW107XG5cbiAgICAgICAgICAgIC8qanNoaW50IGZvcmluOmZhbHNlICovXG4gICAgICAgICAgICBlbnVtZXJhdGlvbjogZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChoYXNQcm9wLmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleGNsdWRlZFByb3RvdHlwZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNQcm9wLmNhbGwoZXhjbHVkZWRQcm90b3R5cGVzW2ldLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgZW51bWVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuICAgIH1cblxufSkoKTtcblxudmFyIHRoaXNBc3NpZ25tZW50UGF0dGVybiA9IC90aGlzXFxzKlxcLlxccypcXFMrXFxzKj0vO1xuZnVuY3Rpb24gaXNDbGFzcyhmbikge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFyIGtleXMgPSBlczUubmFtZXMoZm4ucHJvdG90eXBlKTtcblxuICAgICAgICAgICAgdmFyIGhhc01ldGhvZHMgPSBlczUuaXNFUzUgJiYga2V5cy5sZW5ndGggPiAxO1xuICAgICAgICAgICAgdmFyIGhhc01ldGhvZHNPdGhlclRoYW5Db25zdHJ1Y3RvciA9IGtleXMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICEoa2V5cy5sZW5ndGggPT09IDEgJiYga2V5c1swXSA9PT0gXCJjb25zdHJ1Y3RvclwiKTtcbiAgICAgICAgICAgIHZhciBoYXNUaGlzQXNzaWdubWVudEFuZFN0YXRpY01ldGhvZHMgPVxuICAgICAgICAgICAgICAgIHRoaXNBc3NpZ25tZW50UGF0dGVybi50ZXN0KGZuICsgXCJcIikgJiYgZXM1Lm5hbWVzKGZuKS5sZW5ndGggPiAwO1xuXG4gICAgICAgICAgICBpZiAoaGFzTWV0aG9kcyB8fCBoYXNNZXRob2RzT3RoZXJUaGFuQ29uc3RydWN0b3IgfHxcbiAgICAgICAgICAgICAgICBoYXNUaGlzQXNzaWdubWVudEFuZFN0YXRpY01ldGhvZHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB0b0Zhc3RQcm9wZXJ0aWVzKG9iaikge1xuICAgIC8qanNoaW50IC1XMDI3LC1XMDU1LC1XMDMxKi9cbiAgICBmdW5jdGlvbiBGYWtlQ29uc3RydWN0b3IoKSB7fVxuICAgIEZha2VDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBvYmo7XG4gICAgdmFyIGwgPSA4O1xuICAgIHdoaWxlIChsLS0pIG5ldyBGYWtlQ29uc3RydWN0b3IoKTtcbiAgICByZXR1cm4gb2JqO1xuICAgIGV2YWwob2JqKTtcbn1cblxudmFyIHJpZGVudCA9IC9eW2EteiRfXVthLXokXzAtOV0qJC9pO1xuZnVuY3Rpb24gaXNJZGVudGlmaWVyKHN0cikge1xuICAgIHJldHVybiByaWRlbnQudGVzdChzdHIpO1xufVxuXG5mdW5jdGlvbiBmaWxsZWRSYW5nZShjb3VudCwgcHJlZml4LCBzdWZmaXgpIHtcbiAgICB2YXIgcmV0ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICByZXRbaV0gPSBwcmVmaXggKyBpICsgc3VmZml4O1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBzYWZlVG9TdHJpbmcob2JqKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG9iaiArIFwiXCI7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gXCJbbm8gc3RyaW5nIHJlcHJlc2VudGF0aW9uXVwiO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNFcnJvcihvYmopIHtcbiAgICByZXR1cm4gb2JqICE9PSBudWxsICYmXG4gICAgICAgICAgIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgdHlwZW9mIG9iai5tZXNzYWdlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgIHR5cGVvZiBvYmoubmFtZSA9PT0gXCJzdHJpbmdcIjtcbn1cblxuZnVuY3Rpb24gbWFya0FzT3JpZ2luYXRpbmdGcm9tUmVqZWN0aW9uKGUpIHtcbiAgICB0cnkge1xuICAgICAgICBub3RFbnVtZXJhYmxlUHJvcChlLCBcImlzT3BlcmF0aW9uYWxcIiwgdHJ1ZSk7XG4gICAgfVxuICAgIGNhdGNoKGlnbm9yZSkge31cbn1cblxuZnVuY3Rpb24gb3JpZ2luYXRlc0Zyb21SZWplY3Rpb24oZSkge1xuICAgIGlmIChlID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gKChlIGluc3RhbmNlb2YgRXJyb3JbXCJfX0JsdWViaXJkRXJyb3JUeXBlc19fXCJdLk9wZXJhdGlvbmFsRXJyb3IpIHx8XG4gICAgICAgIGVbXCJpc09wZXJhdGlvbmFsXCJdID09PSB0cnVlKTtcbn1cblxuZnVuY3Rpb24gY2FuQXR0YWNoVHJhY2Uob2JqKSB7XG4gICAgcmV0dXJuIGlzRXJyb3Iob2JqKSAmJiBlczUucHJvcGVydHlJc1dyaXRhYmxlKG9iaiwgXCJzdGFja1wiKTtcbn1cblxudmFyIGVuc3VyZUVycm9yT2JqZWN0ID0gKGZ1bmN0aW9uKCkge1xuICAgIGlmICghKFwic3RhY2tcIiBpbiBuZXcgRXJyb3IoKSkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoY2FuQXR0YWNoVHJhY2UodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB0cnkge3Rocm93IG5ldyBFcnJvcihzYWZlVG9TdHJpbmcodmFsdWUpKTt9XG4gICAgICAgICAgICBjYXRjaChlcnIpIHtyZXR1cm4gZXJyO31cbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChjYW5BdHRhY2hUcmFjZSh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3Ioc2FmZVRvU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgIH07XG4gICAgfVxufSkoKTtcblxuZnVuY3Rpb24gY2xhc3NTdHJpbmcob2JqKSB7XG4gICAgcmV0dXJuIHt9LnRvU3RyaW5nLmNhbGwob2JqKTtcbn1cblxuZnVuY3Rpb24gY29weURlc2NyaXB0b3JzKGZyb20sIHRvLCBmaWx0ZXIpIHtcbiAgICB2YXIga2V5cyA9IGVzNS5uYW1lcyhmcm9tKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmIChmaWx0ZXIoa2V5KSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBlczUuZGVmaW5lUHJvcGVydHkodG8sIGtleSwgZXM1LmdldERlc2NyaXB0b3IoZnJvbSwga2V5KSk7XG4gICAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciBhc0FycmF5ID0gZnVuY3Rpb24odikge1xuICAgIGlmIChlczUuaXNBcnJheSh2KSkge1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IpIHtcbiAgICB2YXIgQXJyYXlGcm9tID0gdHlwZW9mIEFycmF5LmZyb20gPT09IFwiZnVuY3Rpb25cIiA/IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odik7XG4gICAgfSA6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICB2YXIgaXQgPSB2W1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgICAgdmFyIGl0UmVzdWx0O1xuICAgICAgICB3aGlsZSAoISgoaXRSZXN1bHQgPSBpdC5uZXh0KCkpLmRvbmUpKSB7XG4gICAgICAgICAgICByZXQucHVzaChpdFJlc3VsdC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgYXNBcnJheSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgaWYgKGVzNS5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfSBlbHNlIGlmICh2ICE9IG51bGwgJiYgdHlwZW9mIHZbU3ltYm9sLml0ZXJhdG9yXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXlGcm9tKHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG59XG5cbnZhciBpc05vZGUgPSB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICBjbGFzc1N0cmluZyhwcm9jZXNzKS50b0xvd2VyQ2FzZSgpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIjtcblxudmFyIGhhc0VudlZhcmlhYmxlcyA9IHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgdHlwZW9mIHByb2Nlc3MuZW52ICE9PSBcInVuZGVmaW5lZFwiO1xuXG5mdW5jdGlvbiBlbnYoa2V5KSB7XG4gICAgcmV0dXJuIGhhc0VudlZhcmlhYmxlcyA/IHByb2Nlc3MuZW52W2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGdldE5hdGl2ZVByb21pc2UoKSB7XG4gICAgaWYgKHR5cGVvZiBQcm9taXNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24oKXt9KTtcbiAgICAgICAgICAgIGlmICh7fS50b1N0cmluZy5jYWxsKHByb21pc2UpID09PSBcIltvYmplY3QgUHJvbWlzZV1cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZG9tYWluQmluZChzZWxmLCBjYikge1xuICAgIHJldHVybiBzZWxmLmJpbmQoY2IpO1xufVxuXG52YXIgcmV0ID0ge1xuICAgIGlzQ2xhc3M6IGlzQ2xhc3MsXG4gICAgaXNJZGVudGlmaWVyOiBpc0lkZW50aWZpZXIsXG4gICAgaW5oZXJpdGVkRGF0YUtleXM6IGluaGVyaXRlZERhdGFLZXlzLFxuICAgIGdldERhdGFQcm9wZXJ0eU9yRGVmYXVsdDogZ2V0RGF0YVByb3BlcnR5T3JEZWZhdWx0LFxuICAgIHRocm93ZXI6IHRocm93ZXIsXG4gICAgaXNBcnJheTogZXM1LmlzQXJyYXksXG4gICAgYXNBcnJheTogYXNBcnJheSxcbiAgICBub3RFbnVtZXJhYmxlUHJvcDogbm90RW51bWVyYWJsZVByb3AsXG4gICAgaXNQcmltaXRpdmU6IGlzUHJpbWl0aXZlLFxuICAgIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgICBpc0Vycm9yOiBpc0Vycm9yLFxuICAgIGNhbkV2YWx1YXRlOiBjYW5FdmFsdWF0ZSxcbiAgICBlcnJvck9iajogZXJyb3JPYmosXG4gICAgdHJ5Q2F0Y2g6IHRyeUNhdGNoLFxuICAgIGluaGVyaXRzOiBpbmhlcml0cyxcbiAgICB3aXRoQXBwZW5kZWQ6IHdpdGhBcHBlbmRlZCxcbiAgICBtYXliZVdyYXBBc0Vycm9yOiBtYXliZVdyYXBBc0Vycm9yLFxuICAgIHRvRmFzdFByb3BlcnRpZXM6IHRvRmFzdFByb3BlcnRpZXMsXG4gICAgZmlsbGVkUmFuZ2U6IGZpbGxlZFJhbmdlLFxuICAgIHRvU3RyaW5nOiBzYWZlVG9TdHJpbmcsXG4gICAgY2FuQXR0YWNoVHJhY2U6IGNhbkF0dGFjaFRyYWNlLFxuICAgIGVuc3VyZUVycm9yT2JqZWN0OiBlbnN1cmVFcnJvck9iamVjdCxcbiAgICBvcmlnaW5hdGVzRnJvbVJlamVjdGlvbjogb3JpZ2luYXRlc0Zyb21SZWplY3Rpb24sXG4gICAgbWFya0FzT3JpZ2luYXRpbmdGcm9tUmVqZWN0aW9uOiBtYXJrQXNPcmlnaW5hdGluZ0Zyb21SZWplY3Rpb24sXG4gICAgY2xhc3NTdHJpbmc6IGNsYXNzU3RyaW5nLFxuICAgIGNvcHlEZXNjcmlwdG9yczogY29weURlc2NyaXB0b3JzLFxuICAgIGhhc0RldlRvb2xzOiB0eXBlb2YgY2hyb21lICE9PSBcInVuZGVmaW5lZFwiICYmIGNocm9tZSAmJlxuICAgICAgICAgICAgICAgICB0eXBlb2YgY2hyb21lLmxvYWRUaW1lcyA9PT0gXCJmdW5jdGlvblwiLFxuICAgIGlzTm9kZTogaXNOb2RlLFxuICAgIGhhc0VudlZhcmlhYmxlczogaGFzRW52VmFyaWFibGVzLFxuICAgIGVudjogZW52LFxuICAgIGdsb2JhbDogZ2xvYmFsT2JqZWN0LFxuICAgIGdldE5hdGl2ZVByb21pc2U6IGdldE5hdGl2ZVByb21pc2UsXG4gICAgZG9tYWluQmluZDogZG9tYWluQmluZFxufTtcbnJldC5pc1JlY2VudE5vZGUgPSByZXQuaXNOb2RlICYmIChmdW5jdGlvbigpIHtcbiAgICB2YXIgdmVyc2lvbiA9IHByb2Nlc3MudmVyc2lvbnMubm9kZS5zcGxpdChcIi5cIikubWFwKE51bWJlcik7XG4gICAgcmV0dXJuICh2ZXJzaW9uWzBdID09PSAwICYmIHZlcnNpb25bMV0gPiAxMCkgfHwgKHZlcnNpb25bMF0gPiAwKTtcbn0pKCk7XG5cbmlmIChyZXQuaXNOb2RlKSByZXQudG9GYXN0UHJvcGVydGllcyhwcm9jZXNzKTtcblxudHJ5IHt0aHJvdyBuZXcgRXJyb3IoKTsgfSBjYXRjaCAoZSkge3JldC5sYXN0TGluZUVycm9yID0gZTt9XG5tb2R1bGUuZXhwb3J0cyA9IHJldDtcblxufSx7XCIuL2VzNVwiOjEzfV19LHt9LFs0XSkoNClcbn0pOyAgICAgICAgICAgICAgICAgICAgO2lmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cgIT09IG51bGwpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LlAgPSB3aW5kb3cuUHJvbWlzZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYgIT09IG51bGwpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuUCA9IHNlbGYuUHJvbWlzZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9ibHVlYmlyZC9qcy9icm93c2VyL2JsdWViaXJkLmpzIiwiLy8gQnJvd3NlciBSZXF1ZXN0XG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4vLyBVTUQgSEVBREVSIFNUQVJUIFxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgICAgIGRlZmluZShbXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG4gICAgICAgIC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXG4gICAgICAgIC8vIGxpa2UgTm9kZS5cbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzIChyb290IGlzIHdpbmRvdylcbiAgICAgICAgcm9vdC5yZXR1cm5FeHBvcnRzID0gZmFjdG9yeSgpO1xuICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcbi8vIFVNRCBIRUFERVIgRU5EXG5cbnZhciBYSFIgPSBYTUxIdHRwUmVxdWVzdFxuaWYgKCFYSFIpIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBYTUxIdHRwUmVxdWVzdCcpXG5yZXF1ZXN0LmxvZyA9IHtcbiAgJ3RyYWNlJzogbm9vcCwgJ2RlYnVnJzogbm9vcCwgJ2luZm8nOiBub29wLCAnd2Fybic6IG5vb3AsICdlcnJvcic6IG5vb3Bcbn1cblxudmFyIERFRkFVTFRfVElNRU9VVCA9IDMgKiA2MCAqIDEwMDAgLy8gMyBtaW51dGVzXG5cbi8vXG4vLyByZXF1ZXN0XG4vL1xuXG5mdW5jdGlvbiByZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIC8vIFRoZSBlbnRyeS1wb2ludCB0byB0aGUgQVBJOiBwcmVwIHRoZSBvcHRpb25zIG9iamVjdCBhbmQgcGFzcyB0aGUgcmVhbCB3b3JrIHRvIHJ1bl94aHIuXG4gIGlmKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhZCBjYWxsYmFjayBnaXZlbjogJyArIGNhbGxiYWNrKVxuXG4gIGlmKCFvcHRpb25zKVxuICAgIHRocm93IG5ldyBFcnJvcignTm8gb3B0aW9ucyBnaXZlbicpXG5cbiAgdmFyIG9wdGlvbnNfb25SZXNwb25zZSA9IG9wdGlvbnMub25SZXNwb25zZTsgLy8gU2F2ZSB0aGlzIGZvciBsYXRlci5cblxuICBpZih0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpXG4gICAgb3B0aW9ucyA9IHsndXJpJzpvcHRpb25zfTtcbiAgZWxzZVxuICAgIG9wdGlvbnMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpKTsgLy8gVXNlIGEgZHVwbGljYXRlIGZvciBtdXRhdGluZy5cblxuICBvcHRpb25zLm9uUmVzcG9uc2UgPSBvcHRpb25zX29uUmVzcG9uc2UgLy8gQW5kIHB1dCBpdCBiYWNrLlxuXG4gIGlmIChvcHRpb25zLnZlcmJvc2UpIHJlcXVlc3QubG9nID0gZ2V0TG9nZ2VyKCk7XG5cbiAgaWYob3B0aW9ucy51cmwpIHtcbiAgICBvcHRpb25zLnVyaSA9IG9wdGlvbnMudXJsO1xuICAgIGRlbGV0ZSBvcHRpb25zLnVybDtcbiAgfVxuXG4gIGlmKCFvcHRpb25zLnVyaSAmJiBvcHRpb25zLnVyaSAhPT0gXCJcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJvcHRpb25zLnVyaSBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50XCIpO1xuXG4gIGlmKHR5cGVvZiBvcHRpb25zLnVyaSAhPSBcInN0cmluZ1wiKVxuICAgIHRocm93IG5ldyBFcnJvcihcIm9wdGlvbnMudXJpIG11c3QgYmUgYSBzdHJpbmdcIik7XG5cbiAgdmFyIHVuc3VwcG9ydGVkX29wdGlvbnMgPSBbJ3Byb3h5JywgJ19yZWRpcmVjdHNGb2xsb3dlZCcsICdtYXhSZWRpcmVjdHMnLCAnZm9sbG93UmVkaXJlY3QnXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHVuc3VwcG9ydGVkX29wdGlvbnMubGVuZ3RoOyBpKyspXG4gICAgaWYob3B0aW9uc1sgdW5zdXBwb3J0ZWRfb3B0aW9uc1tpXSBdKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3B0aW9ucy5cIiArIHVuc3VwcG9ydGVkX29wdGlvbnNbaV0gKyBcIiBpcyBub3Qgc3VwcG9ydGVkXCIpXG5cbiAgb3B0aW9ucy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gIG9wdGlvbnMubWV0aG9kID0gb3B0aW9ucy5tZXRob2QgfHwgJ0dFVCc7XG4gIG9wdGlvbnMuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyB8fCB7fTtcbiAgb3B0aW9ucy5ib2R5ICAgID0gb3B0aW9ucy5ib2R5IHx8IG51bGxcbiAgb3B0aW9ucy50aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0IHx8IHJlcXVlc3QuREVGQVVMVF9USU1FT1VUXG5cbiAgaWYob3B0aW9ucy5oZWFkZXJzLmhvc3QpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiT3B0aW9ucy5oZWFkZXJzLmhvc3QgaXMgbm90IHN1cHBvcnRlZFwiKTtcblxuICBpZihvcHRpb25zLmpzb24pIHtcbiAgICBvcHRpb25zLmhlYWRlcnMuYWNjZXB0ID0gb3B0aW9ucy5oZWFkZXJzLmFjY2VwdCB8fCAnYXBwbGljYXRpb24vanNvbidcbiAgICBpZihvcHRpb25zLm1ldGhvZCAhPT0gJ0dFVCcpXG4gICAgICBvcHRpb25zLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nXG5cbiAgICBpZih0eXBlb2Ygb3B0aW9ucy5qc29uICE9PSAnYm9vbGVhbicpXG4gICAgICBvcHRpb25zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLmpzb24pXG4gICAgZWxzZSBpZih0eXBlb2Ygb3B0aW9ucy5ib2R5ICE9PSAnc3RyaW5nJylcbiAgICAgIG9wdGlvbnMuYm9keSA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuYm9keSlcbiAgfVxuICBcbiAgLy9CRUdJTiBRUyBIYWNrXG4gIHZhciBzZXJpYWxpemUgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgc3RyID0gW107XG4gICAgZm9yKHZhciBwIGluIG9iailcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgc3RyLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KHApICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQob2JqW3BdKSk7XG4gICAgICB9XG4gICAgcmV0dXJuIHN0ci5qb2luKFwiJlwiKTtcbiAgfVxuICBcbiAgaWYob3B0aW9ucy5xcyl7XG4gICAgdmFyIHFzID0gKHR5cGVvZiBvcHRpb25zLnFzID09ICdzdHJpbmcnKT8gb3B0aW9ucy5xcyA6IHNlcmlhbGl6ZShvcHRpb25zLnFzKTtcbiAgICBpZihvcHRpb25zLnVyaS5pbmRleE9mKCc/JykgIT09IC0xKXsgLy9ubyBnZXQgcGFyYW1zXG4gICAgICAgIG9wdGlvbnMudXJpID0gb3B0aW9ucy51cmkrJyYnK3FzO1xuICAgIH1lbHNleyAvL2V4aXN0aW5nIGdldCBwYXJhbXNcbiAgICAgICAgb3B0aW9ucy51cmkgPSBvcHRpb25zLnVyaSsnPycrcXM7XG4gICAgfVxuICB9XG4gIC8vRU5EIFFTIEhhY2tcbiAgXG4gIC8vQkVHSU4gRk9STSBIYWNrXG4gIHZhciBtdWx0aXBhcnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICAvL3RvZG86IHN1cHBvcnQgZmlsZSB0eXBlICh1c2VmdWw/KVxuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICByZXN1bHQuYm91bmRyeSA9ICctLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJytNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqMTAwMDAwMDAwMCk7XG4gICAgdmFyIGxpbmVzID0gW107XG4gICAgZm9yKHZhciBwIGluIG9iail7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgICAgIGxpbmVzLnB1c2goXG4gICAgICAgICAgICAgICAgJy0tJytyZXN1bHQuYm91bmRyeStcIlxcblwiK1xuICAgICAgICAgICAgICAgICdDb250ZW50LURpc3Bvc2l0aW9uOiBmb3JtLWRhdGE7IG5hbWU9XCInK3ArJ1wiJytcIlxcblwiK1xuICAgICAgICAgICAgICAgIFwiXFxuXCIrXG4gICAgICAgICAgICAgICAgb2JqW3BdK1wiXFxuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGluZXMucHVzaCggJy0tJytyZXN1bHQuYm91bmRyeSsnLS0nICk7XG4gICAgcmVzdWx0LmJvZHkgPSBsaW5lcy5qb2luKCcnKTtcbiAgICByZXN1bHQubGVuZ3RoID0gcmVzdWx0LmJvZHkubGVuZ3RoO1xuICAgIHJlc3VsdC50eXBlID0gJ211bHRpcGFydC9mb3JtLWRhdGE7IGJvdW5kYXJ5PScrcmVzdWx0LmJvdW5kcnk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBcbiAgaWYob3B0aW9ucy5mb3JtKXtcbiAgICBpZih0eXBlb2Ygb3B0aW9ucy5mb3JtID09ICdzdHJpbmcnKSB0aHJvdygnZm9ybSBuYW1lIHVuc3VwcG9ydGVkJyk7XG4gICAgaWYob3B0aW9ucy5tZXRob2QgPT09ICdQT1NUJyl7XG4gICAgICAgIHZhciBlbmNvZGluZyA9IChvcHRpb25zLmVuY29kaW5nIHx8ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBvcHRpb25zLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gZW5jb2Rpbmc7XG4gICAgICAgIHN3aXRjaChlbmNvZGluZyl7XG4gICAgICAgICAgICBjYXNlICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnOlxuICAgICAgICAgICAgICAgIG9wdGlvbnMuYm9keSA9IHNlcmlhbGl6ZShvcHRpb25zLmZvcm0pLnJlcGxhY2UoLyUyMC9nLCBcIitcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtdWx0aXBhcnQvZm9ybS1kYXRhJzpcbiAgICAgICAgICAgICAgICB2YXIgbXVsdGkgPSBtdWx0aXBhcnQob3B0aW9ucy5mb3JtKTtcbiAgICAgICAgICAgICAgICAvL29wdGlvbnMuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXSA9IG11bHRpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmJvZHkgPSBtdWx0aS5ib2R5O1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVyc1snY29udGVudC10eXBlJ10gPSBtdWx0aS50eXBlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdCA6IHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgZW5jb2Rpbmc6JytlbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy9FTkQgRk9STSBIYWNrXG5cbiAgLy8gSWYgb25SZXNwb25zZSBpcyBib29sZWFuIHRydWUsIGNhbGwgYmFjayBpbW1lZGlhdGVseSB3aGVuIHRoZSByZXNwb25zZSBpcyBrbm93bixcbiAgLy8gbm90IHdoZW4gdGhlIGZ1bGwgcmVxdWVzdCBpcyBjb21wbGV0ZS5cbiAgb3B0aW9ucy5vblJlc3BvbnNlID0gb3B0aW9ucy5vblJlc3BvbnNlIHx8IG5vb3BcbiAgaWYob3B0aW9ucy5vblJlc3BvbnNlID09PSB0cnVlKSB7XG4gICAgb3B0aW9ucy5vblJlc3BvbnNlID0gY2FsbGJhY2tcbiAgICBvcHRpb25zLmNhbGxiYWNrID0gbm9vcFxuICB9XG5cbiAgLy8gWFhYIEJyb3dzZXJzIGRvIG5vdCBsaWtlIHRoaXMuXG4gIC8vaWYob3B0aW9ucy5ib2R5KVxuICAvLyAgb3B0aW9ucy5oZWFkZXJzWydjb250ZW50LWxlbmd0aCddID0gb3B0aW9ucy5ib2R5Lmxlbmd0aDtcblxuICAvLyBIVFRQIGJhc2ljIGF1dGhlbnRpY2F0aW9uXG4gIGlmKCFvcHRpb25zLmhlYWRlcnMuYXV0aG9yaXphdGlvbiAmJiBvcHRpb25zLmF1dGgpXG4gICAgb3B0aW9ucy5oZWFkZXJzLmF1dGhvcml6YXRpb24gPSAnQmFzaWMgJyArIGI2NF9lbmMob3B0aW9ucy5hdXRoLnVzZXJuYW1lICsgJzonICsgb3B0aW9ucy5hdXRoLnBhc3N3b3JkKTtcblxuICByZXR1cm4gcnVuX3hocihvcHRpb25zKVxufVxuXG52YXIgcmVxX3NlcSA9IDBcbmZ1bmN0aW9uIHJ1bl94aHIob3B0aW9ucykge1xuICB2YXIgeGhyID0gbmV3IFhIUlxuICAgICwgdGltZWRfb3V0ID0gZmFsc2VcbiAgICAsIGlzX2NvcnMgPSBpc19jcm9zc0RvbWFpbihvcHRpb25zLnVyaSlcbiAgICAsIHN1cHBvcnRzX2NvcnMgPSAoJ3dpdGhDcmVkZW50aWFscycgaW4geGhyKVxuXG4gIHJlcV9zZXEgKz0gMVxuICB4aHIuc2VxX2lkID0gcmVxX3NlcVxuICB4aHIuaWQgPSByZXFfc2VxICsgJzogJyArIG9wdGlvbnMubWV0aG9kICsgJyAnICsgb3B0aW9ucy51cmlcbiAgeGhyLl9pZCA9IHhoci5pZCAvLyBJIGtub3cgSSB3aWxsIHR5cGUgXCJfaWRcIiBmcm9tIGhhYml0IGFsbCB0aGUgdGltZS5cblxuICBpZihpc19jb3JzICYmICFzdXBwb3J0c19jb3JzKSB7XG4gICAgdmFyIGNvcnNfZXJyID0gbmV3IEVycm9yKCdCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgY3Jvc3Mtb3JpZ2luIHJlcXVlc3Q6ICcgKyBvcHRpb25zLnVyaSlcbiAgICBjb3JzX2Vyci5jb3JzID0gJ3Vuc3VwcG9ydGVkJ1xuICAgIHJldHVybiBvcHRpb25zLmNhbGxiYWNrKGNvcnNfZXJyLCB4aHIpXG4gIH1cblxuICB4aHIudGltZW91dFRpbWVyID0gc2V0VGltZW91dCh0b29fbGF0ZSwgb3B0aW9ucy50aW1lb3V0KVxuICBmdW5jdGlvbiB0b29fbGF0ZSgpIHtcbiAgICB0aW1lZF9vdXQgPSB0cnVlXG4gICAgdmFyIGVyID0gbmV3IEVycm9yKCdFVElNRURPVVQnKVxuICAgIGVyLmNvZGUgPSAnRVRJTUVET1VUJ1xuICAgIGVyLmR1cmF0aW9uID0gb3B0aW9ucy50aW1lb3V0XG5cbiAgICByZXF1ZXN0LmxvZy5lcnJvcignVGltZW91dCcsIHsgJ2lkJzp4aHIuX2lkLCAnbWlsbGlzZWNvbmRzJzpvcHRpb25zLnRpbWVvdXQgfSlcbiAgICByZXR1cm4gb3B0aW9ucy5jYWxsYmFjayhlciwgeGhyKVxuICB9XG5cbiAgLy8gU29tZSBzdGF0ZXMgY2FuIGJlIHNraXBwZWQgb3Zlciwgc28gcmVtZW1iZXIgd2hhdCBpcyBzdGlsbCBpbmNvbXBsZXRlLlxuICB2YXIgZGlkID0geydyZXNwb25zZSc6ZmFsc2UsICdsb2FkaW5nJzpmYWxzZSwgJ2VuZCc6ZmFsc2V9XG5cbiAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG9uX3N0YXRlX2NoYW5nZVxuICB4aHIub3BlbihvcHRpb25zLm1ldGhvZCwgb3B0aW9ucy51cmksIHRydWUpIC8vIGFzeW5jaHJvbm91c1xuICBpZihpc19jb3JzKVxuICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSAhISBvcHRpb25zLndpdGhDcmVkZW50aWFsc1xuICB4aHIuc2VuZChvcHRpb25zLmJvZHkpXG4gIHJldHVybiB4aHJcblxuICBmdW5jdGlvbiBvbl9zdGF0ZV9jaGFuZ2UoZXZlbnQpIHtcbiAgICBpZih0aW1lZF9vdXQpXG4gICAgICByZXR1cm4gcmVxdWVzdC5sb2cuZGVidWcoJ0lnbm9yaW5nIHRpbWVkIG91dCBzdGF0ZSBjaGFuZ2UnLCB7J3N0YXRlJzp4aHIucmVhZHlTdGF0ZSwgJ2lkJzp4aHIuaWR9KVxuXG4gICAgcmVxdWVzdC5sb2cuZGVidWcoJ1N0YXRlIGNoYW5nZScsIHsnc3RhdGUnOnhoci5yZWFkeVN0YXRlLCAnaWQnOnhoci5pZCwgJ3RpbWVkX291dCc6dGltZWRfb3V0fSlcblxuICAgIGlmKHhoci5yZWFkeVN0YXRlID09PSBYSFIuT1BFTkVEKSB7XG4gICAgICByZXF1ZXN0LmxvZy5kZWJ1ZygnUmVxdWVzdCBzdGFydGVkJywgeydpZCc6eGhyLmlkfSlcbiAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zLmhlYWRlcnMpXG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgb3B0aW9ucy5oZWFkZXJzW2tleV0pXG4gICAgfVxuXG4gICAgZWxzZSBpZih4aHIucmVhZHlTdGF0ZSA9PT0gWEhSLkhFQURFUlNfUkVDRUlWRUQpXG4gICAgICBvbl9yZXNwb25zZSgpXG5cbiAgICBlbHNlIGlmKHhoci5yZWFkeVN0YXRlID09PSBYSFIuTE9BRElORykge1xuICAgICAgb25fcmVzcG9uc2UoKVxuICAgICAgb25fbG9hZGluZygpXG4gICAgfVxuXG4gICAgZWxzZSBpZih4aHIucmVhZHlTdGF0ZSA9PT0gWEhSLkRPTkUpIHtcbiAgICAgIG9uX3Jlc3BvbnNlKClcbiAgICAgIG9uX2xvYWRpbmcoKVxuICAgICAgb25fZW5kKClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbl9yZXNwb25zZSgpIHtcbiAgICBpZihkaWQucmVzcG9uc2UpXG4gICAgICByZXR1cm5cblxuICAgIGRpZC5yZXNwb25zZSA9IHRydWVcbiAgICByZXF1ZXN0LmxvZy5kZWJ1ZygnR290IHJlc3BvbnNlJywgeydpZCc6eGhyLmlkLCAnc3RhdHVzJzp4aHIuc3RhdHVzfSlcbiAgICBjbGVhclRpbWVvdXQoeGhyLnRpbWVvdXRUaW1lcilcbiAgICB4aHIuc3RhdHVzQ29kZSA9IHhoci5zdGF0dXMgLy8gTm9kZSByZXF1ZXN0IGNvbXBhdGliaWxpdHlcblxuICAgIC8vIERldGVjdCBmYWlsZWQgQ09SUyByZXF1ZXN0cy5cbiAgICBpZihpc19jb3JzICYmIHhoci5zdGF0dXNDb2RlID09IDApIHtcbiAgICAgIHZhciBjb3JzX2VyciA9IG5ldyBFcnJvcignQ09SUyByZXF1ZXN0IHJlamVjdGVkOiAnICsgb3B0aW9ucy51cmkpXG4gICAgICBjb3JzX2Vyci5jb3JzID0gJ3JlamVjdGVkJ1xuXG4gICAgICAvLyBEbyBub3QgcHJvY2VzcyB0aGlzIHJlcXVlc3QgZnVydGhlci5cbiAgICAgIGRpZC5sb2FkaW5nID0gdHJ1ZVxuICAgICAgZGlkLmVuZCA9IHRydWVcblxuICAgICAgcmV0dXJuIG9wdGlvbnMuY2FsbGJhY2soY29yc19lcnIsIHhocilcbiAgICB9XG5cbiAgICBvcHRpb25zLm9uUmVzcG9uc2UobnVsbCwgeGhyKVxuICB9XG5cbiAgZnVuY3Rpb24gb25fbG9hZGluZygpIHtcbiAgICBpZihkaWQubG9hZGluZylcbiAgICAgIHJldHVyblxuXG4gICAgZGlkLmxvYWRpbmcgPSB0cnVlXG4gICAgcmVxdWVzdC5sb2cuZGVidWcoJ1Jlc3BvbnNlIGJvZHkgbG9hZGluZycsIHsnaWQnOnhoci5pZH0pXG4gICAgLy8gVE9ETzogTWF5YmUgc2ltdWxhdGUgXCJkYXRhXCIgZXZlbnRzIGJ5IHdhdGNoaW5nIHhoci5yZXNwb25zZVRleHRcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uX2VuZCgpIHtcbiAgICBpZihkaWQuZW5kKVxuICAgICAgcmV0dXJuXG5cbiAgICBkaWQuZW5kID0gdHJ1ZVxuICAgIHJlcXVlc3QubG9nLmRlYnVnKCdSZXF1ZXN0IGRvbmUnLCB7J2lkJzp4aHIuaWR9KVxuXG4gICAgeGhyLmJvZHkgPSB4aHIucmVzcG9uc2VUZXh0XG4gICAgaWYob3B0aW9ucy5qc29uKSB7XG4gICAgICB0cnkgICAgICAgIHsgeGhyLmJvZHkgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpIH1cbiAgICAgIGNhdGNoIChlcikgeyByZXR1cm4gb3B0aW9ucy5jYWxsYmFjayhlciwgeGhyKSAgICAgICAgfVxuICAgIH1cblxuICAgIG9wdGlvbnMuY2FsbGJhY2sobnVsbCwgeGhyLCB4aHIuYm9keSlcbiAgfVxuXG59IC8vIHJlcXVlc3RcblxucmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZTtcbnJlcXVlc3QuREVGQVVMVF9USU1FT1VUID0gREVGQVVMVF9USU1FT1VUO1xuXG4vL1xuLy8gZGVmYXVsdHNcbi8vXG5cbnJlcXVlc3QuZGVmYXVsdHMgPSBmdW5jdGlvbihvcHRpb25zLCByZXF1ZXN0ZXIpIHtcbiAgdmFyIGRlZiA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICB2YXIgZCA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICBpZih0eXBlb2YgcGFyYW1zID09PSAnc3RyaW5nJylcbiAgICAgICAgcGFyYW1zID0geyd1cmknOiBwYXJhbXN9O1xuICAgICAgZWxzZSB7XG4gICAgICAgIHBhcmFtcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocGFyYW1zKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHBhcmFtc1tpXSA9PT0gdW5kZWZpbmVkKSBwYXJhbXNbaV0gPSBvcHRpb25zW2ldXG4gICAgICB9XG4gICAgICByZXR1cm4gbWV0aG9kKHBhcmFtcywgY2FsbGJhY2spXG4gICAgfVxuICAgIHJldHVybiBkXG4gIH1cbiAgdmFyIGRlID0gZGVmKHJlcXVlc3QpXG4gIGRlLmdldCA9IGRlZihyZXF1ZXN0LmdldClcbiAgZGUucG9zdCA9IGRlZihyZXF1ZXN0LnBvc3QpXG4gIGRlLnB1dCA9IGRlZihyZXF1ZXN0LnB1dClcbiAgZGUuaGVhZCA9IGRlZihyZXF1ZXN0LmhlYWQpXG4gIHJldHVybiBkZVxufVxuXG4vL1xuLy8gSFRUUCBtZXRob2Qgc2hvcnRjdXRzXG4vL1xuXG52YXIgc2hvcnRjdXRzID0gWyAnZ2V0JywgJ3B1dCcsICdwb3N0JywgJ2hlYWQnIF07XG5zaG9ydGN1dHMuZm9yRWFjaChmdW5jdGlvbihzaG9ydGN1dCkge1xuICB2YXIgbWV0aG9kID0gc2hvcnRjdXQudG9VcHBlckNhc2UoKTtcbiAgdmFyIGZ1bmMgICA9IHNob3J0Y3V0LnRvTG93ZXJDYXNlKCk7XG5cbiAgcmVxdWVzdFtmdW5jXSA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgICBpZih0eXBlb2Ygb3B0cyA9PT0gJ3N0cmluZycpXG4gICAgICBvcHRzID0geydtZXRob2QnOm1ldGhvZCwgJ3VyaSc6b3B0c307XG4gICAgZWxzZSB7XG4gICAgICBvcHRzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvcHRzKSk7XG4gICAgICBvcHRzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICB9XG5cbiAgICB2YXIgYXJncyA9IFtvcHRzXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFyZ3VtZW50cywgWzFdKSk7XG4gICAgcmV0dXJuIHJlcXVlc3QuYXBwbHkodGhpcywgYXJncyk7XG4gIH1cbn0pXG5cbi8vXG4vLyBDb3VjaERCIHNob3J0Y3V0XG4vL1xuXG5yZXF1ZXN0LmNvdWNoID0gZnVuY3Rpb24ob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKVxuICAgIG9wdGlvbnMgPSB7J3VyaSc6b3B0aW9uc31cblxuICAvLyBKdXN0IHVzZSB0aGUgcmVxdWVzdCBBUEkgdG8gZG8gSlNPTi5cbiAgb3B0aW9ucy5qc29uID0gdHJ1ZVxuICBpZihvcHRpb25zLmJvZHkpXG4gICAgb3B0aW9ucy5qc29uID0gb3B0aW9ucy5ib2R5XG4gIGRlbGV0ZSBvcHRpb25zLmJvZHlcblxuICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3BcblxuICB2YXIgeGhyID0gcmVxdWVzdChvcHRpb25zLCBjb3VjaF9oYW5kbGVyKVxuICByZXR1cm4geGhyXG5cbiAgZnVuY3Rpb24gY291Y2hfaGFuZGxlcihlciwgcmVzcCwgYm9keSkge1xuICAgIGlmKGVyKVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyLCByZXNwLCBib2R5KVxuXG4gICAgaWYoKHJlc3Auc3RhdHVzQ29kZSA8IDIwMCB8fCByZXNwLnN0YXR1c0NvZGUgPiAyOTkpICYmIGJvZHkuZXJyb3IpIHtcbiAgICAgIC8vIFRoZSBib2R5IGlzIGEgQ291Y2ggSlNPTiBvYmplY3QgaW5kaWNhdGluZyB0aGUgZXJyb3IuXG4gICAgICBlciA9IG5ldyBFcnJvcignQ291Y2hEQiBlcnJvcjogJyArIChib2R5LmVycm9yLnJlYXNvbiB8fCBib2R5LmVycm9yLmVycm9yKSlcbiAgICAgIGZvciAodmFyIGtleSBpbiBib2R5KVxuICAgICAgICBlcltrZXldID0gYm9keVtrZXldXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXIsIHJlc3AsIGJvZHkpO1xuICAgIH1cblxuICAgIHJldHVybiBjYWxsYmFjayhlciwgcmVzcCwgYm9keSk7XG4gIH1cbn1cblxuLy9cbi8vIFV0aWxpdHlcbi8vXG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiBnZXRMb2dnZXIoKSB7XG4gIHZhciBsb2dnZXIgPSB7fVxuICAgICwgbGV2ZWxzID0gWyd0cmFjZScsICdkZWJ1ZycsICdpbmZvJywgJ3dhcm4nLCAnZXJyb3InXVxuICAgICwgbGV2ZWwsIGlcblxuICBmb3IoaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXZlbCA9IGxldmVsc1tpXVxuXG4gICAgbG9nZ2VyW2xldmVsXSA9IG5vb3BcbiAgICBpZih0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZSAmJiBjb25zb2xlW2xldmVsXSlcbiAgICAgIGxvZ2dlcltsZXZlbF0gPSBmb3JtYXR0ZWQoY29uc29sZSwgbGV2ZWwpXG4gIH1cblxuICByZXR1cm4gbG9nZ2VyXG59XG5cbmZ1bmN0aW9uIGZvcm1hdHRlZChvYmosIG1ldGhvZCkge1xuICByZXR1cm4gZm9ybWF0dGVkX2xvZ2dlclxuXG4gIGZ1bmN0aW9uIGZvcm1hdHRlZF9sb2dnZXIoc3RyLCBjb250ZXh0KSB7XG4gICAgaWYodHlwZW9mIGNvbnRleHQgPT09ICdvYmplY3QnKVxuICAgICAgc3RyICs9ICcgJyArIEpTT04uc3RyaW5naWZ5KGNvbnRleHQpXG5cbiAgICByZXR1cm4gb2JqW21ldGhvZF0uY2FsbChvYmosIHN0cilcbiAgfVxufVxuXG4vLyBSZXR1cm4gd2hldGhlciBhIFVSTCBpcyBhIGNyb3NzLWRvbWFpbiByZXF1ZXN0LlxuZnVuY3Rpb24gaXNfY3Jvc3NEb21haW4odXJsKSB7XG4gIHZhciBydXJsID0gL14oW1xcd1xcK1xcLlxcLV0rOikoPzpcXC9cXC8oW15cXC8/IzpdKikoPzo6KFxcZCspKT8pPy9cblxuICAvLyBqUXVlcnkgIzgxMzgsIElFIG1heSB0aHJvdyBhbiBleGNlcHRpb24gd2hlbiBhY2Nlc3NpbmdcbiAgLy8gYSBmaWVsZCBmcm9tIHdpbmRvdy5sb2NhdGlvbiBpZiBkb2N1bWVudC5kb21haW4gaGFzIGJlZW4gc2V0XG4gIHZhciBhamF4TG9jYXRpb25cbiAgdHJ5IHsgYWpheExvY2F0aW9uID0gbG9jYXRpb24uaHJlZiB9XG4gIGNhdGNoIChlKSB7XG4gICAgLy8gVXNlIHRoZSBocmVmIGF0dHJpYnV0ZSBvZiBhbiBBIGVsZW1lbnQgc2luY2UgSUUgd2lsbCBtb2RpZnkgaXQgZ2l2ZW4gZG9jdW1lbnQubG9jYXRpb25cbiAgICBhamF4TG9jYXRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuICAgIGFqYXhMb2NhdGlvbi5ocmVmID0gXCJcIjtcbiAgICBhamF4TG9jYXRpb24gPSBhamF4TG9jYXRpb24uaHJlZjtcbiAgfVxuXG4gIHZhciBhamF4TG9jUGFydHMgPSBydXJsLmV4ZWMoYWpheExvY2F0aW9uLnRvTG93ZXJDYXNlKCkpIHx8IFtdXG4gICAgLCBwYXJ0cyA9IHJ1cmwuZXhlYyh1cmwudG9Mb3dlckNhc2UoKSApXG5cbiAgdmFyIHJlc3VsdCA9ICEhKFxuICAgIHBhcnRzICYmXG4gICAgKCAgcGFydHNbMV0gIT0gYWpheExvY1BhcnRzWzFdXG4gICAgfHwgcGFydHNbMl0gIT0gYWpheExvY1BhcnRzWzJdXG4gICAgfHwgKHBhcnRzWzNdIHx8IChwYXJ0c1sxXSA9PT0gXCJodHRwOlwiID8gODAgOiA0NDMpKSAhPSAoYWpheExvY1BhcnRzWzNdIHx8IChhamF4TG9jUGFydHNbMV0gPT09IFwiaHR0cDpcIiA/IDgwIDogNDQzKSlcbiAgICApXG4gIClcblxuICAvL2NvbnNvbGUuZGVidWcoJ2lzX2Nyb3NzRG9tYWluKCcrdXJsKycpIC0+ICcgKyByZXN1bHQpXG4gIHJldHVybiByZXN1bHRcbn1cblxuLy8gTUlUIExpY2Vuc2UgZnJvbSBodHRwOi8vcGhwanMub3JnL2Z1bmN0aW9ucy9iYXNlNjRfZW5jb2RlOjM1OFxuZnVuY3Rpb24gYjY0X2VuYyAoZGF0YSkge1xuICAgIC8vIEVuY29kZXMgc3RyaW5nIHVzaW5nIE1JTUUgYmFzZTY0IGFsZ29yaXRobVxuICAgIHZhciBiNjQgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCI7XG4gICAgdmFyIG8xLCBvMiwgbzMsIGgxLCBoMiwgaDMsIGg0LCBiaXRzLCBpID0gMCwgYWMgPSAwLCBlbmM9XCJcIiwgdG1wX2FyciA9IFtdO1xuXG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIC8vIGFzc3VtZSB1dGY4IGRhdGFcbiAgICAvLyBkYXRhID0gdGhpcy51dGY4X2VuY29kZShkYXRhKycnKTtcblxuICAgIGRvIHsgLy8gcGFjayB0aHJlZSBvY3RldHMgaW50byBmb3VyIGhleGV0c1xuICAgICAgICBvMSA9IGRhdGEuY2hhckNvZGVBdChpKyspO1xuICAgICAgICBvMiA9IGRhdGEuY2hhckNvZGVBdChpKyspO1xuICAgICAgICBvMyA9IGRhdGEuY2hhckNvZGVBdChpKyspO1xuXG4gICAgICAgIGJpdHMgPSBvMTw8MTYgfCBvMjw8OCB8IG8zO1xuXG4gICAgICAgIGgxID0gYml0cz4+MTggJiAweDNmO1xuICAgICAgICBoMiA9IGJpdHM+PjEyICYgMHgzZjtcbiAgICAgICAgaDMgPSBiaXRzPj42ICYgMHgzZjtcbiAgICAgICAgaDQgPSBiaXRzICYgMHgzZjtcblxuICAgICAgICAvLyB1c2UgaGV4ZXRzIHRvIGluZGV4IGludG8gYjY0LCBhbmQgYXBwZW5kIHJlc3VsdCB0byBlbmNvZGVkIHN0cmluZ1xuICAgICAgICB0bXBfYXJyW2FjKytdID0gYjY0LmNoYXJBdChoMSkgKyBiNjQuY2hhckF0KGgyKSArIGI2NC5jaGFyQXQoaDMpICsgYjY0LmNoYXJBdChoNCk7XG4gICAgfSB3aGlsZSAoaSA8IGRhdGEubGVuZ3RoKTtcblxuICAgIGVuYyA9IHRtcF9hcnIuam9pbignJyk7XG5cbiAgICBzd2l0Y2ggKGRhdGEubGVuZ3RoICUgMykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBlbmMgPSBlbmMuc2xpY2UoMCwgLTIpICsgJz09JztcbiAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGVuYyA9IGVuYy5zbGljZSgwLCAtMSkgKyAnPSc7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBlbmM7XG59XG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4vL1VNRCBGT09URVIgU1RBUlRcbn0pKTtcbi8vVU1EIEZPT1RFUiBFTkRcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYnJvd3Nlci1yZXF1ZXN0L2luZGV4LmpzIiwiLy8gQ29weXJpZ2h0IDIwMTQgU2ltb24gTHlkZWxsXHJcbi8vIFgxMSAo4oCcTUlU4oCdKSBMaWNlbnNlZC4gKFNlZSBMSUNFTlNFLilcclxuXHJcbnZvaWQgKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcclxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcclxuICAgIGRlZmluZShmYWN0b3J5KVxyXG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpXHJcbiAgfSBlbHNlIHtcclxuICAgIHJvb3QucmVzb2x2ZVVybCA9IGZhY3RvcnkoKVxyXG4gIH1cclxufSh0aGlzLCBmdW5jdGlvbigpIHtcclxuXHJcbiAgZnVuY3Rpb24gcmVzb2x2ZVVybCgvKiAuLi51cmxzICovKSB7XHJcbiAgICB2YXIgbnVtVXJscyA9IGFyZ3VtZW50cy5sZW5ndGhcclxuXHJcbiAgICBpZiAobnVtVXJscyA9PT0gMCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZXNvbHZlVXJsIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBhcmd1bWVudDsgZ290IG5vbmUuXCIpXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGJhc2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYmFzZVwiKVxyXG4gICAgYmFzZS5ocmVmID0gYXJndW1lbnRzWzBdXHJcblxyXG4gICAgaWYgKG51bVVybHMgPT09IDEpIHtcclxuICAgICAgcmV0dXJuIGJhc2UuaHJlZlxyXG4gICAgfVxyXG5cclxuICAgIHZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdXHJcbiAgICBoZWFkLmluc2VydEJlZm9yZShiYXNlLCBoZWFkLmZpcnN0Q2hpbGQpXHJcblxyXG4gICAgdmFyIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKVxyXG4gICAgdmFyIHJlc29sdmVkXHJcblxyXG4gICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IG51bVVybHM7IGluZGV4KyspIHtcclxuICAgICAgYS5ocmVmID0gYXJndW1lbnRzW2luZGV4XVxyXG4gICAgICByZXNvbHZlZCA9IGEuaHJlZlxyXG4gICAgICBiYXNlLmhyZWYgPSByZXNvbHZlZFxyXG4gICAgfVxyXG5cclxuICAgIGhlYWQucmVtb3ZlQ2hpbGQoYmFzZSlcclxuXHJcbiAgICByZXR1cm4gcmVzb2x2ZWRcclxuICB9XHJcblxyXG4gIHJldHVybiByZXNvbHZlVXJsXHJcblxyXG59KSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVzb2x2ZS11cmwvcmVzb2x2ZS11cmwuanMiLCJ2YXIgZW5naW5lID0gcmVxdWlyZSgnLi4vc3JjL3N0b3JlLWVuZ2luZScpXG5cbnZhciBzdG9yYWdlcyA9IHJlcXVpcmUoJy4uL3N0b3JhZ2VzL2FsbCcpXG52YXIgcGx1Z2lucyA9IFtyZXF1aXJlKCcuLi9wbHVnaW5zL2pzb24yJyldXG5cbm1vZHVsZS5leHBvcnRzID0gZW5naW5lLmNyZWF0ZVN0b3JlKHN0b3JhZ2VzLCBwbHVnaW5zKVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zdG9yZS9kaXN0L3N0b3JlLmxlZ2FjeS5qcyIsImNvbnN0IG1lcmdlID0gcmVxdWlyZSggJ2xvZGFzaC5tZXJnZScgKTtcblxuY29uc3QgdmFsaWRhdGUgPSByZXF1aXJlKCAnLi4vdmFsaWRhdGUnICk7XG5jb25zdCBWYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCAnLi4vdmFsaWRhdGUvdmFsaWRhdGlvbkVycm9yJyApO1xuY29uc3Qgbm9ybWFsaXplQXJndW1lbnRzID0gcmVxdWlyZSggJy4uL3ZhbGlkYXRlL25vcm1hbGl6ZUFyZ3VtZW50cycgKTtcbmNvbnN0IFBsdWdpbiA9IHJlcXVpcmUoICcuLi9wbHVnaW4nICk7XG5cbmZ1bmN0aW9uIGluaXRpYWxpemUoIGJyaW5rYml0ICkge1xuICAgIGNsYXNzIFBsYXllciBleHRlbmRzIFBsdWdpbiB7XG5cbiAgICAgICAgY29uc3RydWN0b3IoIGNvbmZpZyApIHtcbiAgICAgICAgICAgIHN1cGVyKCBicmlua2JpdCwge30sIGNvbmZpZyApO1xuICAgICAgICAgICAgdGhpcy5yZWFkID0gWyAnX2lkJywgJ2RhdGVDcmVhdGVkJywgJ2VtYWlsJywgJ3VzZXJuYW1lJyBdO1xuICAgICAgICAgICAgdGhpcy53cml0ZSA9IFsgJ2VtYWlsJywgJ3Bhc3N3b3JkJywgJ3VzZXJuYW1lJyBdO1xuICAgICAgICAgICAgaWYgKCBjb25maWcgKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGUuY29uc3RydWN0b3IoIGNvbmZpZywge1xuICAgICAgICAgICAgICAgICAgICB1c2VybmFtZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBlbWFpbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwYXNzd29yZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IGNvbmZpZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWlkZGxld2FyZS5zYXZlID0gdGhpcy5zYXZlTWlkZGxld2FyZS5iaW5kKCB0aGlzICk7XG4gICAgICAgIH1cblxuICAgICAgICBsb2dpbiggLi4uYXJncyApIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBub3JtYWxpemVBcmd1bWVudHMoIC4uLmFyZ3MgKTtcbiAgICAgICAgICAgIG9wdGlvbnMucGFzc3dvcmQgPSBvcHRpb25zLnVyaTtcbiAgICAgICAgICAgIG9wdGlvbnMudXJpID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnJpbmtiaXQubG9naW4oIG1lcmdlKHt9LCB0aGlzLmRhdGEsIG9wdGlvbnMgKSlcbiAgICAgICAgICAgIC50aGVuKCggdXNlciApID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRva2VuID0gdXNlci50b2tlbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9nb3V0KCkge1xuICAgICAgICAgICAgdGhpcy50b2tlbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICggdGhpcy5pc1ByaW1hcnkgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5icmlua2JpdC5sb2dvdXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHByb21vdGUoKSB7XG4gICAgICAgICAgICB0aGlzLmJyaW5rYml0LnByb21vdGVQbGF5ZXIoIHRoaXMgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNhdmVNaWRkbGV3YXJlKCBvcHRpb25zICkge1xuICAgICAgICAgICAgaWYgKCAhdGhpcy5pZCApIG9wdGlvbnMucGFzc1Rva2VuID0gZmFsc2U7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmJvZHkudXNlcm5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5ib2R5LnBhc3N3b3JkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICAgIH1cblxuICAgICAgICBnZXRVcmwoIG1ldGhvZCApIHtcbiAgICAgICAgICAgIHN3aXRjaCAoIG1ldGhvZCApIHtcbiAgICAgICAgICAgICAgICBjYXNlICdwb3N0JzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcuL3BsYXllcnMvJztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYC4vcGxheWVycy8ke3RoaXMuaWR9L2A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YWxpZGF0ZSggbWV0aG9kLCBkYXRhICkge1xuICAgICAgICAgICAgc3dpdGNoICggbWV0aG9kICkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RlbGV0ZSc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5pZCA9PT0gJ3N0cmluZycgP1xuICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5yZWplY3QoIG5ldyBWYWxpZGF0aW9uRXJyb3IoICdDYW5ub3QgZGVsZXRlIHVzZXIgd2l0aG91dCBpZCcgKSk7XG4gICAgICAgICAgICAgICAgY2FzZSAncG9zdCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZSggZGF0YSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcm5hbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VuY2U6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZW1haWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VuY2U6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VuY2U6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjYXNlICdwdXQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdGUoIGRhdGEsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJuYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlbmNlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBlbWFpbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXNzd29yZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVzZW5jZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuaWQgPT09ICdzdHJpbmcnID9cbiAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2UucmVqZWN0KCBuZXcgVmFsaWRhdGlvbkVycm9yKCAnQ2Fubm90IGZldGNoIHVzZXIgd2l0aG91dCBpZCcgKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBQbGF5ZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIG5hbWU6ICdQbGF5ZXInLFxuICAgIGluaXRpYWxpemUsXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BsYXllci9pbmRleC5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEN1c3RvbUVycm9yO1xuQ3VzdG9tRXJyb3IuZmFjdG9yeSA9IHJlcXVpcmUoJy4vZmFjdG9yaWVzLmpzJyk7XG5cbnZhciBFcnIgPSBDdXN0b21FcnJvcignQ3VzdG9tRXJyb3InKTtcbkVyci5vcmRlciA9IEN1c3RvbUVycm9yKEVyciwgeyBtZXNzYWdlOiAnQXJndW1lbnRzIG91dCBvZiBvcmRlci4nLCBjb2RlOiAnRU9BUkcnIH0pO1xuXG4vKipcbiAqIENyZWF0ZSBhIGN1c3RvbSBlcnJvclxuICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXSBUaGUgbmFtZSB0byBnaXZlIHRoZSBlcnJvci4gRGVmYXVsdHMgdG8gdGhlIG5hbWUgb2YgaXQncyBwYXJlbnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcGFyZW50XSBUaGUgRXJyb3Igb3IgQ3VzdG9tRXJyb3IgY29uc3RydWN0b3IgdG8gaW5oZXJpdCBmcm9tLlxuICogQHBhcmFtIHtvYmplY3R9IFtwcm9wZXJ0aWVzXSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzIGZvciB0aGUgY3VzdG9tIGVycm9yLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2ZhY3RvcnldIEEgZnVuY3Rpb24gdG8gY2FsbCB0byBtb2RpZnkgdGhlIGN1c3RvbSBlcnJvciBpbnN0YW5jZSB3aGVuIGl0IGlzIGluc3RhbnRpYXRlZC5cbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gdGhhdCBzaG91bGQgYmUgdXNlZCBhcyBhIGNvbnN0cnVjdG9yLlxuICovXG5mdW5jdGlvbiBDdXN0b21FcnJvcihuYW1lLCBwYXJlbnQsIHByb3BlcnRpZXMsIGZhY3RvcnkpIHtcbiAgICB2YXIgY29uc3RydWN0O1xuICAgIHZhciBpc1Jvb3Q7XG5cbiAgICAvLyBub3JtYWxpemUgYXJndW1lbnRzXG4gICAgcGFyZW50ID0gZmluZEFyZyhhcmd1bWVudHMsIDEsIEVycm9yLCBpc1BhcmVudEFyZywgW2lzUHJvcGVydGllc0FyZywgaXNGYWN0b3J5QXJnXSk7XG4gICAgcHJvcGVydGllcyA9IGZpbmRBcmcoYXJndW1lbnRzLCAyLCB7fSwgaXNQcm9wZXJ0aWVzQXJnLCBbaXNGYWN0b3J5QXJnXSk7XG4gICAgZmFjdG9yeSA9IGZpbmRBcmcoYXJndW1lbnRzLCAzLCBub29wLCBpc0ZhY3RvcnlBcmcsIFtdKTtcbiAgICBuYW1lID0gZmluZEFyZyhhcmd1bWVudHMsIDAsIHBhcmVudCA9PT0gRXJyb3IgPyAnRXJyb3InIDogcGFyZW50LnByb3RvdHlwZS5DdXN0b21FcnJvci5uYW1lLCBpc05hbWVBcmcsIFtpc1BhcmVudEFyZywgaXNQcm9wZXJ0aWVzQXJnLCBpc0ZhY3RvcnlBcmddKTtcblxuICAgIC8vIGlmIHRoaXMgaXMgdGhlIHJvb3QgYW5kIHRoZWlyIGlzIG5vIGZhY3RvcnkgdGhlbiB1c2UgdGhlIGRlZmF1bHQgcm9vdCBmYWN0b3J5XG4gICAgaXNSb290ID0gcGFyZW50ID09PSBFcnJvcjtcbiAgICBpZiAoaXNSb290ICYmIGZhY3RvcnkgPT09IG5vb3ApIGZhY3RvcnkgPSBDdXN0b21FcnJvci5mYWN0b3J5LnJvb3Q7XG5cbiAgICAvLyBidWlsZCB0aGUgY29uc3RydWN0b3IgZnVuY3Rpb25cbiAgICBjb25zdHJ1Y3QgPSBmdW5jdGlvbihtZXNzYWdlLCBjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgdmFyIGFyO1xuICAgICAgICB2YXIgZmFjdG9yaWVzO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgIHZhciBwcm9wcztcblxuICAgICAgICAvLyBmb3JjZSB0aGlzIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcga2V5d29yZFxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgY29uc3RydWN0KSkgcmV0dXJuIG5ldyBjb25zdHJ1Y3QobWVzc2FnZSwgY29uZmlndXJhdGlvbik7XG5cbiAgICAgICAgLy8gcmVuYW1lIHRoZSBjb25zdHJ1Y3RvclxuICAgICAgICBkZWxldGUgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5jb25zdHJ1Y3RvciwgJ25hbWUnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuYW1lLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHRoZSBtZXNzYWdlIGlzIGFuIG9iamVjdFxuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSBtZXNzYWdlID0geyBtZXNzYWdlOiBtZXNzYWdlIH07XG4gICAgICAgIGlmICghbWVzc2FnZSkgbWVzc2FnZSA9IHt9O1xuXG4gICAgICAgIC8vIGJ1aWxkIHRoZSBwcm9wZXJ0aWVzIG9iamVjdFxuICAgICAgICBhciA9IHRoaXMuQ3VzdG9tRXJyb3IuY2hhaW4uc2xpY2UoMCkucmV2ZXJzZSgpLm1hcChmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWUucHJvcGVydGllcyB9KTtcbiAgICAgICAgYXIucHVzaChtZXNzYWdlKTtcbiAgICAgICAgYXIudW5zaGlmdCh7fSk7XG4gICAgICAgIHByb3BzID0gT2JqZWN0LmFzc2lnbi5hcHBseShPYmplY3QsIGFyKTtcblxuICAgICAgICAvLyBidWlsZCB0aGUgZmFjdG9yaWVzIGNhbGxlciAoZm9yY2luZyBzY29wZSB0byB0aGlzKVxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGZhY3RvcmllcyA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhDdXN0b21FcnJvci5mYWN0b3J5KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgZmFjdG9yaWVzW2tleV0gPSBmdW5jdGlvbihwcm9wcywgY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgQ3VzdG9tRXJyb3IuZmFjdG9yeVtrZXldLmNhbGwoX3RoaXMsIHByb3BzLCBjb25maWcsIGZhY3Rvcmllcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjYWxsIGVhY2ggZmFjdG9yeSBpbiB0aGUgY2hhaW4sIHN0YXJ0aW5nIGF0IHRoZSByb290XG4gICAgICAgIGZvciAoaSA9IHRoaXMuQ3VzdG9tRXJyb3IuY2hhaW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGl0ZW0gPSB0aGlzLkN1c3RvbUVycm9yLmNoYWluW2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0uZmFjdG9yeSAhPT0gbm9vcCkge1xuICAgICAgICAgICAgICAgIGl0ZW0uZmFjdG9yeS5jYWxsKHRoaXMsIHByb3BzLCBjb25maWd1cmF0aW9uLCBmYWN0b3JpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIGNhdXNlIHRoZSBmdW5jdGlvbiBwcm90b3R5cGUgdG8gaW5oZXJpdCBmcm9tIHBhcmVudCdzIHByb3RvdHlwZVxuICAgIGNvbnN0cnVjdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHBhcmVudC5wcm90b3R5cGUpO1xuICAgIGNvbnN0cnVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjb25zdHJ1Y3Q7XG5cbiAgICAvLyB1cGRhdGUgZXJyb3IgbmFtZVxuICAgIGNvbnN0cnVjdC5wcm90b3R5cGUubmFtZSA9IG5hbWU7XG5cbiAgICAvLyBhZGQgZGV0YWlscyBhYm91dCB0aGUgY3VzdG9tIGVycm9yIHRvIHRoZSBwcm90b3R5cGVcbiAgICBjb25zdHJ1Y3QucHJvdG90eXBlLkN1c3RvbUVycm9yID0ge1xuICAgICAgICBjaGFpbjogaXNSb290ID8gW10gOiBwYXJlbnQucHJvdG90eXBlLkN1c3RvbUVycm9yLmNoYWluLnNsaWNlKDApLFxuICAgICAgICBmYWN0b3J5OiBmYWN0b3J5LFxuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgICAgcHJvcGVydGllczogcHJvcGVydGllc1xuICAgIH07XG4gICAgY29uc3RydWN0LnByb3RvdHlwZS5DdXN0b21FcnJvci5jaGFpbi51bnNoaWZ0KGNvbnN0cnVjdC5wcm90b3R5cGUuQ3VzdG9tRXJyb3IpO1xuXG4gICAgLy8gdXBkYXRlIHRoZSB0b1N0cmluZyBtZXRob2Qgb24gdGhlIHByb3RvdHlwZSB0byBhY2NlcHQgYSBjb2RlXG4gICAgY29uc3RydWN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5DdXN0b21FcnJvci5jaGFpblt0aGlzLkN1c3RvbUVycm9yLmNoYWluLmxlbmd0aCAtIDFdLm5hbWU7XG4gICAgICAgIGlmICh0aGlzLmNvZGUpIHJlc3VsdCAgKz0gJyAnICsgdGhpcy5jb2RlO1xuICAgICAgICBpZiAodGhpcy5tZXNzYWdlKSByZXN1bHQgKz0gJzogJyArIHRoaXMubWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGNvbnN0cnVjdDtcbn1cblxuXG5cblxuZnVuY3Rpb24gZmluZEFyZyhhcmdzLCBpbmRleCwgZGVmYXVsdFZhbHVlLCBmaWx0ZXIsIGFudGlGaWx0ZXJzKSB7XG4gICAgdmFyIGFudGkgPSAtMTtcbiAgICB2YXIgZm91bmQgPSAtMTtcbiAgICB2YXIgaTtcbiAgICB2YXIgajtcbiAgICB2YXIgbGVuID0gaW5kZXggPCBhcmdzLmxlbmd0aCA/IGluZGV4IDogYXJncy5sZW5ndGg7XG4gICAgdmFyIHZhbDtcblxuICAgIGZvciAoaSA9IDA7IGkgPD0gbGVuOyBpKyspIHtcbiAgICAgICAgdmFsID0gYXJnc1tpXTtcbiAgICAgICAgaWYgKGFudGkgPT09IC0xKSB7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgYW50aUZpbHRlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYW50aUZpbHRlcnNbal0odmFsKSkgYW50aSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvdW5kID09PSAtMSAmJiBmaWx0ZXIodmFsKSkge1xuICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZvdW5kICE9PSAtMSAmJiBhbnRpICE9PSAtMSAmJiBhbnRpIDwgZm91bmQpIHRocm93IG5ldyBFcnIub3JkZXIoKTtcbiAgICByZXR1cm4gZm91bmQgIT09IC0xID9hcmdzW2ZvdW5kXSA6IGRlZmF1bHRWYWx1ZTtcbn1cblxuZnVuY3Rpb24gaXNGYWN0b3J5QXJnKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZSAhPT0gRXJyb3IgJiYgIXZhbHVlLnByb3RvdHlwZS5DdXN0b21FcnJvcjtcbn1cblxuZnVuY3Rpb24gaXNOYW1lQXJnKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG59XG5cbmZ1bmN0aW9uIGlzUGFyZW50QXJnKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiAodmFsdWUgPT09IEVycm9yIHx8IHZhbHVlLnByb3RvdHlwZS5DdXN0b21FcnJvcik7XG59XG5cbmZ1bmN0aW9uIGlzUHJvcGVydGllc0FyZyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2N1c3RvbS1lcnJvci1pbnN0YW5jZS9iaW4vZXJyb3IuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5leHBlY3RSZWNlaXZlID0gZnVuY3Rpb24ocHJvcGVydGllcywgY29uZmlndXJhdGlvbiwgZmFjdG9yeSkge1xuICAgIHZhciBtZXNzYWdlO1xuICAgIGZhY3Rvcnkucm9vdChwcm9wZXJ0aWVzLCBjb25maWd1cmF0aW9uLCBmYWN0b3J5KTtcblxuICAgIG1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2U7XG4gICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoJ2V4cGVjdGVkJykpIG1lc3NhZ2UgKz0gJyBFeHBlY3RlZCAnICsgcHJvcGVydGllcy5leHBlY3RlZCArICcuJztcbiAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eSgncmVjZWl2ZWQnKSkgbWVzc2FnZSArPSAnIFJlY2VpdmVkOiAnICsgcHJvcGVydGllcy5yZWNlaXZlZCArICcuJztcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufTtcblxuZXhwb3J0cy5yb290ID0gZnVuY3Rpb24ocHJvcGVydGllcywgY29uZmlndXJhdGlvbiwgZmFjdG9yaWVzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgY29kZTtcbiAgICB2YXIgY29uZmlnID0geyBzdGFja0xlbmd0aDogRXJyb3Iuc3RhY2tUcmFjZUxpbWl0LCByb290T25seTogdHJ1ZSB9O1xuICAgIHZhciBtZXNzYWdlU3RyID0gJyc7XG4gICAgdmFyIG9yaWdpbmFsU3RhY2tMZW5ndGggPSBFcnJvci5zdGFja1RyYWNlTGltaXQ7XG4gICAgdmFyIHN0YWNrO1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlU3RhY2soKSB7XG4gICAgICAgIHN0YWNrWzBdID0gX3RoaXMudG9TdHJpbmcoKTtcbiAgICAgICAgX3RoaXMuc3RhY2sgPSBzdGFjay5qb2luKCdcXG4nKTtcbiAgICB9XG5cbiAgICAvLyBnZXQgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAgaWYgKCFjb25maWd1cmF0aW9uIHx8IHR5cGVvZiBjb25maWd1cmF0aW9uICE9PSAnb2JqZWN0JykgY29uZmlndXJhdGlvbiA9IHt9O1xuICAgIGlmIChjb25maWd1cmF0aW9uLmhhc093blByb3BlcnR5KCdzdGFja0xlbmd0aCcpICYmXG4gICAgICAgIHR5cGVvZiBjb25maWd1cmF0aW9uLnN0YWNrTGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAhaXNOYU4oY29uZmlndXJhdGlvbi5zdGFja0xlbmd0aCkgJiZcbiAgICAgICAgY29uZmlndXJhdGlvbi5zdGFja0xlbmd0aCA+PSAwKSBjb25maWcuc3RhY2tMZW5ndGggPSBjb25maWd1cmF0aW9uLnN0YWNrTGVuZ3RoO1xuICAgIGlmICghY29uZmlndXJhdGlvbi5oYXNPd25Qcm9wZXJ0eSgncm9vdE9ubHknKSkgY29uZmlnLnJvb3RPbmx5ID0gY29uZmlndXJhdGlvbi5yb290T25seTtcblxuICAgIC8vIGNoZWNrIGlmIHRoaXMgc2hvdWxkIG9ubHkgYmUgcnVuIGFzIHJvb3RcbiAgICBpZiAoIWNvbmZpZy5yb290T25seSB8fCB0aGlzLkN1c3RvbUVycm9yLnBhcmVudCA9PT0gRXJyb3IpIHtcblxuICAgICAgICAvLyBjb3B5IHByb3BlcnRpZXMgb250byB0aGlzIG9iamVjdFxuICAgICAgICBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgc3dpdGNoKGtleSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NvZGUnOlxuICAgICAgICAgICAgICAgICAgICBjb2RlID0gcHJvcGVydGllcy5jb2RlIHx8IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWVzc2FnZSc6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VTdHIgPSBwcm9wZXJ0aWVzLm1lc3NhZ2UgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIF90aGlzW2tleV0gPSBwcm9wZXJ0aWVzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGdlbmVyYXRlIHRoZSBzdGFjayB0cmFjZVxuICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSBjb25maWcuc3RhY2tMZW5ndGggKyAyO1xuICAgICAgICBzdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgICBzdGFjay5zcGxpY2UoMCwgMyk7XG4gICAgICAgIHN0YWNrLnVuc2hpZnQoJycpO1xuICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSBvcmlnaW5hbFN0YWNrTGVuZ3RoO1xuICAgICAgICB0aGlzLnN0YWNrID0gc3RhY2suam9pbignXFxuJyk7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb2RlJywge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvZGUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB1cGRhdGVTdGFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ21lc3NhZ2UnLCB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZVN0cjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZVN0ciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHVwZGF0ZVN0YWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgdXBkYXRlU3RhY2soKTtcblxuICAgIH1cbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jdXN0b20tZXJyb3ItaW5zdGFuY2UvYmluL2ZhY3Rvcmllcy5qcyIsIlxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Jpbi9lcnJvcicpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jdXN0b20tZXJyb3ItaW5zdGFuY2UvaW5kZXguanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gICAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvYXNzaWduJylcbiAgLCBub3JtYWxpemVPcHRzID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3Qvbm9ybWFsaXplLW9wdGlvbnMnKVxuICAsIGlzQ2FsbGFibGUgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9pcy1jYWxsYWJsZScpXG4gICwgY29udGFpbnMgICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvc3RyaW5nLyMvY29udGFpbnMnKVxuXG4gICwgZDtcblxuZCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRzY3IsIHZhbHVlLyosIG9wdGlvbnMqLykge1xuXHR2YXIgYywgZSwgdywgb3B0aW9ucywgZGVzYztcblx0aWYgKChhcmd1bWVudHMubGVuZ3RoIDwgMikgfHwgKHR5cGVvZiBkc2NyICE9PSAnc3RyaW5nJykpIHtcblx0XHRvcHRpb25zID0gdmFsdWU7XG5cdFx0dmFsdWUgPSBkc2NyO1xuXHRcdGRzY3IgPSBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdG9wdGlvbnMgPSBhcmd1bWVudHNbMl07XG5cdH1cblx0aWYgKGRzY3IgPT0gbnVsbCkge1xuXHRcdGMgPSB3ID0gdHJ1ZTtcblx0XHRlID0gZmFsc2U7XG5cdH0gZWxzZSB7XG5cdFx0YyA9IGNvbnRhaW5zLmNhbGwoZHNjciwgJ2MnKTtcblx0XHRlID0gY29udGFpbnMuY2FsbChkc2NyLCAnZScpO1xuXHRcdHcgPSBjb250YWlucy5jYWxsKGRzY3IsICd3Jyk7XG5cdH1cblxuXHRkZXNjID0geyB2YWx1ZTogdmFsdWUsIGNvbmZpZ3VyYWJsZTogYywgZW51bWVyYWJsZTogZSwgd3JpdGFibGU6IHcgfTtcblx0cmV0dXJuICFvcHRpb25zID8gZGVzYyA6IGFzc2lnbihub3JtYWxpemVPcHRzKG9wdGlvbnMpLCBkZXNjKTtcbn07XG5cbmQuZ3MgPSBmdW5jdGlvbiAoZHNjciwgZ2V0LCBzZXQvKiwgb3B0aW9ucyovKSB7XG5cdHZhciBjLCBlLCBvcHRpb25zLCBkZXNjO1xuXHRpZiAodHlwZW9mIGRzY3IgIT09ICdzdHJpbmcnKSB7XG5cdFx0b3B0aW9ucyA9IHNldDtcblx0XHRzZXQgPSBnZXQ7XG5cdFx0Z2V0ID0gZHNjcjtcblx0XHRkc2NyID0gbnVsbDtcblx0fSBlbHNlIHtcblx0XHRvcHRpb25zID0gYXJndW1lbnRzWzNdO1xuXHR9XG5cdGlmIChnZXQgPT0gbnVsbCkge1xuXHRcdGdldCA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICghaXNDYWxsYWJsZShnZXQpKSB7XG5cdFx0b3B0aW9ucyA9IGdldDtcblx0XHRnZXQgPSBzZXQgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoc2V0ID09IG51bGwpIHtcblx0XHRzZXQgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIWlzQ2FsbGFibGUoc2V0KSkge1xuXHRcdG9wdGlvbnMgPSBzZXQ7XG5cdFx0c2V0ID0gdW5kZWZpbmVkO1xuXHR9XG5cdGlmIChkc2NyID09IG51bGwpIHtcblx0XHRjID0gdHJ1ZTtcblx0XHRlID0gZmFsc2U7XG5cdH0gZWxzZSB7XG5cdFx0YyA9IGNvbnRhaW5zLmNhbGwoZHNjciwgJ2MnKTtcblx0XHRlID0gY29udGFpbnMuY2FsbChkc2NyLCAnZScpO1xuXHR9XG5cblx0ZGVzYyA9IHsgZ2V0OiBnZXQsIHNldDogc2V0LCBjb25maWd1cmFibGU6IGMsIGVudW1lcmFibGU6IGUgfTtcblx0cmV0dXJuICFvcHRpb25zID8gZGVzYyA6IGFzc2lnbihub3JtYWxpemVPcHRzKG9wdGlvbnMpLCBkZXNjKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2QvaW5kZXguanMiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9pcy1pbXBsZW1lbnRlZCcpKClcblx0PyBPYmplY3QuYXNzaWduXG5cdDogcmVxdWlyZSgnLi9zaGltJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2VzNS1leHQvb2JqZWN0L2Fzc2lnbi9pbmRleC5qcyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduLCBvYmo7XG5cdGlmICh0eXBlb2YgYXNzaWduICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdG9iaiA9IHsgZm9vOiAncmF6JyB9O1xuXHRhc3NpZ24ob2JqLCB7IGJhcjogJ2R3YScgfSwgeyB0cnp5OiAndHJ6eScgfSk7XG5cdHJldHVybiAob2JqLmZvbyArIG9iai5iYXIgKyBvYmoudHJ6eSkgPT09ICdyYXpkd2F0cnp5Jztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2VzNS1leHQvb2JqZWN0L2Fzc2lnbi9pcy1pbXBsZW1lbnRlZC5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGtleXMgID0gcmVxdWlyZSgnLi4va2V5cycpXG4gICwgdmFsdWUgPSByZXF1aXJlKCcuLi92YWxpZC12YWx1ZScpXG5cbiAgLCBtYXggPSBNYXRoLm1heDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZGVzdCwgc3JjLyosIOKApnNyY24qLykge1xuXHR2YXIgZXJyb3IsIGksIGwgPSBtYXgoYXJndW1lbnRzLmxlbmd0aCwgMiksIGFzc2lnbjtcblx0ZGVzdCA9IE9iamVjdCh2YWx1ZShkZXN0KSk7XG5cdGFzc2lnbiA9IGZ1bmN0aW9uIChrZXkpIHtcblx0XHR0cnkgeyBkZXN0W2tleV0gPSBzcmNba2V5XTsgfSBjYXRjaCAoZSkge1xuXHRcdFx0aWYgKCFlcnJvcikgZXJyb3IgPSBlO1xuXHRcdH1cblx0fTtcblx0Zm9yIChpID0gMTsgaSA8IGw7ICsraSkge1xuXHRcdHNyYyA9IGFyZ3VtZW50c1tpXTtcblx0XHRrZXlzKHNyYykuZm9yRWFjaChhc3NpZ24pO1xuXHR9XG5cdGlmIChlcnJvciAhPT0gdW5kZWZpbmVkKSB0aHJvdyBlcnJvcjtcblx0cmV0dXJuIGRlc3Q7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9lczUtZXh0L29iamVjdC9hc3NpZ24vc2hpbS5qcyIsIi8vIERlcHJlY2F0ZWRcblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbic7IH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2VzNS1leHQvb2JqZWN0L2lzLWNhbGxhYmxlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vaXMtaW1wbGVtZW50ZWQnKSgpXG5cdD8gT2JqZWN0LmtleXNcblx0OiByZXF1aXJlKCcuL3NoaW0nKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZXM1LWV4dC9vYmplY3Qva2V5cy9pbmRleC5qcyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHRyeSB7XG5cdFx0T2JqZWN0LmtleXMoJ3ByaW1pdGl2ZScpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZXM1LWV4dC9vYmplY3Qva2V5cy9pcy1pbXBsZW1lbnRlZC5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGtleXMgPSBPYmplY3Qua2V5cztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG5cdHJldHVybiBrZXlzKG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogT2JqZWN0KG9iamVjdCkpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZXM1LWV4dC9vYmplY3Qva2V5cy9zaGltLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLCBjcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG52YXIgcHJvY2VzcyA9IGZ1bmN0aW9uIChzcmMsIG9iaikge1xuXHR2YXIga2V5O1xuXHRmb3IgKGtleSBpbiBzcmMpIG9ialtrZXldID0gc3JjW2tleV07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRpb25zLyosIOKApm9wdGlvbnMqLykge1xuXHR2YXIgcmVzdWx0ID0gY3JlYXRlKG51bGwpO1xuXHRmb3JFYWNoLmNhbGwoYXJndW1lbnRzLCBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdGlmIChvcHRpb25zID09IG51bGwpIHJldHVybjtcblx0XHRwcm9jZXNzKE9iamVjdChvcHRpb25zKSwgcmVzdWx0KTtcblx0fSk7XG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9lczUtZXh0L29iamVjdC9ub3JtYWxpemUtb3B0aW9ucy5qcyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4pIHtcblx0aWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcihmbiArIFwiIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuXHRyZXR1cm4gZm47XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9lczUtZXh0L29iamVjdC92YWxpZC1jYWxsYWJsZS5qcyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0aWYgKHZhbHVlID09IG51bGwpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgdXNlIG51bGwgb3IgdW5kZWZpbmVkXCIpO1xuXHRyZXR1cm4gdmFsdWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9lczUtZXh0L29iamVjdC92YWxpZC12YWx1ZS5qcyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2lzLWltcGxlbWVudGVkJykoKVxuXHQ/IFN0cmluZy5wcm90b3R5cGUuY29udGFpbnNcblx0OiByZXF1aXJlKCcuL3NoaW0nKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZXM1LWV4dC9zdHJpbmcvIy9jb250YWlucy9pbmRleC5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHN0ciA9ICdyYXpkd2F0cnp5JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdGlmICh0eXBlb2Ygc3RyLmNvbnRhaW5zICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdHJldHVybiAoKHN0ci5jb250YWlucygnZHdhJykgPT09IHRydWUpICYmIChzdHIuY29udGFpbnMoJ2ZvbycpID09PSBmYWxzZSkpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZXM1LWV4dC9zdHJpbmcvIy9jb250YWlucy9pcy1pbXBsZW1lbnRlZC5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGluZGV4T2YgPSBTdHJpbmcucHJvdG90eXBlLmluZGV4T2Y7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlYXJjaFN0cmluZy8qLCBwb3NpdGlvbiovKSB7XG5cdHJldHVybiBpbmRleE9mLmNhbGwodGhpcywgc2VhcmNoU3RyaW5nLCBhcmd1bWVudHNbMV0pID4gLTE7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9lczUtZXh0L3N0cmluZy8jL2NvbnRhaW5zL3NoaW0uanMiLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMCxcbiAgICBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sLFxuICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCA/IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucGlja2Agd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gKiBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nW119IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBwaWNrLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYmFzZVBpY2sob2JqZWN0LCBwcm9wcykge1xuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwcm9wcywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJldHVybiBrZXkgaW4gb2JqZWN0O1xuICB9KTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiAgYF8ucGlja0J5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gcGljayBmcm9tLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGJhc2VQaWNrQnkob2JqZWN0LCBwcm9wcywgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0ge307XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdLFxuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwga2V5KSkge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gYXJyYXk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZmxhdHRlbmFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpIHx8XG4gICAgISEoc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAvLyBTYWZhcmkgOC4xIG1ha2VzIGBhcmd1bWVudHMuY2FsbGVlYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxuICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICghcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpIHx8IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFyZ3NUYWcpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA4LTkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGlzT2JqZWN0KHZhbHVlKSA/IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBwaWNrZWQgYG9iamVjdGAgcHJvcGVydGllcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3Byb3BzXSBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gcGljay5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICpcbiAqIF8ucGljayhvYmplY3QsIFsnYScsICdjJ10pO1xuICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gKi9cbnZhciBwaWNrID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBwcm9wcykge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB7fSA6IGJhc2VQaWNrKG9iamVjdCwgYXJyYXlNYXAoYmFzZUZsYXR0ZW4ocHJvcHMsIDEpLCB0b0tleSkpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGljaztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoLnBpY2svaW5kZXguanMiLCIoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGpzb24yUGx1Z2luXG5cbmZ1bmN0aW9uIGpzb24yUGx1Z2luKCkge1xuXHRyZXF1aXJlKCcuL2xpYi9qc29uMicpXG5cdHJldHVybiB7fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zdG9yZS9wbHVnaW5zL2pzb24yLmpzIiwiLyogZXNsaW50LWRpc2FibGUgKi9cblxuLy8gIGpzb24yLmpzXG4vLyAgMjAxNi0xMC0yOFxuLy8gIFB1YmxpYyBEb21haW4uXG4vLyAgTk8gV0FSUkFOVFkgRVhQUkVTU0VEIE9SIElNUExJRUQuIFVTRSBBVCBZT1VSIE9XTiBSSVNLLlxuLy8gIFNlZSBodHRwOi8vd3d3LkpTT04ub3JnL2pzLmh0bWxcbi8vICBUaGlzIGNvZGUgc2hvdWxkIGJlIG1pbmlmaWVkIGJlZm9yZSBkZXBsb3ltZW50LlxuLy8gIFNlZSBodHRwOi8vamF2YXNjcmlwdC5jcm9ja2ZvcmQuY29tL2pzbWluLmh0bWxcblxuLy8gIFVTRSBZT1VSIE9XTiBDT1BZLiBJVCBJUyBFWFRSRU1FTFkgVU5XSVNFIFRPIExPQUQgQ09ERSBGUk9NIFNFUlZFUlMgWU9VIERPXG4vLyAgTk9UIENPTlRST0wuXG5cbi8vICBUaGlzIGZpbGUgY3JlYXRlcyBhIGdsb2JhbCBKU09OIG9iamVjdCBjb250YWluaW5nIHR3byBtZXRob2RzOiBzdHJpbmdpZnlcbi8vICBhbmQgcGFyc2UuIFRoaXMgZmlsZSBwcm92aWRlcyB0aGUgRVM1IEpTT04gY2FwYWJpbGl0eSB0byBFUzMgc3lzdGVtcy5cbi8vICBJZiBhIHByb2plY3QgbWlnaHQgcnVuIG9uIElFOCBvciBlYXJsaWVyLCB0aGVuIHRoaXMgZmlsZSBzaG91bGQgYmUgaW5jbHVkZWQuXG4vLyAgVGhpcyBmaWxlIGRvZXMgbm90aGluZyBvbiBFUzUgc3lzdGVtcy5cblxuLy8gICAgICBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlKVxuLy8gICAgICAgICAgdmFsdWUgICAgICAgYW55IEphdmFTY3JpcHQgdmFsdWUsIHVzdWFsbHkgYW4gb2JqZWN0IG9yIGFycmF5LlxuLy8gICAgICAgICAgcmVwbGFjZXIgICAgYW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgZGV0ZXJtaW5lcyBob3cgb2JqZWN0XG4vLyAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgYXJlIHN0cmluZ2lmaWVkIGZvciBvYmplY3RzLiBJdCBjYW4gYmUgYVxuLy8gICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbi8vICAgICAgICAgIHNwYWNlICAgICAgIGFuIG9wdGlvbmFsIHBhcmFtZXRlciB0aGF0IHNwZWNpZmllcyB0aGUgaW5kZW50YXRpb25cbi8vICAgICAgICAgICAgICAgICAgICAgIG9mIG5lc3RlZCBzdHJ1Y3R1cmVzLiBJZiBpdCBpcyBvbWl0dGVkLCB0aGUgdGV4dCB3aWxsXG4vLyAgICAgICAgICAgICAgICAgICAgICBiZSBwYWNrZWQgd2l0aG91dCBleHRyYSB3aGl0ZXNwYWNlLiBJZiBpdCBpcyBhIG51bWJlcixcbi8vICAgICAgICAgICAgICAgICAgICAgIGl0IHdpbGwgc3BlY2lmeSB0aGUgbnVtYmVyIG9mIHNwYWNlcyB0byBpbmRlbnQgYXQgZWFjaFxuLy8gICAgICAgICAgICAgICAgICAgICAgbGV2ZWwuIElmIGl0IGlzIGEgc3RyaW5nIChzdWNoIGFzIFwiXFx0XCIgb3IgXCImbmJzcDtcIiksXG4vLyAgICAgICAgICAgICAgICAgICAgICBpdCBjb250YWlucyB0aGUgY2hhcmFjdGVycyB1c2VkIHRvIGluZGVudCBhdCBlYWNoIGxldmVsLlxuLy8gICAgICAgICAgVGhpcyBtZXRob2QgcHJvZHVjZXMgYSBKU09OIHRleHQgZnJvbSBhIEphdmFTY3JpcHQgdmFsdWUuXG4vLyAgICAgICAgICBXaGVuIGFuIG9iamVjdCB2YWx1ZSBpcyBmb3VuZCwgaWYgdGhlIG9iamVjdCBjb250YWlucyBhIHRvSlNPTlxuLy8gICAgICAgICAgbWV0aG9kLCBpdHMgdG9KU09OIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBhbmQgdGhlIHJlc3VsdCB3aWxsIGJlXG4vLyAgICAgICAgICBzdHJpbmdpZmllZC4gQSB0b0pTT04gbWV0aG9kIGRvZXMgbm90IHNlcmlhbGl6ZTogaXQgcmV0dXJucyB0aGVcbi8vICAgICAgICAgIHZhbHVlIHJlcHJlc2VudGVkIGJ5IHRoZSBuYW1lL3ZhbHVlIHBhaXIgdGhhdCBzaG91bGQgYmUgc2VyaWFsaXplZCxcbi8vICAgICAgICAgIG9yIHVuZGVmaW5lZCBpZiBub3RoaW5nIHNob3VsZCBiZSBzZXJpYWxpemVkLiBUaGUgdG9KU09OIG1ldGhvZFxuLy8gICAgICAgICAgd2lsbCBiZSBwYXNzZWQgdGhlIGtleSBhc3NvY2lhdGVkIHdpdGggdGhlIHZhbHVlLCBhbmQgdGhpcyB3aWxsIGJlXG4vLyAgICAgICAgICBib3VuZCB0byB0aGUgdmFsdWUuXG5cbi8vICAgICAgICAgIEZvciBleGFtcGxlLCB0aGlzIHdvdWxkIHNlcmlhbGl6ZSBEYXRlcyBhcyBJU08gc3RyaW5ncy5cblxuLy8gICAgICAgICAgICAgIERhdGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIChrZXkpIHtcbi8vICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZihuKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAvLyBGb3JtYXQgaW50ZWdlcnMgdG8gaGF2ZSBhdCBsZWFzdCB0d28gZGlnaXRzLlxuLy8gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChuIDwgMTApXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcIjBcIiArIG5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICA6IG47XG4vLyAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VVRDRnVsbFllYXIoKSAgICsgXCItXCIgK1xuLy8gICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENNb250aCgpICsgMSkgKyBcIi1cIiArXG4vLyAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ0RhdGUoKSkgICAgICArIFwiVFwiICtcbi8vICAgICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDSG91cnMoKSkgICAgICsgXCI6XCIgK1xuLy8gICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENNaW51dGVzKCkpICAgKyBcIjpcIiArXG4vLyAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ1NlY29uZHMoKSkgICArIFwiWlwiO1xuLy8gICAgICAgICAgICAgIH07XG5cbi8vICAgICAgICAgIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbCByZXBsYWNlciBtZXRob2QuIEl0IHdpbGwgYmUgcGFzc2VkIHRoZVxuLy8gICAgICAgICAga2V5IGFuZCB2YWx1ZSBvZiBlYWNoIG1lbWJlciwgd2l0aCB0aGlzIGJvdW5kIHRvIHRoZSBjb250YWluaW5nXG4vLyAgICAgICAgICBvYmplY3QuIFRoZSB2YWx1ZSB0aGF0IGlzIHJldHVybmVkIGZyb20geW91ciBtZXRob2Qgd2lsbCBiZVxuLy8gICAgICAgICAgc2VyaWFsaXplZC4gSWYgeW91ciBtZXRob2QgcmV0dXJucyB1bmRlZmluZWQsIHRoZW4gdGhlIG1lbWJlciB3aWxsXG4vLyAgICAgICAgICBiZSBleGNsdWRlZCBmcm9tIHRoZSBzZXJpYWxpemF0aW9uLlxuXG4vLyAgICAgICAgICBJZiB0aGUgcmVwbGFjZXIgcGFyYW1ldGVyIGlzIGFuIGFycmF5IG9mIHN0cmluZ3MsIHRoZW4gaXQgd2lsbCBiZVxuLy8gICAgICAgICAgdXNlZCB0byBzZWxlY3QgdGhlIG1lbWJlcnMgdG8gYmUgc2VyaWFsaXplZC4gSXQgZmlsdGVycyB0aGUgcmVzdWx0c1xuLy8gICAgICAgICAgc3VjaCB0aGF0IG9ubHkgbWVtYmVycyB3aXRoIGtleXMgbGlzdGVkIGluIHRoZSByZXBsYWNlciBhcnJheSBhcmVcbi8vICAgICAgICAgIHN0cmluZ2lmaWVkLlxuXG4vLyAgICAgICAgICBWYWx1ZXMgdGhhdCBkbyBub3QgaGF2ZSBKU09OIHJlcHJlc2VudGF0aW9ucywgc3VjaCBhcyB1bmRlZmluZWQgb3Jcbi8vICAgICAgICAgIGZ1bmN0aW9ucywgd2lsbCBub3QgYmUgc2VyaWFsaXplZC4gU3VjaCB2YWx1ZXMgaW4gb2JqZWN0cyB3aWxsIGJlXG4vLyAgICAgICAgICBkcm9wcGVkOyBpbiBhcnJheXMgdGhleSB3aWxsIGJlIHJlcGxhY2VkIHdpdGggbnVsbC4gWW91IGNhbiB1c2Vcbi8vICAgICAgICAgIGEgcmVwbGFjZXIgZnVuY3Rpb24gdG8gcmVwbGFjZSB0aG9zZSB3aXRoIEpTT04gdmFsdWVzLlxuXG4vLyAgICAgICAgICBKU09OLnN0cmluZ2lmeSh1bmRlZmluZWQpIHJldHVybnMgdW5kZWZpbmVkLlxuXG4vLyAgICAgICAgICBUaGUgb3B0aW9uYWwgc3BhY2UgcGFyYW1ldGVyIHByb2R1Y2VzIGEgc3RyaW5naWZpY2F0aW9uIG9mIHRoZVxuLy8gICAgICAgICAgdmFsdWUgdGhhdCBpcyBmaWxsZWQgd2l0aCBsaW5lIGJyZWFrcyBhbmQgaW5kZW50YXRpb24gdG8gbWFrZSBpdFxuLy8gICAgICAgICAgZWFzaWVyIHRvIHJlYWQuXG5cbi8vICAgICAgICAgIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBub24tZW1wdHkgc3RyaW5nLCB0aGVuIHRoYXQgc3RyaW5nIHdpbGxcbi8vICAgICAgICAgIGJlIHVzZWQgZm9yIGluZGVudGF0aW9uLiBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgbnVtYmVyLCB0aGVuXG4vLyAgICAgICAgICB0aGUgaW5kZW50YXRpb24gd2lsbCBiZSB0aGF0IG1hbnkgc3BhY2VzLlxuXG4vLyAgICAgICAgICBFeGFtcGxlOlxuXG4vLyAgICAgICAgICB0ZXh0ID0gSlNPTi5zdHJpbmdpZnkoW1wiZVwiLCB7cGx1cmlidXM6IFwidW51bVwifV0pO1xuLy8gICAgICAgICAgLy8gdGV4dCBpcyAnW1wiZVwiLHtcInBsdXJpYnVzXCI6XCJ1bnVtXCJ9XSdcblxuLy8gICAgICAgICAgdGV4dCA9IEpTT04uc3RyaW5naWZ5KFtcImVcIiwge3BsdXJpYnVzOiBcInVudW1cIn1dLCBudWxsLCBcIlxcdFwiKTtcbi8vICAgICAgICAgIC8vIHRleHQgaXMgJ1tcXG5cXHRcImVcIixcXG5cXHR7XFxuXFx0XFx0XCJwbHVyaWJ1c1wiOiBcInVudW1cIlxcblxcdH1cXG5dJ1xuXG4vLyAgICAgICAgICB0ZXh0ID0gSlNPTi5zdHJpbmdpZnkoW25ldyBEYXRlKCldLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuLy8gICAgICAgICAgICAgIHJldHVybiB0aGlzW2tleV0gaW5zdGFuY2VvZiBEYXRlXG4vLyAgICAgICAgICAgICAgICAgID8gXCJEYXRlKFwiICsgdGhpc1trZXldICsgXCIpXCJcbi8vICAgICAgICAgICAgICAgICAgOiB2YWx1ZTtcbi8vICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgLy8gdGV4dCBpcyAnW1wiRGF0ZSgtLS1jdXJyZW50IHRpbWUtLS0pXCJdJ1xuXG4vLyAgICAgIEpTT04ucGFyc2UodGV4dCwgcmV2aXZlcilcbi8vICAgICAgICAgIFRoaXMgbWV0aG9kIHBhcnNlcyBhIEpTT04gdGV4dCB0byBwcm9kdWNlIGFuIG9iamVjdCBvciBhcnJheS5cbi8vICAgICAgICAgIEl0IGNhbiB0aHJvdyBhIFN5bnRheEVycm9yIGV4Y2VwdGlvbi5cblxuLy8gICAgICAgICAgVGhlIG9wdGlvbmFsIHJldml2ZXIgcGFyYW1ldGVyIGlzIGEgZnVuY3Rpb24gdGhhdCBjYW4gZmlsdGVyIGFuZFxuLy8gICAgICAgICAgdHJhbnNmb3JtIHRoZSByZXN1bHRzLiBJdCByZWNlaXZlcyBlYWNoIG9mIHRoZSBrZXlzIGFuZCB2YWx1ZXMsXG4vLyAgICAgICAgICBhbmQgaXRzIHJldHVybiB2YWx1ZSBpcyB1c2VkIGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIHZhbHVlLlxuLy8gICAgICAgICAgSWYgaXQgcmV0dXJucyB3aGF0IGl0IHJlY2VpdmVkLCB0aGVuIHRoZSBzdHJ1Y3R1cmUgaXMgbm90IG1vZGlmaWVkLlxuLy8gICAgICAgICAgSWYgaXQgcmV0dXJucyB1bmRlZmluZWQgdGhlbiB0aGUgbWVtYmVyIGlzIGRlbGV0ZWQuXG5cbi8vICAgICAgICAgIEV4YW1wbGU6XG5cbi8vICAgICAgICAgIC8vIFBhcnNlIHRoZSB0ZXh0LiBWYWx1ZXMgdGhhdCBsb29rIGxpa2UgSVNPIGRhdGUgc3RyaW5ncyB3aWxsXG4vLyAgICAgICAgICAvLyBiZSBjb252ZXJ0ZWQgdG8gRGF0ZSBvYmplY3RzLlxuXG4vLyAgICAgICAgICBteURhdGEgPSBKU09OLnBhcnNlKHRleHQsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4vLyAgICAgICAgICAgICAgdmFyIGE7XG4vLyAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuLy8gICAgICAgICAgICAgICAgICBhID1cbi8vICAgL14oXFxkezR9KS0oXFxkezJ9KS0oXFxkezJ9KVQoXFxkezJ9KTooXFxkezJ9KTooXFxkezJ9KD86XFwuXFxkKik/KVokLy5leGVjKHZhbHVlKTtcbi8vICAgICAgICAgICAgICAgICAgaWYgKGEpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygrYVsxXSwgK2FbMl0gLSAxLCArYVszXSwgK2FbNF0sXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgK2FbNV0sICthWzZdKSk7XG4vLyAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuLy8gICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgIG15RGF0YSA9IEpTT04ucGFyc2UoJ1tcIkRhdGUoMDkvMDkvMjAwMSlcIl0nLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuLy8gICAgICAgICAgICAgIHZhciBkO1xuLy8gICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcbi8vICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnNsaWNlKDAsIDUpID09PSBcIkRhdGUoXCIgJiZcbi8vICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnNsaWNlKC0xKSA9PT0gXCIpXCIpIHtcbi8vICAgICAgICAgICAgICAgICAgZCA9IG5ldyBEYXRlKHZhbHVlLnNsaWNlKDUsIC0xKSk7XG4vLyAgICAgICAgICAgICAgICAgIGlmIChkKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcbi8vICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4vLyAgICAgICAgICB9KTtcblxuLy8gIFRoaXMgaXMgYSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24uIFlvdSBhcmUgZnJlZSB0byBjb3B5LCBtb2RpZnksIG9yXG4vLyAgcmVkaXN0cmlidXRlLlxuXG4vKmpzbGludFxuICAgIGV2YWwsIGZvciwgdGhpc1xuKi9cblxuLypwcm9wZXJ0eVxuICAgIEpTT04sIGFwcGx5LCBjYWxsLCBjaGFyQ29kZUF0LCBnZXRVVENEYXRlLCBnZXRVVENGdWxsWWVhciwgZ2V0VVRDSG91cnMsXG4gICAgZ2V0VVRDTWludXRlcywgZ2V0VVRDTW9udGgsIGdldFVUQ1NlY29uZHMsIGhhc093blByb3BlcnR5LCBqb2luLFxuICAgIGxhc3RJbmRleCwgbGVuZ3RoLCBwYXJzZSwgcHJvdG90eXBlLCBwdXNoLCByZXBsYWNlLCBzbGljZSwgc3RyaW5naWZ5LFxuICAgIHRlc3QsIHRvSlNPTiwgdG9TdHJpbmcsIHZhbHVlT2ZcbiovXG5cblxuLy8gQ3JlYXRlIGEgSlNPTiBvYmplY3Qgb25seSBpZiBvbmUgZG9lcyBub3QgYWxyZWFkeSBleGlzdC4gV2UgY3JlYXRlIHRoZVxuLy8gbWV0aG9kcyBpbiBhIGNsb3N1cmUgdG8gYXZvaWQgY3JlYXRpbmcgZ2xvYmFsIHZhcmlhYmxlcy5cblxuaWYgKHR5cGVvZiBKU09OICE9PSBcIm9iamVjdFwiKSB7XG4gICAgSlNPTiA9IHt9O1xufVxuXG4oZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIHJ4X29uZSA9IC9eW1xcXSw6e31cXHNdKiQvO1xuICAgIHZhciByeF90d28gPSAvXFxcXCg/OltcIlxcXFxcXC9iZm5ydF18dVswLTlhLWZBLUZdezR9KS9nO1xuICAgIHZhciByeF90aHJlZSA9IC9cIlteXCJcXFxcXFxuXFxyXSpcInx0cnVlfGZhbHNlfG51bGx8LT9cXGQrKD86XFwuXFxkKik/KD86W2VFXVsrXFwtXT9cXGQrKT8vZztcbiAgICB2YXIgcnhfZm91ciA9IC8oPzpefDp8LCkoPzpcXHMqXFxbKSsvZztcbiAgICB2YXIgcnhfZXNjYXBhYmxlID0gL1tcXFxcXCJcXHUwMDAwLVxcdTAwMWZcXHUwMDdmLVxcdTAwOWZcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZztcbiAgICB2YXIgcnhfZGFuZ2Vyb3VzID0gL1tcXHUwMDAwXFx1MDBhZFxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2c7XG5cbiAgICBmdW5jdGlvbiBmKG4pIHtcbiAgICAgICAgLy8gRm9ybWF0IGludGVnZXJzIHRvIGhhdmUgYXQgbGVhc3QgdHdvIGRpZ2l0cy5cbiAgICAgICAgcmV0dXJuIG4gPCAxMFxuICAgICAgICAgICAgPyBcIjBcIiArIG5cbiAgICAgICAgICAgIDogbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0aGlzX3ZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBEYXRlLnByb3RvdHlwZS50b0pTT04gIT09IFwiZnVuY3Rpb25cIikge1xuXG4gICAgICAgIERhdGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIGlzRmluaXRlKHRoaXMudmFsdWVPZigpKVxuICAgICAgICAgICAgICAgID8gdGhpcy5nZXRVVENGdWxsWWVhcigpICsgXCItXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ01vbnRoKCkgKyAxKSArIFwiLVwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENEYXRlKCkpICsgXCJUXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ0hvdXJzKCkpICsgXCI6XCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ01pbnV0ZXMoKSkgKyBcIjpcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDU2Vjb25kcygpKSArIFwiWlwiXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnRvSlNPTiA9IHRoaXNfdmFsdWU7XG4gICAgICAgIE51bWJlci5wcm90b3R5cGUudG9KU09OID0gdGhpc192YWx1ZTtcbiAgICAgICAgU3RyaW5nLnByb3RvdHlwZS50b0pTT04gPSB0aGlzX3ZhbHVlO1xuICAgIH1cblxuICAgIHZhciBnYXA7XG4gICAgdmFyIGluZGVudDtcbiAgICB2YXIgbWV0YTtcbiAgICB2YXIgcmVwO1xuXG5cbiAgICBmdW5jdGlvbiBxdW90ZShzdHJpbmcpIHtcblxuLy8gSWYgdGhlIHN0cmluZyBjb250YWlucyBubyBjb250cm9sIGNoYXJhY3RlcnMsIG5vIHF1b3RlIGNoYXJhY3RlcnMsIGFuZCBub1xuLy8gYmFja3NsYXNoIGNoYXJhY3RlcnMsIHRoZW4gd2UgY2FuIHNhZmVseSBzbGFwIHNvbWUgcXVvdGVzIGFyb3VuZCBpdC5cbi8vIE90aGVyd2lzZSB3ZSBtdXN0IGFsc28gcmVwbGFjZSB0aGUgb2ZmZW5kaW5nIGNoYXJhY3RlcnMgd2l0aCBzYWZlIGVzY2FwZVxuLy8gc2VxdWVuY2VzLlxuXG4gICAgICAgIHJ4X2VzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICByZXR1cm4gcnhfZXNjYXBhYmxlLnRlc3Qoc3RyaW5nKVxuICAgICAgICAgICAgPyBcIlxcXCJcIiArIHN0cmluZy5yZXBsYWNlKHJ4X2VzY2FwYWJsZSwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IG1ldGFbYV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBjID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgID8gY1xuICAgICAgICAgICAgICAgICAgICA6IFwiXFxcXHVcIiArIChcIjAwMDBcIiArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICAgICAgICAgIH0pICsgXCJcXFwiXCJcbiAgICAgICAgICAgIDogXCJcXFwiXCIgKyBzdHJpbmcgKyBcIlxcXCJcIjtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHN0cihrZXksIGhvbGRlcikge1xuXG4vLyBQcm9kdWNlIGEgc3RyaW5nIGZyb20gaG9sZGVyW2tleV0uXG5cbiAgICAgICAgdmFyIGk7ICAgICAgICAgIC8vIFRoZSBsb29wIGNvdW50ZXIuXG4gICAgICAgIHZhciBrOyAgICAgICAgICAvLyBUaGUgbWVtYmVyIGtleS5cbiAgICAgICAgdmFyIHY7ICAgICAgICAgIC8vIFRoZSBtZW1iZXIgdmFsdWUuXG4gICAgICAgIHZhciBsZW5ndGg7XG4gICAgICAgIHZhciBtaW5kID0gZ2FwO1xuICAgICAgICB2YXIgcGFydGlhbDtcbiAgICAgICAgdmFyIHZhbHVlID0gaG9sZGVyW2tleV07XG5cbi8vIElmIHRoZSB2YWx1ZSBoYXMgYSB0b0pTT04gbWV0aG9kLCBjYWxsIGl0IHRvIG9idGFpbiBhIHJlcGxhY2VtZW50IHZhbHVlLlxuXG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUudG9KU09OID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKGtleSk7XG4gICAgICAgIH1cblxuLy8gSWYgd2Ugd2VyZSBjYWxsZWQgd2l0aCBhIHJlcGxhY2VyIGZ1bmN0aW9uLCB0aGVuIGNhbGwgdGhlIHJlcGxhY2VyIHRvXG4vLyBvYnRhaW4gYSByZXBsYWNlbWVudCB2YWx1ZS5cblxuICAgICAgICBpZiAodHlwZW9mIHJlcCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHJlcC5jYWxsKGhvbGRlciwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cblxuLy8gV2hhdCBoYXBwZW5zIG5leHQgZGVwZW5kcyBvbiB0aGUgdmFsdWUncyB0eXBlLlxuXG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBxdW90ZSh2YWx1ZSk7XG5cbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuXG4vLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIEVuY29kZSBub24tZmluaXRlIG51bWJlcnMgYXMgbnVsbC5cblxuICAgICAgICAgICAgcmV0dXJuIGlzRmluaXRlKHZhbHVlKVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKHZhbHVlKVxuICAgICAgICAgICAgICAgIDogXCJudWxsXCI7XG5cbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgY2FzZSBcIm51bGxcIjpcblxuLy8gSWYgdGhlIHZhbHVlIGlzIGEgYm9vbGVhbiBvciBudWxsLCBjb252ZXJ0IGl0IHRvIGEgc3RyaW5nLiBOb3RlOlxuLy8gdHlwZW9mIG51bGwgZG9lcyBub3QgcHJvZHVjZSBcIm51bGxcIi4gVGhlIGNhc2UgaXMgaW5jbHVkZWQgaGVyZSBpblxuLy8gdGhlIHJlbW90ZSBjaGFuY2UgdGhhdCB0aGlzIGdldHMgZml4ZWQgc29tZWRheS5cblxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG5cbi8vIElmIHRoZSB0eXBlIGlzIFwib2JqZWN0XCIsIHdlIG1pZ2h0IGJlIGRlYWxpbmcgd2l0aCBhbiBvYmplY3Qgb3IgYW4gYXJyYXkgb3Jcbi8vIG51bGwuXG5cbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuXG4vLyBEdWUgdG8gYSBzcGVjaWZpY2F0aW9uIGJsdW5kZXIgaW4gRUNNQVNjcmlwdCwgdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIixcbi8vIHNvIHdhdGNoIG91dCBmb3IgdGhhdCBjYXNlLlxuXG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICAgICAgfVxuXG4vLyBNYWtlIGFuIGFycmF5IHRvIGhvbGQgdGhlIHBhcnRpYWwgcmVzdWx0cyBvZiBzdHJpbmdpZnlpbmcgdGhpcyBvYmplY3QgdmFsdWUuXG5cbiAgICAgICAgICAgIGdhcCArPSBpbmRlbnQ7XG4gICAgICAgICAgICBwYXJ0aWFsID0gW107XG5cbi8vIElzIHRoZSB2YWx1ZSBhbiBhcnJheT9cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodmFsdWUpID09PSBcIltvYmplY3QgQXJyYXldXCIpIHtcblxuLy8gVGhlIHZhbHVlIGlzIGFuIGFycmF5LiBTdHJpbmdpZnkgZXZlcnkgZWxlbWVudC4gVXNlIG51bGwgYXMgYSBwbGFjZWhvbGRlclxuLy8gZm9yIG5vbi1KU09OIHZhbHVlcy5cblxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbFtpXSA9IHN0cihpLCB2YWx1ZSkgfHwgXCJudWxsXCI7XG4gICAgICAgICAgICAgICAgfVxuXG4vLyBKb2luIGFsbCBvZiB0aGUgZWxlbWVudHMgdG9nZXRoZXIsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcywgYW5kIHdyYXAgdGhlbSBpblxuLy8gYnJhY2tldHMuXG5cbiAgICAgICAgICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDBcbiAgICAgICAgICAgICAgICAgICAgPyBcIltdXCJcbiAgICAgICAgICAgICAgICAgICAgOiBnYXBcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCJbXFxuXCIgKyBnYXAgKyBwYXJ0aWFsLmpvaW4oXCIsXFxuXCIgKyBnYXApICsgXCJcXG5cIiArIG1pbmQgKyBcIl1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcIltcIiArIHBhcnRpYWwuam9pbihcIixcIikgKyBcIl1cIjtcbiAgICAgICAgICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfVxuXG4vLyBJZiB0aGUgcmVwbGFjZXIgaXMgYW4gYXJyYXksIHVzZSBpdCB0byBzZWxlY3QgdGhlIG1lbWJlcnMgdG8gYmUgc3RyaW5naWZpZWQuXG5cbiAgICAgICAgICAgIGlmIChyZXAgJiYgdHlwZW9mIHJlcCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHJlcC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVwW2ldID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrID0gcmVwW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHN0cihrLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChxdW90ZShrKSArIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2FwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFwiOiBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIjpcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkgKyB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbi8vIE90aGVyd2lzZSwgaXRlcmF0ZSB0aHJvdWdoIGFsbCBvZiB0aGUga2V5cyBpbiB0aGUgb2JqZWN0LlxuXG4gICAgICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gc3RyKGssIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKHF1b3RlKGspICsgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gXCI6IFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiOlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSArIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4vLyBKb2luIGFsbCBvZiB0aGUgbWVtYmVyIHRleHRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsXG4vLyBhbmQgd3JhcCB0aGVtIGluIGJyYWNlcy5cblxuICAgICAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwXG4gICAgICAgICAgICAgICAgPyBcInt9XCJcbiAgICAgICAgICAgICAgICA6IGdhcFxuICAgICAgICAgICAgICAgICAgICA/IFwie1xcblwiICsgZ2FwICsgcGFydGlhbC5qb2luKFwiLFxcblwiICsgZ2FwKSArIFwiXFxuXCIgKyBtaW5kICsgXCJ9XCJcbiAgICAgICAgICAgICAgICAgICAgOiBcIntcIiArIHBhcnRpYWwuam9pbihcIixcIikgKyBcIn1cIjtcbiAgICAgICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgIH1cblxuLy8gSWYgdGhlIEpTT04gb2JqZWN0IGRvZXMgbm90IHlldCBoYXZlIGEgc3RyaW5naWZ5IG1ldGhvZCwgZ2l2ZSBpdCBvbmUuXG5cbiAgICBpZiAodHlwZW9mIEpTT04uc3RyaW5naWZ5ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgbWV0YSA9IHsgICAgLy8gdGFibGUgb2YgY2hhcmFjdGVyIHN1YnN0aXR1dGlvbnNcbiAgICAgICAgICAgIFwiXFxiXCI6IFwiXFxcXGJcIixcbiAgICAgICAgICAgIFwiXFx0XCI6IFwiXFxcXHRcIixcbiAgICAgICAgICAgIFwiXFxuXCI6IFwiXFxcXG5cIixcbiAgICAgICAgICAgIFwiXFxmXCI6IFwiXFxcXGZcIixcbiAgICAgICAgICAgIFwiXFxyXCI6IFwiXFxcXHJcIixcbiAgICAgICAgICAgIFwiXFxcIlwiOiBcIlxcXFxcXFwiXCIsXG4gICAgICAgICAgICBcIlxcXFxcIjogXCJcXFxcXFxcXFwiXG4gICAgICAgIH07XG4gICAgICAgIEpTT04uc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHZhbHVlLCByZXBsYWNlciwgc3BhY2UpIHtcblxuLy8gVGhlIHN0cmluZ2lmeSBtZXRob2QgdGFrZXMgYSB2YWx1ZSBhbmQgYW4gb3B0aW9uYWwgcmVwbGFjZXIsIGFuZCBhbiBvcHRpb25hbFxuLy8gc3BhY2UgcGFyYW1ldGVyLCBhbmQgcmV0dXJucyBhIEpTT04gdGV4dC4gVGhlIHJlcGxhY2VyIGNhbiBiZSBhIGZ1bmN0aW9uXG4vLyB0aGF0IGNhbiByZXBsYWNlIHZhbHVlcywgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0IHdpbGwgc2VsZWN0IHRoZSBrZXlzLlxuLy8gQSBkZWZhdWx0IHJlcGxhY2VyIG1ldGhvZCBjYW4gYmUgcHJvdmlkZWQuIFVzZSBvZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGNhblxuLy8gcHJvZHVjZSB0ZXh0IHRoYXQgaXMgbW9yZSBlYXNpbHkgcmVhZGFibGUuXG5cbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZ2FwID0gXCJcIjtcbiAgICAgICAgICAgIGluZGVudCA9IFwiXCI7XG5cbi8vIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBudW1iZXIsIG1ha2UgYW4gaW5kZW50IHN0cmluZyBjb250YWluaW5nIHRoYXRcbi8vIG1hbnkgc3BhY2VzLlxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNwYWNlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNwYWNlOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ICs9IFwiIFwiO1xuICAgICAgICAgICAgICAgIH1cblxuLy8gSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIHN0cmluZywgaXQgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbmRlbnQgc3RyaW5nLlxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzcGFjZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGluZGVudCA9IHNwYWNlO1xuICAgICAgICAgICAgfVxuXG4vLyBJZiB0aGVyZSBpcyBhIHJlcGxhY2VyLCBpdCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gYXJyYXkuXG4vLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yLlxuXG4gICAgICAgICAgICByZXAgPSByZXBsYWNlcjtcbiAgICAgICAgICAgIGlmIChyZXBsYWNlciAmJiB0eXBlb2YgcmVwbGFjZXIgIT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgICAgICAgICAodHlwZW9mIHJlcGxhY2VyICE9PSBcIm9iamVjdFwiIHx8XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiByZXBsYWNlci5sZW5ndGggIT09IFwibnVtYmVyXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSlNPTi5zdHJpbmdpZnlcIik7XG4gICAgICAgICAgICB9XG5cbi8vIE1ha2UgYSBmYWtlIHJvb3Qgb2JqZWN0IGNvbnRhaW5pbmcgb3VyIHZhbHVlIHVuZGVyIHRoZSBrZXkgb2YgXCJcIi5cbi8vIFJldHVybiB0aGUgcmVzdWx0IG9mIHN0cmluZ2lmeWluZyB0aGUgdmFsdWUuXG5cbiAgICAgICAgICAgIHJldHVybiBzdHIoXCJcIiwge1wiXCI6IHZhbHVlfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG5cbi8vIElmIHRoZSBKU09OIG9iamVjdCBkb2VzIG5vdCB5ZXQgaGF2ZSBhIHBhcnNlIG1ldGhvZCwgZ2l2ZSBpdCBvbmUuXG5cbiAgICBpZiAodHlwZW9mIEpTT04ucGFyc2UgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBKU09OLnBhcnNlID0gZnVuY3Rpb24gKHRleHQsIHJldml2ZXIpIHtcblxuLy8gVGhlIHBhcnNlIG1ldGhvZCB0YWtlcyBhIHRleHQgYW5kIGFuIG9wdGlvbmFsIHJldml2ZXIgZnVuY3Rpb24sIGFuZCByZXR1cm5zXG4vLyBhIEphdmFTY3JpcHQgdmFsdWUgaWYgdGhlIHRleHQgaXMgYSB2YWxpZCBKU09OIHRleHQuXG5cbiAgICAgICAgICAgIHZhciBqO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiB3YWxrKGhvbGRlciwga2V5KSB7XG5cbi8vIFRoZSB3YWxrIG1ldGhvZCBpcyB1c2VkIHRvIHJlY3Vyc2l2ZWx5IHdhbGsgdGhlIHJlc3VsdGluZyBzdHJ1Y3R1cmUgc29cbi8vIHRoYXQgbW9kaWZpY2F0aW9ucyBjYW4gYmUgbWFkZS5cblxuICAgICAgICAgICAgICAgIHZhciBrO1xuICAgICAgICAgICAgICAgIHZhciB2O1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGhvbGRlcltrZXldO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSB3YWxrKHZhbHVlLCBrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2tdID0gdjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVba107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXZpdmVyLmNhbGwoaG9sZGVyLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuXG4vLyBQYXJzaW5nIGhhcHBlbnMgaW4gZm91ciBzdGFnZXMuIEluIHRoZSBmaXJzdCBzdGFnZSwgd2UgcmVwbGFjZSBjZXJ0YWluXG4vLyBVbmljb2RlIGNoYXJhY3RlcnMgd2l0aCBlc2NhcGUgc2VxdWVuY2VzLiBKYXZhU2NyaXB0IGhhbmRsZXMgbWFueSBjaGFyYWN0ZXJzXG4vLyBpbmNvcnJlY3RseSwgZWl0aGVyIHNpbGVudGx5IGRlbGV0aW5nIHRoZW0sIG9yIHRyZWF0aW5nIHRoZW0gYXMgbGluZSBlbmRpbmdzLlxuXG4gICAgICAgICAgICB0ZXh0ID0gU3RyaW5nKHRleHQpO1xuICAgICAgICAgICAgcnhfZGFuZ2Vyb3VzLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICBpZiAocnhfZGFuZ2Vyb3VzLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHJ4X2Rhbmdlcm91cywgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHVcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiMDAwMFwiICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4vLyBJbiB0aGUgc2Vjb25kIHN0YWdlLCB3ZSBydW4gdGhlIHRleHQgYWdhaW5zdCByZWd1bGFyIGV4cHJlc3Npb25zIHRoYXQgbG9va1xuLy8gZm9yIG5vbi1KU09OIHBhdHRlcm5zLiBXZSBhcmUgZXNwZWNpYWxseSBjb25jZXJuZWQgd2l0aCBcIigpXCIgYW5kIFwibmV3XCJcbi8vIGJlY2F1c2UgdGhleSBjYW4gY2F1c2UgaW52b2NhdGlvbiwgYW5kIFwiPVwiIGJlY2F1c2UgaXQgY2FuIGNhdXNlIG11dGF0aW9uLlxuLy8gQnV0IGp1c3QgdG8gYmUgc2FmZSwgd2Ugd2FudCB0byByZWplY3QgYWxsIHVuZXhwZWN0ZWQgZm9ybXMuXG5cbi8vIFdlIHNwbGl0IHRoZSBzZWNvbmQgc3RhZ2UgaW50byA0IHJlZ2V4cCBvcGVyYXRpb25zIGluIG9yZGVyIHRvIHdvcmsgYXJvdW5kXG4vLyBjcmlwcGxpbmcgaW5lZmZpY2llbmNpZXMgaW4gSUUncyBhbmQgU2FmYXJpJ3MgcmVnZXhwIGVuZ2luZXMuIEZpcnN0IHdlXG4vLyByZXBsYWNlIHRoZSBKU09OIGJhY2tzbGFzaCBwYWlycyB3aXRoIFwiQFwiIChhIG5vbi1KU09OIGNoYXJhY3RlcikuIFNlY29uZCwgd2Vcbi8vIHJlcGxhY2UgYWxsIHNpbXBsZSB2YWx1ZSB0b2tlbnMgd2l0aCBcIl1cIiBjaGFyYWN0ZXJzLiBUaGlyZCwgd2UgZGVsZXRlIGFsbFxuLy8gb3BlbiBicmFja2V0cyB0aGF0IGZvbGxvdyBhIGNvbG9uIG9yIGNvbW1hIG9yIHRoYXQgYmVnaW4gdGhlIHRleHQuIEZpbmFsbHksXG4vLyB3ZSBsb29rIHRvIHNlZSB0aGF0IHRoZSByZW1haW5pbmcgY2hhcmFjdGVycyBhcmUgb25seSB3aGl0ZXNwYWNlIG9yIFwiXVwiIG9yXG4vLyBcIixcIiBvciBcIjpcIiBvciBcIntcIiBvciBcIn1cIi4gSWYgdGhhdCBpcyBzbywgdGhlbiB0aGUgdGV4dCBpcyBzYWZlIGZvciBldmFsLlxuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgcnhfb25lLnRlc3QoXG4gICAgICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHJ4X3R3bywgXCJAXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShyeF90aHJlZSwgXCJdXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShyeF9mb3VyLCBcIlwiKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkge1xuXG4vLyBJbiB0aGUgdGhpcmQgc3RhZ2Ugd2UgdXNlIHRoZSBldmFsIGZ1bmN0aW9uIHRvIGNvbXBpbGUgdGhlIHRleHQgaW50byBhXG4vLyBKYXZhU2NyaXB0IHN0cnVjdHVyZS4gVGhlIFwie1wiIG9wZXJhdG9yIGlzIHN1YmplY3QgdG8gYSBzeW50YWN0aWMgYW1iaWd1aXR5XG4vLyBpbiBKYXZhU2NyaXB0OiBpdCBjYW4gYmVnaW4gYSBibG9jayBvciBhbiBvYmplY3QgbGl0ZXJhbC4gV2Ugd3JhcCB0aGUgdGV4dFxuLy8gaW4gcGFyZW5zIHRvIGVsaW1pbmF0ZSB0aGUgYW1iaWd1aXR5LlxuXG4gICAgICAgICAgICAgICAgaiA9IGV2YWwoXCIoXCIgKyB0ZXh0ICsgXCIpXCIpO1xuXG4vLyBJbiB0aGUgb3B0aW9uYWwgZm91cnRoIHN0YWdlLCB3ZSByZWN1cnNpdmVseSB3YWxrIHRoZSBuZXcgc3RydWN0dXJlLCBwYXNzaW5nXG4vLyBlYWNoIG5hbWUvdmFsdWUgcGFpciB0byBhIHJldml2ZXIgZnVuY3Rpb24gZm9yIHBvc3NpYmxlIHRyYW5zZm9ybWF0aW9uLlxuXG4gICAgICAgICAgICAgICAgcmV0dXJuICh0eXBlb2YgcmV2aXZlciA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgICAgICA/IHdhbGsoe1wiXCI6IGp9LCBcIlwiKVxuICAgICAgICAgICAgICAgICAgICA6IGo7XG4gICAgICAgICAgICB9XG5cbi8vIElmIHRoZSB0ZXh0IGlzIG5vdCBKU09OIHBhcnNlYWJsZSwgdGhlbiBhIFN5bnRheEVycm9yIGlzIHRocm93bi5cblxuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiSlNPTi5wYXJzZVwiKTtcbiAgICAgICAgfTtcbiAgICB9XG59KCkpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc3RvcmUvcGx1Z2lucy9saWIvanNvbjIuanMiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpXG52YXIgc2xpY2UgPSB1dGlsLnNsaWNlXG52YXIgcGx1Y2sgPSB1dGlsLnBsdWNrXG52YXIgZWFjaCA9IHV0aWwuZWFjaFxudmFyIGJpbmQgPSB1dGlsLmJpbmRcbnZhciBjcmVhdGUgPSB1dGlsLmNyZWF0ZVxudmFyIGlzTGlzdCA9IHV0aWwuaXNMaXN0XG52YXIgaXNGdW5jdGlvbiA9IHV0aWwuaXNGdW5jdGlvblxudmFyIGlzT2JqZWN0ID0gdXRpbC5pc09iamVjdFxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0Y3JlYXRlU3RvcmU6IGNyZWF0ZVN0b3JlXG59XG5cbnZhciBzdG9yZUFQSSA9IHtcblx0dmVyc2lvbjogJzIuMC4xMicsXG5cdGVuYWJsZWQ6IGZhbHNlLFxuXHRcblx0Ly8gZ2V0IHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBrZXkuIElmIHRoYXQgdmFsdWVcblx0Ly8gaXMgdW5kZWZpbmVkLCBpdCByZXR1cm5zIG9wdGlvbmFsRGVmYXVsdFZhbHVlIGluc3RlYWQuXG5cdGdldDogZnVuY3Rpb24oa2V5LCBvcHRpb25hbERlZmF1bHRWYWx1ZSkge1xuXHRcdHZhciBkYXRhID0gdGhpcy5zdG9yYWdlLnJlYWQodGhpcy5fbmFtZXNwYWNlUHJlZml4ICsga2V5KVxuXHRcdHJldHVybiB0aGlzLl9kZXNlcmlhbGl6ZShkYXRhLCBvcHRpb25hbERlZmF1bHRWYWx1ZSlcblx0fSxcblxuXHQvLyBzZXQgd2lsbCBzdG9yZSB0aGUgZ2l2ZW4gdmFsdWUgYXQga2V5IGFuZCByZXR1cm5zIHZhbHVlLlxuXHQvLyBDYWxsaW5nIHNldCB3aXRoIHZhbHVlID09PSB1bmRlZmluZWQgaXMgZXF1aXZhbGVudCB0byBjYWxsaW5nIHJlbW92ZS5cblx0c2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiB0aGlzLnJlbW92ZShrZXkpXG5cdFx0fVxuXHRcdHRoaXMuc3RvcmFnZS53cml0ZSh0aGlzLl9uYW1lc3BhY2VQcmVmaXggKyBrZXksIHRoaXMuX3NlcmlhbGl6ZSh2YWx1ZSkpXG5cdFx0cmV0dXJuIHZhbHVlXG5cdH0sXG5cblx0Ly8gcmVtb3ZlIGRlbGV0ZXMgdGhlIGtleSBhbmQgdmFsdWUgc3RvcmVkIGF0IHRoZSBnaXZlbiBrZXkuXG5cdHJlbW92ZTogZnVuY3Rpb24oa2V5KSB7XG5cdFx0dGhpcy5zdG9yYWdlLnJlbW92ZSh0aGlzLl9uYW1lc3BhY2VQcmVmaXggKyBrZXkpXG5cdH0sXG5cblx0Ly8gZWFjaCB3aWxsIGNhbGwgdGhlIGdpdmVuIGNhbGxiYWNrIG9uY2UgZm9yIGVhY2gga2V5LXZhbHVlIHBhaXJcblx0Ly8gaW4gdGhpcyBzdG9yZS5cblx0ZWFjaDogZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHR2YXIgc2VsZiA9IHRoaXNcblx0XHR0aGlzLnN0b3JhZ2UuZWFjaChmdW5jdGlvbih2YWwsIG5hbWVzcGFjZWRLZXkpIHtcblx0XHRcdGNhbGxiYWNrLmNhbGwoc2VsZiwgc2VsZi5fZGVzZXJpYWxpemUodmFsKSwgKG5hbWVzcGFjZWRLZXkgfHwgJycpLnJlcGxhY2Uoc2VsZi5fbmFtZXNwYWNlUmVnZXhwLCAnJykpXG5cdFx0fSlcblx0fSxcblxuXHQvLyBjbGVhckFsbCB3aWxsIHJlbW92ZSBhbGwgdGhlIHN0b3JlZCBrZXktdmFsdWUgcGFpcnMgaW4gdGhpcyBzdG9yZS5cblx0Y2xlYXJBbGw6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuc3RvcmFnZS5jbGVhckFsbCgpXG5cdH0sXG5cblx0Ly8gYWRkaXRpb25hbCBmdW5jdGlvbmFsaXR5IHRoYXQgY2FuJ3QgbGl2ZSBpbiBwbHVnaW5zXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdC8vIGhhc05hbWVzcGFjZSByZXR1cm5zIHRydWUgaWYgdGhpcyBzdG9yZSBpbnN0YW5jZSBoYXMgdGhlIGdpdmVuIG5hbWVzcGFjZS5cblx0aGFzTmFtZXNwYWNlOiBmdW5jdGlvbihuYW1lc3BhY2UpIHtcblx0XHRyZXR1cm4gKHRoaXMuX25hbWVzcGFjZVByZWZpeCA9PSAnX19zdG9yZWpzXycrbmFtZXNwYWNlKydfJylcblx0fSxcblxuXHQvLyBjcmVhdGVTdG9yZSBjcmVhdGVzIGEgc3RvcmUuanMgaW5zdGFuY2Ugd2l0aCB0aGUgZmlyc3Rcblx0Ly8gZnVuY3Rpb25pbmcgc3RvcmFnZSBpbiB0aGUgbGlzdCBvZiBzdG9yYWdlIGNhbmRpZGF0ZXMsXG5cdC8vIGFuZCBhcHBsaWVzIHRoZSB0aGUgZ2l2ZW4gbWl4aW5zIHRvIHRoZSBpbnN0YW5jZS5cblx0Y3JlYXRlU3RvcmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBjcmVhdGVTdG9yZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG5cdH0sXG5cdFxuXHRhZGRQbHVnaW46IGZ1bmN0aW9uKHBsdWdpbikge1xuXHRcdHRoaXMuX2FkZFBsdWdpbihwbHVnaW4pXG5cdH0sXG5cdFxuXHRuYW1lc3BhY2U6IGZ1bmN0aW9uKG5hbWVzcGFjZSkge1xuXHRcdHJldHVybiBjcmVhdGVTdG9yZSh0aGlzLnN0b3JhZ2UsIHRoaXMucGx1Z2lucywgbmFtZXNwYWNlKVxuXHR9XG59XG5cbmZ1bmN0aW9uIF93YXJuKCkge1xuXHR2YXIgX2NvbnNvbGUgPSAodHlwZW9mIGNvbnNvbGUgPT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogY29uc29sZSlcblx0aWYgKCFfY29uc29sZSkgeyByZXR1cm4gfVxuXHR2YXIgZm4gPSAoX2NvbnNvbGUud2FybiA/IF9jb25zb2xlLndhcm4gOiBfY29uc29sZS5sb2cpXG5cdGZuLmFwcGx5KF9jb25zb2xlLCBhcmd1bWVudHMpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlKHN0b3JhZ2VzLCBwbHVnaW5zLCBuYW1lc3BhY2UpIHtcblx0aWYgKCFuYW1lc3BhY2UpIHtcblx0XHRuYW1lc3BhY2UgPSAnJ1xuXHR9XG5cdGlmIChzdG9yYWdlcyAmJiAhaXNMaXN0KHN0b3JhZ2VzKSkge1xuXHRcdHN0b3JhZ2VzID0gW3N0b3JhZ2VzXVxuXHR9XG5cdGlmIChwbHVnaW5zICYmICFpc0xpc3QocGx1Z2lucykpIHtcblx0XHRwbHVnaW5zID0gW3BsdWdpbnNdXG5cdH1cblxuXHR2YXIgbmFtZXNwYWNlUHJlZml4ID0gKG5hbWVzcGFjZSA/ICdfX3N0b3JlanNfJytuYW1lc3BhY2UrJ18nIDogJycpXG5cdHZhciBuYW1lc3BhY2VSZWdleHAgPSAobmFtZXNwYWNlID8gbmV3IFJlZ0V4cCgnXicrbmFtZXNwYWNlUHJlZml4KSA6IG51bGwpXG5cdHZhciBsZWdhbE5hbWVzcGFjZXMgPSAvXlthLXpBLVowLTlfXFwtXSokLyAvLyBhbHBoYS1udW1lcmljICsgdW5kZXJzY29yZSBhbmQgZGFzaFxuXHRpZiAoIWxlZ2FsTmFtZXNwYWNlcy50ZXN0KG5hbWVzcGFjZSkpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ3N0b3JlLmpzIG5hbWVzcGFjZXMgY2FuIG9ubHkgaGF2ZSBhbHBoYW51bWVyaWNzICsgdW5kZXJzY29yZXMgYW5kIGRhc2hlcycpXG5cdH1cblx0XG5cdHZhciBfcHJpdmF0ZVN0b3JlUHJvcHMgPSB7XG5cdFx0X25hbWVzcGFjZVByZWZpeDogbmFtZXNwYWNlUHJlZml4LFxuXHRcdF9uYW1lc3BhY2VSZWdleHA6IG5hbWVzcGFjZVJlZ2V4cCxcblxuXHRcdF90ZXN0U3RvcmFnZTogZnVuY3Rpb24oc3RvcmFnZSkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIHRlc3RTdHIgPSAnX19zdG9yZWpzX190ZXN0X18nXG5cdFx0XHRcdHN0b3JhZ2Uud3JpdGUodGVzdFN0ciwgdGVzdFN0cilcblx0XHRcdFx0dmFyIG9rID0gKHN0b3JhZ2UucmVhZCh0ZXN0U3RyKSA9PT0gdGVzdFN0cilcblx0XHRcdFx0c3RvcmFnZS5yZW1vdmUodGVzdFN0cilcblx0XHRcdFx0cmV0dXJuIG9rXG5cdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlXG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9hc3NpZ25QbHVnaW5GblByb3A6IGZ1bmN0aW9uKHBsdWdpbkZuUHJvcCwgcHJvcE5hbWUpIHtcblx0XHRcdHZhciBvbGRGbiA9IHRoaXNbcHJvcE5hbWVdXG5cdFx0XHR0aGlzW3Byb3BOYW1lXSA9IGZ1bmN0aW9uIHBsdWdpbkZuKCkge1xuXHRcdFx0XHR2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMClcblx0XHRcdFx0dmFyIHNlbGYgPSB0aGlzXG5cblx0XHRcdFx0Ly8gc3VwZXJfZm4gY2FsbHMgdGhlIG9sZCBmdW5jdGlvbiB3aGljaCB3YXMgb3ZlcndyaXR0ZW4gYnlcblx0XHRcdFx0Ly8gdGhpcyBtaXhpbi5cblx0XHRcdFx0ZnVuY3Rpb24gc3VwZXJfZm4oKSB7XG5cdFx0XHRcdFx0aWYgKCFvbGRGbikgeyByZXR1cm4gfVxuXHRcdFx0XHRcdGVhY2goYXJndW1lbnRzLCBmdW5jdGlvbihhcmcsIGkpIHtcblx0XHRcdFx0XHRcdGFyZ3NbaV0gPSBhcmdcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdHJldHVybiBvbGRGbi5hcHBseShzZWxmLCBhcmdzKVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2l2ZSBtaXhpbmcgZnVuY3Rpb24gYWNjZXNzIHRvIHN1cGVyX2ZuIGJ5IHByZWZpeGluZyBhbGwgbWl4aW4gZnVuY3Rpb25cblx0XHRcdFx0Ly8gYXJndW1lbnRzIHdpdGggc3VwZXJfZm4uXG5cdFx0XHRcdHZhciBuZXdGbkFyZ3MgPSBbc3VwZXJfZm5dLmNvbmNhdChhcmdzKVxuXG5cdFx0XHRcdHJldHVybiBwbHVnaW5GblByb3AuYXBwbHkoc2VsZiwgbmV3Rm5BcmdzKVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfc2VyaWFsaXplOiBmdW5jdGlvbihvYmopIHtcblx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopXG5cdFx0fSxcblxuXHRcdF9kZXNlcmlhbGl6ZTogZnVuY3Rpb24oc3RyVmFsLCBkZWZhdWx0VmFsKSB7XG5cdFx0XHRpZiAoIXN0clZhbCkgeyByZXR1cm4gZGVmYXVsdFZhbCB9XG5cdFx0XHQvLyBJdCBpcyBwb3NzaWJsZSB0aGF0IGEgcmF3IHN0cmluZyB2YWx1ZSBoYXMgYmVlbiBwcmV2aW91c2x5IHN0b3JlZFxuXHRcdFx0Ly8gaW4gYSBzdG9yYWdlIHdpdGhvdXQgdXNpbmcgc3RvcmUuanMsIG1lYW5pbmcgaXQgd2lsbCBiZSBhIHJhd1xuXHRcdFx0Ly8gc3RyaW5nIHZhbHVlIGluc3RlYWQgb2YgYSBKU09OIHNlcmlhbGl6ZWQgc3RyaW5nLiBCeSBkZWZhdWx0aW5nXG5cdFx0XHQvLyB0byB0aGUgcmF3IHN0cmluZyB2YWx1ZSBpbiBjYXNlIG9mIGEgSlNPTiBwYXJzZSBlcnJvciwgd2UgYWxsb3dcblx0XHRcdC8vIGZvciBwYXN0IHN0b3JlZCB2YWx1ZXMgdG8gYmUgZm9yd2FyZHMtY29tcGF0aWJsZSB3aXRoIHN0b3JlLmpzXG5cdFx0XHR2YXIgdmFsID0gJydcblx0XHRcdHRyeSB7IHZhbCA9IEpTT04ucGFyc2Uoc3RyVmFsKSB9XG5cdFx0XHRjYXRjaChlKSB7IHZhbCA9IHN0clZhbCB9XG5cblx0XHRcdHJldHVybiAodmFsICE9PSB1bmRlZmluZWQgPyB2YWwgOiBkZWZhdWx0VmFsKVxuXHRcdH0sXG5cdFx0XG5cdFx0X2FkZFN0b3JhZ2U6IGZ1bmN0aW9uKHN0b3JhZ2UpIHtcblx0XHRcdGlmICh0aGlzLmVuYWJsZWQpIHsgcmV0dXJuIH1cblx0XHRcdGlmICh0aGlzLl90ZXN0U3RvcmFnZShzdG9yYWdlKSkge1xuXHRcdFx0XHR0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlXG5cdFx0XHRcdHRoaXMuZW5hYmxlZCA9IHRydWVcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X2FkZFBsdWdpbjogZnVuY3Rpb24ocGx1Z2luKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXNcblxuXHRcdFx0Ly8gSWYgdGhlIHBsdWdpbiBpcyBhbiBhcnJheSwgdGhlbiBhZGQgYWxsIHBsdWdpbnMgaW4gdGhlIGFycmF5LlxuXHRcdFx0Ly8gVGhpcyBhbGxvd3MgZm9yIGEgcGx1Z2luIHRvIGRlcGVuZCBvbiBvdGhlciBwbHVnaW5zLlxuXHRcdFx0aWYgKGlzTGlzdChwbHVnaW4pKSB7XG5cdFx0XHRcdGVhY2gocGx1Z2luLCBmdW5jdGlvbihwbHVnaW4pIHtcblx0XHRcdFx0XHRzZWxmLl9hZGRQbHVnaW4ocGx1Z2luKVxuXHRcdFx0XHR9KVxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiBhbGwgcGx1Z2lucyB3ZSd2ZSBzZWVuIHNvIGZhciwgc28gdGhhdCB3ZVxuXHRcdFx0Ly8gZG9uJ3QgYWRkIGFueSBvZiB0aGVtIHR3aWNlLlxuXHRcdFx0dmFyIHNlZW5QbHVnaW4gPSBwbHVjayh0aGlzLnBsdWdpbnMsIGZ1bmN0aW9uKHNlZW5QbHVnaW4pIHtcblx0XHRcdFx0cmV0dXJuIChwbHVnaW4gPT09IHNlZW5QbHVnaW4pXG5cdFx0XHR9KVxuXHRcdFx0aWYgKHNlZW5QbHVnaW4pIHtcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHR0aGlzLnBsdWdpbnMucHVzaChwbHVnaW4pXG5cblx0XHRcdC8vIENoZWNrIHRoYXQgdGhlIHBsdWdpbiBpcyBwcm9wZXJseSBmb3JtZWRcblx0XHRcdGlmICghaXNGdW5jdGlvbihwbHVnaW4pKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignUGx1Z2lucyBtdXN0IGJlIGZ1bmN0aW9uIHZhbHVlcyB0aGF0IHJldHVybiBvYmplY3RzJylcblx0XHRcdH1cblxuXHRcdFx0dmFyIHBsdWdpblByb3BlcnRpZXMgPSBwbHVnaW4uY2FsbCh0aGlzKVxuXHRcdFx0aWYgKCFpc09iamVjdChwbHVnaW5Qcm9wZXJ0aWVzKSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1BsdWdpbnMgbXVzdCByZXR1cm4gYW4gb2JqZWN0IG9mIGZ1bmN0aW9uIHByb3BlcnRpZXMnKVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdGhlIHBsdWdpbiBmdW5jdGlvbiBwcm9wZXJ0aWVzIHRvIHRoaXMgc3RvcmUgaW5zdGFuY2UuXG5cdFx0XHRlYWNoKHBsdWdpblByb3BlcnRpZXMsIGZ1bmN0aW9uKHBsdWdpbkZuUHJvcCwgcHJvcE5hbWUpIHtcblx0XHRcdFx0aWYgKCFpc0Z1bmN0aW9uKHBsdWdpbkZuUHJvcCkpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0JhZCBwbHVnaW4gcHJvcGVydHk6ICcrcHJvcE5hbWUrJyBmcm9tIHBsdWdpbiAnK3BsdWdpbi5uYW1lKycuIFBsdWdpbnMgc2hvdWxkIG9ubHkgcmV0dXJuIGZ1bmN0aW9ucy4nKVxuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYuX2Fzc2lnblBsdWdpbkZuUHJvcChwbHVnaW5GblByb3AsIHByb3BOYW1lKVxuXHRcdFx0fSlcblx0XHR9LFxuXHRcdFxuXHRcdC8vIFB1dCBkZXByZWNhdGVkIHByb3BlcnRpZXMgaW4gdGhlIHByaXZhdGUgQVBJLCBzbyBhcyB0byBub3QgZXhwb3NlIGl0IHRvIGFjY2lkZW50aWFsXG5cdFx0Ly8gZGlzY292ZXJ5IHRocm91Z2ggaW5zcGVjdGlvbiBvZiB0aGUgc3RvcmUgb2JqZWN0LlxuXHRcdFxuXHRcdC8vIERlcHJlY2F0ZWQ6IGFkZFN0b3JhZ2Vcblx0XHRhZGRTdG9yYWdlOiBmdW5jdGlvbihzdG9yYWdlKSB7XG5cdFx0XHRfd2Fybignc3RvcmUuYWRkU3RvcmFnZShzdG9yYWdlKSBpcyBkZXByZWNhdGVkLiBVc2UgY3JlYXRlU3RvcmUoW3N0b3JhZ2VzXSknKVxuXHRcdFx0dGhpcy5fYWRkU3RvcmFnZShzdG9yYWdlKVxuXHRcdH1cblx0fVxuXG5cdHZhciBzdG9yZSA9IGNyZWF0ZShfcHJpdmF0ZVN0b3JlUHJvcHMsIHN0b3JlQVBJLCB7XG5cdFx0cGx1Z2luczogW11cblx0fSlcblx0c3RvcmUucmF3ID0ge31cblx0ZWFjaChzdG9yZSwgZnVuY3Rpb24ocHJvcCwgcHJvcE5hbWUpIHtcblx0XHRpZiAoaXNGdW5jdGlvbihwcm9wKSkge1xuXHRcdFx0c3RvcmUucmF3W3Byb3BOYW1lXSA9IGJpbmQoc3RvcmUsIHByb3ApXHRcdFx0XG5cdFx0fVxuXHR9KVxuXHRlYWNoKHN0b3JhZ2VzLCBmdW5jdGlvbihzdG9yYWdlKSB7XG5cdFx0c3RvcmUuX2FkZFN0b3JhZ2Uoc3RvcmFnZSlcblx0fSlcblx0ZWFjaChwbHVnaW5zLCBmdW5jdGlvbihwbHVnaW4pIHtcblx0XHRzdG9yZS5fYWRkUGx1Z2luKHBsdWdpbilcblx0fSlcblx0cmV0dXJuIHN0b3JlXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3N0b3JlL3NyYy9zdG9yZS1lbmdpbmUuanMiLCJtb2R1bGUuZXhwb3J0cyA9IFtcblx0Ly8gTGlzdGVkIGluIG9yZGVyIG9mIHVzYWdlIHByZWZlcmVuY2Vcblx0cmVxdWlyZSgnLi9sb2NhbFN0b3JhZ2UnKSxcblx0cmVxdWlyZSgnLi9vbGRGRi1nbG9iYWxTdG9yYWdlJyksXG5cdHJlcXVpcmUoJy4vb2xkSUUtdXNlckRhdGFTdG9yYWdlJyksXG5cdHJlcXVpcmUoJy4vY29va2llU3RvcmFnZScpLFxuXHRyZXF1aXJlKCcuL3Nlc3Npb25TdG9yYWdlJyksXG5cdHJlcXVpcmUoJy4vbWVtb3J5U3RvcmFnZScpXG5dXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3N0b3JlL3N0b3JhZ2VzL2FsbC5qcyIsIi8vIGNvb2tpZVN0b3JhZ2UgaXMgdXNlZnVsIFNhZmFyaSBwcml2YXRlIGJyb3dzZXIgbW9kZSwgd2hlcmUgbG9jYWxTdG9yYWdlXG4vLyBkb2Vzbid0IHdvcmsgYnV0IGNvb2tpZXMgZG8uIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgYWRvcHRlZCBmcm9tXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU3RvcmFnZS9Mb2NhbFN0b3JhZ2VcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi9zcmMvdXRpbCcpXG52YXIgR2xvYmFsID0gdXRpbC5HbG9iYWxcbnZhciB0cmltID0gdXRpbC50cmltXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRuYW1lOiAnY29va2llU3RvcmFnZScsXG5cdHJlYWQ6IHJlYWQsXG5cdHdyaXRlOiB3cml0ZSxcblx0ZWFjaDogZWFjaCxcblx0cmVtb3ZlOiByZW1vdmUsXG5cdGNsZWFyQWxsOiBjbGVhckFsbCxcbn1cblxudmFyIGRvYyA9IEdsb2JhbC5kb2N1bWVudFxuXG5mdW5jdGlvbiByZWFkKGtleSkge1xuXHRpZiAoIWtleSB8fCAhX2hhcyhrZXkpKSB7IHJldHVybiBudWxsIH1cblx0dmFyIHJlZ2V4cFN0ciA9IFwiKD86XnwuKjtcXFxccyopXCIgK1xuXHRcdGVzY2FwZShrZXkpLnJlcGxhY2UoL1tcXC1cXC5cXCtcXCpdL2csIFwiXFxcXCQmXCIpICtcblx0XHRcIlxcXFxzKlxcXFw9XFxcXHMqKCg/OlteO10oPyE7KSkqW147XT8pLipcIlxuXHRyZXR1cm4gdW5lc2NhcGUoZG9jLmNvb2tpZS5yZXBsYWNlKG5ldyBSZWdFeHAocmVnZXhwU3RyKSwgXCIkMVwiKSlcbn1cblxuZnVuY3Rpb24gZWFjaChjYWxsYmFjaykge1xuXHR2YXIgY29va2llcyA9IGRvYy5jb29raWUuc3BsaXQoLzsgPy9nKVxuXHRmb3IgKHZhciBpID0gY29va2llcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdGlmICghdHJpbShjb29raWVzW2ldKSkge1xuXHRcdFx0Y29udGludWVcblx0XHR9XG5cdFx0dmFyIGt2cCA9IGNvb2tpZXNbaV0uc3BsaXQoJz0nKVxuXHRcdHZhciBrZXkgPSB1bmVzY2FwZShrdnBbMF0pXG5cdFx0dmFyIHZhbCA9IHVuZXNjYXBlKGt2cFsxXSlcblx0XHRjYWxsYmFjayh2YWwsIGtleSlcblx0fVxufVxuXG5mdW5jdGlvbiB3cml0ZShrZXksIGRhdGEpIHtcblx0aWYoIWtleSkgeyByZXR1cm4gfVxuXHRkb2MuY29va2llID0gZXNjYXBlKGtleSkgKyBcIj1cIiArIGVzY2FwZShkYXRhKSArIFwiOyBleHBpcmVzPVR1ZSwgMTkgSmFuIDIwMzggMDM6MTQ6MDcgR01UOyBwYXRoPS9cIlxufVxuXG5mdW5jdGlvbiByZW1vdmUoa2V5KSB7XG5cdGlmICgha2V5IHx8ICFfaGFzKGtleSkpIHtcblx0XHRyZXR1cm5cblx0fVxuXHRkb2MuY29va2llID0gZXNjYXBlKGtleSkgKyBcIj07IGV4cGlyZXM9VGh1LCAwMSBKYW4gMTk3MCAwMDowMDowMCBHTVQ7IHBhdGg9L1wiXG59XG5cbmZ1bmN0aW9uIGNsZWFyQWxsKCkge1xuXHRlYWNoKGZ1bmN0aW9uKF8sIGtleSkge1xuXHRcdHJlbW92ZShrZXkpXG5cdH0pXG59XG5cbmZ1bmN0aW9uIF9oYXMoa2V5KSB7XG5cdHJldHVybiAobmV3IFJlZ0V4cChcIig/Ol58O1xcXFxzKilcIiArIGVzY2FwZShrZXkpLnJlcGxhY2UoL1tcXC1cXC5cXCtcXCpdL2csIFwiXFxcXCQmXCIpICsgXCJcXFxccypcXFxcPVwiKSkudGVzdChkb2MuY29va2llKVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zdG9yZS9zdG9yYWdlcy9jb29raWVTdG9yYWdlLmpzIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi9zcmMvdXRpbCcpXG52YXIgR2xvYmFsID0gdXRpbC5HbG9iYWxcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdG5hbWU6ICdsb2NhbFN0b3JhZ2UnLFxuXHRyZWFkOiByZWFkLFxuXHR3cml0ZTogd3JpdGUsXG5cdGVhY2g6IGVhY2gsXG5cdHJlbW92ZTogcmVtb3ZlLFxuXHRjbGVhckFsbDogY2xlYXJBbGwsXG59XG5cbmZ1bmN0aW9uIGxvY2FsU3RvcmFnZSgpIHtcblx0cmV0dXJuIEdsb2JhbC5sb2NhbFN0b3JhZ2Vcbn1cblxuZnVuY3Rpb24gcmVhZChrZXkpIHtcblx0cmV0dXJuIGxvY2FsU3RvcmFnZSgpLmdldEl0ZW0oa2V5KVxufVxuXG5mdW5jdGlvbiB3cml0ZShrZXksIGRhdGEpIHtcblx0cmV0dXJuIGxvY2FsU3RvcmFnZSgpLnNldEl0ZW0oa2V5LCBkYXRhKVxufVxuXG5mdW5jdGlvbiBlYWNoKGZuKSB7XG5cdGZvciAodmFyIGkgPSBsb2NhbFN0b3JhZ2UoKS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdHZhciBrZXkgPSBsb2NhbFN0b3JhZ2UoKS5rZXkoaSlcblx0XHRmbihyZWFkKGtleSksIGtleSlcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmUoa2V5KSB7XG5cdHJldHVybiBsb2NhbFN0b3JhZ2UoKS5yZW1vdmVJdGVtKGtleSlcbn1cblxuZnVuY3Rpb24gY2xlYXJBbGwoKSB7XG5cdHJldHVybiBsb2NhbFN0b3JhZ2UoKS5jbGVhcigpXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3N0b3JlL3N0b3JhZ2VzL2xvY2FsU3RvcmFnZS5qcyIsIi8vIG1lbW9yeVN0b3JhZ2UgaXMgYSB1c2VmdWwgbGFzdCBmYWxsYmFjayB0byBlbnN1cmUgdGhhdCB0aGUgc3RvcmVcbi8vIGlzIGZ1bmN0aW9ucyAobWVhbmluZyBzdG9yZS5nZXQoKSwgc3RvcmUuc2V0KCksIGV0YyB3aWxsIGFsbCBmdW5jdGlvbikuXG4vLyBIb3dldmVyLCBzdG9yZWQgdmFsdWVzIHdpbGwgbm90IHBlcnNpc3Qgd2hlbiB0aGUgYnJvd3NlciBuYXZpZ2F0ZXMgdG9cbi8vIGEgbmV3IHBhZ2Ugb3IgcmVsb2FkcyB0aGUgY3VycmVudCBwYWdlLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0bmFtZTogJ21lbW9yeVN0b3JhZ2UnLFxuXHRyZWFkOiByZWFkLFxuXHR3cml0ZTogd3JpdGUsXG5cdGVhY2g6IGVhY2gsXG5cdHJlbW92ZTogcmVtb3ZlLFxuXHRjbGVhckFsbDogY2xlYXJBbGwsXG59XG5cbnZhciBtZW1vcnlTdG9yYWdlID0ge31cblxuZnVuY3Rpb24gcmVhZChrZXkpIHtcblx0cmV0dXJuIG1lbW9yeVN0b3JhZ2Vba2V5XVxufVxuXG5mdW5jdGlvbiB3cml0ZShrZXksIGRhdGEpIHtcblx0bWVtb3J5U3RvcmFnZVtrZXldID0gZGF0YVxufVxuXG5mdW5jdGlvbiBlYWNoKGNhbGxiYWNrKSB7XG5cdGZvciAodmFyIGtleSBpbiBtZW1vcnlTdG9yYWdlKSB7XG5cdFx0aWYgKG1lbW9yeVN0b3JhZ2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0Y2FsbGJhY2sobWVtb3J5U3RvcmFnZVtrZXldLCBrZXkpXG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZShrZXkpIHtcblx0ZGVsZXRlIG1lbW9yeVN0b3JhZ2Vba2V5XVxufVxuXG5mdW5jdGlvbiBjbGVhckFsbChrZXkpIHtcblx0bWVtb3J5U3RvcmFnZSA9IHt9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3N0b3JlL3N0b3JhZ2VzL21lbW9yeVN0b3JhZ2UuanMiLCIvLyBvbGRGRi1nbG9iYWxTdG9yYWdlIHByb3ZpZGVzIHN0b3JhZ2UgZm9yIEZpcmVmb3hcbi8vIHZlcnNpb25zIDYgYW5kIDcsIHdoZXJlIG5vIGxvY2FsU3RvcmFnZSwgZXRjXG4vLyBpcyBhdmFpbGFibGUuXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vc3JjL3V0aWwnKVxudmFyIEdsb2JhbCA9IHV0aWwuR2xvYmFsXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRuYW1lOiAnb2xkRkYtZ2xvYmFsU3RvcmFnZScsXG5cdHJlYWQ6IHJlYWQsXG5cdHdyaXRlOiB3cml0ZSxcblx0ZWFjaDogZWFjaCxcblx0cmVtb3ZlOiByZW1vdmUsXG5cdGNsZWFyQWxsOiBjbGVhckFsbCxcbn1cblxudmFyIGdsb2JhbFN0b3JhZ2UgPSBHbG9iYWwuZ2xvYmFsU3RvcmFnZVxuXG5mdW5jdGlvbiByZWFkKGtleSkge1xuXHRyZXR1cm4gZ2xvYmFsU3RvcmFnZVtrZXldXG59XG5cbmZ1bmN0aW9uIHdyaXRlKGtleSwgZGF0YSkge1xuXHRnbG9iYWxTdG9yYWdlW2tleV0gPSBkYXRhXG59XG5cbmZ1bmN0aW9uIGVhY2goZm4pIHtcblx0Zm9yICh2YXIgaSA9IGdsb2JhbFN0b3JhZ2UubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHR2YXIga2V5ID0gZ2xvYmFsU3RvcmFnZS5rZXkoaSlcblx0XHRmbihnbG9iYWxTdG9yYWdlW2tleV0sIGtleSlcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmUoa2V5KSB7XG5cdHJldHVybiBnbG9iYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KVxufVxuXG5mdW5jdGlvbiBjbGVhckFsbCgpIHtcblx0ZWFjaChmdW5jdGlvbihrZXksIF8pIHtcblx0XHRkZWxldGUgZ2xvYmFsU3RvcmFnZVtrZXldXG5cdH0pXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3N0b3JlL3N0b3JhZ2VzL29sZEZGLWdsb2JhbFN0b3JhZ2UuanMiLCIvLyBvbGRJRS11c2VyRGF0YVN0b3JhZ2UgcHJvdmlkZXMgc3RvcmFnZSBmb3IgSW50ZXJuZXQgRXhwbG9yZXJcbi8vIHZlcnNpb25zIDYgYW5kIDcsIHdoZXJlIG5vIGxvY2FsU3RvcmFnZSwgc2Vzc2lvblN0b3JhZ2UsIGV0Y1xuLy8gaXMgYXZhaWxhYmxlLlxuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3NyYy91dGlsJylcbnZhciBHbG9iYWwgPSB1dGlsLkdsb2JhbFxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0bmFtZTogJ29sZElFLXVzZXJEYXRhU3RvcmFnZScsXG5cdHdyaXRlOiB3cml0ZSxcblx0cmVhZDogcmVhZCxcblx0ZWFjaDogZWFjaCxcblx0cmVtb3ZlOiByZW1vdmUsXG5cdGNsZWFyQWxsOiBjbGVhckFsbCxcbn1cblxudmFyIHN0b3JhZ2VOYW1lID0gJ3N0b3JlanMnXG52YXIgZG9jID0gR2xvYmFsLmRvY3VtZW50XG52YXIgX3dpdGhTdG9yYWdlRWwgPSBfbWFrZUlFU3RvcmFnZUVsRnVuY3Rpb24oKVxudmFyIGRpc2FibGUgPSAoR2xvYmFsLm5hdmlnYXRvciA/IEdsb2JhbC5uYXZpZ2F0b3IudXNlckFnZW50IDogJycpLm1hdGNoKC8gKE1TSUUgOHxNU0lFIDl8TVNJRSAxMClcXC4vKSAvLyBNU0lFIDkueCwgTVNJRSAxMC54XG5cbmZ1bmN0aW9uIHdyaXRlKHVuZml4ZWRLZXksIGRhdGEpIHtcblx0aWYgKGRpc2FibGUpIHsgcmV0dXJuIH1cblx0dmFyIGZpeGVkS2V5ID0gZml4S2V5KHVuZml4ZWRLZXkpXG5cdF93aXRoU3RvcmFnZUVsKGZ1bmN0aW9uKHN0b3JhZ2VFbCkge1xuXHRcdHN0b3JhZ2VFbC5zZXRBdHRyaWJ1dGUoZml4ZWRLZXksIGRhdGEpXG5cdFx0c3RvcmFnZUVsLnNhdmUoc3RvcmFnZU5hbWUpXG5cdH0pXG59XG5cbmZ1bmN0aW9uIHJlYWQodW5maXhlZEtleSkge1xuXHRpZiAoZGlzYWJsZSkgeyByZXR1cm4gfVxuXHR2YXIgZml4ZWRLZXkgPSBmaXhLZXkodW5maXhlZEtleSlcblx0dmFyIHJlcyA9IG51bGxcblx0X3dpdGhTdG9yYWdlRWwoZnVuY3Rpb24oc3RvcmFnZUVsKSB7XG5cdFx0cmVzID0gc3RvcmFnZUVsLmdldEF0dHJpYnV0ZShmaXhlZEtleSlcblx0fSlcblx0cmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBlYWNoKGNhbGxiYWNrKSB7XG5cdF93aXRoU3RvcmFnZUVsKGZ1bmN0aW9uKHN0b3JhZ2VFbCkge1xuXHRcdHZhciBhdHRyaWJ1dGVzID0gc3RvcmFnZUVsLlhNTERvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hdHRyaWJ1dGVzXG5cdFx0Zm9yICh2YXIgaT1hdHRyaWJ1dGVzLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcblx0XHRcdHZhciBhdHRyID0gYXR0cmlidXRlc1tpXVxuXHRcdFx0Y2FsbGJhY2soc3RvcmFnZUVsLmdldEF0dHJpYnV0ZShhdHRyLm5hbWUpLCBhdHRyLm5hbWUpXG5cdFx0fVxuXHR9KVxufVxuXG5mdW5jdGlvbiByZW1vdmUodW5maXhlZEtleSkge1xuXHR2YXIgZml4ZWRLZXkgPSBmaXhLZXkodW5maXhlZEtleSlcblx0X3dpdGhTdG9yYWdlRWwoZnVuY3Rpb24oc3RvcmFnZUVsKSB7XG5cdFx0c3RvcmFnZUVsLnJlbW92ZUF0dHJpYnV0ZShmaXhlZEtleSlcblx0XHRzdG9yYWdlRWwuc2F2ZShzdG9yYWdlTmFtZSlcblx0fSlcbn1cblxuZnVuY3Rpb24gY2xlYXJBbGwoKSB7XG5cdF93aXRoU3RvcmFnZUVsKGZ1bmN0aW9uKHN0b3JhZ2VFbCkge1xuXHRcdHZhciBhdHRyaWJ1dGVzID0gc3RvcmFnZUVsLlhNTERvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hdHRyaWJ1dGVzXG5cdFx0c3RvcmFnZUVsLmxvYWQoc3RvcmFnZU5hbWUpXG5cdFx0Zm9yICh2YXIgaT1hdHRyaWJ1dGVzLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcblx0XHRcdHN0b3JhZ2VFbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlc1tpXS5uYW1lKVxuXHRcdH1cblx0XHRzdG9yYWdlRWwuc2F2ZShzdG9yYWdlTmFtZSlcblx0fSlcbn1cblxuLy8gSGVscGVyc1xuLy8vLy8vLy8vL1xuXG4vLyBJbiBJRTcsIGtleXMgY2Fubm90IHN0YXJ0IHdpdGggYSBkaWdpdCBvciBjb250YWluIGNlcnRhaW4gY2hhcnMuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21hcmN1c3dlc3Rpbi9zdG9yZS5qcy9pc3N1ZXMvNDBcbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbWFyY3Vzd2VzdGluL3N0b3JlLmpzL2lzc3Vlcy84M1xudmFyIGZvcmJpZGRlbkNoYXJzUmVnZXggPSBuZXcgUmVnRXhwKFwiWyFcXFwiIyQlJicoKSorLC9cXFxcXFxcXDo7PD0+P0BbXFxcXF1eYHt8fX5dXCIsIFwiZ1wiKVxuZnVuY3Rpb24gZml4S2V5KGtleSkge1xuXHRyZXR1cm4ga2V5LnJlcGxhY2UoL15cXGQvLCAnX19fJCYnKS5yZXBsYWNlKGZvcmJpZGRlbkNoYXJzUmVnZXgsICdfX18nKVxufVxuXG5mdW5jdGlvbiBfbWFrZUlFU3RvcmFnZUVsRnVuY3Rpb24oKSB7XG5cdGlmICghZG9jIHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50LmFkZEJlaGF2aW9yKSB7XG5cdFx0cmV0dXJuIG51bGxcblx0fVxuXHR2YXIgc2NyaXB0VGFnID0gJ3NjcmlwdCcsXG5cdFx0c3RvcmFnZU93bmVyLFxuXHRcdHN0b3JhZ2VDb250YWluZXIsXG5cdFx0c3RvcmFnZUVsXG5cblx0Ly8gU2luY2UgI3VzZXJEYXRhIHN0b3JhZ2UgYXBwbGllcyBvbmx5IHRvIHNwZWNpZmljIHBhdGhzLCB3ZSBuZWVkIHRvXG5cdC8vIHNvbWVob3cgbGluayBvdXIgZGF0YSB0byBhIHNwZWNpZmljIHBhdGguICBXZSBjaG9vc2UgL2Zhdmljb24uaWNvXG5cdC8vIGFzIGEgcHJldHR5IHNhZmUgb3B0aW9uLCBzaW5jZSBhbGwgYnJvd3NlcnMgYWxyZWFkeSBtYWtlIGEgcmVxdWVzdCB0b1xuXHQvLyB0aGlzIFVSTCBhbnl3YXkgYW5kIGJlaW5nIGEgNDA0IHdpbGwgbm90IGh1cnQgdXMgaGVyZS4gIFdlIHdyYXAgYW5cblx0Ly8gaWZyYW1lIHBvaW50aW5nIHRvIHRoZSBmYXZpY29uIGluIGFuIEFjdGl2ZVhPYmplY3QoaHRtbGZpbGUpIG9iamVjdFxuXHQvLyAoc2VlOiBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvYWE3NTI1NzQodj1WUy44NSkuYXNweClcblx0Ly8gc2luY2UgdGhlIGlmcmFtZSBhY2Nlc3MgcnVsZXMgYXBwZWFyIHRvIGFsbG93IGRpcmVjdCBhY2Nlc3MgYW5kXG5cdC8vIG1hbmlwdWxhdGlvbiBvZiB0aGUgZG9jdW1lbnQgZWxlbWVudCwgZXZlbiBmb3IgYSA0MDQgcGFnZS4gIFRoaXNcblx0Ly8gZG9jdW1lbnQgY2FuIGJlIHVzZWQgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBkb2N1bWVudCAod2hpY2ggd291bGRcblx0Ly8gaGF2ZSBiZWVuIGxpbWl0ZWQgdG8gdGhlIGN1cnJlbnQgcGF0aCkgdG8gcGVyZm9ybSAjdXNlckRhdGEgc3RvcmFnZS5cblx0dHJ5IHtcblx0XHQvKiBnbG9iYWwgQWN0aXZlWE9iamVjdCAqL1xuXHRcdHN0b3JhZ2VDb250YWluZXIgPSBuZXcgQWN0aXZlWE9iamVjdCgnaHRtbGZpbGUnKVxuXHRcdHN0b3JhZ2VDb250YWluZXIub3BlbigpXG5cdFx0c3RvcmFnZUNvbnRhaW5lci53cml0ZSgnPCcrc2NyaXB0VGFnKyc+ZG9jdW1lbnQudz13aW5kb3c8Lycrc2NyaXB0VGFnKyc+PGlmcmFtZSBzcmM9XCIvZmF2aWNvbi5pY29cIj48L2lmcmFtZT4nKVxuXHRcdHN0b3JhZ2VDb250YWluZXIuY2xvc2UoKVxuXHRcdHN0b3JhZ2VPd25lciA9IHN0b3JhZ2VDb250YWluZXIudy5mcmFtZXNbMF0uZG9jdW1lbnRcblx0XHRzdG9yYWdlRWwgPSBzdG9yYWdlT3duZXIuY3JlYXRlRWxlbWVudCgnZGl2Jylcblx0fSBjYXRjaChlKSB7XG5cdFx0Ly8gc29tZWhvdyBBY3RpdmVYT2JqZWN0IGluc3RhbnRpYXRpb24gZmFpbGVkIChwZXJoYXBzIHNvbWUgc3BlY2lhbFxuXHRcdC8vIHNlY3VyaXR5IHNldHRpbmdzIG9yIG90aGVyd3NlKSwgZmFsbCBiYWNrIHRvIHBlci1wYXRoIHN0b3JhZ2Vcblx0XHRzdG9yYWdlRWwgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jylcblx0XHRzdG9yYWdlT3duZXIgPSBkb2MuYm9keVxuXHR9XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHN0b3JlRnVuY3Rpb24pIHtcblx0XHR2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKVxuXHRcdGFyZ3MudW5zaGlmdChzdG9yYWdlRWwpXG5cdFx0Ly8gU2VlIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzMTA4MSh2PVZTLjg1KS5hc3B4XG5cdFx0Ly8gYW5kIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzMTQyNCh2PVZTLjg1KS5hc3B4XG5cdFx0c3RvcmFnZU93bmVyLmFwcGVuZENoaWxkKHN0b3JhZ2VFbClcblx0XHRzdG9yYWdlRWwuYWRkQmVoYXZpb3IoJyNkZWZhdWx0I3VzZXJEYXRhJylcblx0XHRzdG9yYWdlRWwubG9hZChzdG9yYWdlTmFtZSlcblx0XHRzdG9yZUZ1bmN0aW9uLmFwcGx5KHRoaXMsIGFyZ3MpXG5cdFx0c3RvcmFnZU93bmVyLnJlbW92ZUNoaWxkKHN0b3JhZ2VFbClcblx0XHRyZXR1cm5cblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zdG9yZS9zdG9yYWdlcy9vbGRJRS11c2VyRGF0YVN0b3JhZ2UuanMiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3NyYy91dGlsJylcbnZhciBHbG9iYWwgPSB1dGlsLkdsb2JhbFxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0bmFtZTogJ3Nlc3Npb25TdG9yYWdlJyxcblx0cmVhZDogcmVhZCxcblx0d3JpdGU6IHdyaXRlLFxuXHRlYWNoOiBlYWNoLFxuXHRyZW1vdmU6IHJlbW92ZSxcblx0Y2xlYXJBbGw6IGNsZWFyQWxsXG59XG5cbmZ1bmN0aW9uIHNlc3Npb25TdG9yYWdlKCkge1xuXHRyZXR1cm4gR2xvYmFsLnNlc3Npb25TdG9yYWdlXG59XG5cbmZ1bmN0aW9uIHJlYWQoa2V5KSB7XG5cdHJldHVybiBzZXNzaW9uU3RvcmFnZSgpLmdldEl0ZW0oa2V5KVxufVxuXG5mdW5jdGlvbiB3cml0ZShrZXksIGRhdGEpIHtcblx0cmV0dXJuIHNlc3Npb25TdG9yYWdlKCkuc2V0SXRlbShrZXksIGRhdGEpXG59XG5cbmZ1bmN0aW9uIGVhY2goZm4pIHtcblx0Zm9yICh2YXIgaSA9IHNlc3Npb25TdG9yYWdlKCkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHR2YXIga2V5ID0gc2Vzc2lvblN0b3JhZ2UoKS5rZXkoaSlcblx0XHRmbihyZWFkKGtleSksIGtleSlcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmUoa2V5KSB7XG5cdHJldHVybiBzZXNzaW9uU3RvcmFnZSgpLnJlbW92ZUl0ZW0oa2V5KVxufVxuXG5mdW5jdGlvbiBjbGVhckFsbCgpIHtcblx0cmV0dXJuIHNlc3Npb25TdG9yYWdlKCkuY2xlYXIoKVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zdG9yZS9zdG9yYWdlcy9zZXNzaW9uU3RvcmFnZS5qcyIsInZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsb3NlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwod2luZG93LCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwiLyohXG4gKiB2YWxpZGF0ZS5qcyAwLjExLjFcbiAqXG4gKiAoYykgMjAxMy0yMDE2IE5pY2tsYXMgQW5zbWFuLCAyMDEzIFdyYXBwXG4gKiBWYWxpZGF0ZS5qcyBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIEZvciBhbGwgZGV0YWlscyBhbmQgZG9jdW1lbnRhdGlvbjpcbiAqIGh0dHA6Ly92YWxpZGF0ZWpzLm9yZy9cbiAqL1xuXG4oZnVuY3Rpb24oZXhwb3J0cywgbW9kdWxlLCBkZWZpbmUpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgLy8gVGhlIG1haW4gZnVuY3Rpb24gdGhhdCBjYWxscyB0aGUgdmFsaWRhdG9ycyBzcGVjaWZpZWQgYnkgdGhlIGNvbnN0cmFpbnRzLlxuICAvLyBUaGUgb3B0aW9ucyBhcmUgdGhlIGZvbGxvd2luZzpcbiAgLy8gICAtIGZvcm1hdCAoc3RyaW5nKSAtIEFuIG9wdGlvbiB0aGF0IGNvbnRyb2xzIGhvdyB0aGUgcmV0dXJuZWQgdmFsdWUgaXMgZm9ybWF0dGVkXG4gIC8vICAgICAqIGZsYXQgLSBSZXR1cm5zIGEgZmxhdCBhcnJheSBvZiBqdXN0IHRoZSBlcnJvciBtZXNzYWdlc1xuICAvLyAgICAgKiBncm91cGVkIC0gUmV0dXJucyB0aGUgbWVzc2FnZXMgZ3JvdXBlZCBieSBhdHRyaWJ1dGUgKGRlZmF1bHQpXG4gIC8vICAgICAqIGRldGFpbGVkIC0gUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcmF3IHZhbGlkYXRpb24gZGF0YVxuICAvLyAgIC0gZnVsbE1lc3NhZ2VzIChib29sZWFuKSAtIElmIGB0cnVlYCAoZGVmYXVsdCkgdGhlIGF0dHJpYnV0ZSBuYW1lIGlzIHByZXBlbmRlZCB0byB0aGUgZXJyb3IuXG4gIC8vXG4gIC8vIFBsZWFzZSBub3RlIHRoYXQgdGhlIG9wdGlvbnMgYXJlIGFsc28gcGFzc2VkIHRvIGVhY2ggdmFsaWRhdG9yLlxuICB2YXIgdmFsaWRhdGUgPSBmdW5jdGlvbihhdHRyaWJ1dGVzLCBjb25zdHJhaW50cywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB2LmV4dGVuZCh7fSwgdi5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgIHZhciByZXN1bHRzID0gdi5ydW5WYWxpZGF0aW9ucyhhdHRyaWJ1dGVzLCBjb25zdHJhaW50cywgb3B0aW9ucylcbiAgICAgICwgYXR0clxuICAgICAgLCB2YWxpZGF0b3I7XG5cbiAgICBmb3IgKGF0dHIgaW4gcmVzdWx0cykge1xuICAgICAgZm9yICh2YWxpZGF0b3IgaW4gcmVzdWx0c1thdHRyXSkge1xuICAgICAgICBpZiAodi5pc1Byb21pc2UocmVzdWx0c1thdHRyXVt2YWxpZGF0b3JdKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVzZSB2YWxpZGF0ZS5hc3luYyBpZiB5b3Ugd2FudCBzdXBwb3J0IGZvciBwcm9taXNlc1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsaWRhdGUucHJvY2Vzc1ZhbGlkYXRpb25SZXN1bHRzKHJlc3VsdHMsIG9wdGlvbnMpO1xuICB9O1xuXG4gIHZhciB2ID0gdmFsaWRhdGU7XG5cbiAgLy8gQ29waWVzIG92ZXIgYXR0cmlidXRlcyBmcm9tIG9uZSBvciBtb3JlIHNvdXJjZXMgdG8gYSBzaW5nbGUgZGVzdGluYXRpb24uXG4gIC8vIFZlcnkgbXVjaCBzaW1pbGFyIHRvIHVuZGVyc2NvcmUncyBleHRlbmQuXG4gIC8vIFRoZSBmaXJzdCBhcmd1bWVudCBpcyB0aGUgdGFyZ2V0IG9iamVjdCBhbmQgdGhlIHJlbWFpbmluZyBhcmd1bWVudHMgd2lsbCBiZVxuICAvLyB1c2VkIGFzIHNvdXJjZXMuXG4gIHYuZXh0ZW5kID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLmZvckVhY2goZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICBmb3IgKHZhciBhdHRyIGluIHNvdXJjZSkge1xuICAgICAgICBvYmpbYXR0cl0gPSBzb3VyY2VbYXR0cl07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICB2LmV4dGVuZCh2YWxpZGF0ZSwge1xuICAgIC8vIFRoaXMgaXMgdGhlIHZlcnNpb24gb2YgdGhlIGxpYnJhcnkgYXMgYSBzZW12ZXIuXG4gICAgLy8gVGhlIHRvU3RyaW5nIGZ1bmN0aW9uIHdpbGwgYWxsb3cgaXQgdG8gYmUgY29lcmNlZCBpbnRvIGEgc3RyaW5nXG4gICAgdmVyc2lvbjoge1xuICAgICAgbWFqb3I6IDAsXG4gICAgICBtaW5vcjogMTEsXG4gICAgICBwYXRjaDogMSxcbiAgICAgIG1ldGFkYXRhOiBudWxsLFxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmVyc2lvbiA9IHYuZm9ybWF0KFwiJXttYWpvcn0uJXttaW5vcn0uJXtwYXRjaH1cIiwgdi52ZXJzaW9uKTtcbiAgICAgICAgaWYgKCF2LmlzRW1wdHkodi52ZXJzaW9uLm1ldGFkYXRhKSkge1xuICAgICAgICAgIHZlcnNpb24gKz0gXCIrXCIgKyB2LnZlcnNpb24ubWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZlcnNpb247XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIEJlbG93IGlzIHRoZSBkZXBlbmRlbmNpZXMgdGhhdCBhcmUgdXNlZCBpbiB2YWxpZGF0ZS5qc1xuXG4gICAgLy8gVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBQcm9taXNlIGltcGxlbWVudGF0aW9uLlxuICAgIC8vIElmIHlvdSBhcmUgdXNpbmcgUS5qcywgUlNWUCBvciBhbnkgb3RoZXIgQSsgY29tcGF0aWJsZSBpbXBsZW1lbnRhdGlvblxuICAgIC8vIG92ZXJyaWRlIHRoaXMgYXR0cmlidXRlIHRvIGJlIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGF0IHByb21pc2UuXG4gICAgLy8gU2luY2UgalF1ZXJ5IHByb21pc2VzIGFyZW4ndCBBKyBjb21wYXRpYmxlIHRoZXkgd29uJ3Qgd29yay5cbiAgICBQcm9taXNlOiB0eXBlb2YgUHJvbWlzZSAhPT0gXCJ1bmRlZmluZWRcIiA/IFByb21pc2UgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBudWxsLFxuXG4gICAgRU1QVFlfU1RSSU5HX1JFR0VYUDogL15cXHMqJC8sXG5cbiAgICAvLyBSdW5zIHRoZSB2YWxpZGF0b3JzIHNwZWNpZmllZCBieSB0aGUgY29uc3RyYWludHMgb2JqZWN0LlxuICAgIC8vIFdpbGwgcmV0dXJuIGFuIGFycmF5IG9mIHRoZSBmb3JtYXQ6XG4gICAgLy8gICAgIFt7YXR0cmlidXRlOiBcIjxhdHRyaWJ1dGUgbmFtZT5cIiwgZXJyb3I6IFwiPHZhbGlkYXRpb24gcmVzdWx0PlwifSwgLi4uXVxuICAgIHJ1blZhbGlkYXRpb25zOiBmdW5jdGlvbihhdHRyaWJ1dGVzLCBjb25zdHJhaW50cywgb3B0aW9ucykge1xuICAgICAgdmFyIHJlc3VsdHMgPSBbXVxuICAgICAgICAsIGF0dHJcbiAgICAgICAgLCB2YWxpZGF0b3JOYW1lXG4gICAgICAgICwgdmFsdWVcbiAgICAgICAgLCB2YWxpZGF0b3JzXG4gICAgICAgICwgdmFsaWRhdG9yXG4gICAgICAgICwgdmFsaWRhdG9yT3B0aW9uc1xuICAgICAgICAsIGVycm9yO1xuXG4gICAgICBpZiAodi5pc0RvbUVsZW1lbnQoYXR0cmlidXRlcykgfHwgdi5pc0pxdWVyeUVsZW1lbnQoYXR0cmlidXRlcykpIHtcbiAgICAgICAgYXR0cmlidXRlcyA9IHYuY29sbGVjdEZvcm1WYWx1ZXMoYXR0cmlidXRlcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIExvb3BzIHRocm91Z2ggZWFjaCBjb25zdHJhaW50cywgZmluZHMgdGhlIGNvcnJlY3QgdmFsaWRhdG9yIGFuZCBydW4gaXQuXG4gICAgICBmb3IgKGF0dHIgaW4gY29uc3RyYWludHMpIHtcbiAgICAgICAgdmFsdWUgPSB2LmdldERlZXBPYmplY3RWYWx1ZShhdHRyaWJ1dGVzLCBhdHRyKTtcbiAgICAgICAgLy8gVGhpcyBhbGxvd3MgdGhlIGNvbnN0cmFpbnRzIGZvciBhbiBhdHRyaWJ1dGUgdG8gYmUgYSBmdW5jdGlvbi5cbiAgICAgICAgLy8gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHZhbHVlLCBhdHRyaWJ1dGUgbmFtZSwgdGhlIGNvbXBsZXRlIGRpY3Qgb2ZcbiAgICAgICAgLy8gYXR0cmlidXRlcyBhcyB3ZWxsIGFzIHRoZSBvcHRpb25zIGFuZCBjb25zdHJhaW50cyBwYXNzZWQgaW4uXG4gICAgICAgIC8vIFRoaXMgaXMgdXNlZnVsIHdoZW4geW91IHdhbnQgdG8gaGF2ZSBkaWZmZXJlbnRcbiAgICAgICAgLy8gdmFsaWRhdGlvbnMgZGVwZW5kaW5nIG9uIHRoZSBhdHRyaWJ1dGUgdmFsdWUuXG4gICAgICAgIHZhbGlkYXRvcnMgPSB2LnJlc3VsdChjb25zdHJhaW50c1thdHRyXSwgdmFsdWUsIGF0dHJpYnV0ZXMsIGF0dHIsIG9wdGlvbnMsIGNvbnN0cmFpbnRzKTtcblxuICAgICAgICBmb3IgKHZhbGlkYXRvck5hbWUgaW4gdmFsaWRhdG9ycykge1xuICAgICAgICAgIHZhbGlkYXRvciA9IHYudmFsaWRhdG9yc1t2YWxpZGF0b3JOYW1lXTtcblxuICAgICAgICAgIGlmICghdmFsaWRhdG9yKSB7XG4gICAgICAgICAgICBlcnJvciA9IHYuZm9ybWF0KFwiVW5rbm93biB2YWxpZGF0b3IgJXtuYW1lfVwiLCB7bmFtZTogdmFsaWRhdG9yTmFtZX0pO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YWxpZGF0b3JPcHRpb25zID0gdmFsaWRhdG9yc1t2YWxpZGF0b3JOYW1lXTtcbiAgICAgICAgICAvLyBUaGlzIGFsbG93cyB0aGUgb3B0aW9ucyB0byBiZSBhIGZ1bmN0aW9uLiBUaGUgZnVuY3Rpb24gd2lsbCBiZVxuICAgICAgICAgIC8vIGNhbGxlZCB3aXRoIHRoZSB2YWx1ZSwgYXR0cmlidXRlIG5hbWUsIHRoZSBjb21wbGV0ZSBkaWN0IG9mXG4gICAgICAgICAgLy8gYXR0cmlidXRlcyBhcyB3ZWxsIGFzIHRoZSBvcHRpb25zIGFuZCBjb25zdHJhaW50cyBwYXNzZWQgaW4uXG4gICAgICAgICAgLy8gVGhpcyBpcyB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byBoYXZlIGRpZmZlcmVudFxuICAgICAgICAgIC8vIHZhbGlkYXRpb25zIGRlcGVuZGluZyBvbiB0aGUgYXR0cmlidXRlIHZhbHVlLlxuICAgICAgICAgIHZhbGlkYXRvck9wdGlvbnMgPSB2LnJlc3VsdCh2YWxpZGF0b3JPcHRpb25zLCB2YWx1ZSwgYXR0cmlidXRlcywgYXR0ciwgb3B0aW9ucywgY29uc3RyYWludHMpO1xuICAgICAgICAgIGlmICghdmFsaWRhdG9yT3B0aW9ucykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICBhdHRyaWJ1dGU6IGF0dHIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICB2YWxpZGF0b3I6IHZhbGlkYXRvck5hbWUsXG4gICAgICAgICAgICBnbG9iYWxPcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAgICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcbiAgICAgICAgICAgIG9wdGlvbnM6IHZhbGlkYXRvck9wdGlvbnMsXG4gICAgICAgICAgICBlcnJvcjogdmFsaWRhdG9yLmNhbGwodmFsaWRhdG9yLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIHZhbGlkYXRvck9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYXR0cixcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSxcblxuICAgIC8vIFRha2VzIHRoZSBvdXRwdXQgZnJvbSBydW5WYWxpZGF0aW9ucyBhbmQgY29udmVydHMgaXQgdG8gdGhlIGNvcnJlY3RcbiAgICAvLyBvdXRwdXQgZm9ybWF0LlxuICAgIHByb2Nlc3NWYWxpZGF0aW9uUmVzdWx0czogZnVuY3Rpb24oZXJyb3JzLCBvcHRpb25zKSB7XG4gICAgICBlcnJvcnMgPSB2LnBydW5lRW1wdHlFcnJvcnMoZXJyb3JzLCBvcHRpb25zKTtcbiAgICAgIGVycm9ycyA9IHYuZXhwYW5kTXVsdGlwbGVFcnJvcnMoZXJyb3JzLCBvcHRpb25zKTtcbiAgICAgIGVycm9ycyA9IHYuY29udmVydEVycm9yTWVzc2FnZXMoZXJyb3JzLCBvcHRpb25zKTtcblxuICAgICAgdmFyIGZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0IHx8IFwiZ3JvdXBlZFwiO1xuXG4gICAgICBpZiAodHlwZW9mIHYuZm9ybWF0dGVyc1tmb3JtYXRdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVycm9ycyA9IHYuZm9ybWF0dGVyc1tmb3JtYXRdKGVycm9ycyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iodi5mb3JtYXQoXCJVbmtub3duIGZvcm1hdCAle2Zvcm1hdH1cIiwgb3B0aW9ucykpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdi5pc0VtcHR5KGVycm9ycykgPyB1bmRlZmluZWQgOiBlcnJvcnM7XG4gICAgfSxcblxuICAgIC8vIFJ1bnMgdGhlIHZhbGlkYXRpb25zIHdpdGggc3VwcG9ydCBmb3IgcHJvbWlzZXMuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiBhIHByb21pc2UgdGhhdCBpcyBzZXR0bGVkIHdoZW4gYWxsIHRoZVxuICAgIC8vIHZhbGlkYXRpb24gcHJvbWlzZXMgaGF2ZSBiZWVuIGNvbXBsZXRlZC5cbiAgICAvLyBJdCBjYW4gYmUgY2FsbGVkIGV2ZW4gaWYgbm8gdmFsaWRhdGlvbnMgcmV0dXJuZWQgYSBwcm9taXNlLlxuICAgIGFzeW5jOiBmdW5jdGlvbihhdHRyaWJ1dGVzLCBjb25zdHJhaW50cywgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHYuZXh0ZW5kKHt9LCB2LmFzeW5jLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICB2YXIgV3JhcEVycm9ycyA9IG9wdGlvbnMud3JhcEVycm9ycyB8fCBmdW5jdGlvbihlcnJvcnMpIHtcbiAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgIH07XG5cbiAgICAgIC8vIFJlbW92ZXMgdW5rbm93biBhdHRyaWJ1dGVzXG4gICAgICBpZiAob3B0aW9ucy5jbGVhbkF0dHJpYnV0ZXMgIT09IGZhbHNlKSB7XG4gICAgICAgIGF0dHJpYnV0ZXMgPSB2LmNsZWFuQXR0cmlidXRlcyhhdHRyaWJ1dGVzLCBjb25zdHJhaW50cyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHRzID0gdi5ydW5WYWxpZGF0aW9ucyhhdHRyaWJ1dGVzLCBjb25zdHJhaW50cywgb3B0aW9ucyk7XG5cbiAgICAgIHJldHVybiBuZXcgdi5Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2LndhaXRGb3JSZXN1bHRzKHJlc3VsdHMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGVycm9ycyA9IHYucHJvY2Vzc1ZhbGlkYXRpb25SZXN1bHRzKHJlc3VsdHMsIG9wdGlvbnMpO1xuICAgICAgICAgIGlmIChlcnJvcnMpIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgV3JhcEVycm9ycyhlcnJvcnMsIG9wdGlvbnMsIGF0dHJpYnV0ZXMsIGNvbnN0cmFpbnRzKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoYXR0cmlidXRlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgc2luZ2xlOiBmdW5jdGlvbih2YWx1ZSwgY29uc3RyYWludHMsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSB2LmV4dGVuZCh7fSwgdi5zaW5nbGUub3B0aW9ucywgb3B0aW9ucywge1xuICAgICAgICBmb3JtYXQ6IFwiZmxhdFwiLFxuICAgICAgICBmdWxsTWVzc2FnZXM6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB2KHtzaW5nbGU6IHZhbHVlfSwge3NpbmdsZTogY29uc3RyYWludHN9LCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBhIHByb21pc2UgdGhhdCBpcyByZXNvbHZlZCB3aGVuIGFsbCBwcm9taXNlcyBpbiB0aGUgcmVzdWx0cyBhcnJheVxuICAgIC8vIGFyZSBzZXR0bGVkLiBUaGUgcHJvbWlzZSByZXR1cm5lZCBmcm9tIHRoaXMgZnVuY3Rpb24gaXMgYWx3YXlzIHJlc29sdmVkLFxuICAgIC8vIG5ldmVyIHJlamVjdGVkLlxuICAgIC8vIFRoaXMgZnVuY3Rpb24gbW9kaWZpZXMgdGhlIGlucHV0IGFyZ3VtZW50LCBpdCByZXBsYWNlcyB0aGUgcHJvbWlzZXNcbiAgICAvLyB3aXRoIHRoZSB2YWx1ZSByZXR1cm5lZCBmcm9tIHRoZSBwcm9taXNlLlxuICAgIHdhaXRGb3JSZXN1bHRzOiBmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAgICAvLyBDcmVhdGUgYSBzZXF1ZW5jZSBvZiBhbGwgdGhlIHJlc3VsdHMgc3RhcnRpbmcgd2l0aCBhIHJlc29sdmVkIHByb21pc2UuXG4gICAgICByZXR1cm4gcmVzdWx0cy5yZWR1Y2UoZnVuY3Rpb24obWVtbywgcmVzdWx0KSB7XG4gICAgICAgIC8vIElmIHRoaXMgcmVzdWx0IGlzbid0IGEgcHJvbWlzZSBza2lwIGl0IGluIHRoZSBzZXF1ZW5jZS5cbiAgICAgICAgaWYgKCF2LmlzUHJvbWlzZShyZXN1bHQuZXJyb3IpKSB7XG4gICAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWVtby50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZXJyb3IudGhlbihmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgcmVzdWx0LmVycm9yID0gZXJyb3IgfHwgbnVsbDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBuZXcgdi5Qcm9taXNlKGZ1bmN0aW9uKHIpIHsgcigpOyB9KSk7IC8vIEEgcmVzb2x2ZWQgcHJvbWlzZVxuICAgIH0sXG5cbiAgICAvLyBJZiB0aGUgZ2l2ZW4gYXJndW1lbnQgaXMgYSBjYWxsOiBmdW5jdGlvbiB0aGUgYW5kOiBmdW5jdGlvbiByZXR1cm4gdGhlIHZhbHVlXG4gICAgLy8gb3RoZXJ3aXNlIGp1c3QgcmV0dXJuIHRoZSB2YWx1ZS4gQWRkaXRpb25hbCBhcmd1bWVudHMgd2lsbCBiZSBwYXNzZWQgYXNcbiAgICAvLyBhcmd1bWVudHMgdG8gdGhlIGZ1bmN0aW9uLlxuICAgIC8vIEV4YW1wbGU6XG4gICAgLy8gYGBgXG4gICAgLy8gcmVzdWx0KCdmb28nKSAvLyAnZm9vJ1xuICAgIC8vIHJlc3VsdChNYXRoLm1heCwgMSwgMikgLy8gMlxuICAgIC8vIGBgYFxuICAgIHJlc3VsdDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICAvLyBDaGVja3MgaWYgdGhlIHZhbHVlIGlzIGEgbnVtYmVyLiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IGNvbnNpZGVyIE5hTiBhXG4gICAgLy8gbnVtYmVyIGxpa2UgbWFueSBvdGhlciBgaXNOdW1iZXJgIGZ1bmN0aW9ucyBkby5cbiAgICBpc051bWJlcjogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgZmFsc2UgaWYgdGhlIG9iamVjdCBpcyBub3QgYSBmdW5jdGlvblxuICAgIGlzRnVuY3Rpb246IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuICAgIH0sXG5cbiAgICAvLyBBIHNpbXBsZSBjaGVjayB0byB2ZXJpZnkgdGhhdCB0aGUgdmFsdWUgaXMgYW4gaW50ZWdlci4gVXNlcyBgaXNOdW1iZXJgXG4gICAgLy8gYW5kIGEgc2ltcGxlIG1vZHVsbyBjaGVjay5cbiAgICBpc0ludGVnZXI6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdi5pc051bWJlcih2YWx1ZSkgJiYgdmFsdWUgJSAxID09PSAwO1xuICAgIH0sXG5cbiAgICAvLyBDaGVja3MgaWYgdGhlIHZhbHVlIGlzIGEgYm9vbGVhblxuICAgIGlzQm9vbGVhbjogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcbiAgICB9LFxuXG4gICAgLy8gVXNlcyB0aGUgYE9iamVjdGAgZnVuY3Rpb24gdG8gY2hlY2sgaWYgdGhlIGdpdmVuIGFyZ3VtZW50IGlzIGFuIG9iamVjdC5cbiAgICBpc09iamVjdDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKTtcbiAgICB9LFxuXG4gICAgLy8gU2ltcGx5IGNoZWNrcyBpZiB0aGUgb2JqZWN0IGlzIGFuIGluc3RhbmNlIG9mIGEgZGF0ZVxuICAgIGlzRGF0ZTogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRGF0ZTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBmYWxzZSBpZiB0aGUgb2JqZWN0IGlzIGBudWxsYCBvZiBgdW5kZWZpbmVkYFxuICAgIGlzRGVmaW5lZDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICE9PSBudWxsICYmIG9iaiAhPT0gdW5kZWZpbmVkO1xuICAgIH0sXG5cbiAgICAvLyBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50IGlzIGEgcHJvbWlzZS4gQW55dGhpbmcgd2l0aCBhIGB0aGVuYFxuICAgIC8vIGZ1bmN0aW9uIGlzIGNvbnNpZGVyZWQgYSBwcm9taXNlLlxuICAgIGlzUHJvbWlzZTogZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuICEhcCAmJiB2LmlzRnVuY3Rpb24ocC50aGVuKTtcbiAgICB9LFxuXG4gICAgaXNKcXVlcnlFbGVtZW50OiBmdW5jdGlvbihvKSB7XG4gICAgICByZXR1cm4gbyAmJiB2LmlzU3RyaW5nKG8uanF1ZXJ5KTtcbiAgICB9LFxuXG4gICAgaXNEb21FbGVtZW50OiBmdW5jdGlvbihvKSB7XG4gICAgICBpZiAoIW8pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW8ucXVlcnlTZWxlY3RvckFsbCB8fCAhby5xdWVyeVNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHYuaXNPYmplY3QoZG9jdW1lbnQpICYmIG8gPT09IGRvY3VtZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zODQzODAvNjk5MzA0XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gbyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG8gJiZcbiAgICAgICAgICB0eXBlb2YgbyA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgIG8gIT09IG51bGwgJiZcbiAgICAgICAgICBvLm5vZGVUeXBlID09PSAxICYmXG4gICAgICAgICAgdHlwZW9mIG8ubm9kZU5hbWUgPT09IFwic3RyaW5nXCI7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgYXR0cjtcblxuICAgICAgLy8gTnVsbCBhbmQgdW5kZWZpbmVkIGFyZSBlbXB0eVxuICAgICAgaWYgKCF2LmlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGZ1bmN0aW9ucyBhcmUgbm9uIGVtcHR5XG4gICAgICBpZiAodi5pc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIFdoaXRlc3BhY2Ugb25seSBzdHJpbmdzIGFyZSBlbXB0eVxuICAgICAgaWYgKHYuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2LkVNUFRZX1NUUklOR19SRUdFWFAudGVzdCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEZvciBhcnJheXMgd2UgdXNlIHRoZSBsZW5ndGggcHJvcGVydHlcbiAgICAgIGlmICh2LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPT09IDA7XG4gICAgICB9XG5cbiAgICAgIC8vIERhdGVzIGhhdmUgbm8gYXR0cmlidXRlcyBidXQgYXJlbid0IGVtcHR5XG4gICAgICBpZiAodi5pc0RhdGUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UgZmluZCBhdCBsZWFzdCBvbmUgcHJvcGVydHkgd2UgY29uc2lkZXIgaXQgbm9uIGVtcHR5XG4gICAgICBpZiAodi5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgZm9yIChhdHRyIGluIHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8vIEZvcm1hdHMgdGhlIHNwZWNpZmllZCBzdHJpbmdzIHdpdGggdGhlIGdpdmVuIHZhbHVlcyBsaWtlIHNvOlxuICAgIC8vIGBgYFxuICAgIC8vIGZvcm1hdChcIkZvbzogJXtmb299XCIsIHtmb286IFwiYmFyXCJ9KSAvLyBcIkZvbyBiYXJcIlxuICAgIC8vIGBgYFxuICAgIC8vIElmIHlvdSB3YW50IHRvIHdyaXRlICV7Li4ufSB3aXRob3V0IGhhdmluZyBpdCByZXBsYWNlZCBzaW1wbHlcbiAgICAvLyBwcmVmaXggaXQgd2l0aCAlIGxpa2UgdGhpcyBgRm9vOiAlJXtmb299YCBhbmQgaXQgd2lsbCBiZSByZXR1cm5lZFxuICAgIC8vIGFzIGBcIkZvbzogJXtmb299XCJgXG4gICAgZm9ybWF0OiB2LmV4dGVuZChmdW5jdGlvbihzdHIsIHZhbHMpIHtcbiAgICAgIGlmICghdi5pc1N0cmluZyhzdHIpKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyLnJlcGxhY2Uodi5mb3JtYXQuRk9STUFUX1JFR0VYUCwgZnVuY3Rpb24obTAsIG0xLCBtMikge1xuICAgICAgICBpZiAobTEgPT09ICclJykge1xuICAgICAgICAgIHJldHVybiBcIiV7XCIgKyBtMiArIFwifVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsc1ttMl0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCB7XG4gICAgICAvLyBGaW5kcyAle2tleX0gc3R5bGUgcGF0dGVybnMgaW4gdGhlIGdpdmVuIHN0cmluZ1xuICAgICAgRk9STUFUX1JFR0VYUDogLyglPyklXFx7KFteXFx9XSspXFx9L2dcbiAgICB9KSxcblxuICAgIC8vIFwiUHJldHRpZmllc1wiIHRoZSBnaXZlbiBzdHJpbmcuXG4gICAgLy8gUHJldHRpZnlpbmcgbWVhbnMgcmVwbGFjaW5nIFsuXFxfLV0gd2l0aCBzcGFjZXMgYXMgd2VsbCBhcyBzcGxpdHRpbmdcbiAgICAvLyBjYW1lbCBjYXNlIHdvcmRzLlxuICAgIHByZXR0aWZ5OiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIGlmICh2LmlzTnVtYmVyKHN0cikpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG1vcmUgdGhhbiAyIGRlY2ltYWxzIHJvdW5kIGl0IHRvIHR3b1xuICAgICAgICBpZiAoKHN0ciAqIDEwMCkgJSAxID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIFwiXCIgKyBzdHI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoTWF0aC5yb3VuZChzdHIgKiAxMDApIC8gMTAwKS50b0ZpeGVkKDIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh2LmlzQXJyYXkoc3RyKSkge1xuICAgICAgICByZXR1cm4gc3RyLm1hcChmdW5jdGlvbihzKSB7IHJldHVybiB2LnByZXR0aWZ5KHMpOyB9KS5qb2luKFwiLCBcIik7XG4gICAgICB9XG5cbiAgICAgIGlmICh2LmlzT2JqZWN0KHN0cikpIHtcbiAgICAgICAgcmV0dXJuIHN0ci50b1N0cmluZygpO1xuICAgICAgfVxuXG4gICAgICAvLyBFbnN1cmUgdGhlIHN0cmluZyBpcyBhY3R1YWxseSBhIHN0cmluZ1xuICAgICAgc3RyID0gXCJcIiArIHN0cjtcblxuICAgICAgcmV0dXJuIHN0clxuICAgICAgICAvLyBTcGxpdHMga2V5cyBzZXBhcmF0ZWQgYnkgcGVyaW9kc1xuICAgICAgICAucmVwbGFjZSgvKFteXFxzXSlcXC4oW15cXHNdKS9nLCAnJDEgJDInKVxuICAgICAgICAvLyBSZW1vdmVzIGJhY2tzbGFzaGVzXG4gICAgICAgIC5yZXBsYWNlKC9cXFxcKy9nLCAnJylcbiAgICAgICAgLy8gUmVwbGFjZXMgLSBhbmQgLSB3aXRoIHNwYWNlXG4gICAgICAgIC5yZXBsYWNlKC9bXy1dL2csICcgJylcbiAgICAgICAgLy8gU3BsaXRzIGNhbWVsIGNhc2VkIHdvcmRzXG4gICAgICAgIC5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCBmdW5jdGlvbihtMCwgbTEsIG0yKSB7XG4gICAgICAgICAgcmV0dXJuIFwiXCIgKyBtMSArIFwiIFwiICsgbTIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnRvTG93ZXJDYXNlKCk7XG4gICAgfSxcblxuICAgIHN0cmluZ2lmeVZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHYucHJldHRpZnkodmFsdWUpO1xuICAgIH0sXG5cbiAgICBpc1N0cmluZzogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuICAgIH0sXG5cbiAgICBpc0FycmF5OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHt9LnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH0sXG5cbiAgICAvLyBDaGVja3MgaWYgdGhlIG9iamVjdCBpcyBhIGhhc2gsIHdoaWNoIGlzIGVxdWl2YWxlbnQgdG8gYW4gb2JqZWN0IHRoYXRcbiAgICAvLyBpcyBuZWl0aGVyIGFuIGFycmF5IG5vciBhIGZ1bmN0aW9uLlxuICAgIGlzSGFzaDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB2LmlzT2JqZWN0KHZhbHVlKSAmJiAhdi5pc0FycmF5KHZhbHVlKSAmJiAhdi5pc0Z1bmN0aW9uKHZhbHVlKTtcbiAgICB9LFxuXG4gICAgY29udGFpbnM6IGZ1bmN0aW9uKG9iaiwgdmFsdWUpIHtcbiAgICAgIGlmICghdi5pc0RlZmluZWQob2JqKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodi5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG9iai5pbmRleE9mKHZhbHVlKSAhPT0gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUgaW4gb2JqO1xuICAgIH0sXG5cbiAgICB1bmlxdWU6IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICBpZiAoIXYuaXNBcnJheShhcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5LmZpbHRlcihmdW5jdGlvbihlbCwgaW5kZXgsIGFycmF5KSB7XG4gICAgICAgIHJldHVybiBhcnJheS5pbmRleE9mKGVsKSA9PSBpbmRleDtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmb3JFYWNoS2V5SW5LZXlwYXRoOiBmdW5jdGlvbihvYmplY3QsIGtleXBhdGgsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoIXYuaXNTdHJpbmcoa2V5cGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgdmFyIGtleSA9IFwiXCJcbiAgICAgICAgLCBpXG4gICAgICAgICwgZXNjYXBlID0gZmFsc2U7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlwYXRoLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHN3aXRjaCAoa2V5cGF0aFtpXSkge1xuICAgICAgICAgIGNhc2UgJy4nOlxuICAgICAgICAgICAgaWYgKGVzY2FwZSkge1xuICAgICAgICAgICAgICBlc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAga2V5ICs9ICcuJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9iamVjdCA9IGNhbGxiYWNrKG9iamVjdCwga2V5LCBmYWxzZSk7XG4gICAgICAgICAgICAgIGtleSA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1xcXFwnOlxuICAgICAgICAgICAgaWYgKGVzY2FwZSkge1xuICAgICAgICAgICAgICBlc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAga2V5ICs9ICdcXFxcJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVzY2FwZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBlc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGtleSArPSBrZXlwYXRoW2ldO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhbGxiYWNrKG9iamVjdCwga2V5LCB0cnVlKTtcbiAgICB9LFxuXG4gICAgZ2V0RGVlcE9iamVjdFZhbHVlOiBmdW5jdGlvbihvYmosIGtleXBhdGgpIHtcbiAgICAgIGlmICghdi5pc09iamVjdChvYmopKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2LmZvckVhY2hLZXlJbktleXBhdGgob2JqLCBrZXlwYXRoLCBmdW5jdGlvbihvYmosIGtleSkge1xuICAgICAgICBpZiAodi5pc09iamVjdChvYmopKSB7XG4gICAgICAgICAgcmV0dXJuIG9ialtrZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gVGhpcyByZXR1cm5zIGFuIG9iamVjdCB3aXRoIGFsbCB0aGUgdmFsdWVzIG9mIHRoZSBmb3JtLlxuICAgIC8vIEl0IHVzZXMgdGhlIGlucHV0IG5hbWUgYXMga2V5IGFuZCB0aGUgdmFsdWUgYXMgdmFsdWVcbiAgICAvLyBTbyBmb3IgZXhhbXBsZSB0aGlzOlxuICAgIC8vIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJlbWFpbFwiIHZhbHVlPVwiZm9vQGJhci5jb21cIiAvPlxuICAgIC8vIHdvdWxkIHJldHVybjpcbiAgICAvLyB7ZW1haWw6IFwiZm9vQGJhci5jb21cIn1cbiAgICBjb2xsZWN0Rm9ybVZhbHVlczogZnVuY3Rpb24oZm9ybSwgb3B0aW9ucykge1xuICAgICAgdmFyIHZhbHVlcyA9IHt9XG4gICAgICAgICwgaVxuICAgICAgICAsIGpcbiAgICAgICAgLCBpbnB1dFxuICAgICAgICAsIGlucHV0c1xuICAgICAgICAsIG9wdGlvblxuICAgICAgICAsIHZhbHVlO1xuXG4gICAgICBpZiAodi5pc0pxdWVyeUVsZW1lbnQoZm9ybSkpIHtcbiAgICAgICAgZm9ybSA9IGZvcm1bMF07XG4gICAgICB9XG5cbiAgICAgIGlmICghZm9ybSkge1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgfVxuXG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgaW5wdXRzID0gZm9ybS5xdWVyeVNlbGVjdG9yQWxsKFwiaW5wdXRbbmFtZV0sIHRleHRhcmVhW25hbWVdXCIpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpbnB1dCA9IGlucHV0cy5pdGVtKGkpO1xuXG4gICAgICAgIGlmICh2LmlzRGVmaW5lZChpbnB1dC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWlnbm9yZWRcIikpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IHYuc2FuaXRpemVGb3JtVmFsdWUoaW5wdXQudmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoaW5wdXQudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUgPyArdmFsdWUgOiBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0LnR5cGUgPT09IFwiY2hlY2tib3hcIikge1xuICAgICAgICAgIGlmIChpbnB1dC5hdHRyaWJ1dGVzLnZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIWlucHV0LmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbaW5wdXQubmFtZV0gfHwgbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBpbnB1dC5jaGVja2VkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dC50eXBlID09PSBcInJhZGlvXCIpIHtcbiAgICAgICAgICBpZiAoIWlucHV0LmNoZWNrZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzW2lucHV0Lm5hbWVdIHx8IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhbHVlc1tpbnB1dC5uYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpbnB1dHMgPSBmb3JtLnF1ZXJ5U2VsZWN0b3JBbGwoXCJzZWxlY3RbbmFtZV1cIik7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlucHV0ID0gaW5wdXRzLml0ZW0oaSk7XG4gICAgICAgIGlmIChpbnB1dC5tdWx0aXBsZSkge1xuICAgICAgICAgIHZhbHVlID0gW107XG4gICAgICAgICAgZm9yIChqIGluIGlucHV0Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbiA9IGlucHV0Lm9wdGlvbnNbal07XG4gICAgICAgICAgICBpZiAob3B0aW9uLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgIHZhbHVlLnB1c2godi5zYW5pdGl6ZUZvcm1WYWx1ZShvcHRpb24udmFsdWUsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSB2LnNhbml0aXplRm9ybVZhbHVlKGlucHV0Lm9wdGlvbnNbaW5wdXQuc2VsZWN0ZWRJbmRleF0udmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlc1tpbnB1dC5uYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH0sXG5cbiAgICBzYW5pdGl6ZUZvcm1WYWx1ZTogZnVuY3Rpb24odmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zLnRyaW0gJiYgdi5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLm51bGxpZnkgIT09IGZhbHNlICYmIHZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICBjYXBpdGFsaXplOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIGlmICghdi5pc1N0cmluZyhzdHIpKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyWzBdLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSBhbGwgZXJyb3JzIHdobydzIGVycm9yIGF0dHJpYnV0ZSBpcyBlbXB0eSAobnVsbCBvciB1bmRlZmluZWQpXG4gICAgcHJ1bmVFbXB0eUVycm9yczogZnVuY3Rpb24oZXJyb3JzKSB7XG4gICAgICByZXR1cm4gZXJyb3JzLmZpbHRlcihmdW5jdGlvbihlcnJvcikge1xuICAgICAgICByZXR1cm4gIXYuaXNFbXB0eShlcnJvci5lcnJvcik7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gSW5cbiAgICAvLyBbe2Vycm9yOiBbXCJlcnIxXCIsIFwiZXJyMlwiXSwgLi4ufV1cbiAgICAvLyBPdXRcbiAgICAvLyBbe2Vycm9yOiBcImVycjFcIiwgLi4ufSwge2Vycm9yOiBcImVycjJcIiwgLi4ufV1cbiAgICAvL1xuICAgIC8vIEFsbCBhdHRyaWJ1dGVzIGluIGFuIGVycm9yIHdpdGggbXVsdGlwbGUgbWVzc2FnZXMgYXJlIGR1cGxpY2F0ZWRcbiAgICAvLyB3aGVuIGV4cGFuZGluZyB0aGUgZXJyb3JzLlxuICAgIGV4cGFuZE11bHRpcGxlRXJyb3JzOiBmdW5jdGlvbihlcnJvcnMpIHtcbiAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgIGVycm9ycy5mb3JFYWNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgIC8vIFJlbW92ZXMgZXJyb3JzIHdpdGhvdXQgYSBtZXNzYWdlXG4gICAgICAgIGlmICh2LmlzQXJyYXkoZXJyb3IuZXJyb3IpKSB7XG4gICAgICAgICAgZXJyb3IuZXJyb3IuZm9yRWFjaChmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKHYuZXh0ZW5kKHt9LCBlcnJvciwge2Vycm9yOiBtc2d9KSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0LnB1c2goZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnRzIHRoZSBlcnJvciBtZXNhZ2VzIGJ5IHByZXBlbmRpbmcgdGhlIGF0dHJpYnV0ZSBuYW1lIHVubGVzcyB0aGVcbiAgICAvLyBtZXNzYWdlIGlzIHByZWZpeGVkIGJ5IF5cbiAgICBjb252ZXJ0RXJyb3JNZXNzYWdlczogZnVuY3Rpb24oZXJyb3JzLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgZXJyb3JzLmZvckVhY2goZnVuY3Rpb24oZXJyb3JJbmZvKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHYucmVzdWx0KGVycm9ySW5mby5lcnJvcixcbiAgICAgICAgICAgIGVycm9ySW5mby52YWx1ZSxcbiAgICAgICAgICAgIGVycm9ySW5mby5hdHRyaWJ1dGUsXG4gICAgICAgICAgICBlcnJvckluZm8ub3B0aW9ucyxcbiAgICAgICAgICAgIGVycm9ySW5mby5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgZXJyb3JJbmZvLmdsb2JhbE9wdGlvbnMpO1xuXG4gICAgICAgIGlmICghdi5pc1N0cmluZyhlcnJvcikpIHtcbiAgICAgICAgICByZXQucHVzaChlcnJvckluZm8pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvclswXSA9PT0gJ14nKSB7XG4gICAgICAgICAgZXJyb3IgPSBlcnJvci5zbGljZSgxKTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmZ1bGxNZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBlcnJvciA9IHYuY2FwaXRhbGl6ZSh2LnByZXR0aWZ5KGVycm9ySW5mby5hdHRyaWJ1dGUpKSArIFwiIFwiICsgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IgPSBlcnJvci5yZXBsYWNlKC9cXFxcXFxeL2csIFwiXlwiKTtcbiAgICAgICAgZXJyb3IgPSB2LmZvcm1hdChlcnJvciwge3ZhbHVlOiB2LnN0cmluZ2lmeVZhbHVlKGVycm9ySW5mby52YWx1ZSl9KTtcbiAgICAgICAgcmV0LnB1c2godi5leHRlbmQoe30sIGVycm9ySW5mbywge2Vycm9yOiBlcnJvcn0pKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuXG4gICAgLy8gSW46XG4gICAgLy8gW3thdHRyaWJ1dGU6IFwiPGF0dHJpYnV0ZU5hbWU+XCIsIC4uLn1dXG4gICAgLy8gT3V0OlxuICAgIC8vIHtcIjxhdHRyaWJ1dGVOYW1lPlwiOiBbe2F0dHJpYnV0ZTogXCI8YXR0cmlidXRlTmFtZT5cIiwgLi4ufV19XG4gICAgZ3JvdXBFcnJvcnNCeUF0dHJpYnV0ZTogZnVuY3Rpb24oZXJyb3JzKSB7XG4gICAgICB2YXIgcmV0ID0ge307XG4gICAgICBlcnJvcnMuZm9yRWFjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICB2YXIgbGlzdCA9IHJldFtlcnJvci5hdHRyaWJ1dGVdO1xuICAgICAgICBpZiAobGlzdCkge1xuICAgICAgICAgIGxpc3QucHVzaChlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0W2Vycm9yLmF0dHJpYnV0ZV0gPSBbZXJyb3JdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIC8vIEluOlxuICAgIC8vIFt7ZXJyb3I6IFwiPG1lc3NhZ2UgMT5cIiwgLi4ufSwge2Vycm9yOiBcIjxtZXNzYWdlIDI+XCIsIC4uLn1dXG4gICAgLy8gT3V0OlxuICAgIC8vIFtcIjxtZXNzYWdlIDE+XCIsIFwiPG1lc3NhZ2UgMj5cIl1cbiAgICBmbGF0dGVuRXJyb3JzVG9BcnJheTogZnVuY3Rpb24oZXJyb3JzKSB7XG4gICAgICByZXR1cm4gZXJyb3JzXG4gICAgICAgIC5tYXAoZnVuY3Rpb24oZXJyb3IpIHsgcmV0dXJuIGVycm9yLmVycm9yOyB9KVxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgc2VsZikge1xuICAgICAgICAgIHJldHVybiBzZWxmLmluZGV4T2YodmFsdWUpID09PSBpbmRleDtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGNsZWFuQXR0cmlidXRlczogZnVuY3Rpb24oYXR0cmlidXRlcywgd2hpdGVsaXN0KSB7XG4gICAgICBmdW5jdGlvbiB3aGl0ZWxpc3RDcmVhdG9yKG9iaiwga2V5LCBsYXN0KSB7XG4gICAgICAgIGlmICh2LmlzT2JqZWN0KG9ialtrZXldKSkge1xuICAgICAgICAgIHJldHVybiBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG9ialtrZXldID0gbGFzdCA/IHRydWUgOiB7fSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGJ1aWxkT2JqZWN0V2hpdGVsaXN0KHdoaXRlbGlzdCkge1xuICAgICAgICB2YXIgb3cgPSB7fVxuICAgICAgICAgICwgbGFzdE9iamVjdFxuICAgICAgICAgICwgYXR0cjtcbiAgICAgICAgZm9yIChhdHRyIGluIHdoaXRlbGlzdCkge1xuICAgICAgICAgIGlmICghd2hpdGVsaXN0W2F0dHJdKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdi5mb3JFYWNoS2V5SW5LZXlwYXRoKG93LCBhdHRyLCB3aGl0ZWxpc3RDcmVhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3c7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNsZWFuUmVjdXJzaXZlKGF0dHJpYnV0ZXMsIHdoaXRlbGlzdCkge1xuICAgICAgICBpZiAoIXYuaXNPYmplY3QoYXR0cmlidXRlcykpIHtcbiAgICAgICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXQgPSB2LmV4dGVuZCh7fSwgYXR0cmlidXRlcylcbiAgICAgICAgICAsIHdcbiAgICAgICAgICAsIGF0dHJpYnV0ZTtcblxuICAgICAgICBmb3IgKGF0dHJpYnV0ZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgdyA9IHdoaXRlbGlzdFthdHRyaWJ1dGVdO1xuXG4gICAgICAgICAgaWYgKHYuaXNPYmplY3QodykpIHtcbiAgICAgICAgICAgIHJldFthdHRyaWJ1dGVdID0gY2xlYW5SZWN1cnNpdmUocmV0W2F0dHJpYnV0ZV0sIHcpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXcpIHtcbiAgICAgICAgICAgIGRlbGV0ZSByZXRbYXR0cmlidXRlXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cblxuICAgICAgaWYgKCF2LmlzT2JqZWN0KHdoaXRlbGlzdCkgfHwgIXYuaXNPYmplY3QoYXR0cmlidXRlcykpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuXG4gICAgICB3aGl0ZWxpc3QgPSBidWlsZE9iamVjdFdoaXRlbGlzdCh3aGl0ZWxpc3QpO1xuICAgICAgcmV0dXJuIGNsZWFuUmVjdXJzaXZlKGF0dHJpYnV0ZXMsIHdoaXRlbGlzdCk7XG4gICAgfSxcblxuICAgIGV4cG9zZU1vZHVsZTogZnVuY3Rpb24odmFsaWRhdGUsIHJvb3QsIGV4cG9ydHMsIG1vZHVsZSwgZGVmaW5lKSB7XG4gICAgICBpZiAoZXhwb3J0cykge1xuICAgICAgICBpZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gdmFsaWRhdGU7XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0cy52YWxpZGF0ZSA9IHZhbGlkYXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC52YWxpZGF0ZSA9IHZhbGlkYXRlO1xuICAgICAgICBpZiAodmFsaWRhdGUuaXNGdW5jdGlvbihkZWZpbmUpICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgICBkZWZpbmUoW10sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbGlkYXRlOyB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICB3YXJuOiBmdW5jdGlvbihtc2cpIHtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW3ZhbGlkYXRlLmpzXSBcIiArIG1zZyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGVycm9yOiBmdW5jdGlvbihtc2cpIHtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJbdmFsaWRhdGUuanNdIFwiICsgbXNnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHZhbGlkYXRlLnZhbGlkYXRvcnMgPSB7XG4gICAgLy8gUHJlc2VuY2UgdmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIGlzbid0IGVtcHR5XG4gICAgcHJlc2VuY2U6IGZ1bmN0aW9uKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gdi5leHRlbmQoe30sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5hbGxvd0VtcHR5ID8gIXYuaXNEZWZpbmVkKHZhbHVlKSA6IHYuaXNFbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMubWVzc2FnZSB8fCB0aGlzLm1lc3NhZ2UgfHwgXCJjYW4ndCBiZSBibGFua1wiO1xuICAgICAgfVxuICAgIH0sXG4gICAgbGVuZ3RoOiBmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucywgYXR0cmlidXRlKSB7XG4gICAgICAvLyBFbXB0eSB2YWx1ZXMgYXJlIGFsbG93ZWRcbiAgICAgIGlmICghdi5pc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgb3B0aW9ucyA9IHYuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICB2YXIgaXMgPSBvcHRpb25zLmlzXG4gICAgICAgICwgbWF4aW11bSA9IG9wdGlvbnMubWF4aW11bVxuICAgICAgICAsIG1pbmltdW0gPSBvcHRpb25zLm1pbmltdW1cbiAgICAgICAgLCB0b2tlbml6ZXIgPSBvcHRpb25zLnRva2VuaXplciB8fCBmdW5jdGlvbih2YWwpIHsgcmV0dXJuIHZhbDsgfVxuICAgICAgICAsIGVyclxuICAgICAgICAsIGVycm9ycyA9IFtdO1xuXG4gICAgICB2YWx1ZSA9IHRva2VuaXplcih2YWx1ZSk7XG4gICAgICB2YXIgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgICAgaWYoIXYuaXNOdW1iZXIobGVuZ3RoKSkge1xuICAgICAgICB2LmVycm9yKHYuZm9ybWF0KFwiQXR0cmlidXRlICV7YXR0cn0gaGFzIGEgbm9uIG51bWVyaWMgdmFsdWUgZm9yIGBsZW5ndGhgXCIsIHthdHRyOiBhdHRyaWJ1dGV9KSk7XG4gICAgICAgIHJldHVybiBvcHRpb25zLm1lc3NhZ2UgfHwgdGhpcy5ub3RWYWxpZCB8fCBcImhhcyBhbiBpbmNvcnJlY3QgbGVuZ3RoXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIElzIGNoZWNrc1xuICAgICAgaWYgKHYuaXNOdW1iZXIoaXMpICYmIGxlbmd0aCAhPT0gaXMpIHtcbiAgICAgICAgZXJyID0gb3B0aW9ucy53cm9uZ0xlbmd0aCB8fFxuICAgICAgICAgIHRoaXMud3JvbmdMZW5ndGggfHxcbiAgICAgICAgICBcImlzIHRoZSB3cm9uZyBsZW5ndGggKHNob3VsZCBiZSAle2NvdW50fSBjaGFyYWN0ZXJzKVwiO1xuICAgICAgICBlcnJvcnMucHVzaCh2LmZvcm1hdChlcnIsIHtjb3VudDogaXN9KSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2LmlzTnVtYmVyKG1pbmltdW0pICYmIGxlbmd0aCA8IG1pbmltdW0pIHtcbiAgICAgICAgZXJyID0gb3B0aW9ucy50b29TaG9ydCB8fFxuICAgICAgICAgIHRoaXMudG9vU2hvcnQgfHxcbiAgICAgICAgICBcImlzIHRvbyBzaG9ydCAobWluaW11bSBpcyAle2NvdW50fSBjaGFyYWN0ZXJzKVwiO1xuICAgICAgICBlcnJvcnMucHVzaCh2LmZvcm1hdChlcnIsIHtjb3VudDogbWluaW11bX0pKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHYuaXNOdW1iZXIobWF4aW11bSkgJiYgbGVuZ3RoID4gbWF4aW11bSkge1xuICAgICAgICBlcnIgPSBvcHRpb25zLnRvb0xvbmcgfHxcbiAgICAgICAgICB0aGlzLnRvb0xvbmcgfHxcbiAgICAgICAgICBcImlzIHRvbyBsb25nIChtYXhpbXVtIGlzICV7Y291bnR9IGNoYXJhY3RlcnMpXCI7XG4gICAgICAgIGVycm9ycy5wdXNoKHYuZm9ybWF0KGVyciwge2NvdW50OiBtYXhpbXVtfSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMubWVzc2FnZSB8fCBlcnJvcnM7XG4gICAgICB9XG4gICAgfSxcbiAgICBudW1lcmljYWxpdHk6IGZ1bmN0aW9uKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAvLyBFbXB0eSB2YWx1ZXMgYXJlIGZpbmVcbiAgICAgIGlmICghdi5pc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgb3B0aW9ucyA9IHYuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICB2YXIgZXJyb3JzID0gW11cbiAgICAgICAgLCBuYW1lXG4gICAgICAgICwgY291bnRcbiAgICAgICAgLCBjaGVja3MgPSB7XG4gICAgICAgICAgICBncmVhdGVyVGhhbjogICAgICAgICAgZnVuY3Rpb24odiwgYykgeyByZXR1cm4gdiA+IGM7IH0sXG4gICAgICAgICAgICBncmVhdGVyVGhhbk9yRXF1YWxUbzogZnVuY3Rpb24odiwgYykgeyByZXR1cm4gdiA+PSBjOyB9LFxuICAgICAgICAgICAgZXF1YWxUbzogICAgICAgICAgICAgIGZ1bmN0aW9uKHYsIGMpIHsgcmV0dXJuIHYgPT09IGM7IH0sXG4gICAgICAgICAgICBsZXNzVGhhbjogICAgICAgICAgICAgZnVuY3Rpb24odiwgYykgeyByZXR1cm4gdiA8IGM7IH0sXG4gICAgICAgICAgICBsZXNzVGhhbk9yRXF1YWxUbzogICAgZnVuY3Rpb24odiwgYykgeyByZXR1cm4gdiA8PSBjOyB9LFxuICAgICAgICAgICAgZGl2aXNpYmxlQnk6ICAgICAgICAgIGZ1bmN0aW9uKHYsIGMpIHsgcmV0dXJuIHYgJSBjID09PSAwOyB9XG4gICAgICAgICAgfTtcblxuICAgICAgLy8gU3RyaWN0IHdpbGwgY2hlY2sgdGhhdCBpdCBpcyBhIHZhbGlkIGxvb2tpbmcgbnVtYmVyXG4gICAgICBpZiAodi5pc1N0cmluZyh2YWx1ZSkgJiYgb3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSBcIl4oMHxbMS05XVxcXFxkKilcIjtcbiAgICAgICAgaWYgKCFvcHRpb25zLm9ubHlJbnRlZ2VyKSB7XG4gICAgICAgICAgcGF0dGVybiArPSBcIihcXFxcLlxcXFxkKyk/XCI7XG4gICAgICAgIH1cbiAgICAgICAgcGF0dGVybiArPSBcIiRcIjtcblxuICAgICAgICBpZiAoIShuZXcgUmVnRXhwKHBhdHRlcm4pLnRlc3QodmFsdWUpKSkge1xuICAgICAgICAgIHJldHVybiBvcHRpb25zLm1lc3NhZ2UgfHxcbiAgICAgICAgICAgIG9wdGlvbnMubm90VmFsaWQgfHxcbiAgICAgICAgICAgIHRoaXMubm90VmFsaWQgfHxcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSB8fFxuICAgICAgICAgICAgXCJtdXN0IGJlIGEgdmFsaWQgbnVtYmVyXCI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ29lcmNlIHRoZSB2YWx1ZSB0byBhIG51bWJlciB1bmxlc3Mgd2UncmUgYmVpbmcgc3RyaWN0LlxuICAgICAgaWYgKG9wdGlvbnMubm9TdHJpbmdzICE9PSB0cnVlICYmIHYuaXNTdHJpbmcodmFsdWUpICYmICF2LmlzRW1wdHkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBpdCdzIG5vdCBhIG51bWJlciB3ZSBzaG91bGRuJ3QgY29udGludWUgc2luY2UgaXQgd2lsbCBjb21wYXJlIGl0LlxuICAgICAgaWYgKCF2LmlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5tZXNzYWdlIHx8XG4gICAgICAgICAgb3B0aW9ucy5ub3RWYWxpZCB8fFxuICAgICAgICAgIHRoaXMubm90VmFsaWQgfHxcbiAgICAgICAgICB0aGlzLm1lc3NhZ2UgfHxcbiAgICAgICAgICBcImlzIG5vdCBhIG51bWJlclwiO1xuICAgICAgfVxuXG4gICAgICAvLyBTYW1lIGxvZ2ljIGFzIGFib3ZlLCBzb3J0IG9mLiBEb24ndCBib3RoZXIgd2l0aCBjb21wYXJpc29ucyBpZiB0aGlzXG4gICAgICAvLyBkb2Vzbid0IHBhc3MuXG4gICAgICBpZiAob3B0aW9ucy5vbmx5SW50ZWdlciAmJiAhdi5pc0ludGVnZXIodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLm1lc3NhZ2UgfHxcbiAgICAgICAgICBvcHRpb25zLm5vdEludGVnZXIgfHxcbiAgICAgICAgICB0aGlzLm5vdEludGVnZXIgfHxcbiAgICAgICAgICB0aGlzLm1lc3NhZ2UgfHxcbiAgICAgICAgICBcIm11c3QgYmUgYW4gaW50ZWdlclwiO1xuICAgICAgfVxuXG4gICAgICBmb3IgKG5hbWUgaW4gY2hlY2tzKSB7XG4gICAgICAgIGNvdW50ID0gb3B0aW9uc1tuYW1lXTtcbiAgICAgICAgaWYgKHYuaXNOdW1iZXIoY291bnQpICYmICFjaGVja3NbbmFtZV0odmFsdWUsIGNvdW50KSkge1xuICAgICAgICAgIC8vIFRoaXMgcGlja3MgdGhlIGRlZmF1bHQgbWVzc2FnZSBpZiBzcGVjaWZpZWRcbiAgICAgICAgICAvLyBGb3IgZXhhbXBsZSB0aGUgZ3JlYXRlclRoYW4gY2hlY2sgdXNlcyB0aGUgbWVzc2FnZSBmcm9tXG4gICAgICAgICAgLy8gdGhpcy5ub3RHcmVhdGVyVGhhbiBzbyB3ZSBjYXBpdGFsaXplIHRoZSBuYW1lIGFuZCBwcmVwZW5kIFwibm90XCJcbiAgICAgICAgICB2YXIga2V5ID0gXCJub3RcIiArIHYuY2FwaXRhbGl6ZShuYW1lKTtcbiAgICAgICAgICB2YXIgbXNnID0gb3B0aW9uc1trZXldIHx8XG4gICAgICAgICAgICB0aGlzW2tleV0gfHxcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSB8fFxuICAgICAgICAgICAgXCJtdXN0IGJlICV7dHlwZX0gJXtjb3VudH1cIjtcblxuICAgICAgICAgIGVycm9ycy5wdXNoKHYuZm9ybWF0KG1zZywge1xuICAgICAgICAgICAgY291bnQ6IGNvdW50LFxuICAgICAgICAgICAgdHlwZTogdi5wcmV0dGlmeShuYW1lKVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5vZGQgJiYgdmFsdWUgJSAyICE9PSAxKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG9wdGlvbnMubm90T2RkIHx8XG4gICAgICAgICAgICB0aGlzLm5vdE9kZCB8fFxuICAgICAgICAgICAgdGhpcy5tZXNzYWdlIHx8XG4gICAgICAgICAgICBcIm11c3QgYmUgb2RkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZXZlbiAmJiB2YWx1ZSAlIDIgIT09IDApIHtcbiAgICAgICAgZXJyb3JzLnB1c2gob3B0aW9ucy5ub3RFdmVuIHx8XG4gICAgICAgICAgICB0aGlzLm5vdEV2ZW4gfHxcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSB8fFxuICAgICAgICAgICAgXCJtdXN0IGJlIGV2ZW5cIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLm1lc3NhZ2UgfHwgZXJyb3JzO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGF0ZXRpbWU6IHYuZXh0ZW5kKGZ1bmN0aW9uKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIXYuaXNGdW5jdGlvbih0aGlzLnBhcnNlKSB8fCAhdi5pc0Z1bmN0aW9uKHRoaXMuZm9ybWF0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCb3RoIHRoZSBwYXJzZSBhbmQgZm9ybWF0IGZ1bmN0aW9ucyBuZWVkcyB0byBiZSBzZXQgdG8gdXNlIHRoZSBkYXRldGltZS9kYXRlIHZhbGlkYXRvclwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gRW1wdHkgdmFsdWVzIGFyZSBmaW5lXG4gICAgICBpZiAoIXYuaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMgPSB2LmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgdmFyIGVyclxuICAgICAgICAsIGVycm9ycyA9IFtdXG4gICAgICAgICwgZWFybGllc3QgPSBvcHRpb25zLmVhcmxpZXN0ID8gdGhpcy5wYXJzZShvcHRpb25zLmVhcmxpZXN0LCBvcHRpb25zKSA6IE5hTlxuICAgICAgICAsIGxhdGVzdCA9IG9wdGlvbnMubGF0ZXN0ID8gdGhpcy5wYXJzZShvcHRpb25zLmxhdGVzdCwgb3B0aW9ucykgOiBOYU47XG5cbiAgICAgIHZhbHVlID0gdGhpcy5wYXJzZSh2YWx1ZSwgb3B0aW9ucyk7XG5cbiAgICAgIC8vIDg2NDAwMDAwIGlzIHRoZSBudW1iZXIgb2Ygc2Vjb25kcyBpbiBhIGRheSwgdGhpcyBpcyB1c2VkIHRvIHJlbW92ZVxuICAgICAgLy8gdGhlIHRpbWUgZnJvbSB0aGUgZGF0ZVxuICAgICAgaWYgKGlzTmFOKHZhbHVlKSB8fCBvcHRpb25zLmRhdGVPbmx5ICYmIHZhbHVlICUgODY0MDAwMDAgIT09IDApIHtcbiAgICAgICAgZXJyID0gb3B0aW9ucy5ub3RWYWxpZCB8fFxuICAgICAgICAgIG9wdGlvbnMubWVzc2FnZSB8fFxuICAgICAgICAgIHRoaXMubm90VmFsaWQgfHxcbiAgICAgICAgICBcIm11c3QgYmUgYSB2YWxpZCBkYXRlXCI7XG4gICAgICAgIHJldHVybiB2LmZvcm1hdChlcnIsIHt2YWx1ZTogYXJndW1lbnRzWzBdfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oZWFybGllc3QpICYmIHZhbHVlIDwgZWFybGllc3QpIHtcbiAgICAgICAgZXJyID0gb3B0aW9ucy50b29FYXJseSB8fFxuICAgICAgICAgIG9wdGlvbnMubWVzc2FnZSB8fFxuICAgICAgICAgIHRoaXMudG9vRWFybHkgfHxcbiAgICAgICAgICBcIm11c3QgYmUgbm8gZWFybGllciB0aGFuICV7ZGF0ZX1cIjtcbiAgICAgICAgZXJyID0gdi5mb3JtYXQoZXJyLCB7XG4gICAgICAgICAgdmFsdWU6IHRoaXMuZm9ybWF0KHZhbHVlLCBvcHRpb25zKSxcbiAgICAgICAgICBkYXRlOiB0aGlzLmZvcm1hdChlYXJsaWVzdCwgb3B0aW9ucylcbiAgICAgICAgfSk7XG4gICAgICAgIGVycm9ycy5wdXNoKGVycik7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4obGF0ZXN0KSAmJiB2YWx1ZSA+IGxhdGVzdCkge1xuICAgICAgICBlcnIgPSBvcHRpb25zLnRvb0xhdGUgfHxcbiAgICAgICAgICBvcHRpb25zLm1lc3NhZ2UgfHxcbiAgICAgICAgICB0aGlzLnRvb0xhdGUgfHxcbiAgICAgICAgICBcIm11c3QgYmUgbm8gbGF0ZXIgdGhhbiAle2RhdGV9XCI7XG4gICAgICAgIGVyciA9IHYuZm9ybWF0KGVyciwge1xuICAgICAgICAgIGRhdGU6IHRoaXMuZm9ybWF0KGxhdGVzdCwgb3B0aW9ucyksXG4gICAgICAgICAgdmFsdWU6IHRoaXMuZm9ybWF0KHZhbHVlLCBvcHRpb25zKVxuICAgICAgICB9KTtcbiAgICAgICAgZXJyb3JzLnB1c2goZXJyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHYudW5pcXVlKGVycm9ycyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgcGFyc2U6IG51bGwsXG4gICAgICBmb3JtYXQ6IG51bGxcbiAgICB9KSxcbiAgICBkYXRlOiBmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHYuZXh0ZW5kKHt9LCBvcHRpb25zLCB7ZGF0ZU9ubHk6IHRydWV9KTtcbiAgICAgIHJldHVybiB2LnZhbGlkYXRvcnMuZGF0ZXRpbWUuY2FsbCh2LnZhbGlkYXRvcnMuZGF0ZXRpbWUsIHZhbHVlLCBvcHRpb25zKTtcbiAgICB9LFxuICAgIGZvcm1hdDogZnVuY3Rpb24odmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIGlmICh2LmlzU3RyaW5nKG9wdGlvbnMpIHx8IChvcHRpb25zIGluc3RhbmNlb2YgUmVnRXhwKSkge1xuICAgICAgICBvcHRpb25zID0ge3BhdHRlcm46IG9wdGlvbnN9O1xuICAgICAgfVxuXG4gICAgICBvcHRpb25zID0gdi5leHRlbmQoe30sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgIHZhciBtZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlIHx8IHRoaXMubWVzc2FnZSB8fCBcImlzIGludmFsaWRcIlxuICAgICAgICAsIHBhdHRlcm4gPSBvcHRpb25zLnBhdHRlcm5cbiAgICAgICAgLCBtYXRjaDtcblxuICAgICAgLy8gRW1wdHkgdmFsdWVzIGFyZSBhbGxvd2VkXG4gICAgICBpZiAoIXYuaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXYuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgfVxuXG4gICAgICBpZiAodi5pc1N0cmluZyhwYXR0ZXJuKSkge1xuICAgICAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cChvcHRpb25zLnBhdHRlcm4sIG9wdGlvbnMuZmxhZ3MpO1xuICAgICAgfVxuICAgICAgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWModmFsdWUpO1xuICAgICAgaWYgKCFtYXRjaCB8fCBtYXRjaFswXS5sZW5ndGggIT0gdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgfVxuICAgIH0sXG4gICAgaW5jbHVzaW9uOiBmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgLy8gRW1wdHkgdmFsdWVzIGFyZSBmaW5lXG4gICAgICBpZiAoIXYuaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodi5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7d2l0aGluOiBvcHRpb25zfTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSB2LmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgIGlmICh2LmNvbnRhaW5zKG9wdGlvbnMud2l0aGluLCB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2UgfHxcbiAgICAgICAgdGhpcy5tZXNzYWdlIHx8XG4gICAgICAgIFwiXiV7dmFsdWV9IGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgbGlzdFwiO1xuICAgICAgcmV0dXJuIHYuZm9ybWF0KG1lc3NhZ2UsIHt2YWx1ZTogdmFsdWV9KTtcbiAgICB9LFxuICAgIGV4Y2x1c2lvbjogZnVuY3Rpb24odmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIC8vIEVtcHR5IHZhbHVlcyBhcmUgZmluZVxuICAgICAgaWYgKCF2LmlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHYuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zID0ge3dpdGhpbjogb3B0aW9uc307XG4gICAgICB9XG4gICAgICBvcHRpb25zID0gdi5leHRlbmQoe30sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICBpZiAoIXYuY29udGFpbnMob3B0aW9ucy53aXRoaW4sIHZhbHVlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZSB8fCB0aGlzLm1lc3NhZ2UgfHwgXCJeJXt2YWx1ZX0gaXMgcmVzdHJpY3RlZFwiO1xuICAgICAgcmV0dXJuIHYuZm9ybWF0KG1lc3NhZ2UsIHt2YWx1ZTogdmFsdWV9KTtcbiAgICB9LFxuICAgIGVtYWlsOiB2LmV4dGVuZChmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHYuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgdmFyIG1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2UgfHwgdGhpcy5tZXNzYWdlIHx8IFwiaXMgbm90IGEgdmFsaWQgZW1haWxcIjtcbiAgICAgIC8vIEVtcHR5IHZhbHVlcyBhcmUgZmluZVxuICAgICAgaWYgKCF2LmlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF2LmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5QQVRURVJOLmV4ZWModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIFBBVFRFUk46IC9eW2EtejAtOVxcdTAwN0YtXFx1ZmZmZiEjJCUmJyorXFwvPT9eX2B7fH1+LV0rKD86XFwuW2EtejAtOVxcdTAwN0YtXFx1ZmZmZiEjJCUmJyorXFwvPT9eX2B7fH1+LV0rKSpAKD86W2EtejAtOV0oPzpbYS16MC05LV0qW2EtejAtOV0pP1xcLikrW2Etel17Mix9JC9pXG4gICAgfSksXG4gICAgZXF1YWxpdHk6IGZ1bmN0aW9uKHZhbHVlLCBvcHRpb25zLCBhdHRyaWJ1dGUsIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmICghdi5pc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHYuaXNTdHJpbmcob3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IHthdHRyaWJ1dGU6IG9wdGlvbnN9O1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IHYuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgdmFyIG1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2UgfHxcbiAgICAgICAgdGhpcy5tZXNzYWdlIHx8XG4gICAgICAgIFwiaXMgbm90IGVxdWFsIHRvICV7YXR0cmlidXRlfVwiO1xuXG4gICAgICBpZiAodi5pc0VtcHR5KG9wdGlvbnMuYXR0cmlidXRlKSB8fCAhdi5pc1N0cmluZyhvcHRpb25zLmF0dHJpYnV0ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGF0dHJpYnV0ZSBtdXN0IGJlIGEgbm9uIGVtcHR5IHN0cmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG90aGVyVmFsdWUgPSB2LmdldERlZXBPYmplY3RWYWx1ZShhdHRyaWJ1dGVzLCBvcHRpb25zLmF0dHJpYnV0ZSlcbiAgICAgICAgLCBjb21wYXJhdG9yID0gb3B0aW9ucy5jb21wYXJhdG9yIHx8IGZ1bmN0aW9uKHYxLCB2Mikge1xuICAgICAgICAgIHJldHVybiB2MSA9PT0gdjI7XG4gICAgICAgIH07XG5cbiAgICAgIGlmICghY29tcGFyYXRvcih2YWx1ZSwgb3RoZXJWYWx1ZSwgb3B0aW9ucywgYXR0cmlidXRlLCBhdHRyaWJ1dGVzKSkge1xuICAgICAgICByZXR1cm4gdi5mb3JtYXQobWVzc2FnZSwge2F0dHJpYnV0ZTogdi5wcmV0dGlmeShvcHRpb25zLmF0dHJpYnV0ZSl9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gQSBVUkwgdmFsaWRhdG9yIHRoYXQgaXMgdXNlZCB0byB2YWxpZGF0ZSBVUkxzIHdpdGggdGhlIGFiaWxpdHkgdG9cbiAgICAvLyByZXN0cmljdCBzY2hlbWVzIGFuZCBzb21lIGRvbWFpbnMuXG4gICAgdXJsOiBmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgaWYgKCF2LmlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBvcHRpb25zID0gdi5leHRlbmQoe30sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgIHZhciBtZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlIHx8IHRoaXMubWVzc2FnZSB8fCBcImlzIG5vdCBhIHZhbGlkIHVybFwiXG4gICAgICAgICwgc2NoZW1lcyA9IG9wdGlvbnMuc2NoZW1lcyB8fCB0aGlzLnNjaGVtZXMgfHwgWydodHRwJywgJ2h0dHBzJ11cbiAgICAgICAgLCBhbGxvd0xvY2FsID0gb3B0aW9ucy5hbGxvd0xvY2FsIHx8IHRoaXMuYWxsb3dMb2NhbCB8fCBmYWxzZTtcblxuICAgICAgaWYgKCF2LmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgIH1cblxuICAgICAgLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZHBlcmluaS83MjkyOTRcbiAgICAgIHZhciByZWdleCA9XG4gICAgICAgIFwiXlwiICtcbiAgICAgICAgLy8gcHJvdG9jb2wgaWRlbnRpZmllclxuICAgICAgICBcIig/Oig/OlwiICsgc2NoZW1lcy5qb2luKFwifFwiKSArIFwiKTovLylcIiArXG4gICAgICAgIC8vIHVzZXI6cGFzcyBhdXRoZW50aWNhdGlvblxuICAgICAgICBcIig/OlxcXFxTKyg/OjpcXFxcUyopP0ApP1wiICtcbiAgICAgICAgXCIoPzpcIjtcblxuICAgICAgdmFyIHRsZCA9IFwiKD86XFxcXC4oPzpbYS16XFxcXHUwMGExLVxcXFx1ZmZmZl17Mix9KSlcIjtcblxuICAgICAgaWYgKGFsbG93TG9jYWwpIHtcbiAgICAgICAgdGxkICs9IFwiP1wiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVnZXggKz1cbiAgICAgICAgICAvLyBJUCBhZGRyZXNzIGV4Y2x1c2lvblxuICAgICAgICAgIC8vIHByaXZhdGUgJiBsb2NhbCBuZXR3b3Jrc1xuICAgICAgICAgIFwiKD8hKD86MTB8MTI3KSg/OlxcXFwuXFxcXGR7MSwzfSl7M30pXCIgK1xuICAgICAgICAgIFwiKD8hKD86MTY5XFxcXC4yNTR8MTkyXFxcXC4xNjgpKD86XFxcXC5cXFxcZHsxLDN9KXsyfSlcIiArXG4gICAgICAgICAgXCIoPyExNzJcXFxcLig/OjFbNi05XXwyXFxcXGR8M1swLTFdKSg/OlxcXFwuXFxcXGR7MSwzfSl7Mn0pXCI7XG4gICAgICB9XG5cbiAgICAgIHJlZ2V4ICs9XG4gICAgICAgICAgLy8gSVAgYWRkcmVzcyBkb3R0ZWQgbm90YXRpb24gb2N0ZXRzXG4gICAgICAgICAgLy8gZXhjbHVkZXMgbG9vcGJhY2sgbmV0d29yayAwLjAuMC4wXG4gICAgICAgICAgLy8gZXhjbHVkZXMgcmVzZXJ2ZWQgc3BhY2UgPj0gMjI0LjAuMC4wXG4gICAgICAgICAgLy8gZXhjbHVkZXMgbmV0d29yayAmIGJyb2FjYXN0IGFkZHJlc3Nlc1xuICAgICAgICAgIC8vIChmaXJzdCAmIGxhc3QgSVAgYWRkcmVzcyBvZiBlYWNoIGNsYXNzKVxuICAgICAgICAgIFwiKD86WzEtOV1cXFxcZD98MVxcXFxkXFxcXGR8MlswMV1cXFxcZHwyMlswLTNdKVwiICtcbiAgICAgICAgICBcIig/OlxcXFwuKD86MT9cXFxcZHsxLDJ9fDJbMC00XVxcXFxkfDI1WzAtNV0pKXsyfVwiICtcbiAgICAgICAgICBcIig/OlxcXFwuKD86WzEtOV1cXFxcZD98MVxcXFxkXFxcXGR8MlswLTRdXFxcXGR8MjVbMC00XSkpXCIgK1xuICAgICAgICBcInxcIiArXG4gICAgICAgICAgLy8gaG9zdCBuYW1lXG4gICAgICAgICAgXCIoPzooPzpbYS16XFxcXHUwMGExLVxcXFx1ZmZmZjAtOV0tKikqW2EtelxcXFx1MDBhMS1cXFxcdWZmZmYwLTldKylcIiArXG4gICAgICAgICAgLy8gZG9tYWluIG5hbWVcbiAgICAgICAgICBcIig/OlxcXFwuKD86W2EtelxcXFx1MDBhMS1cXFxcdWZmZmYwLTldLSopKlthLXpcXFxcdTAwYTEtXFxcXHVmZmZmMC05XSspKlwiICtcbiAgICAgICAgICB0bGQgK1xuICAgICAgICBcIilcIiArXG4gICAgICAgIC8vIHBvcnQgbnVtYmVyXG4gICAgICAgIFwiKD86OlxcXFxkezIsNX0pP1wiICtcbiAgICAgICAgLy8gcmVzb3VyY2UgcGF0aFxuICAgICAgICBcIig/OlsvPyNdXFxcXFMqKT9cIiArXG4gICAgICBcIiRcIjtcblxuICAgICAgdmFyIFBBVFRFUk4gPSBuZXcgUmVnRXhwKHJlZ2V4LCAnaScpO1xuICAgICAgaWYgKCFQQVRURVJOLmV4ZWModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YWxpZGF0ZS5mb3JtYXR0ZXJzID0ge1xuICAgIGRldGFpbGVkOiBmdW5jdGlvbihlcnJvcnMpIHtyZXR1cm4gZXJyb3JzO30sXG4gICAgZmxhdDogdi5mbGF0dGVuRXJyb3JzVG9BcnJheSxcbiAgICBncm91cGVkOiBmdW5jdGlvbihlcnJvcnMpIHtcbiAgICAgIHZhciBhdHRyO1xuXG4gICAgICBlcnJvcnMgPSB2Lmdyb3VwRXJyb3JzQnlBdHRyaWJ1dGUoZXJyb3JzKTtcbiAgICAgIGZvciAoYXR0ciBpbiBlcnJvcnMpIHtcbiAgICAgICAgZXJyb3JzW2F0dHJdID0gdi5mbGF0dGVuRXJyb3JzVG9BcnJheShlcnJvcnNbYXR0cl0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVycm9ycztcbiAgICB9LFxuICAgIGNvbnN0cmFpbnQ6IGZ1bmN0aW9uKGVycm9ycykge1xuICAgICAgdmFyIGF0dHI7XG4gICAgICBlcnJvcnMgPSB2Lmdyb3VwRXJyb3JzQnlBdHRyaWJ1dGUoZXJyb3JzKTtcbiAgICAgIGZvciAoYXR0ciBpbiBlcnJvcnMpIHtcbiAgICAgICAgZXJyb3JzW2F0dHJdID0gZXJyb3JzW2F0dHJdLm1hcChmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LnZhbGlkYXRvcjtcbiAgICAgICAgfSkuc29ydCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVycm9ycztcbiAgICB9XG4gIH07XG5cbiAgdmFsaWRhdGUuZXhwb3NlTW9kdWxlKHZhbGlkYXRlLCB0aGlzLCBleHBvcnRzLCBtb2R1bGUsIGRlZmluZSk7XG59KS5jYWxsKHRoaXMsXG4gICAgICAgIHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGV4cG9ydHMgOiBudWxsLFxuICAgICAgICB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIG1vZHVsZSA6IG51bGwsXG4gICAgICAgIHR5cGVvZiBkZWZpbmUgIT09ICd1bmRlZmluZWQnID8gLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZGVmaW5lIDogbnVsbCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3ZhbGlkYXRlLmpzL3ZhbGlkYXRlLmpzIiwiZ2xvYmFsLlByb21pc2UgPSByZXF1aXJlKCAnYmx1ZWJpcmQnICk7XG5jb25zdCBldmVudEVtaXR0ZXIgPSByZXF1aXJlKCAnZXZlbnQtZW1pdHRlcicgKTtcbmNvbnN0IHJlcXVlc3QgPSBQcm9taXNlLnByb21pc2lmeSggcmVxdWlyZSggJ2Jyb3dzZXItcmVxdWVzdCcgKSk7XG5jb25zdCBtZXJnZSA9IHJlcXVpcmUoICdsb2Rhc2gubWVyZ2UnICk7XG5jb25zdCByZXNvbHZlVXJsID0gcmVxdWlyZSggJ3Jlc29sdmUtdXJsJyApO1xuY29uc3Qgc3RvcmUgPSByZXF1aXJlKCAnc3RvcmUnICk7XG5cbmNvbnN0IG5vcm1hbGl6ZUFyZ3VtZW50cyA9IHJlcXVpcmUoICcuL3ZhbGlkYXRlL25vcm1hbGl6ZUFyZ3VtZW50cycgKTtcbmNvbnN0IG5vcm1hbGl6ZVJlc3BvbnNlID0gcmVxdWlyZSggJy4vdmFsaWRhdGUvbm9ybWFsaXplUmVzcG9uc2UnICk7XG5jb25zdCB2YWxpZGF0ZSA9IHJlcXVpcmUoICcuL3ZhbGlkYXRlJyApO1xuY29uc3QgQnJpbmtiaXRFdmVudCA9IHJlcXVpcmUoICcuL2V2ZW50cycgKTtcblxuY29uc3QgUGxheWVyID0gcmVxdWlyZSggJy4vcGxheWVyJyApO1xuXG5jbGFzcyBCcmlua2JpdCB7XG4gICAgY29uc3RydWN0b3IoIGNvbmZpZyApIHtcbiAgICAgICAgdmFsaWRhdGUuY29uc3RydWN0b3IoIGNvbmZpZywge1xuICAgICAgICAgICAgYmFzZToge1xuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnYW1lSWQ6IHtcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgcHJlc2VuY2U6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFyc2U6IHtcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdGF5TG9nZ2VkSW46IHtcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZ2FtZUlkID0gY29uZmlnLmdhbWVJZDtcbiAgICAgICAgdGhpcy5iYXNlID0gdHlwZW9mIGNvbmZpZy5iYXNlICE9PSAnc3RyaW5nJyA/ICcvYXBpJyA6IGNvbmZpZy5iYXNlO1xuICAgICAgICB0aGlzLnBhcnNlID0gY29uZmlnLnBhcnNlID8gY29uZmlnLnBhcnNlIDogSlNPTi5wYXJzZTtcbiAgICAgICAgdGhpcy5zdGF5TG9nZ2VkSW4gPSBjb25maWcuc3RheUxvZ2dlZEluO1xuICAgICAgICB0aGlzLnVzZSggUGxheWVyICk7XG4gICAgfVxuXG4gICAgcmVzb2x2ZVVybCggdXJpICkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZVVybCggdGhpcy5iYXNlLCB1cmkgKTtcbiAgICB9XG5cbiAgICBzdG9yZSgga2V5LCB2YWx1ZSApIHtcbiAgICAgICAgc3RvcmUuc2V0KCBgJHt0aGlzLmdhbWVJZH1fJHtrZXl9YCwgdmFsdWUgKTtcbiAgICB9XG5cbiAgICByZXRyaWV2ZSgga2V5ICkge1xuICAgICAgICByZXR1cm4gc3RvcmUuZ2V0KCBgJHt0aGlzLmdhbWVJZH1fJHtrZXl9YCApO1xuICAgIH1cblxuICAgIHJlbW92ZSgga2V5ICkge1xuICAgICAgICByZXR1cm4gc3RvcmUucmVtb3ZlKCBgJHt0aGlzLmdhbWVJZH1fJHtrZXl9YCApO1xuICAgIH1cblxuICAgIHJlcXVlc3QoIC4uLmFyZ3MgKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBub3JtYWxpemVBcmd1bWVudHMoIC4uLmFyZ3MgKTtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVJlc3BvbnNlKCB0aGlzLl9yZXF1ZXN0KCBvcHRpb25zICksIG9wdGlvbnMgKTtcbiAgICB9XG5cbiAgICBnZXQoIC4uLmFyZ3MgKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBub3JtYWxpemVBcmd1bWVudHMoIC4uLmFyZ3MgKTtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVJlc3BvbnNlKCB0aGlzLl9nZXQoIG9wdGlvbnMgKSwgb3B0aW9ucyApO1xuICAgIH1cblxuICAgIHB1dCggLi4uYXJncyApIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IG5vcm1hbGl6ZUFyZ3VtZW50cyggLi4uYXJncyApO1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplUmVzcG9uc2UoIHRoaXMuX3B1dCggb3B0aW9ucyApLCBvcHRpb25zICk7XG4gICAgfVxuXG4gICAgcG9zdCggLi4uYXJncyApIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IG5vcm1hbGl6ZUFyZ3VtZW50cyggLi4uYXJncyApO1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplUmVzcG9uc2UoIHRoaXMuX3Bvc3QoIG9wdGlvbnMgKSwgb3B0aW9ucyApO1xuICAgIH1cblxuICAgIGRlbGV0ZSggLi4uYXJncyApIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IG5vcm1hbGl6ZUFyZ3VtZW50cyggLi4uYXJncyApO1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplUmVzcG9uc2UoIHRoaXMuX2RlbGV0ZSggb3B0aW9ucyApLCBvcHRpb25zICk7XG4gICAgfVxuXG4gICAgbG9naW4oIC4uLmFyZ3MgKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBub3JtYWxpemVBcmd1bWVudHMoIC4uLmFyZ3MgKTtcbiAgICAgICAgbGV0IHRva2VuO1xuICAgICAgICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS5hbnkoW1xuICAgICAgICAgICAgdmFsaWRhdGUoIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBlbWFpbDoge1xuICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwYXNzd29yZDoge1xuICAgICAgICAgICAgICAgICAgICBwcmVzZW5jZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB2YWxpZGF0ZSggb3B0aW9ucywge1xuICAgICAgICAgICAgICAgIHVzZXJuYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHBhc3N3b3JkOiB7XG4gICAgICAgICAgICAgICAgICAgIHByZXNlbmNlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXSlcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgICAgICBncmFudF90eXBlOiAncGFzc3dvcmQnLFxuICAgICAgICAgICAgICAgIHVzZXJuYW1lOiBvcHRpb25zLnVzZXJuYW1lIHx8IG9wdGlvbnMuZW1haWwsXG4gICAgICAgICAgICAgICAgcGFzc3dvcmQ6IG9wdGlvbnMucGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgc2NvcGU6ICdwbGF5ZXIuYmFzaWNfaW5mbzpyZWFkIHBsYXllci5iYXNpY19pbmZvOndyaXRlIGRhdGE6cmVhZDp3cml0ZScsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc3Qoe1xuICAgICAgICAgICAgICAgIHVyaTogJy4vdG9rZW4vJyxcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKCggcmVzcG9uc2UgKSA9PiB7XG4gICAgICAgICAgICB0b2tlbiA9IHJlc3BvbnNlLmJvZHkuYWNjZXNzX3Rva2VuO1xuICAgICAgICAgICAgaWYgKCB0aGlzLnN0YXlMb2dnZWRJbiApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JlKCAndG9rZW4nLCB0b2tlbiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldCggJy4vcGxheWVyaW5mby8nLCB0b2tlbiApO1xuICAgICAgICB9KVxuICAgICAgICAudGhlbigoIHJlc3BvbnNlICkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGxheWVyID0gbmV3IHRoaXMuUGxheWVyKCByZXNwb25zZS5ib2R5ICk7XG4gICAgICAgICAgICBwbGF5ZXIudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgIGlmICggIXRoaXMuUGxheWVyLnByaW1hcnkgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5QbGF5ZXIucHJpbWFyeSA9IHBsYXllcjtcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMuc3RheUxvZ2dlZEluICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3JlKCAncGxheWVyJywgcGxheWVyLmRhdGEgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoICdsb2dpbicsIG5ldyBCcmlua2JpdEV2ZW50KCAnbG9naW4nLCBwbGF5ZXIgKSk7XG4gICAgICAgICAgICByZXR1cm4gcGxheWVyO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVJlc3BvbnNlKCBwcm9taXNlLCBvcHRpb25zICk7XG4gICAgfVxuXG4gICAgbG9nb3V0KCkge1xuICAgICAgICB0aGlzLlBsYXllci5wcmltYXJ5ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnJlbW92ZSggJ3Rva2VuJyApO1xuICAgICAgICB0aGlzLnJlbW92ZSggJ3BsYXllcicgKTtcbiAgICB9XG5cbiAgICBwcm9tb3RlKCBwbGF5ZXIgKSB7XG4gICAgICAgIHRoaXMuUGxheWVyLnByaW1hcnkgPSBwbGF5ZXI7XG4gICAgICAgIGlmICggdGhpcy5zdGF5TG9nZ2VkSW4gKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3JlKCAndG9rZW4nLCBwbGF5ZXIuaWQgKTtcbiAgICAgICAgICAgIHRoaXMuc3RvcmUoICdwbGF5ZXInLCBwbGF5ZXIuZGF0YSApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXNlKCBwbHVnaW4gKSB7XG4gICAgICAgIGlmICggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCB0aGlzLCBwbHVnaW4ubmFtZSApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIGBCcmlua2JpdCBwbHVnaW4gbmFtZXNwYWNlIGNvbmZsaWN0OiB0d28gcGx1Z2lucyBhcmUgbmFtZWQgJyR7cGx1Z2luLm5hbWV9Jy4gUGxlYXNlIHJlbmFtZSBvbmUgb2YgdGhlbS5gICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1twbHVnaW4ubmFtZV0gPSBwbHVnaW4uaW5pdGlhbGl6ZSggdGhpcyApO1xuICAgIH1cblxuICAgIC8vIHByaXZhdGUgcHJvbWlzZS1kcml2ZW4gYXBpXG5cbiAgICBfcmVxdWVzdCggb3B0aW9ucyApIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKCBvcHRpb25zLCB7XG4gICAgICAgICAgICB1cmk6IHtcbiAgICAgICAgICAgICAgICBwcmVzZW5jZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBvcHRpb25zLnVyaSA9IHRoaXMucmVzb2x2ZVVybCggb3B0aW9ucy51cmkgKTtcbiAgICAgICAgICAgIGlmICggdHlwZW9mIG9wdGlvbnMuYm9keSA9PT0gJ29iamVjdCcgKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoIG9wdGlvbnMuYm9keSApO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuanNvbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IG9wdGlvbnMudG9rZW4gfHwgdGhpcy5yZXRyaWV2ZSggJ3Rva2VuJyApO1xuICAgICAgICAgICAgaWYgKCB0b2tlbiAmJiBvcHRpb25zLnBhc3NUb2tlbiAhPT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5oZWFkZXJzID0gbWVyZ2UoIG9wdGlvbnMuaGVhZGVycywge1xuICAgICAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0KCBvcHRpb25zIClcbiAgICAgICAgICAgIC50aGVuKCggcmVzcG9uc2UgKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgcmVzcG9uc2UuYm9keSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmJvZHkgPSB0aGlzLnBhcnNlKCByZXNwb25zZS5ib2R5ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICggcmVzcG9uc2Uuc3RhdHVzQ29kZSA+PSA0MDAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCggbmV3IEVycm9yKCByZXNwb25zZS5ib2R5ICkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoICdyZXNwb25zZScsIG5ldyBCcmlua2JpdEV2ZW50KCAncmVzcG9uc2UnLCByZXNwb25zZSApKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2dldCggLi4uYXJncyApIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IG1lcmdlKHt9LCBub3JtYWxpemVBcmd1bWVudHMoIC4uLmFyZ3MgKSwge1xuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCBvcHRzICk7XG4gICAgfVxuXG4gICAgX3B1dCggLi4uYXJncyApIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IG1lcmdlKHt9LCBub3JtYWxpemVBcmd1bWVudHMoIC4uLmFyZ3MgKSwge1xuICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCggb3B0cyApO1xuICAgIH1cblxuICAgIF9wb3N0KCAuLi5hcmdzICkge1xuICAgICAgICBjb25zdCBvcHRzID0gbWVyZ2Uoe30sIG5vcm1hbGl6ZUFyZ3VtZW50cyggLi4uYXJncyApLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCggb3B0cyApO1xuICAgIH1cblxuICAgIF9kZWxldGUoIC4uLmFyZ3MgKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSBtZXJnZSh7fSwgbm9ybWFsaXplQXJndW1lbnRzKCAuLi5hcmdzICksIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCggb3B0cyApO1xuICAgIH1cbn1cblxuQnJpbmtiaXQuQnJpbmtiaXRFdmVudCA9IEJyaW5rYml0RXZlbnQ7XG5cbmV2ZW50RW1pdHRlciggQnJpbmtiaXQucHJvdG90eXBlICk7XG5cbm1vZHVsZS5leHBvcnRzID0gQnJpbmtiaXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvaW5kZXguanMiLCJjb25zdCBtZXJnZSA9IHJlcXVpcmUoICdsb2Rhc2gubWVyZ2UnICk7XG5jb25zdCBwaWNrID0gcmVxdWlyZSggJ2xvZGFzaC5waWNrJyApO1xuY29uc3QgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSggJ2V2ZW50LWVtaXR0ZXInICk7XG5cbmNvbnN0IHZhbGlkYXRlID0gcmVxdWlyZSggJy4uL3ZhbGlkYXRlJyApO1xuY29uc3Qgbm9ybWFsaXplQXJndW1lbnRzID0gcmVxdWlyZSggJy4uL3ZhbGlkYXRlL25vcm1hbGl6ZUFyZ3VtZW50cycgKTtcbmNvbnN0IG5vcm1hbGl6ZVJlc3BvbnNlID0gcmVxdWlyZSggJy4uL3ZhbGlkYXRlL25vcm1hbGl6ZVJlc3BvbnNlJyApO1xuY29uc3QgQnJpbmtiaXRFdmVudCA9IHJlcXVpcmUoICcuLi9ldmVudHMnICk7XG5cbmNsYXNzIFBsdWdpbiB7XG5cbiAgICBjb25zdHJ1Y3RvciggYnJpbmtiaXQsIGRlZmF1bHRzLCBjb25maWcgKSB7XG4gICAgICAgIHRoaXMuYnJpbmtiaXQgPSBicmlua2JpdDtcbiAgICAgICAgdGhpcy5yZWFkID0gW107XG4gICAgICAgIHRoaXMud3JpdGUgPSBbXTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGVmYXVsdHMgfHwge307XG4gICAgICAgIHRoaXMubWlkZGxld2FyZSA9IHt9O1xuICAgICAgICBpZiAoIGNvbmZpZyApIHtcbiAgICAgICAgICAgIHZhbGlkYXRlLmNvbnN0cnVjdG9yKCBjb25maWcsIHtcbiAgICAgICAgICAgICAgICBfaWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICggY29uZmlnLl9pZCApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlkID0gY29uZmlnLl9pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhbGlkYXRlKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIGZldGNoKCAuLi5hcmdzICkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gbm9ybWFsaXplQXJndW1lbnRzKCAuLi5hcmdzICk7XG4gICAgICAgIG9wdGlvbnMudG9rZW4gPSB0aGlzLnRva2VuO1xuICAgICAgICBvcHRpb25zLnVyaSA9IG9wdGlvbnMudXJpIHx8IHRoaXMuZ2V0VXJsKCAnZ2V0JyApO1xuICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy52YWxpZGF0ZSggJ2dldCcsIG9wdGlvbnMgKVxuICAgICAgICAudGhlbigoKSA9PiB0aGlzLmJyaW5rYml0Ll9nZXQoIG9wdGlvbnMgKSlcbiAgICAgICAgLnRoZW4oKCByZXNwb25zZSApID0+IHtcbiAgICAgICAgICAgIG1lcmdlKCB0aGlzLmRhdGEsIHBpY2soIHJlc3BvbnNlLmJvZHksIHRoaXMucmVhZCApKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCggJ2ZldGNoJywgbmV3IEJyaW5rYml0RXZlbnQoICdmZXRjaCcsIHJlc3BvbnNlICkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVJlc3BvbnNlKCBwcm9taXNlLCBvcHRpb25zICk7XG4gICAgfVxuXG4gICAgc2F2ZSggLi4uYXJncyApIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IG5vcm1hbGl6ZUFyZ3VtZW50cyggLi4uYXJncyApO1xuICAgICAgICBpZiAoIG9wdGlvbnMuYm9keSApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KCBvcHRpb25zLmJvZHkgKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLnRva2VuID0gdGhpcy50b2tlbjtcbiAgICAgICAgb3B0aW9ucy5ib2R5ID0gcGljayggdGhpcy5kYXRhLCB0aGlzLndyaXRlICk7XG4gICAgICAgIG9wdGlvbnMubWV0aG9kID0gb3B0aW9ucy5tZXRob2QgfHwgKCB0aGlzLmlkID8gJ3B1dCcgOiAncG9zdCcgKTtcbiAgICAgICAgb3B0aW9ucy51cmkgPSBvcHRpb25zLnVyaSB8fCB0aGlzLmdldFVybCggb3B0aW9ucy5tZXRob2QgKTtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHRoaXMucHJvY2Vzc01pZGRsZXdhcmUoICdzYXZlJywgb3B0aW9ucyApO1xuICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy52YWxpZGF0ZSggb3B0cy5tZXRob2QsIG9wdHMuYm9keSApXG4gICAgICAgIC50aGVuKCgpID0+IHRoaXMuYnJpbmtiaXQuX3JlcXVlc3QoIG9wdHMgKSlcbiAgICAgICAgLnRoZW4oKCByZXNwb25zZSApID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0KCByZXNwb25zZS5ib2R5ICk7XG4gICAgICAgICAgICBpZiAoIHJlc3BvbnNlLmJvZHkuX2lkICkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5faWQgPSByZXNwb25zZS5ib2R5Ll9pZDtcbiAgICAgICAgICAgICAgICB0aGlzLmlkID0gcmVzcG9uc2UuYm9keS5faWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoICdzYXZlJywgbmV3IEJyaW5rYml0RXZlbnQoICdzYXZlJywgcmVzcG9uc2UgKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplUmVzcG9uc2UoIHByb21pc2UsIG9wdGlvbnMgKTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZSggJ2RlbGV0ZScgKVxuICAgICAgICAudGhlbigoKSA9PiB0aGlzLmJyaW5rYml0Ll9kZWxldGUoIHRoaXMuZ2V0VXJsKCAnZGVsZXRlJyApKSlcbiAgICAgICAgLnRoZW4oKCByZXNwb25zZSApID0+IHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmRhdGEuaWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGdldCggYXR0ciApIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBhdHRyID09PSAnc3RyaW5nJyA/IHRoaXMuZGF0YVthdHRyXSA6IHBpY2soIHRoaXMuZGF0YSwgYXR0ciApO1xuICAgIH1cblxuICAgIHNldCggYXR0ciwgdmFsdWUgKSB7XG4gICAgICAgIGlmICggdHlwZW9mIGF0dHIgPT09ICdvYmplY3QnICkge1xuICAgICAgICAgICAgbWVyZ2UoIHRoaXMuZGF0YSwgcGljayggYXR0ciwgdGhpcy53cml0ZSApKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggdGhpcy53cml0ZS5pbmNsdWRlcyggYXR0ciApKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFbYXR0cl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb2Nlc3NNaWRkbGV3YXJlKCBtZXRob2QsIG9wdHMgKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5taWRkbGV3YXJlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgdHlwZW9mIHRoaXMubWlkZGxld2FyZVttZXRob2RdID09PSAnZnVuY3Rpb24nID8gdGhpcy5taWRkbGV3YXJlW21ldGhvZF0oIG9wdHMgKSA6IG9wdHM7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZSggLi4uYXJncyApIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgdGhpcyggLi4uYXJncyApO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2Uuc2F2ZSgpXG4gICAgICAgIC50aGVuKCgpID0+IGluc3RhbmNlICk7XG4gICAgfVxuXG59XG5cblxuZXZlbnRFbWl0dGVyKCBQbHVnaW4ucHJvdG90eXBlICk7XG5cbm1vZHVsZS5leHBvcnRzID0gUGx1Z2luO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BsdWdpbi9pbmRleC5qcyJdLCJzb3VyY2VSb290IjoiIn0=